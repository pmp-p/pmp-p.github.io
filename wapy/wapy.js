/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)

  if (!Module.expectedDataFileDownloads) {
    Module.expectedDataFileDownloads = 0;
    Module.finishedDataFileDownloads = 0;
  }
  Module.expectedDataFileDownloads++;
  (function() {
   var loadPackage = function(metadata) {
  
      var PACKAGE_PATH;
      if (typeof window === 'object') {
        PACKAGE_PATH = window['encodeURIComponent'](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf('/')) + '/');
      } else if (typeof location !== 'undefined') {
        // worker
        PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf('/')) + '/');
      } else {
        throw 'using preloaded data can only be done on a web page or in a web worker';
      }
      var PACKAGE_NAME = 'wapy.data';
      var REMOTE_PACKAGE_BASE = 'wapy.data';
      if (typeof Module['locateFilePackage'] === 'function' && !Module['locateFile']) {
        Module['locateFile'] = Module['locateFilePackage'];
        err('warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)');
      }
      var REMOTE_PACKAGE_NAME = Module['locateFile'] ? Module['locateFile'](REMOTE_PACKAGE_BASE, '') : REMOTE_PACKAGE_BASE;
    
      var REMOTE_PACKAGE_SIZE = metadata['remote_package_size'];
      var PACKAGE_UUID = metadata['package_uuid'];
    
      function fetchRemotePackage(packageName, packageSize, callback, errback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', packageName, true);
        xhr.responseType = 'arraybuffer';
        xhr.onprogress = function(event) {
          var url = packageName;
          var size = packageSize;
          if (event.total) size = event.total;
          if (event.loaded) {
            if (!xhr.addedTotal) {
              xhr.addedTotal = true;
              if (!Module.dataFileDownloads) Module.dataFileDownloads = {};
              Module.dataFileDownloads[url] = {
                loaded: event.loaded,
                total: size
              };
            } else {
              Module.dataFileDownloads[url].loaded = event.loaded;
            }
            var total = 0;
            var loaded = 0;
            var num = 0;
            for (var download in Module.dataFileDownloads) {
            var data = Module.dataFileDownloads[download];
              total += data.total;
              loaded += data.loaded;
              num++;
            }
            total = Math.ceil(total * Module.expectedDataFileDownloads/num);
            if (Module['setStatus']) Module['setStatus']('Downloading data... (' + loaded + '/' + total + ')');
          } else if (!Module.dataFileDownloads) {
            if (Module['setStatus']) Module['setStatus']('Downloading data...');
          }
        };
        xhr.onerror = function(event) {
          throw new Error("NetworkError for: " + packageName);
        }
        xhr.onload = function(event) {
          if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            var packageData = xhr.response;
            callback(packageData);
          } else {
            throw new Error(xhr.statusText + " : " + xhr.responseURL);
          }
        };
        xhr.send(null);
      };

      function handleError(error) {
        console.error('package error:', error);
      };
    
        var fetchedCallback = null;
        var fetched = Module['getPreloadedPackage'] ? Module['getPreloadedPackage'](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;

        if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function(data) {
          if (fetchedCallback) {
            fetchedCallback(data);
            fetchedCallback = null;
          } else {
            fetched = data;
          }
        }, handleError);
      
    function runWithFS() {
  
      function assert(check, msg) {
        if (!check) throw msg + new Error().stack;
      }
  Module['FS_createPath']('/', 'lib', true, true);
Module['FS_createPath']('/', 'assets', true, true);

      /** @constructor */
      function DataRequest(start, end, audio) {
        this.start = start;
        this.end = end;
        this.audio = audio;
      }
      DataRequest.prototype = {
        requests: {},
        open: function(mode, name) {
          this.name = name;
          this.requests[name] = this;
          Module['addRunDependency']('fp ' + this.name);
        },
        send: function() {},
        onload: function() {
          var byteArray = this.byteArray.subarray(this.start, this.end);
          this.finish(byteArray);
        },
        finish: function(byteArray) {
          var that = this;
  
          Module['FS_createPreloadedFile'](this.name, null, byteArray, true, true, function() {
            Module['removeRunDependency']('fp ' + that.name);
          }, function() {
            if (that.audio) {
              Module['removeRunDependency']('fp ' + that.name); // workaround for chromium bug 124926 (still no audio with this, but at least we don't hang)
            } else {
              err('Preloading file ' + that.name + ' failed');
            }
          }, false, true); // canOwn this data in the filesystem, it is a slide into the heap that will never change
  
          this.requests[this.name] = null;
        }
      };
  
    
      function processPackageData(arrayBuffer) {
        Module.finishedDataFileDownloads++;
        assert(arrayBuffer, 'Loading data file failed.');
        assert(arrayBuffer instanceof ArrayBuffer, 'bad input to processPackageData');
        var byteArray = new Uint8Array(arrayBuffer);
        var curr;
        
            var compressedData = {"data":null,"cachedOffset":76825,"cachedIndexes":[-1,-1],"cachedChunks":[null,null],"offsets":[0,553,624,665,726,787,838,1065,1241,1367,1581,1643,1702,1757,1807,2009,2162,2251,2312,2371,2433,2542,2836,3058,3204,3276,3512,3711,3870,4139,4386,4539,4664,4777,4925,5089,5239,5286,5311,5406,5516,5758,5913,6115,6347,6529,6650,6793,7028,7204,7386,7566,7731,7852,7991,8127,8225,8361,8490,8783,8982,9271,9416,9608,9885,10010,10200,10380,10533,10701,10834,10931,11063,11187,11347,11401,11426,11491,11670,11779,11927,12166,12372,12502,12736,12871,12970,13103,13229,13474,13603,13744,13870,13960,14085,14207,14487,14686,14864,15021,15143,15243,15362,15520,15655,15797,15931,16059,16148,16252,16367,16490,16657,16781,16806,16865,16992,17103,17233,17334,17573,17760,17949,18033,18139,18247,18476,18650,18821,18944,19049,19281,19387,19524,19742,19889,20015,20144,20238,20334,20478,20695,20896,21030,21155,21254,21511,21616,21741,21923,22165,22229,22254,22294,22406,22611,22709,22910,23141,23287,23382,23479,23593,23807,24006,24173,24370,24478,24574,24677,24803,25058,25196,25316,25431,25523,25627,25743,25953,26171,26284,26397,26491,26591,26695,26805,27009,27162,27279,27363,27388,27413,27491,27573,27658,27740,27825,27891,27974,28055,28142,28236,28335,28430,28562,28635,28727,28821,28920,29056,29159,29263,29347,29452,29555,29645,29756,29861,29966,30070,30145,30246,30352,30457,30561,30707,30814,30887,30912,30937,31002,31109,31205,31300,31379,31463,31550,31638,31733,31829,31925,32035,32118,32209,32307,32417,32527,32640,32750,32839,32931,33031,33147,33257,33396,33506,33615,33695,33797,33897,34007,34116,34226,34336,34422,34531,34564,34589,34763,34920,35058,35196,35333,35468,35605,35754,35928,36077,36219,36345,36488,36636,36786,36925,37074,37258,37390,37522,37671,37836,37989,38138,38287,38435,38555,38706,38855,39004,39192,39327,39470,39590,39749,39867,39987,40053,40149,40310,40439,40574,40713,40850,40994,41138,41282,41426,41547,41683,41825,41970,42144,42287,42429,42556,42710,42867,43014,43158,43301,43444,43588,43700,43848,43996,44167,44305,44439,44573,44709,44849,44982,45225,45321,45346,45442,45673,45814,45958,46094,46240,46363,46481,46605,46731,46871,47024,47167,47314,47455,47643,47805,47969,48154,48300,48496,48697,48891,49073,49223,49405,49584,49782,49996,50201,50409,50578,50770,50952,51096,51307,51484,51616,51747,51947,52126,52278,52496,52706,52915,53113,53282,53460,53641,53855,54076,54282,54499,54672,54854,55057,55214,55420,55631,55835,56037,56210,56396,56573,56789,57002,57207,57414,57587,57778,57967,58105,58315,58526,58693,58811,58959,59140,59288,59506,59720,59937,60132,60329,60513,60718,60850,61071,61282,61498,61680,61866,62073,62229,62380,62533,62672,62814,62975,63145,63330,63461,63605,63767,63917,64097,64289,64482,64634,64845,65048,65250,65387,65548,65573,65742,65847,66049,66175,66270,66403,66531,66814,67003,67172,67324,67418,67546,67671,67963,68136,68290,68460,68570,68855,68995,69242,69517,69698,69841,69978,70083,70269,70391,70601,70786,70911,71058,71294,71498,71695,71720,71745,71834,71988,72100,72224,72377,72538,72773,72984,73106,73216,73371,73567,73743,74018,74347,74557,74631,74748,74922,75072,75122,75347,75499,75598,75639,75700,75761,75812,76039,76215,76341,76555,76617,76676,76731,76784],"sizes":[553,71,41,61,61,51,227,176,126,214,62,59,55,50,202,153,89,61,59,62,109,294,222,146,72,236,199,159,269,247,153,125,113,148,164,150,47,25,95,110,242,155,202,232,182,121,143,235,176,182,180,165,121,139,136,98,136,129,293,199,289,145,192,277,125,190,180,153,168,133,97,132,124,160,54,25,65,179,109,148,239,206,130,234,135,99,133,126,245,129,141,126,90,125,122,280,199,178,157,122,100,119,158,135,142,134,128,89,104,115,123,167,124,25,59,127,111,130,101,239,187,189,84,106,108,229,174,171,123,105,232,106,137,218,147,126,129,94,96,144,217,201,134,125,99,257,105,125,182,242,64,25,40,112,205,98,201,231,146,95,97,114,214,199,167,197,108,96,103,126,255,138,120,115,92,104,116,210,218,113,113,94,100,104,110,204,153,117,84,25,25,78,82,85,82,85,66,83,81,87,94,99,95,132,73,92,94,99,136,103,104,84,105,103,90,111,105,105,104,75,101,106,105,104,146,107,73,25,25,65,107,96,95,79,84,87,88,95,96,96,110,83,91,98,110,110,113,110,89,92,100,116,110,139,110,109,80,102,100,110,109,110,110,86,109,33,25,174,157,138,138,137,135,137,149,174,149,142,126,143,148,150,139,149,184,132,132,149,165,153,149,149,148,120,151,149,149,188,135,143,120,159,118,120,66,96,161,129,135,139,137,144,144,144,144,121,136,142,145,174,143,142,127,154,157,147,144,143,143,144,112,148,148,171,138,134,134,136,140,133,243,96,25,96,231,141,144,136,146,123,118,124,126,140,153,143,147,141,188,162,164,185,146,196,201,194,182,150,182,179,198,214,205,208,169,192,182,144,211,177,132,131,200,179,152,218,210,209,198,169,178,181,214,221,206,217,173,182,203,157,206,211,204,202,173,186,177,216,213,205,207,173,191,189,138,210,211,167,118,148,181,148,218,214,217,195,197,184,205,132,221,211,216,182,186,207,156,151,153,139,142,161,170,185,131,144,162,150,180,192,193,152,211,203,202,137,161,25,169,105,202,126,95,133,128,283,189,169,152,94,128,125,292,173,154,170,110,285,140,247,275,181,143,137,105,186,122,210,185,125,147,236,204,197,25,25,89,154,112,124,153,161,235,211,122,110,155,196,176,275,329,210,74,117,174,150,50,225,152,99,41,61,61,51,227,176,126,214,62,59,55,53,41],"successes":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}
;
            compressedData['data'] = byteArray;
            assert(typeof LZ4 === 'object', 'LZ4 not present - was your app build with  -s LZ4=1  ?');
            LZ4.loadPackage({ 'metadata': metadata, 'compressedData': compressedData });
            Module['removeRunDependency']('datafile_wapy.data');
      
      };
      Module['addRunDependency']('datafile_wapy.data');
    
      if (!Module.preloadResults) Module.preloadResults = {};
    
        Module.preloadResults[PACKAGE_NAME] = {fromCache: false};
        if (fetched) {
          processPackageData(fetched);
          fetched = null;
        } else {
          fetchedCallback = processPackageData;
        }
      
    }
    if (Module['calledRun']) {
      runWithFS();
    } else {
      if (!Module['preRun']) Module['preRun'] = [];
      Module["preRun"].push(runWithFS); // FS is not initialized yet, wait for it
    }
  
   }
   loadPackage({"files": [{"filename": "/lib/libtest.so", "start": 0, "end": 488, "audio": 0}, {"filename": "/hello.bmp", "start": 488, "end": 1089822, "audio": 0}, {"filename": "/assets/site_wapy.py", "start": 1089822, "end": 1089822, "audio": 0}], "remote_package_size": 80921, "package_uuid": "476deed6-5048-4bd3-b6a5-257bf2004915"});
  
  })();
  


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = true;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}



// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;


// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  if (!(typeof window === 'object' || typeof importScripts === 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

  read_ = function shell_read(url) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function readBinary(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };




  }

  setWindowTitle = function(title) { document.title = title };
} else
{
  throw new Error('environment detection error');
}


// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
if (Module['arguments']) arguments_ = Module['arguments'];if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', { configurable: true, get: function() { abort('Module.arguments has been replaced with plain arguments_') } });
if (Module['thisProgram']) thisProgram = Module['thisProgram'];if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', { configurable: true, get: function() { abort('Module.thisProgram has been replaced with plain thisProgram') } });
if (Module['quit']) quit_ = Module['quit'];if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', { configurable: true, get: function() { abort('Module.quit has been replaced with plain quit_') } });

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
assert(typeof Module['TOTAL_MEMORY'] === 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
if (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', { configurable: true, get: function() { abort('Module.read has been replaced with plain read_') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', { configurable: true, get: function() { abort('Module.readAsync has been replaced with plain readAsync') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', { configurable: true, get: function() { abort('Module.readBinary has been replaced with plain readBinary') } });
if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';




/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;

// stack management, and other functionality that is provided by the compiled code,
// should not be used before it is ready

/** @suppress{duplicate} */
var stackSave;
/** @suppress{duplicate} */
var stackRestore;
/** @suppress{duplicate} */
var stackAlloc;

stackSave = stackRestore = stackAlloc = function() {
  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
};

function staticAlloc(size) {
  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');
}

function dynamicAlloc(size) {
  assert(DYNAMICTOP_PTR);
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  assert(end <= HEAP8.length, 'failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');
  HEAP32[DYNAMICTOP_PTR>>2] = end;
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}


// dynamic linker/loader (a-la ld.so on ELF systems)
var LDSO = {
  // next free handle to use for a loaded dso.
  // (handle=0 is avoided as it means "error" in dlopen)
  nextHandle: 1,

  loadedLibs: {         // handle -> dso [refcount, name, module, global]
    // program itself
    // XXX uglifyjs fails on "[-1]: {"
    '-1': {
      refcount: Infinity,   // = nodelete
      name:     '__self__',
      module:   Module,
      global:   true
    }
  },

  loadedLibNames: {     // name   -> handle
    // program itself
    '__self__': -1
  },
}

// fetchBinary fetches binaray data @ url. (async)
function fetchBinary(url) {
  return fetch(url, { credentials: 'same-origin' }).then(function(response) {
    if (!response['ok']) {
      throw "failed to load binary file at '" + url + "'";
    }
    return response['arrayBuffer']();
  }).then(function(buffer) {
    return new Uint8Array(buffer);
  });
}

// loadDynamicLibrary loads dynamic library @ lib URL / path and returns handle for loaded DSO.
//
// Several flags affect the loading:
//
// - if flags.global=true, symbols from the loaded library are merged into global
//   process namespace. Flags.global is thus similar to RTLD_GLOBAL in ELF.
//
// - if flags.nodelete=true, the library will be never unloaded. Flags.nodelete
//   is thus similar to RTLD_NODELETE in ELF.
//
// - if flags.loadAsync=true, the loading is performed asynchronously and
//   loadDynamicLibrary returns corresponding promise.
//
// - if flags.fs is provided, it is used as FS-like interface to load library data.
//   By default, when flags.fs=undefined, native loading capabilities of the
//   environment are used.
//
// If a library was already loaded, it is not loaded a second time. However
// flags.global and flags.nodelete are handled every time a load request is made.
// Once a library becomes "global" or "nodelete", it cannot be removed or unloaded.
function loadDynamicLibrary(lib, flags) {
  // when loadDynamicLibrary did not have flags, libraries were loaded globally & permanently
  flags = flags || {global: true, nodelete: true}

  var handle = LDSO.loadedLibNames[lib];
  var dso;
  if (handle) {
    // the library is being loaded or has been loaded already.
    //
    // however it could be previously loaded only locally and if we get
    // load request with global=true we have to make it globally visible now.
    dso = LDSO.loadedLibs[handle];
    if (flags.global && !dso.global) {
      dso.global = true;
      if (dso.module !== 'loading') {
        // ^^^ if module is 'loading' - symbols merging will be eventually done by the loader.
        mergeLibSymbols(dso.module)
      }
    }
    // same for "nodelete"
    if (flags.nodelete && dso.refcount !== Infinity) {
      dso.refcount = Infinity;
    }
    dso.refcount++
    return flags.loadAsync ? Promise.resolve(handle) : handle;
  }

  // allocate new DSO & handle
  handle = LDSO.nextHandle++;
  dso = {
    refcount: flags.nodelete ? Infinity : 1,
    name:     lib,
    module:   'loading',
    global:   flags.global,
  };
  LDSO.loadedLibNames[lib] = handle;
  LDSO.loadedLibs[handle] = dso;

  // libData <- libFile
  function loadLibData(libFile) {
    // for wasm, we can use fetch for async, but for fs mode we can only imitate it
    if (flags.fs) {
      var libData = flags.fs.readFile(libFile, {encoding: 'binary'});
      if (!(libData instanceof Uint8Array)) {
        libData = new Uint8Array(lib_data);
      }
      return flags.loadAsync ? Promise.resolve(libData) : libData;
    }

    if (flags.loadAsync) {
      return fetchBinary(libFile);
    }
    // load the binary synchronously
    return readBinary(libFile);
  }

  // libModule <- libData
  function createLibModule(libData) {
    return loadWebAssemblyModule(libData, flags)
  }

  // libModule <- lib
  function getLibModule() {
    // lookup preloaded cache first
    if (Module['preloadedWasm'] !== undefined &&
        Module['preloadedWasm'][lib] !== undefined) {
      var libModule = Module['preloadedWasm'][lib];
      return flags.loadAsync ? Promise.resolve(libModule) : libModule;
    }

    // module not preloaded - load lib data and create new module from it
    if (flags.loadAsync) {
      return loadLibData(lib).then(function(libData) {
        return createLibModule(libData);
      });
    }

    return createLibModule(loadLibData(lib));
  }

  // Module.symbols <- libModule.symbols (flags.global handler)
  function mergeLibSymbols(libModule) {
    // add symbols into global namespace TODO: weak linking etc.
    for (var sym in libModule) {
      if (!libModule.hasOwnProperty(sym)) {
        continue;
      }

      // When RTLD_GLOBAL is enable, the symbols defined by this shared object will be made
      // available for symbol resolution of subsequently loaded shared objects.
      //
      // We should copy the symbols (which include methods and variables) from SIDE_MODULE to MAIN_MODULE.

      var module_sym = sym;
      module_sym = '_' + sym;

      if (!Module.hasOwnProperty(module_sym)) {
        Module[module_sym] = libModule[sym];
      }
      else {
        var curr = Module[sym], next = libModule[sym];
        // don't warn on functions - might be odr, linkonce_odr, etc.
        if (!(typeof curr === 'function' && typeof next === 'function')) {
          err("warning: symbol '" + sym + "' from '" + lib + "' already exists (duplicate symbol? or weak linking, which isn't supported yet?)"); // + [curr, ' vs ', next]);
        }
      }
    }
  }

  // module for lib is loaded - update the dso & global namespace
  function moduleLoaded(libModule) {
    if (dso.global) {
      mergeLibSymbols(libModule);
    }
    dso.module = libModule;
  }

  if (flags.loadAsync) {
    return getLibModule().then(function(libModule) {
      moduleLoaded(libModule);
      return handle;
    })
  }

  moduleLoaded(getLibModule());
  return handle;
}

// Applies relocations to exported things.
function relocateExports(exports, memoryBase, tableBase, moduleLocal) {
  var relocated = {};

  for (var e in exports) {
    var value = exports[e];
    if (typeof value === 'object') {
      // a breaking change in the wasm spec, globals are now objects
      // https://github.com/WebAssembly/mutable-global/issues/1
      value = value.value;
    }
    if (typeof value === 'number') {
      // relocate it - modules export the absolute value, they can't relocate before they export
        value += memoryBase;
    }
    relocated[e] = value;
    if (moduleLocal) {
      moduleLocal['_' + e] = value;
    }
  }
  return relocated;
}

// Loads a side module from binary data
function loadWebAssemblyModule(binary, flags) {
  var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);
  assert(int32View[0] == 0x6d736100, 'need to see wasm magic number'); // \0asm
  // we should see the dylink section right after the magic number and wasm version
  assert(binary[8] === 0, 'need the dylink section to be first')
  var next = 9;
  function getLEB() {
    var ret = 0;
    var mul = 1;
    while (1) {
      var byte = binary[next++];
      ret += ((byte & 0x7f) * mul);
      mul *= 0x80;
      if (!(byte & 0x80)) break;
    }
    return ret;
  }
  var sectionSize = getLEB();
  assert(binary[next] === 6);                 next++; // size of "dylink" string
  assert(binary[next] === 'd'.charCodeAt(0)); next++;
  assert(binary[next] === 'y'.charCodeAt(0)); next++;
  assert(binary[next] === 'l'.charCodeAt(0)); next++;
  assert(binary[next] === 'i'.charCodeAt(0)); next++;
  assert(binary[next] === 'n'.charCodeAt(0)); next++;
  assert(binary[next] === 'k'.charCodeAt(0)); next++;
  var memorySize = getLEB();
  var memoryAlign = getLEB();
  var tableSize = getLEB();
  var tableAlign = getLEB();

  // shared libraries this module needs. We need to load them first, so that
  // current module could resolve its imports. (see tools/shared.py
  // WebAssembly.make_shared_library() for "dylink" section extension format)
  var neededDynlibsCount = getLEB();
  var neededDynlibs = [];
  for (var i = 0; i < neededDynlibsCount; ++i) {
    var nameLen = getLEB();
    var nameUTF8 = binary.subarray(next, next + nameLen);
    next += nameLen;
    var name = UTF8ArrayToString(nameUTF8, 0);
    neededDynlibs.push(name);
  }

  // loadModule loads the wasm module after all its dependencies have been loaded.
  // can be called both sync/async.
  function loadModule() {
    // alignments are powers of 2
    memoryAlign = Math.pow(2, memoryAlign);
    tableAlign = Math.pow(2, tableAlign);
    // finalize alignments and verify them
    memoryAlign = Math.max(memoryAlign, STACK_ALIGN); // we at least need stack alignment
    assert(tableAlign === 1, 'invalid tableAlign ' + tableAlign);
    // prepare memory
    var memoryBase = alignMemory(getMemory(memorySize + memoryAlign), memoryAlign); // TODO: add to cleanups
    // prepare env imports
    var env = asmLibraryArg;
    // TODO: use only __memory_base and __table_base, need to update asm.js backend
    var table = wasmTable;
    var tableBase = table.length;
    var originalTable = table;
    table.grow(tableSize);
    assert(table === originalTable);
    // zero-initialize memory and table
    // The static area consists of explicitly initialized data, followed by zero-initialized data.
    // The latter may need zeroing out if the MAIN_MODULE has already used this memory area before
    // dlopen'ing the SIDE_MODULE.  Since we don't know the size of the explicitly initialized data
    // here, we just zero the whole thing, which is suboptimal, but should at least resolve bugs
    // from uninitialized memory.
    for (var i = memoryBase; i < memoryBase + memorySize; i++) {
      HEAP8[i] = 0;
    }
    for (var i = tableBase; i < tableBase + tableSize; i++) {
      table.set(i, null);
    }

    // We resolve symbols against the global Module but failing that also
    // against the local symbols exported a side module.  This is because
    // a) Module sometime need to import their own symbols
    // b) Symbols from loaded modules are not always added to the global Module.
    var moduleLocal = {};

    var resolveSymbol = function(sym, type, legalized) {
      if (legalized) {
        sym = 'orig$' + sym;
      }

      var resolved = Module["asm"][sym];
      if (!resolved) {
        sym = '_' + sym;
        resolved = Module[sym];
        if (!resolved) {
          resolved = moduleLocal[sym];
        }
        assert(resolved, 'missing linked ' + type + ' `' + sym + '`. perhaps a side module was not linked in? if this global was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment');
      }
      return resolved;
    }

    // copy currently exported symbols so the new module can import them
    for (var x in Module) {
      if (!(x in env)) {
        env[x] = Module[x];
      }
    }

    // TODO kill ↓↓↓ (except "symbols local to this module", it will likely be
    // not needed if we require that if A wants symbols from B it has to link
    // to B explicitly: similarly to -Wl,--no-undefined)
    //
    // wasm dynamic libraries are pure wasm, so they cannot assist in
    // their own loading. When side module A wants to import something
    // provided by a side module B that is loaded later, we need to
    // add a layer of indirection, but worse, we can't even tell what
    // to add the indirection for, without inspecting what A's imports
    // are. To do that here, we use a JS proxy (another option would
    // be to inspect the binary directly).
    var proxyHandler = {
      'get': function(obj, prop) {
        // symbols that should be local to this module
        switch (prop) {
          case '__memory_base':
          case 'gb':
            return memoryBase;
          case '__table_base':
          case 'fb':
            return tableBase;
        }

        if (prop in obj) {
          return obj[prop]; // already present
        }
        if (prop.startsWith('g$')) {
          // a global. the g$ function returns the global address.
          var name = prop.substr(2); // without g$ prefix
          return obj[prop] = function() {
            return resolveSymbol(name, 'global');
          };
        }
        if (prop.startsWith('fp$')) {
          // the fp$ function returns the address (table index) of the function
          var parts = prop.split('$');
          assert(parts.length == 3)
          var name = parts[1];
          var sig = parts[2];
          var legalized = sig.indexOf('j') >= 0; // check for i64s
          var fp = 0;
          return obj[prop] = function() {
            if (!fp) {
              var f = resolveSymbol(name, 'function', legalized);
              fp = addFunction(f, sig);
            }
            return fp;
          };
        }
        if (prop.startsWith('invoke_')) {
          // A missing invoke, i.e., an invoke for a function type
          // present in the dynamic library but not in the main JS,
          // and the dynamic library cannot provide JS for it. Use
          // the generic "X" invoke for it.
          return obj[prop] = invoke_X;
        }
        // otherwise this is regular function import - call it indirectly
        return obj[prop] = function() {
          return resolveSymbol(prop, 'function').apply(null, arguments);
        };
      }
    };
    var proxy = new Proxy(env, proxyHandler);
    var info = {
      global: {
        'NaN': NaN,
        'Infinity': Infinity,
      },
      'global.Math': Math,
      env: proxy,
      wasi_snapshot_preview1: proxy,
    };
    var oldTable = [];
    for (var i = 0; i < tableBase; i++) {
      oldTable.push(table.get(i));
    }

    function postInstantiation(instance, moduleLocal) {
      // the table should be unchanged
      assert(table === originalTable);
      assert(table === wasmTable);
      // the old part of the table should be unchanged
      for (var i = 0; i < tableBase; i++) {
        assert(table.get(i) === oldTable[i], 'old table entries must remain the same');
      }
      // verify that the new table region was filled in
      for (var i = 0; i < tableSize; i++) {
        assert(table.get(tableBase + i) !== undefined, 'table entry was not filled in');
      }
      var exports = relocateExports(instance.exports, memoryBase, tableBase, moduleLocal);
      // initialize the module
      var init = exports['__post_instantiate'];
      if (init) {
        if (runtimeInitialized) {
          init();
        } else {
          // we aren't ready to run compiled code yet
          __ATINIT__.push(init);
        }
      }
      return exports;
    }

    if (flags.loadAsync) {
      return WebAssembly.instantiate(binary, info).then(function(result) {
        return postInstantiation(result.instance, moduleLocal);
      });
    } else {
      var instance = new WebAssembly.Instance(new WebAssembly.Module(binary), info);
      return postInstantiation(instance, moduleLocal);
    }
  }

  // now load needed libraries and the module itself.
  if (flags.loadAsync) {
    return Promise.all(neededDynlibs.map(function(dynNeeded) {
      return loadDynamicLibrary(dynNeeded, flags);
    })).then(function() {
      return loadModule();
    });
  }

  neededDynlibs.forEach(function(dynNeeded) {
    loadDynamicLibrary(dynNeeded, flags);
  });
  return loadModule();
}
Module['loadWebAssemblyModule'] = loadWebAssemblyModule;




/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function === "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < table.length; i++) {
      var item = table.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  // Make sure functionsInTableMap is actually up to date, that is, that this
  // function is not actually in the wasm Table despite not being tracked in
  // functionsInTableMap.
  for (var i = 0; i < table.length; i++) {
    assert(table.get(i) != func, 'function in Table but not functionsInTableMap');
  }

  var ret;
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    ret = freeTableIndexes.pop();
  } else {
    ret = table.length;
    // Grow the table
    try {
      table.grow(1);
    } catch (err) {
      if (!(err instanceof RangeError)) {
        throw err;
      }
      throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
    }
  }

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunctionWasm(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {
  assert(typeof func !== 'undefined');
  if (typeof sig === 'undefined') {
    err('warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but can be required for the LLVM wasm backend, so it is recommended for full portability.');
  }

  return addFunctionWasm(func, sig);
}

function removeFunction(index) {
  removeFunctionWasm(index);
}



var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

/** @param {Array=} args */
function dynCall(sig, ptr, args) {
  if (args && args.length) {
    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
    assert(args.length === sig.substring(1).replace(/j/g, '--').length);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    assert(sig.length == 1);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};

function getCompilerSetting(name) {
  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';
}

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;

GLOBAL_BASE = alignMemory(GLOBAL_BASE, 1);


/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


var wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', { configurable: true, get: function() { abort('Module.wasmBinary has been replaced with plain wasmBinary') } });
var noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', { configurable: true, get: function() { abort('Module.noExitRuntime has been replaced with plain noExitRuntime') } });


if (typeof WebAssembly !== 'object') {
  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}





// Wasm globals

var wasmMemory;

// In fastcomp asm.js, we don't need a wasm Table at all.
// In the wasm backend, we polyfill the WebAssembly object,
// so this creates a (non-native-wasm) table for us.
var wasmTable = new WebAssembly.Table({
  'initial': 1137,
  'element': 'anyfunc'
});


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}



/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var STATIC_BASE = 1024,
    STACK_BASE = 17906704,
    STACKTOP = STACK_BASE,
    STACK_MAX = 1129488,
    DYNAMIC_BASE = 17906704,
    DYNAMICTOP_PTR = 1129312;

assert(STACK_BASE % 16 === 0, 'stack must start aligned');
assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');



var TOTAL_STACK = 16777216;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 671088640;if (!Object.getOwnPropertyDescriptor(Module, 'INITIAL_MEMORY')) Object.defineProperty(Module, 'INITIAL_MEMORY', { configurable: true, get: function() { abort('Module.INITIAL_MEMORY has been replaced with plain INITIAL_INITIAL_MEMORY') } });

assert(INITIAL_INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,
       'JS engine does not provide full typed array support');



/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




// In standalone mode, the wasm creates the memory, and the user can't provide it.
// In non-standalone/normal mode, we create the memory here.

/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm
// memory is created in the wasm, not in JS.)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
      ,
      'maximum': INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
    });
  }


if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_INITIAL_MEMORY = buffer.byteLength;
assert(INITIAL_INITIAL_MEMORY % WASM_PAGE_SIZE === 0);
updateGlobalBufferAndViews(buffer);

HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  assert((STACK_MAX & 3) == 0);
  // The stack grows downwards
  HEAPU32[(STACK_MAX >> 2)+1] = 0x2135467;
  HEAPU32[(STACK_MAX >> 2)+2] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  HEAP32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  var cookie1 = HEAPU32[(STACK_MAX >> 2)+1];
  var cookie2 = HEAPU32[(STACK_MAX >> 2)+2];
  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));
  }
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

function abortStackOverflow(allocSize) {
  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');
}




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Endianness check (note: assumes compiler arch was little-endian)
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';
})();

function abortFnPtrError(ptr, sig) {
	var possibleSig = '';
	for(var x in debug_tables) {
		var tbl = debug_tables[x];
		if (tbl[ptr]) {
			possibleSig += 'as sig "' + x + '" pointing to function ' + tbl[ptr] + ', ';
		}
	}
	abort("Invalid function pointer " + ptr + " called with signature '" + sig + "'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). This pointer might make sense in another type signature: " + possibleSig);
}



function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback(Module); // Pass the module as the first argument.
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  checkStackCookie();
  assert(!runtimeInitialized);
  runtimeInitialized = true;
  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
TTY.init();
PIPEFS.root = FS.mount(PIPEFS, {}, null);
SOCKFS.root = FS.mount(SOCKFS, {}, null);
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  FS.ignorePermissions = false;
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  checkStackCookie();
  runtimeExited = true;
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

/** @param {number|boolean=} ignore */
function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
/** @param {number|boolean=} ignore */
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data
Module["preloadedWasm"] = {}; // maps url to wasm instance exports


/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  out(what);
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  var output = 'abort(' + what + ') at ' + stackTrace();
  what = output;

  // Throw a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  throw new WebAssembly.RuntimeError(what);
}



addOnPreRun(function() {
  function loadDynamicLibraries(libs) {
    if (libs) {
      libs.forEach(function(lib) {
        // libraries linked to main never go away
        loadDynamicLibrary(lib, {global: true, nodelete: true});
      });
    }
  }
  // if we can load dynamic libraries synchronously, do so, otherwise, preload
  if (Module['dynamicLibraries'] && Module['dynamicLibraries'].length > 0 && !readBinary) {
    // we can't read binary data synchronously, so preload
    addRunDependency('preload_dynamicLibraries');
    Promise.all(Module['dynamicLibraries'].map(function(lib) {
      return loadDynamicLibrary(lib, {loadAsync: true, global: true, nodelete: true});
    })).then(function() {
      // we got them all, wonderful
      removeRunDependency('preload_dynamicLibraries');
    });
    return;
  }
  loadDynamicLibraries(Module['dynamicLibraries']);
});

function lookupSymbol(ptr) { // for a pointer, print out all symbols that resolve to it
  var ret = [];
  for (var i in Module) {
    if (Module[i] === ptr) ret.push(i);
  }
  print(ptr + ' is ' + ret);
}

var memoryInitializer = null;


/**
 * @license
 * Copyright 2015 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */







/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

function hasPrefix(str, prefix) {
  return String.prototype.startsWith ?
      str.startsWith(prefix) :
      str.indexOf(prefix) === 0;
}

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return hasPrefix(filename, fileURIPrefix);
}



var wasmBinaryFile = 'wapy.wasm';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }

    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, and have the Fetch api, use that;
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function'
      ) {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function(resolve, reject) {
    resolve(getBinary());
  });
}



// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    exports = relocateExports(exports, GLOBAL_BASE, 0);
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');


  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }


  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);
      abort(reason);
    });
  }

  // Prefer streaming instantiation if available.
  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiatedSource, function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            instantiateArrayBuffer(receiveInstantiatedSource);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiatedSource);
    }
  }
  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}


// Globals used by JS i64 conversions
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  43: function($0) {return wasm_file_open(UTF8ToString($0));},  
 120: function($0) {return wasm_file_exists(UTF8ToString($0), true);},  
 172: function($0) {return wasm_file_open(UTF8ToString($0),UTF8ToString($0));},  
 120325: function($0, $1, $2) {window.plink.shm = $0; window.plink.io_port_kbd = $1; window.PyRun_SimpleString_MAXSIZE = $2; console.log("window.plink.shm=" + window.plink.shm); console.log("window.plink.io_port_kbd=" + window.plink.io_port_kbd); window.setTimeout( init_repl_begin , 1000 );},  
 120600: function() {console.log("91:SystemExit");},  
 309200: function($0, $1, $2, $3) {var cif = $0; var fn = $1; var rvalue = $2; var avalue = $3; var cif_abi = HEAPU32[cif >> 2]; var cif_nargs = HEAPU32[(cif + 4) >> 2]; var cif_arg_types = HEAPU32[(cif + 8) >> 2]; var cif_rtype = HEAPU32[(cif + 12) >> 2]; var args = [fn]; var sig = ""; var sigFloat = Module['usingWasm'] ? "f" : "d"; var rtype = HEAPU16[(cif_rtype + 6 ) >> 1]; if (rtype === 0) { sig = 'v'; } else if (rtype === 1 || rtype === 5 || rtype === 6 || rtype === 7 || rtype === 8 || rtype === 9 || rtype === 10 || rtype === 14) { sig = 'i'; } else if (rtype === 2) { sig = sigFloat; } else if (rtype === 3 || rtype === 4) { sig = 'd'; } else if (rtype === 11 || rtype === 12) { sig = 'j'; } else if (rtype === 13) { throw new Error('struct ret marshalling nyi'); } else if (rtype === 15) { throw new Error('complex ret marshalling nyi'); } else { throw new Error('Unexpected rtype ' + rtype); } for (var i = 0; i < cif_nargs; i++) { var ptr = HEAPU32[(avalue >> 2) + i]; var arg_type = HEAPU32[(cif_arg_types >> 2) + i]; var typ = HEAPU16[(arg_type + 6) >> 1]; if (typ === 1 || typ === 10) { args.push(HEAP32[ptr >> 2]); sig += 'i'; } else if (typ === 2) { args.push(HEAPF32[ptr >> 2]); sig += sigFloat; } else if (typ === 3 || typ === 4) { args.push(HEAPF64[ptr >> 3]); sig += 'd'; } else if (typ === 5) { args.push(HEAPU8[ptr]); sig += 'i'; } else if (typ === 6) { args.push(HEAP8[ptr]); sig += 'i'; } else if (typ === 7) { args.push(HEAPU16[ptr >> 1]); sig += 'i'; } else if (typ === 8) { args.push(HEAP16[ptr >> 1]); sig += 'i'; } else if (typ === 9 || typ === 14) { args.push(HEAPU32[ptr >> 2]); sig += 'i'; } else if (typ === 11 || typ === 12) { args.push(HEAPU32[ptr >> 2]); args.push(HEAPU32[(ptr + 4) >> 2]); sig += 'j'; } else if (typ === 13) { throw new Error('struct marshalling nyi'); } else if (typ === 15) { throw new Error('complex marshalling nyi'); } else { throw new Error('Unexpected type ' + typ); } } var func = Module['dynCall_' + sig]; if (func) { var result = func.apply(null, args); } else { console.error('fn is', fn); console.error('sig is', sig); console.error('args is', args); for (var x in Module) { console.error('-- ' + x); } throw new Error('invalid function pointer in ffi_call'); } if (rtype === 0) { } else if (rtype === 1 || rtype === 9 || rtype === 10 || rtype === 14) { HEAP32[rvalue >> 2] = result; } else if (rtype === 2) { HEAPF32[rvalue >> 2] = result; } else if (rtype === 3 || rtype === 4) { HEAPF64[rvalue >> 3] = result; } else if (rtype === 5 || rtype === 6) { HEAP8[rvalue] = result; } else if (rtype === 7 || rtype === 8) { HEAP16[rvalue >> 1] = result; } else if (rtype === 11 || rtype === 12) { HEAP32[rvalue >> 2] = result; HEAP32[(rvalue + 4) >> 2] = Module.getTempRet0(); } else if (rtype === 13) { throw new Error('struct ret marshalling nyi'); } else if (rtype === 15) { throw new Error('complex ret marshalling nyi'); } else { throw new Error('Unexpected rtype ' + rtype); }},  
 314320: function() {console.log("91:SystemExit");},  
 315210: function($0) {var str = UTF8ToString($0) + '\n\n' + 'Abort/Retry/Ignore/AlwaysIgnore? [ariA] :'; var reply = window.prompt(str, "i"); if (reply === null) { reply = "i"; } return allocate(intArrayFromString(reply), 'i8', ALLOC_NORMAL);},  
 357966: function($0, $1, $2, $3, $4) {return Browser.safeSetTimeout(function() { dynCall('viiii', $0, [$1, $2, $3, $4]); }, $2);},  
 358061: function($0) {window.clearTimeout($0);},  
 377195: function($0, $1) {alert(UTF8ToString($0) + "\n\n" + UTF8ToString($1));},  
 379465: function($0, $1, $2) {var w = $0; var h = $1; var pixels = $2; if (!Module['SDL2']) Module['SDL2'] = {}; var SDL2 = Module['SDL2']; if (SDL2.ctxCanvas !== Module['canvas']) { SDL2.ctx = Module['createContext'](Module['canvas'], false, true); SDL2.ctxCanvas = Module['canvas']; } if (SDL2.w !== w || SDL2.h !== h || SDL2.imageCtx !== SDL2.ctx) { SDL2.image = SDL2.ctx.createImageData(w, h); SDL2.w = w; SDL2.h = h; SDL2.imageCtx = SDL2.ctx; } var data = SDL2.image.data; var src = pixels >> 2; var dst = 0; var num; if (typeof CanvasPixelArray !== 'undefined' && data instanceof CanvasPixelArray) { num = data.length; while (dst < num) { var val = HEAP32[src]; data[dst ] = val & 0xff; data[dst+1] = (val >> 8) & 0xff; data[dst+2] = (val >> 16) & 0xff; data[dst+3] = 0xff; src++; dst += 4; } } else { if (SDL2.data32Data !== data) { SDL2.data32 = new Int32Array(data.buffer); SDL2.data8 = new Uint8Array(data.buffer); } var data32 = SDL2.data32; num = data32.length; data32.set(HEAP32.subarray(src, src + num)); var data8 = SDL2.data8; var i = 3; var j = i + 4*num; if (num % 8 == 0) { while (i < j) { data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; } } else { while (i < j) { data8[i] = 0xff; i = i + 4 | 0; } } } SDL2.ctx.putImageData(SDL2.image, 0, 0); return 0;},  
 380944: function($0, $1, $2, $3, $4) {var w = $0; var h = $1; var hot_x = $2; var hot_y = $3; var pixels = $4; var canvas = document.createElement("canvas"); canvas.width = w; canvas.height = h; var ctx = canvas.getContext("2d"); var image = ctx.createImageData(w, h); var data = image.data; var src = pixels >> 2; var dst = 0; var num; if (typeof CanvasPixelArray !== 'undefined' && data instanceof CanvasPixelArray) { num = data.length; while (dst < num) { var val = HEAP32[src]; data[dst ] = val & 0xff; data[dst+1] = (val >> 8) & 0xff; data[dst+2] = (val >> 16) & 0xff; data[dst+3] = (val >> 24) & 0xff; src++; dst += 4; } } else { var data32 = new Int32Array(data.buffer); num = data32.length; data32.set(HEAP32.subarray(src, src + num)); } ctx.putImageData(image, 0, 0); var url = hot_x === 0 && hot_y === 0 ? "url(" + canvas.toDataURL() + "), auto" : "url(" + canvas.toDataURL() + ") " + hot_x + " " + hot_y + ", auto"; var urlBuf = _malloc(url.length + 1); stringToUTF8(url, urlBuf, url.length + 1); return urlBuf;},  
 381933: function($0) {if (Module['canvas']) { Module['canvas'].style['cursor'] = UTF8ToString($0); } return 0;},  
 382026: function() {if (Module['canvas']) { Module['canvas'].style['cursor'] = 'none'; }},  
 382419: function() {return screen.width;},  
 382446: function() {return screen.height;},  
 382474: function() {return window.innerWidth;},  
 382506: function() {return window.innerHeight;},  
 382584: function($0) {if (typeof setWindowTitle !== 'undefined') { setWindowTitle(UTF8ToString($0)); } return 0;},  
 382736: function() {if (typeof(AudioContext) !== 'undefined') { return 1; } else if (typeof(webkitAudioContext) !== 'undefined') { return 1; } return 0;},  
 382902: function() {if ((typeof(navigator.mediaDevices) !== 'undefined') && (typeof(navigator.mediaDevices.getUserMedia) !== 'undefined')) { return 1; } else if (typeof(navigator.webkitGetUserMedia) !== 'undefined') { return 1; } return 0;},  
 383128: function($0) {if(typeof(Module['SDL2']) === 'undefined') { Module['SDL2'] = {}; } var SDL2 = Module['SDL2']; if (!$0) { SDL2.audio = {}; } else { SDL2.capture = {}; } if (!SDL2.audioContext) { if (typeof(AudioContext) !== 'undefined') { SDL2.audioContext = new AudioContext(); } else if (typeof(webkitAudioContext) !== 'undefined') { SDL2.audioContext = new webkitAudioContext(); } } return SDL2.audioContext === undefined ? -1 : 0;},  
 383611: function() {var SDL2 = Module['SDL2']; return SDL2.audioContext.sampleRate;},  
 383681: function($0, $1, $2, $3) {var SDL2 = Module['SDL2']; var have_microphone = function(stream) { if (SDL2.capture.silenceTimer !== undefined) { clearTimeout(SDL2.capture.silenceTimer); SDL2.capture.silenceTimer = undefined; } SDL2.capture.mediaStreamNode = SDL2.audioContext.createMediaStreamSource(stream); SDL2.capture.scriptProcessorNode = SDL2.audioContext.createScriptProcessor($1, $0, 1); SDL2.capture.scriptProcessorNode.onaudioprocess = function(audioProcessingEvent) { if ((SDL2 === undefined) || (SDL2.capture === undefined)) { return; } audioProcessingEvent.outputBuffer.getChannelData(0).fill(0.0); SDL2.capture.currentCaptureBuffer = audioProcessingEvent.inputBuffer; dynCall('vi', $2, [$3]); }; SDL2.capture.mediaStreamNode.connect(SDL2.capture.scriptProcessorNode); SDL2.capture.scriptProcessorNode.connect(SDL2.audioContext.destination); SDL2.capture.stream = stream; }; var no_microphone = function(error) { }; SDL2.capture.silenceBuffer = SDL2.audioContext.createBuffer($0, $1, SDL2.audioContext.sampleRate); SDL2.capture.silenceBuffer.getChannelData(0).fill(0.0); var silence_callback = function() { SDL2.capture.currentCaptureBuffer = SDL2.capture.silenceBuffer; dynCall('vi', $2, [$3]); }; SDL2.capture.silenceTimer = setTimeout(silence_callback, ($1 / SDL2.audioContext.sampleRate) * 1000); if ((navigator.mediaDevices !== undefined) && (navigator.mediaDevices.getUserMedia !== undefined)) { navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(have_microphone).catch(no_microphone); } else if (navigator.webkitGetUserMedia !== undefined) { navigator.webkitGetUserMedia({ audio: true, video: false }, have_microphone, no_microphone); }},  
 385333: function($0, $1, $2, $3) {var SDL2 = Module['SDL2']; SDL2.audio.scriptProcessorNode = SDL2.audioContext['createScriptProcessor']($1, 0, $0); SDL2.audio.scriptProcessorNode['onaudioprocess'] = function (e) { if ((SDL2 === undefined) || (SDL2.audio === undefined)) { return; } SDL2.audio.currentOutputBuffer = e['outputBuffer']; dynCall('vi', $2, [$3]); }; SDL2.audio.scriptProcessorNode['connect'](SDL2.audioContext['destination']);},  
 385743: function($0, $1) {var SDL2 = Module['SDL2']; var numChannels = SDL2.capture.currentCaptureBuffer.numberOfChannels; for (var c = 0; c < numChannels; ++c) { var channelData = SDL2.capture.currentCaptureBuffer.getChannelData(c); if (channelData.length != $1) { throw 'Web Audio capture buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + $1 + ' samples!'; } if (numChannels == 1) { for (var j = 0; j < $1; ++j) { setValue($0 + (j * 4), channelData[j], 'float'); } } else { for (var j = 0; j < $1; ++j) { setValue($0 + (((j * numChannels) + c) * 4), channelData[j], 'float'); } } }},  
 386348: function($0, $1) {var SDL2 = Module['SDL2']; var numChannels = SDL2.audio.currentOutputBuffer['numberOfChannels']; for (var c = 0; c < numChannels; ++c) { var channelData = SDL2.audio.currentOutputBuffer['getChannelData'](c); if (channelData.length != $1) { throw 'Web Audio output buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + $1 + ' samples!'; } for (var j = 0; j < $1; ++j) { channelData[j] = HEAPF32[$0 + ((j*numChannels + c) << 2) >> 2]; } }},  
 386828: function($0) {var SDL2 = Module['SDL2']; if ($0) { if (SDL2.capture.silenceTimer !== undefined) { clearTimeout(SDL2.capture.silenceTimer); } if (SDL2.capture.stream !== undefined) { var tracks = SDL2.capture.stream.getAudioTracks(); for (var i = 0; i < tracks.length; i++) { SDL2.capture.stream.removeTrack(tracks[i]); } SDL2.capture.stream = undefined; } if (SDL2.capture.scriptProcessorNode !== undefined) { SDL2.capture.scriptProcessorNode.onaudioprocess = function(audioProcessingEvent) {}; SDL2.capture.scriptProcessorNode.disconnect(); SDL2.capture.scriptProcessorNode = undefined; } if (SDL2.capture.mediaStreamNode !== undefined) { SDL2.capture.mediaStreamNode.disconnect(); SDL2.capture.mediaStreamNode = undefined; } if (SDL2.capture.silenceBuffer !== undefined) { SDL2.capture.silenceBuffer = undefined } SDL2.capture = undefined; } else { if (SDL2.audio.scriptProcessorNode != undefined) { SDL2.audio.scriptProcessorNode.disconnect(); SDL2.audio.scriptProcessorNode = undefined; } SDL2.audio = undefined; } if ((SDL2.audioContext !== undefined) && (SDL2.audio === undefined) && (SDL2.capture === undefined)) { SDL2.audioContext.close(); SDL2.audioContext = undefined; }}
};

function _emscripten_asm_const_iii(code, sigPtr, argbuf) {
  code -= 1024;

  var args = readAsmConstArgs(sigPtr, argbuf);
  return ASM_CONSTS[code].apply(null, args);
}



// STATICTOP = STATIC_BASE + 1128464;
/* global initializers */  __ATINIT__.push({ func: function() { ___assign_got_enties() } }, { func: function() { ___wasm_call_ctors() } });




/* no memory initializer */
// {{PRE_LIBRARY}}


  
  
  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        console.error('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {
        if (typeof setImmediate === 'undefined') {
          // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
          var setImmediates = [];
          var emscriptenMainLoopMessageId = 'setimmediate';
          var Browser_setImmediate_messageHandler = function(event) {
            // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
            // so check for both cases.
            if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
              event.stopPropagation();
              setImmediates.shift()();
            }
          }
          addEventListener("message", Browser_setImmediate_messageHandler, true);
          setImmediate = /** @type{function(function(): ?, ...?): number} */(function Browser_emulated_setImmediate(func) {
            setImmediates.push(func);
            if (ENVIRONMENT_IS_WORKER) {
              if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];
              Module['setImmediates'].push(func);
              postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
            } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
          })
        }
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
          setImmediate(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'immediate';
      }
      return 0;
    }
  Module["_emscripten_set_main_loop_timing"] = _emscripten_set_main_loop_timing;
  
  var _emscripten_get_now;_emscripten_get_now = function() { return performance.now(); }
  ;
  Module["_emscripten_get_now"] = _emscripten_get_now;/** @param {number|boolean=} noSetTiming */
  function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg, noSetTiming) {
      noExitRuntime = true;
  
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = func;
      Browser.mainLoop.arg = arg;
  
      var browserIterationFunc;
      if (typeof arg !== 'undefined') {
        browserIterationFunc = function() {
          Module['dynCall_vi'](func, arg);
        };
      } else {
        browserIterationFunc = function() {
          Module['dynCall_v'](func);
        };
      }
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
  
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
  
          // catches pause/resume main loop from blocker execution
          if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        } else if (Browser.mainLoop.timingMode == 0/*EM_TIMING_SETTIMEOUT*/) {
          Browser.mainLoop.tickStartTime = _emscripten_get_now();
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
  
  
  
        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          warnOnce('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }
  
        Browser.mainLoop.runIter(browserIterationFunc);
  
        checkStackCookie();
  
        // catch pauses from the main loop itself
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
        Browser.mainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'unwind';
      }
    }
  Module["_emscripten_set_main_loop"] = _emscripten_set_main_loop;var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function() {
          Browser.mainLoop.scheduler = null;
          Browser.mainLoop.currentlyRunningMainloop++; // Incrementing this signals the previous main loop that it's now become old, and it must return.
        },resume:function() {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          _emscripten_set_main_loop(func, 0, false, Browser.mainLoop.arg, true /* do not set timing and call scheduler, we will do it on the next lines */);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },updateStatus:function() {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function(func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          try {
            func();
          } catch (e) {
            if (e instanceof ExitStatus) {
              return;
            } else {
              if (e && typeof e === 'object' && e.stack) err('exception thrown: ' + [e, e.stack]);
              throw e;
            }
          }
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function() {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            assert(typeof url == 'string', 'createObjectURL must return a url as a string');
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
        var wasmPlugin = {};
        wasmPlugin['asyncWasmLoadPromise'] = new Promise(
          function(resolve, reject) { return resolve(); });
        wasmPlugin['canHandle'] = function(name) {
          return !Module.noWasmDecoding && name.endsWith('.so');
        };
        wasmPlugin['handle'] = function(byteArray, name, onload, onerror) {
          // loadWebAssemblyModule can not load modules out-of-order, so rather
          // than just running the promises in parallel, this makes a chain of
          // promises to run in series.
          this['asyncWasmLoadPromise'] = this['asyncWasmLoadPromise'].then(
            function() {
              return loadWebAssemblyModule(byteArray, {loadAsync: true, nodelete: true});
            }).then(
              function(module) {
                Module['preloadedWasm'][name] = module;
                onload();
              },
              function(err) {
                console.warn("Couldn't instantiate wasm: " + name + " '" + err + "'");
                onerror();
              });
        };
        Module['preloadPlugins'].push(wasmPlugin);
  
        // Canvas event setup
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
  
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },createContext:function(canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: 1,
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL !== 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function(canvas, useWebGL, setInModule) {},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:function(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullscreen);
          if (Module['onFullscreen']) Module['onFullscreen'](Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? function() { canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
  
        canvasContainer.requestFullscreen();
      },requestFullScreen:function() {
        abort('Module.requestFullScreen has been replaced by Module.requestFullscreen (without a capital S)');
      },exitFullscreen:function() {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }
  
        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (function() {});
        CFS.apply(document, []);
        return true;
      },nextRAF:0,fakeRequestAnimationFrame:function(func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function(func) {
        if (typeof requestAnimationFrame === 'function') {
          requestAnimationFrame(func);
          return;
        }
        var RAF = Browser.fakeRequestAnimationFrame;
        RAF(func);
      },safeCallback:function(func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function() {
        Browser.allowAsyncCallbacks = false;
      },resumeAsyncCallbacks:function() { // marks future callbacks as ok to execute, and synchronously runs any remaining ones right now
        Browser.allowAsyncCallbacks = true;
        if (Browser.queuedAsyncCallbacks.length > 0) {
          var callbacks = Browser.queuedAsyncCallbacks;
          Browser.queuedAsyncCallbacks = [];
          callbacks.forEach(function(func) {
            func();
          });
        }
      },safeRequestAnimationFrame:function(func) {
        return Browser.requestAnimationFrame(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        });
      },safeSetTimeout:function(func, timeout) {
        noExitRuntime = true;
        return setTimeout(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        }, timeout);
      },safeSetInterval:function(func, timeout) {
        noExitRuntime = true;
        return setInterval(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } // drop it on the floor otherwise, next interval will kick in
        }, timeout);
      },getMimetype:function(name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function(func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function(event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function(event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function(event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch(event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
  
          // check if SDL is available
          if (typeof SDL != "undefined") {
            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
            // just add the mouse delta to the current absolut mouse position
            // FIXME: ideally this should be clamped against the canvas size and zero
            Browser.mouseX += Browser.mouseMovementX;
            Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
          // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset
          // and we have no viable fallback.
          assert((typeof scrollX !== 'undefined') && (typeof scrollY !== 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
  
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              if (!last) last = coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },asyncLoad:function(url, onload, onerror, noRunDep) {
        var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
        readAsync(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency(dep);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (dep) addRunDependency(dep);
      },resizeListeners:[],updateResizeListeners:function() {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function(width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)]=flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)]=flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function(canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function() {
        var handle = Browser.nextWgetRequestHandle;
        Browser.nextWgetRequestHandle++;
        return handle;
      }};
  Module["Browser"] = Browser;

  function demangle(func) {
      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
      return func;
    }
  Module["demangle"] = demangle;

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }
  Module["demangleAll"] = demangleAll;

  function jsStackTrace() {
      var err = new Error();
      if (!err.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          err = e;
        }
        if (!err.stack) {
          return '(no stack trace available)';
        }
      }
      return err.stack.toString();
    }
  Module["jsStackTrace"] = jsStackTrace;

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }
  Module["stackTrace"] = stackTrace;

  function _SDL_uclibc_exp(
  ) {
  if (!Module['_SDL_uclibc_exp']) abort("external function 'SDL_uclibc_exp' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_SDL_uclibc_exp'].apply(null, arguments);
  }

  function _SDL_uclibc_fmod(
  ) {
  if (!Module['_SDL_uclibc_fmod']) abort("external function 'SDL_uclibc_fmod' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_SDL_uclibc_fmod'].apply(null, arguments);
  }

  function _SDL_uclibc_log10(
  ) {
  if (!Module['_SDL_uclibc_log10']) abort("external function 'SDL_uclibc_log10' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_SDL_uclibc_log10'].apply(null, arguments);
  }

  
  
  var _emscripten_get_now_is_monotonic=true;;
  Module["_emscripten_get_now_is_monotonic"] = _emscripten_get_now_is_monotonic;
  
  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)]=value;
      return value;
    }
  Module["setErrNo"] = setErrNo;function _clock_gettime(clk_id, tp) {
      // int clock_gettime(clockid_t clk_id, struct timespec *tp);
      var now;
      if (clk_id === 0) {
        now = Date.now();
      } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
        now = _emscripten_get_now();
      } else {
        setErrNo(28);
        return -1;
      }
      HEAP32[((tp)>>2)]=(now/1000)|0; // seconds
      HEAP32[(((tp)+(4))>>2)]=((now % 1000)*1000*1000)|0; // nanoseconds
      return 0;
    }
  Module["_clock_gettime"] = _clock_gettime;function ___clock_gettime(a0,a1
  ) {
  return _clock_gettime(a0,a1);
  }
  Module["___clock_gettime"] = ___clock_gettime;

  function ___handle_stack_overflow() {
      abort('stack overflow')
    }
  Module["___handle_stack_overflow"] = ___handle_stack_overflow;

  function ___map_file(pathname, size) {
      setErrNo(63);
      return -1;
    }
  Module["___map_file"] = ___map_file;

  function ___sys__newselect(nfds, readfds, writefds, exceptfds, timeout) {
      // readfds are supported,
      // writefds checks socket open status
      // exceptfds not supported
      // timeout is always 0 - fully async
      assert(nfds <= 64, 'nfds must be less than or equal to 64');  // fd sets have 64 bits // TODO: this could be 1024 based on current musl headers
      assert(!exceptfds, 'exceptfds not supported');
  
      var total = 0;
      
      var srcReadLow = (readfds ? HEAP32[((readfds)>>2)] : 0),
          srcReadHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0);
      var srcWriteLow = (writefds ? HEAP32[((writefds)>>2)] : 0),
          srcWriteHigh = (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0);
      var srcExceptLow = (exceptfds ? HEAP32[((exceptfds)>>2)] : 0),
          srcExceptHigh = (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var dstReadLow = 0,
          dstReadHigh = 0;
      var dstWriteLow = 0,
          dstWriteHigh = 0;
      var dstExceptLow = 0,
          dstExceptHigh = 0;
  
      var allLow = (readfds ? HEAP32[((readfds)>>2)] : 0) |
                   (writefds ? HEAP32[((writefds)>>2)] : 0) |
                   (exceptfds ? HEAP32[((exceptfds)>>2)] : 0);
      var allHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0) |
                    (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0) |
                    (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var check = function(fd, low, high, val) {
        return (fd < 32 ? (low & val) : (high & val));
      };
  
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << (fd % 32);
        if (!(check(fd, allLow, allHigh, mask))) {
          continue;  // index isn't in the set
        }
  
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
  
        var flags = SYSCALLS.DEFAULT_POLLMASK;
  
        if (stream.stream_ops.poll) {
          flags = stream.stream_ops.poll(stream);
        }
  
        if ((flags & 1) && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? (dstReadLow = dstReadLow | mask) : (dstReadHigh = dstReadHigh | mask);
          total++;
        }
        if ((flags & 4) && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? (dstWriteLow = dstWriteLow | mask) : (dstWriteHigh = dstWriteHigh | mask);
          total++;
        }
        if ((flags & 2) && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? (dstExceptLow = dstExceptLow | mask) : (dstExceptHigh = dstExceptHigh | mask);
          total++;
        }
      }
  
      if (readfds) {
        HEAP32[((readfds)>>2)]=dstReadLow;
        HEAP32[(((readfds)+(4))>>2)]=dstReadHigh;
      }
      if (writefds) {
        HEAP32[((writefds)>>2)]=dstWriteLow;
        HEAP32[(((writefds)+(4))>>2)]=dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[((exceptfds)>>2)]=dstExceptLow;
        HEAP32[(((exceptfds)+(4))>>2)]=dstExceptHigh;
      }
      
      return total;
    }
  Module["___sys__newselect"] = ___sys__newselect;

  
  
  var PATH={splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  Module["PATH"] = PATH;
  
  
  var PATH_FS={resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  Module["PATH_FS"] = PATH_FS;
  
  var TTY={ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  Module["TTY"] = TTY;
  
  var MEMFS={ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function(node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
        return;
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              assert(position === 0, 'canOwn must imply no weird position inside the file');
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, buffer, offset, length, position, prot, flags) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                contents.buffer === buffer.buffer ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            // malloc() can lead to growing the heap. If targeting the heap, we need to
            // re-acquire the heap buffer object in case growth had occurred.
            var fromHeap = (buffer.buffer == HEAP8.buffer);
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            (fromHeap ? HEAP8 : buffer).set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  Module["MEMFS"] = MEMFS;
  
  var ERRNO_MESSAGES={0:"Success",1:"Arg list too long",2:"Permission denied",3:"Address already in use",4:"Address not available",5:"Address family not supported by protocol family",6:"No more processes",7:"Socket already connected",8:"Bad file number",9:"Trying to read unreadable message",10:"Mount device busy",11:"Operation canceled",12:"No children",13:"Connection aborted",14:"Connection refused",15:"Connection reset by peer",16:"File locking deadlock error",17:"Destination address required",18:"Math arg out of domain of func",19:"Quota exceeded",20:"File exists",21:"Bad address",22:"File too large",23:"Host is unreachable",24:"Identifier removed",25:"Illegal byte sequence",26:"Connection already in progress",27:"Interrupted system call",28:"Invalid argument",29:"I/O error",30:"Socket is already connected",31:"Is a directory",32:"Too many symbolic links",33:"Too many open files",34:"Too many links",35:"Message too long",36:"Multihop attempted",37:"File or path name too long",38:"Network interface is not configured",39:"Connection reset by network",40:"Network is unreachable",41:"Too many open files in system",42:"No buffer space available",43:"No such device",44:"No such file or directory",45:"Exec format error",46:"No record locks available",47:"The link has been severed",48:"Not enough core",49:"No message of desired type",50:"Protocol not available",51:"No space left on device",52:"Function not implemented",53:"Socket is not connected",54:"Not a directory",55:"Directory not empty",56:"State not recoverable",57:"Socket operation on non-socket",59:"Not a typewriter",60:"No such device or address",61:"Value too large for defined data type",62:"Previous owner died",63:"Not super-user",64:"Broken pipe",65:"Protocol error",66:"Unknown protocol",67:"Protocol wrong type for socket",68:"Math result not representable",69:"Read only file system",70:"Illegal seek",71:"No such process",72:"Stale file handle",73:"Connection timed out",74:"Text file busy",75:"Cross-device link",100:"Device not a stream",101:"Bad font file fmt",102:"Invalid slot",103:"Invalid request code",104:"No anode",105:"Block device required",106:"Channel number out of range",107:"Level 3 halted",108:"Level 3 reset",109:"Link number out of range",110:"Protocol driver not attached",111:"No CSI structure available",112:"Level 2 halted",113:"Invalid exchange",114:"Invalid request descriptor",115:"Exchange full",116:"No data (for no delay io)",117:"Timer expired",118:"Out of streams resources",119:"Machine is not on the network",120:"Package not installed",121:"The object is remote",122:"Advertise error",123:"Srmount error",124:"Communication error on send",125:"Cross mount point (not really error)",126:"Given log. name not unique",127:"f.d. invalid for this operation",128:"Remote address changed",129:"Can   access a needed shared lib",130:"Accessing a corrupted shared lib",131:".lib section in a.out corrupted",132:"Attempting to link in too many libs",133:"Attempting to exec a shared library",135:"Streams pipe error",136:"Too many users",137:"Socket type not supported",138:"Not supported",139:"Protocol family not supported",140:"Can't send after socket shutdown",141:"Too many references",142:"Host is down",148:"No medium (in tape drive)",156:"Level 2 not synchronized"};
  Module["ERRNO_MESSAGES"] = ERRNO_MESSAGES;
  
  var ERRNO_CODES={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};
  Module["ERRNO_CODES"] = ERRNO_CODES;
  
  var LZ4={DIR_MODE:16895,FILE_MODE:33279,CHUNK_SIZE:-1,codec:null,init:function() {
        if (LZ4.codec) return;
        LZ4.codec = (function() {
          /*
  MiniLZ4: Minimal LZ4 block decoding and encoding.
  
  based off of node-lz4, https://github.com/pierrec/node-lz4
  
  ====
  Copyright (c) 2012 Pierre Curto
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  ====
  
  changes have the same license
  */
  
  var MiniLZ4 = (function() {
  
  var exports = {};
  
  /**
   * Decode a block. Assumptions: input contains all sequences of a 
   * chunk, output is large enough to receive the decoded data.
   * If the output buffer is too small, an error will be thrown.
   * If the returned value is negative, an error occured at the returned offset.
   *
   * @param {ArrayBufferView} input input data
   * @param {ArrayBufferView} output output data
   * @param {number=} sIdx
   * @param {number=} eIdx
   * @return {number} number of decoded bytes
   * @private
   */
  exports.uncompress = function (input, output, sIdx, eIdx) {
  	sIdx = sIdx || 0
  	eIdx = eIdx || (input.length - sIdx)
  	// Process each sequence in the incoming data
  	for (var i = sIdx, n = eIdx, j = 0; i < n;) {
  		var token = input[i++]
  
  		// Literals
  		var literals_length = (token >> 4)
  		if (literals_length > 0) {
  			// length of literals
  			var l = literals_length + 240
  			while (l === 255) {
  				l = input[i++]
  				literals_length += l
  			}
  
  			// Copy the literals
  			var end = i + literals_length
  			while (i < end) output[j++] = input[i++]
  
  			// End of buffer?
  			if (i === n) return j
  		}
  
  		// Match copy
  		// 2 bytes offset (little endian)
  		var offset = input[i++] | (input[i++] << 8)
  
  		// XXX 0 is an invalid offset value
  		if (offset === 0) return j
  		if (offset > j) return -(i-2)
  
  		// length of match copy
  		var match_length = (token & 0xf)
  		var l = match_length + 240
  		while (l === 255) {
  			l = input[i++]
  			match_length += l
  		}
  
  		// Copy the match
  		var pos = j - offset // position of the match copy in the current output
  		var end = j + match_length + 4 // minmatch = 4
  		while (j < end) output[j++] = output[pos++]
  	}
  
  	return j
  }
  
  var
  	maxInputSize	= 0x7E000000
  ,	minMatch		= 4
  // uint32() optimization
  ,	hashLog			= 16
  ,	hashShift		= (minMatch * 8) - hashLog
  ,	hashSize		= 1 << hashLog
  
  ,	copyLength		= 8
  ,	lastLiterals	= 5
  ,	mfLimit			= copyLength + minMatch
  ,	skipStrength	= 6
  
  ,	mlBits  		= 4
  ,	mlMask  		= (1 << mlBits) - 1
  ,	runBits 		= 8 - mlBits
  ,	runMask 		= (1 << runBits) - 1
  
  ,	hasher 			= /* XXX uint32( */ 2654435761 /* ) */
  
  assert(hashShift === 16);
  var hashTable = new Int16Array(1<<16);
  var empty = new Int16Array(hashTable.length);
  
  // CompressBound returns the maximum length of a lz4 block, given it's uncompressed length
  exports.compressBound = function (isize) {
  	return isize > maxInputSize
  		? 0
  		: (isize + (isize/255) + 16) | 0
  }
  
  /** @param {number=} sIdx
  	@param {number=} eIdx */
  exports.compress = function (src, dst, sIdx, eIdx) {
  	hashTable.set(empty);
  	return compressBlock(src, dst, 0, sIdx || 0, eIdx || dst.length)
  }
  
  function compressBlock (src, dst, pos, sIdx, eIdx) {
  	// XXX var Hash = uint32() // Reusable unsigned 32 bits integer
  	var dpos = sIdx
  	var dlen = eIdx - sIdx
  	var anchor = 0
  
  	if (src.length >= maxInputSize) throw new Error("input too large")
  
  	// Minimum of input bytes for compression (LZ4 specs)
  	if (src.length > mfLimit) {
  		var n = exports.compressBound(src.length)
  		if ( dlen < n ) throw Error("output too small: " + dlen + " < " + n)
  
  		var 
  			step  = 1
  		,	findMatchAttempts = (1 << skipStrength) + 3
  		// Keep last few bytes incompressible (LZ4 specs):
  		// last 5 bytes must be literals
  		,	srcLength = src.length - mfLimit
  
  		while (pos + minMatch < srcLength) {
  			// Find a match
  			// min match of 4 bytes aka sequence
  			var sequenceLowBits = src[pos+1]<<8 | src[pos]
  			var sequenceHighBits = src[pos+3]<<8 | src[pos+2]
  			// compute hash for the current sequence
  			var hash = Math.imul(sequenceLowBits | (sequenceHighBits << 16), hasher) >>> hashShift;
  			/* XXX Hash.fromBits(sequenceLowBits, sequenceHighBits)
  							.multiply(hasher)
  							.shiftr(hashShift)
  							.toNumber() */
  			// get the position of the sequence matching the hash
  			// NB. since 2 different sequences may have the same hash
  			// it is double-checked below
  			// do -1 to distinguish between initialized and uninitialized values
  			var ref = hashTable[hash] - 1
  			// save position of current sequence in hash table
  			hashTable[hash] = pos + 1
  
  			// first reference or within 64k limit or current sequence !== hashed one: no match
  			if ( ref < 0 ||
  				((pos - ref) >>> 16) > 0 ||
  				(
  					((src[ref+3]<<8 | src[ref+2]) != sequenceHighBits) ||
  					((src[ref+1]<<8 | src[ref]) != sequenceLowBits )
  				)
  			) {
  				// increase step if nothing found within limit
  				step = findMatchAttempts++ >> skipStrength
  				pos += step
  				continue
  			}
  
  			findMatchAttempts = (1 << skipStrength) + 3
  
  			// got a match
  			var literals_length = pos - anchor
  			var offset = pos - ref
  
  			// minMatch already verified
  			pos += minMatch
  			ref += minMatch
  
  			// move to the end of the match (>=minMatch)
  			var match_length = pos
  			while (pos < srcLength && src[pos] == src[ref]) {
  				pos++
  				ref++
  			}
  
  			// match length
  			match_length = pos - match_length
  
  			// token
  			var token = match_length < mlMask ? match_length : mlMask
  
  			// encode literals length
  			if (literals_length >= runMask) {
  				// add match length to the token
  				dst[dpos++] = (runMask << mlBits) + token
  				for (var len = literals_length - runMask; len > 254; len -= 255) {
  					dst[dpos++] = 255
  				}
  				dst[dpos++] = len
  			} else {
  				// add match length to the token
  				dst[dpos++] = (literals_length << mlBits) + token
  			}
  
  			// write literals
  			for (var i = 0; i < literals_length; i++) {
  				dst[dpos++] = src[anchor+i]
  			}
  
  			// encode offset
  			dst[dpos++] = offset
  			dst[dpos++] = (offset >> 8)
  
  			// encode match length
  			if (match_length >= mlMask) {
  				match_length -= mlMask
  				while (match_length >= 255) {
  					match_length -= 255
  					dst[dpos++] = 255
  				}
  
  				dst[dpos++] = match_length
  			}
  
  			anchor = pos
  		}
  	}
  
  	// cannot compress input
  	if (anchor == 0) return 0
  
  	// Write last literals
  	// encode literals length
  	literals_length = src.length - anchor
  	if (literals_length >= runMask) {
  		// add match length to the token
  		dst[dpos++] = (runMask << mlBits)
  		for (var ln = literals_length - runMask; ln > 254; ln -= 255) {
  			dst[dpos++] = 255
  		}
  		dst[dpos++] = ln
  	} else {
  		// add match length to the token
  		dst[dpos++] = (literals_length << mlBits)
  	}
  
  	// write literals
  	pos = anchor
  	while (pos < src.length) {
  		dst[dpos++] = src[pos++]
  	}
  
  	return dpos
  }
  
  exports.CHUNK_SIZE = 2048; // musl libc does readaheads of 1024 bytes, so a multiple of that is a good idea
  
  exports.compressPackage = function(data, verify) {
    if (verify) {
      var temp = new Uint8Array(exports.CHUNK_SIZE);
    }
    // compress the data in chunks
    assert(data instanceof ArrayBuffer);
    data = new Uint8Array(data);
    console.log('compressing package of size ' + data.length);
    var compressedChunks = [];
    var successes = [];
    var offset = 0;
    var total = 0;
    while (offset < data.length) {
      var chunk = data.subarray(offset, offset + exports.CHUNK_SIZE);
      //console.log('compress a chunk ' + [offset, total, data.length]);
      offset += exports.CHUNK_SIZE;
      var bound = exports.compressBound(chunk.length);
      var compressed = new Uint8Array(bound);
      var compressedSize = exports.compress(chunk, compressed);
      if (compressedSize > 0) {
        assert(compressedSize <= bound);
        compressed = compressed.subarray(0, compressedSize);
        compressedChunks.push(compressed);
        total += compressedSize;
        successes.push(1);
        if (verify) {
          var back = exports.uncompress(compressed, temp);
          assert(back === chunk.length, [back, chunk.length]);
          for (var i = 0; i < chunk.length; i++) {
            assert(chunk[i] === temp[i]);
          }
        }
      } else {
        assert(compressedSize === 0);
        // failure to compress :(
        compressedChunks.push(chunk);
        total += chunk.length; // last chunk may not be the full exports.CHUNK_SIZE size
        successes.push(0);
      }
    }
    data = null; // XXX null out pack['data'] too?
    var compressedData = {
      'data': new Uint8Array(total + exports.CHUNK_SIZE*2), // store all the compressed data, plus room for two cached decompressed chunk, in one fast array
      'cachedOffset': total,
      'cachedIndexes': [-1, -1], // cache last two blocks, so that reading 1,2,3 + preloading another block won't trigger decompress thrashing
      'cachedChunks': [null, null],
      'offsets': [], // chunk# => start in compressed data
      'sizes': [],
      'successes': successes, // 1 if chunk is compressed
    };
    offset = 0;
    for (var i = 0; i < compressedChunks.length; i++) {
      compressedData['data'].set(compressedChunks[i], offset);
      compressedData['offsets'][i] = offset;
      compressedData['sizes'][i] = compressedChunks[i].length
      offset += compressedChunks[i].length;
    }
    console.log('compressed package into ' + [compressedData['data'].length]);
    assert(offset === total);
    return compressedData;
  };
  
  assert(exports.CHUNK_SIZE < (1 << 15)); // we use 16-bit ints as the type of the hash table, chunk size must be smaller
  
  return exports;
  
  })();
  
  ;
          return MiniLZ4;
        })();
        LZ4.CHUNK_SIZE = LZ4.codec.CHUNK_SIZE;
      },loadPackage:function (pack) {
        LZ4.init();
        var compressedData = pack['compressedData'];
        if (!compressedData) compressedData = LZ4.codec.compressPackage(pack['data']);
        assert(compressedData['cachedIndexes'].length === compressedData['cachedChunks'].length);
        for (var i = 0; i < compressedData['cachedIndexes'].length; i++) {
          compressedData['cachedIndexes'][i] = -1;
          compressedData['cachedChunks'][i] = compressedData['data'].subarray(compressedData['cachedOffset'] + i*LZ4.CHUNK_SIZE,
                                                                        compressedData['cachedOffset'] + (i+1)*LZ4.CHUNK_SIZE);
          assert(compressedData['cachedChunks'][i].length === LZ4.CHUNK_SIZE);
        }
        pack['metadata'].files.forEach(function(file) {
          var dir = PATH.dirname(file.filename);
          var name = PATH.basename(file.filename);
          FS.createPath('', dir, true, true);
          var parent = FS.analyzePath(dir).object;
          LZ4.createNode(parent, name, LZ4.FILE_MODE, 0, {
            compressedData: compressedData,
            start: file.start,
            end: file.end,
          });
        });
      },createNode:function (parent, name, mode, dev, contents, mtime) {
        var node = FS.createNode(parent, name, mode);
        node.mode = mode;
        node.node_ops = LZ4.node_ops;
        node.stream_ops = LZ4.stream_ops;
        node.timestamp = (mtime || new Date).getTime();
        assert(LZ4.FILE_MODE !== LZ4.DIR_MODE);
        if (mode === LZ4.FILE_MODE) {
          node.size = contents.end - contents.start;
          node.contents = contents;
        } else {
          node.size = 4096;
          node.contents = {};
        }
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },node_ops:{getattr:function(node) {
          return {
            dev: 1,
            ino: node.id,
            mode: node.mode,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: undefined,
            size: node.size,
            atime: new Date(node.timestamp),
            mtime: new Date(node.timestamp),
            ctime: new Date(node.timestamp),
            blksize: 4096,
            blocks: Math.ceil(node.size / 4096),
          };
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
        },lookup:function(parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        },mknod:function (parent, name, mode, dev) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },rename:function (oldNode, newDir, newName) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },unlink:function(parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },rmdir:function(parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },readdir:function(node) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },symlink:function(parent, newName, oldPath) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },readlink:function(node) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          //console.log('LZ4 read ' + [offset, length, position]);
          length = Math.min(length, stream.node.size - position);
          if (length <= 0) return 0;
          var contents = stream.node.contents;
          var compressedData = contents.compressedData;
          var written = 0;
          while (written < length) {
            var start = contents.start + position + written; // start index in uncompressed data
            var desired = length - written;
            //console.log('current read: ' + ['start', start, 'desired', desired]);
            var chunkIndex = Math.floor(start / LZ4.CHUNK_SIZE);
            var compressedStart = compressedData['offsets'][chunkIndex];
            var compressedSize = compressedData['sizes'][chunkIndex];
            var currChunk;
            if (compressedData['successes'][chunkIndex]) {
              var found = compressedData['cachedIndexes'].indexOf(chunkIndex);
              if (found >= 0) {
                currChunk = compressedData['cachedChunks'][found];
              } else {
                // decompress the chunk
                compressedData['cachedIndexes'].pop();
                compressedData['cachedIndexes'].unshift(chunkIndex);
                currChunk = compressedData['cachedChunks'].pop();
                compressedData['cachedChunks'].unshift(currChunk);
                if (compressedData['debug']) {
                  console.log('decompressing chunk ' + chunkIndex);
                  Module['decompressedChunks'] = (Module['decompressedChunks'] || 0) + 1;
                }
                var compressed = compressedData['data'].subarray(compressedStart, compressedStart + compressedSize);
                //var t = Date.now();
                var originalSize = LZ4.codec.uncompress(compressed, currChunk);
                //console.log('decompress time: ' + (Date.now() - t));
                if (chunkIndex < compressedData['successes'].length-1) assert(originalSize === LZ4.CHUNK_SIZE); // all but the last chunk must be full-size
              }
            } else {
              // uncompressed
              currChunk = compressedData['data'].subarray(compressedStart, compressedStart + LZ4.CHUNK_SIZE);
            }
            var startInChunk = start % LZ4.CHUNK_SIZE;
            var endInChunk = Math.min(startInChunk + desired, LZ4.CHUNK_SIZE);
            buffer.set(currChunk.subarray(startInChunk, endInChunk), offset + written);
            var currWritten = endInChunk - startInChunk;
            written += currWritten;
          }
          return written;
        },write:function (stream, buffer, offset, length, position) {
          throw new FS.ErrnoError(ERRNO_CODES.EIO);
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.size;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        }}};
  Module["LZ4"] = LZ4;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return setErrNo(e.errno);
      },lookupPath:function(path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function(parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function(node) {
        FS.hashRemoveNode(node);
      },isRoot:function(node) {
        return node === node.parent;
      },isMountpoint:function(node) {
        return !!node.mounted;
      },isFile:function(mode) {
        return (mode & 61440) === 32768;
      },isDir:function(mode) {
        return (mode & 61440) === 16384;
      },isLink:function(mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function(mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function(mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function(mode) {
        return (mode & 61440) === 4096;
      },isSocket:function(mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return 2;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return 2;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:function(dir) {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:function(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:function(fd) {
        return FS.streams[fd];
      },createStream:function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function(fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function() {
          throw new FS.ErrnoError(70);
        }},major:function(dev) {
        return ((dev) >> 8);
      },minor:function(dev) {
        return ((dev) & 0xff);
      },makedev:function(ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function(dev) {
        return FS.devices[dev];
      },getMounts:function(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function(populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function(type, opts, mountpoint) {
        if (typeof type === 'string') {
          // The filesystem was not included, and instead we have an error
          // message stored in the variable.
          throw type;
        }
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:function(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:function(path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(10);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          err("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:function(path) {
        return FS.stat(path, true);
      },chmod:function(path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function(path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          err("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:function(stream) {
        return stream.fd === null;
      },llseek:function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          err("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function(stream, buffer, offset, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function(stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function(stream) {
        return 0;
      },ioctl:function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:function() {
        return FS.currentPath;
      },chdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else
        {}
        if (!random_device) {
          // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
          random_device = function() { abort("no cryptographic support found for random_device. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"); };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function() {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        var stdout = FS.open('/dev/stdout', 'w');
        var stderr = FS.open('/dev/stderr', 'w');
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
  
          // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
          // now ensures it shows what we want.
          if (this.stack) {
            // Define the stack property for Node.js 4, which otherwise errors on the next line.
            Object.defineProperty(this, "stack", { value: (new Error).stack, writable: true });
            this.stack = demangleAll(this.stack);
          }
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function() {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:function(input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function() {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function(canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function(parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function(relative, base) {
        return PATH_FS.resolve(base, relative);
      },standardizePath:function(path) {
        return PATH.normalize(path);
      },findObject:function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          setErrNo(ret.error);
          return null;
        }
      },analyzePath:function(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function(parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function(parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function(parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function(parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function(parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) setErrNo(29);
        return success;
      },createLazyFile:function(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(29);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(29);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function() {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  Module["FS"] = FS;var SYSCALLS={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(dirfd, path) {
        if (path[0] !== '/') {
          // relative path
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path;
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)]=stat.dev;
        HEAP32[(((buf)+(4))>>2)]=0;
        HEAP32[(((buf)+(8))>>2)]=stat.ino;
        HEAP32[(((buf)+(12))>>2)]=stat.mode;
        HEAP32[(((buf)+(16))>>2)]=stat.nlink;
        HEAP32[(((buf)+(20))>>2)]=stat.uid;
        HEAP32[(((buf)+(24))>>2)]=stat.gid;
        HEAP32[(((buf)+(28))>>2)]=stat.rdev;
        HEAP32[(((buf)+(32))>>2)]=0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)]=tempI64[0],HEAP32[(((buf)+(44))>>2)]=tempI64[1]);
        HEAP32[(((buf)+(48))>>2)]=4096;
        HEAP32[(((buf)+(52))>>2)]=stat.blocks;
        HEAP32[(((buf)+(56))>>2)]=(stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)]=0;
        HEAP32[(((buf)+(64))>>2)]=(stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)]=0;
        HEAP32[(((buf)+(72))>>2)]=(stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)]=0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)]=tempI64[0],HEAP32[(((buf)+(84))>>2)]=tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doDup:function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        assert(SYSCALLS.varargs != undefined);
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      }};
  Module["SYSCALLS"] = SYSCALLS;function ___sys_access(path, amode) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doAccess(path, amode);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_access"] = ___sys_access;

  function ___sys_acct(filename) {
      return -52; // unsupported features
    }
  Module["___sys_acct"] = ___sys_acct;

  function ___sys_chdir(path) {try {
  
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_chdir"] = ___sys_chdir;

  function ___sys_chmod(path, mode) {try {
  
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_chmod"] = ___sys_chmod;

  function ___sys_chown32(path, owner, group) {try {
  
      path = SYSCALLS.getStr(path);
      FS.chown(path, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_chown32"] = ___sys_chown32;

  function ___sys_dup(fd) {try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.open(old.path, old.flags, 0).fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_dup"] = ___sys_dup;

  function ___sys_dup2(oldfd, suggestFD) {try {
  
      var old = SYSCALLS.getStreamFromFD(oldfd);
      if (old.fd === suggestFD) return suggestFD;
      return SYSCALLS.doDup(old.path, old.flags, suggestFD);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_dup2"] = ___sys_dup2;

  function ___sys_dup3(fd, suggestFD, flags) {try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      assert(!flags);
      if (old.fd === suggestFD) return -28;
      return SYSCALLS.doDup(old.path, old.flags, suggestFD);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_dup3"] = ___sys_dup3;

  function ___sys_fadvise64_64(fd, offset, len, advice) {
      return 0; // your advice is important to us (but we can't use it)
    }
  Module["___sys_fadvise64_64"] = ___sys_fadvise64_64;

  function ___sys_fallocate(fd, mode, off_low, off_high, len_low, len_high) {try {
  
      
      
      var stream = SYSCALLS.getStreamFromFD(fd)
      var offset = SYSCALLS.get64(off_low, off_high);
      var len = SYSCALLS.get64(len_low, len_high);
      assert(mode === 0);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fallocate"] = ___sys_fallocate;

  function ___sys_fchdir(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.chdir(stream.path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fchdir"] = ___sys_fchdir;

  function ___sys_fchmod(fd, mode) {try {
  
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fchmod"] = ___sys_fchmod;

  function ___sys_fchmodat(dirfd, path, mode, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      mode = SYSCALLS.get();
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fchmodat"] = ___sys_fchmodat;

  function ___sys_fchown32(fd, owner, group) {try {
  
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fchown32"] = ___sys_fchown32;

  function ___sys_fchownat(dirfd, path, owner, group, flags) {try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path);
      FS.chown(path, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fchownat"] = ___sys_fchownat;

  function ___sys_fcntl64(fd, cmd, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 12:
        /* case 12: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)]=2;
          return 0;
        }
        case 13:
        case 14:
        /* case 13: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 14: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fcntl64"] = ___sys_fcntl64;

  function ___sys_fdatasync(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fdatasync"] = ___sys_fdatasync;

  function ___sys_fstat64(fd, buf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fstat64"] = ___sys_fstat64;

  function ___sys_fstatat64(dirfd, path, buf, flags) {try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & (~256);
      assert(!flags, flags);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fstatat64"] = ___sys_fstatat64;

  function ___sys_fstatfs64(fd, size, buf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return ___sys_statfs64(0, size, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_fstatfs64"] = ___sys_fstatfs64;

  function ___sys_ftruncate64(fd, zero, low, high) {try {
  
      var length = SYSCALLS.get64(low, high);
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_ftruncate64"] = ___sys_ftruncate64;

  function ___sys_getcwd(buf, size) {try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd);
      if (size < cwdLengthInBytes + 1) return -68;
      stringToUTF8(cwd, buf, size);
      return buf;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_getcwd"] = ___sys_getcwd;

  function ___sys_getdents64(fd, dirp, count) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd)
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
  
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
  
      var idx = Math.floor(off / struct_size);
  
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name[0] === '.') {
          id = 1;
          type = 4; // DT_DIR
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
                 8;                             // DT_REG, regular file.
        }
        (tempI64 = [id>>>0,(tempDouble=id,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((dirp + pos)>>2)]=tempI64[0],HEAP32[(((dirp + pos)+(4))>>2)]=tempI64[1]);
        (tempI64 = [(idx + 1) * struct_size>>>0,(tempDouble=(idx + 1) * struct_size,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((dirp + pos)+(8))>>2)]=tempI64[0],HEAP32[(((dirp + pos)+(12))>>2)]=tempI64[1]);
        HEAP16[(((dirp + pos)+(16))>>1)]=280;
        HEAP8[(((dirp + pos)+(18))>>0)]=type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_getdents64"] = ___sys_getdents64;

  function ___sys_getegid32() {
      return 0;
    }
  Module["___sys_getegid32"] = ___sys_getegid32;

  function ___sys_geteuid32(
  ) {
  return ___sys_getegid32();
  }
  Module["___sys_geteuid32"] = ___sys_geteuid32;

  function ___sys_getgid32(
  ) {
  return ___sys_getegid32();
  }
  Module["___sys_getgid32"] = ___sys_getgid32;

  function ___sys_getgroups32(size, list) {
      if (size < 1) return -28;
      HEAP32[((list)>>2)]=0;
      return 1;
    }
  Module["___sys_getgroups32"] = ___sys_getgroups32;

  function ___sys_getpgid(pid) {
      if (pid && pid !== 42) return -71;
      return 42;
    }
  Module["___sys_getpgid"] = ___sys_getpgid;

  function ___sys_getpid() {
      return 42;
    }
  Module["___sys_getpid"] = ___sys_getpid;

  function ___sys_getppid() {
      return 1;
    }
  Module["___sys_getppid"] = ___sys_getppid;

  function ___sys_getpriority() {
      return 0;
    }
  Module["___sys_getpriority"] = ___sys_getpriority;

  function ___sys_getresgid32(ruid, euid, suid) {
      HEAP32[((ruid)>>2)]=0;
      HEAP32[((euid)>>2)]=0;
      HEAP32[((suid)>>2)]=0;
      return 0;
    }
  Module["___sys_getresgid32"] = ___sys_getresgid32;

  function ___sys_getresuid32(a0,a1,a2
  ) {
  return ___sys_getresgid32(a0,a1,a2);
  }
  Module["___sys_getresuid32"] = ___sys_getresuid32;

  function ___sys_getrusage(who, usage) {try {
  
      _memset(usage, 0, 136);
      HEAP32[((usage)>>2)]=1; // fake some values
      HEAP32[(((usage)+(4))>>2)]=2;
      HEAP32[(((usage)+(8))>>2)]=3;
      HEAP32[(((usage)+(12))>>2)]=4;
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_getrusage"] = ___sys_getrusage;

  function ___sys_getsid(pid) {
      if (pid && pid !== 42) return -71;
      return 42;
    }
  Module["___sys_getsid"] = ___sys_getsid;

  function ___sys_getuid32(
  ) {
  return ___sys_getegid32();
  }
  Module["___sys_getuid32"] = ___sys_getuid32;

  function ___sys_ioctl(fd, op, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)]=0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_ioctl"] = ___sys_ioctl;

  function ___sys_lchown32(path, owner, group) {try {
  
      path = SYSCALLS.getStr(path);
      FS.chown(path, owner, group); // XXX we ignore the 'l' aspect, and do the same as chown
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_lchown32"] = ___sys_lchown32;

  function ___sys_link(oldpath, newpath) {
      return -34; // no hardlinks for us
    }
  Module["___sys_link"] = ___sys_link;

  function ___sys_linkat(olddirfd, oldpath, newdirfd, newpath, flags) {
      return -34; // no hardlinks for us
    }
  Module["___sys_linkat"] = ___sys_linkat;

  function ___sys_lstat64(path, buf) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_lstat64"] = ___sys_lstat64;

  function ___sys_madvise1(addr, length, advice) {
      return 0; // advice is welcome, but ignored
    }
  Module["___sys_madvise1"] = ___sys_madvise1;

  function ___sys_mincore(addr, length, vec) {
      return -52; // unsupported feature
    }
  Module["___sys_mincore"] = ___sys_mincore;

  function ___sys_mkdir(path, mode) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doMkdir(path, mode);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_mkdir"] = ___sys_mkdir;

  function ___sys_mkdirat(dirfd, path, mode) {try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doMkdir(path, mode);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_mkdirat"] = ___sys_mkdirat;

  function ___sys_mknod(path, mode, dev) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doMknod(path, mode, dev);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_mknod"] = ___sys_mknod;

  function ___sys_mknodat(dirfd, path, mode, dev) {try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doMknod(path, mode, dev);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_mknodat"] = ___sys_mknodat;

  function ___sys_mlock(addr, len) {
      return 0;
    }
  Module["___sys_mlock"] = ___sys_mlock;

  function ___sys_mlockall(flags) {
      return 0;
    }
  Module["___sys_mlockall"] = ___sys_mlockall;

  
  function syscallMmap2(addr, len, prot, flags, fd, off) {
      off <<= 12; // undo pgoffset
      var ptr;
      var allocated = false;
  
      // addr argument must be page aligned if MAP_FIXED flag is set.
      if ((flags & 16) !== 0 && (addr % 16384) !== 0) {
        return -28;
      }
  
      // MAP_ANONYMOUS (aka MAP_ANON) isn't actually defined by POSIX spec,
      // but it is widely used way to allocate memory pages on Linux, BSD and Mac.
      // In this case fd argument is ignored.
      if ((flags & 32) !== 0) {
        ptr = _memalign(16384, len);
        if (!ptr) return -48;
        _memset(ptr, 0, len);
        allocated = true;
      } else {
        var info = FS.getStream(fd);
        if (!info) return -8;
        var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags);
        ptr = res.ptr;
        allocated = res.allocated;
      }
      SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, prot: prot, flags: flags, offset: off };
      return ptr;
    }
  Module["syscallMmap2"] = syscallMmap2;function ___sys_mmap2(addr, len, prot, flags, fd, off) {try {
  
      return syscallMmap2(addr, len, prot, flags, fd, off);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_mmap2"] = ___sys_mmap2;

  function ___sys_mprotect(addr, len, size) {
      return 0; // let's not and say we did
    }
  Module["___sys_mprotect"] = ___sys_mprotect;

  function ___sys_mremap(old_addr, old_size, new_size, flags) {
      return -48; // never succeed
    }
  Module["___sys_mremap"] = ___sys_mremap;

  function ___sys_msync(addr, len, flags) {try {
  
      var info = SYSCALLS.mappings[addr];
      if (!info) return 0;
      SYSCALLS.doMsync(addr, FS.getStream(info.fd), len, info.flags, 0);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_msync"] = ___sys_msync;

  function ___sys_munlock(addr, len) {
      return 0;
    }
  Module["___sys_munlock"] = ___sys_munlock;

  function ___sys_munlockall() {
      return 0;
    }
  Module["___sys_munlockall"] = ___sys_munlockall;

  
  function syscallMunmap(addr, len) {
      if ((addr | 0) === -1 || len === 0) {
        return -28;
      }
      // TODO: support unmmap'ing parts of allocations
      var info = SYSCALLS.mappings[addr];
      if (!info) return 0;
      if (len === info.len) {
        var stream = FS.getStream(info.fd);
        if (info.prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);
        }
        FS.munmap(stream);
        SYSCALLS.mappings[addr] = null;
        if (info.allocated) {
          _free(info.malloc);
        }
      }
      return 0;
    }
  Module["syscallMunmap"] = syscallMunmap;function ___sys_munmap(addr, len) {try {
  
      return syscallMunmap(addr, len);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_munmap"] = ___sys_munmap;

  function ___sys_nice(inc) {
      return -63; // no meaning to nice for our single-process environment
    }
  Module["___sys_nice"] = ___sys_nice;

  function ___sys_open(path, flags, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var pathname = SYSCALLS.getStr(path);
      var mode = SYSCALLS.get();
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_open"] = ___sys_open;

  function ___sys_openat(dirfd, path, flags, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = SYSCALLS.get();
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_openat"] = ___sys_openat;

  function ___sys_pause() {
      return -27; // we can't pause
    }
  Module["___sys_pause"] = ___sys_pause;

  
  var PIPEFS={BUCKET_BUFFER_SIZE:8192,mount:function (mount) {
        // Do not pollute the real root directory or its child nodes with pipes
        // Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createPipe:function () {
        var pipe = {
          buckets: []
        };
  
        pipe.buckets.push({
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: 0,
          roffset: 0
        });
  
        var rName = PIPEFS.nextname();
        var wName = PIPEFS.nextname();
        var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
        var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
  
        rNode.pipe = pipe;
        wNode.pipe = pipe;
  
        var readableStream = FS.createStream({
          path: rName,
          node: rNode,
          flags: FS.modeStringToFlags('r'),
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        rNode.stream = readableStream;
  
        var writableStream = FS.createStream({
          path: wName,
          node: wNode,
          flags: FS.modeStringToFlags('w'),
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        wNode.stream = writableStream;
  
        return {
          readable_fd: readableStream.fd,
          writable_fd: writableStream.fd
        };
      },stream_ops:{poll:function (stream) {
          var pipe = stream.node.pipe;
  
          if ((stream.flags & 2097155) === 1) {
            return (256 | 4);
          } else {
            if (pipe.buckets.length > 0) {
              for (var i = 0; i < pipe.buckets.length; i++) {
                var bucket = pipe.buckets[i];
                if (bucket.offset - bucket.roffset > 0) {
                  return (64 | 1);
                }
              }
            }
          }
  
          return 0;
        },ioctl:function (stream, request, varargs) {
          return ERRNO_CODES.EINVAL;
        },fsync:function (stream) {
          return ERRNO_CODES.EINVAL;
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
          var currentLength = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            currentLength += bucket.offset - bucket.roffset;
          }
  
          assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
          var data = buffer.subarray(offset, offset + length);
  
          if (length <= 0) {
            return 0;
          }
          if (currentLength == 0) {
            // Behave as if the read end is always non-blocking
            throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
          }
          var toRead = Math.min(currentLength, length);
  
          var totalRead = toRead;
          var toRemove = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var currBucket = pipe.buckets[i];
            var bucketSize = currBucket.offset - currBucket.roffset;
  
            if (toRead <= bucketSize) {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              if (toRead < bucketSize) {
                tmpSlice = tmpSlice.subarray(0, toRead);
                currBucket.roffset += toRead;
              } else {
                toRemove++;
              }
              data.set(tmpSlice);
              break;
            } else {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              data.set(tmpSlice);
              data = data.subarray(tmpSlice.byteLength);
              toRead -= tmpSlice.byteLength;
              toRemove++;
            }
          }
  
          if (toRemove && toRemove == pipe.buckets.length) {
            // Do not generate excessive garbage in use cases such as
            // write several bytes, read everything, write several bytes, read everything...
            toRemove--;
            pipe.buckets[toRemove].offset = 0;
            pipe.buckets[toRemove].roffset = 0;
          }
  
          pipe.buckets.splice(0, toRemove);
  
          return totalRead;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
  
          assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
          var data = buffer.subarray(offset, offset + length);
  
          var dataLen = data.byteLength;
          if (dataLen <= 0) {
            return 0;
          }
  
          var currBucket = null;
  
          if (pipe.buckets.length == 0) {
            currBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            };
            pipe.buckets.push(currBucket);
          } else {
            currBucket = pipe.buckets[pipe.buckets.length - 1];
          }
  
          assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
  
          var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
          if (freeBytesInCurrBuffer >= dataLen) {
            currBucket.buffer.set(data, currBucket.offset);
            currBucket.offset += dataLen;
            return dataLen;
          } else if (freeBytesInCurrBuffer > 0) {
            currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
            currBucket.offset += freeBytesInCurrBuffer;
            data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
          }
  
          var numBuckets = (data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE) | 0;
          var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
  
          for (var i = 0; i < numBuckets; i++) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: PIPEFS.BUCKET_BUFFER_SIZE,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
            data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
          }
  
          if (remElements > 0) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: data.byteLength,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data);
          }
  
          return dataLen;
        },close:function (stream) {
          var pipe = stream.node.pipe;
          pipe.buckets = null;
        }},nextname:function () {
        if (!PIPEFS.nextname.current) {
          PIPEFS.nextname.current = 0;
        }
        return 'pipe[' + (PIPEFS.nextname.current++) + ']';
      }};
  Module["PIPEFS"] = PIPEFS;function ___sys_pipe(fdPtr) {try {
  
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
  
      var res = PIPEFS.createPipe();
  
      HEAP32[((fdPtr)>>2)]=res.readable_fd;
      HEAP32[(((fdPtr)+(4))>>2)]=res.writable_fd;
  
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_pipe"] = ___sys_pipe;

  function ___sys_pipe2(fds, flags) {
      return -52; // unsupported feature
    }
  Module["___sys_pipe2"] = ___sys_pipe2;

  function ___sys_poll(fds, nfds, timeout) {try {
  
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[((pollfd)>>2)];
        var events = HEAP16[(((pollfd)+(4))>>1)];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops.poll) {
            mask = stream.stream_ops.poll(stream);
          }
        }
        mask &= events | 8 | 16;
        if (mask) nonzero++;
        HEAP16[(((pollfd)+(6))>>1)]=mask;
      }
      return nonzero;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_poll"] = ___sys_poll;

  function ___sys_pread64(fd, buf, count, zero, low, high) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd)
      var offset = SYSCALLS.get64(low, high);
      return FS.read(stream, HEAP8,buf, count, offset);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_pread64"] = ___sys_pread64;

  function ___sys_preadv(fd, iov, iovcnt, low, high) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doReadv(stream, iov, iovcnt, offset);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_preadv"] = ___sys_preadv;

  function ___sys_prlimit64(pid, resource, new_limit, old_limit) {try {
  
      if (old_limit) { // just report no limits
        HEAP32[((old_limit)>>2)]=-1;  // RLIM_INFINITY
        HEAP32[(((old_limit)+(4))>>2)]=-1;  // RLIM_INFINITY
        HEAP32[(((old_limit)+(8))>>2)]=-1;  // RLIM_INFINITY
        HEAP32[(((old_limit)+(12))>>2)]=-1;  // RLIM_INFINITY
      }
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_prlimit64"] = ___sys_prlimit64;

  function ___sys_pselect6() {
      return -52; // unsupported feature
    }
  Module["___sys_pselect6"] = ___sys_pselect6;

  function ___sys_pwrite64(fd, buf, count, zero, low, high) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd)
      var offset = SYSCALLS.get64(low, high);
      return FS.write(stream, HEAP8,buf, count, offset);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_pwrite64"] = ___sys_pwrite64;

  function ___sys_pwritev(fd, iov, iovcnt, low, high) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var offset = SYSCALLS.get64(low, high);
      return SYSCALLS.doWritev(stream, iov, iovcnt, offset);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_pwritev"] = ___sys_pwritev;

  function ___sys_read(fd, buf, count) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return FS.read(stream, HEAP8,buf, count);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_read"] = ___sys_read;

  function ___sys_readlink(path, buf, bufsize) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doReadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_readlink"] = ___sys_readlink;

  function ___sys_readlinkat(dirfd, path, buf, bufsize) {try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doReadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_readlinkat"] = ___sys_readlinkat;

  function ___sys_recvmmsg(sockfd, msgvec, vlen, flags) {
      return 0;
    }
  Module["___sys_recvmmsg"] = ___sys_recvmmsg;

  function ___sys_rename(old_path, new_path) {try {
  
      old_path = SYSCALLS.getStr(old_path);
      new_path = SYSCALLS.getStr(new_path);
      FS.rename(old_path, new_path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_rename"] = ___sys_rename;

  function ___sys_renameat(olddirfd, oldpath, newdirfd, newpath) {try {
  
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_renameat"] = ___sys_renameat;

  function ___sys_rmdir(path) {try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_rmdir"] = ___sys_rmdir;

  function ___sys_sendmmsg(sockfd, msg, flags) {
      return 0;
    }
  Module["___sys_sendmmsg"] = ___sys_sendmmsg;

  function ___sys_setdomainname(name, size) {
      return -63;
    }
  Module["___sys_setdomainname"] = ___sys_setdomainname;

  function ___sys_setpgid(pid, pgid) {
      if (pid && pid !== 42) return -71;
      if (pgid && pgid !== 42) return -63;
      return 0;
    }
  Module["___sys_setpgid"] = ___sys_setpgid;

  function ___sys_setpriority() {
      return -63;
    }
  Module["___sys_setpriority"] = ___sys_setpriority;

  function ___sys_setrlimit(varargs) {
      return 0; // no-op
    }
  Module["___sys_setrlimit"] = ___sys_setrlimit;

  function ___sys_setsid() {
      return 0; // no-op
    }
  Module["___sys_setsid"] = ___sys_setsid;

  
  var SOCKFS={mount:function(mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] && 
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};
  
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = /** @this{Object} */ function(event, callback) {
  	    if ('function' === typeof callback) {
  		  this._callbacks[event] = callback;
          }
  	    return this;
        };
  
        Module['websocket'].emit = /** @this{Object} */ function(event, param) {
  	    if ('function' === typeof this._callbacks[event]) {
  		  this._callbacks[event].call(this, param);
          }
        };
  
        // If debug is enabled register simple default logging callbacks for each Event.
  
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function(family, type, protocol) {
        var streaming = type == 1;
        if (protocol) {
          assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: FS.modeStringToFlags('r+'),
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function(stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function(stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function(stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function() {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function(sock, addr, port) {
          var ws;
  
          if (typeof addr === 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));
  
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }
  
              // The default WebSocket options
              var opts = undefined;
  
              if (subProtocols !== 'null') {
                // The regex trims the string (removes spaces at the beginning and end, then splits the string by
                // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
                subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
                // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
                opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;
              }
  
              // some webservers (azure) does not support subprotocol header
              if (runtimeConfig && null === Module['websocket']['subprotocol']) {
                subProtocols = 'null';
                opts = undefined;
              }
  
              // If node we use the ws library.
              var WebSocketConstructor;
              {
                WebSocketConstructor = WebSocket;
              }
              ws = new WebSocketConstructor(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
            }
          }
  
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport !== 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function(sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function(sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function(sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function(sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            Module['websocket'].emit('open', sock.stream.fd);
  
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            if (typeof data === 'string') {
              var encoder = new TextEncoder(); // should be utf-8
              data = encoder.encode(data); // make a typed array from the string
            } else {
              assert(data.byteLength !== undefined); // must receive an ArrayBuffer
              if (data.byteLength == 0) {
                // An empty ArrayBuffer will emit a pseudo disconnect event
                // as recv/recvmsg will return zero which indicates that a socket
                // has performed a shutdown although the connection has not been disconnected yet.
                return;
              } else {
                data = new Uint8Array(data); // make a typed array view on the array buffer
              }
            }
  
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g. 
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },poll:function(sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function(sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)]=bytes;
              return 0;
            default:
              return ERRNO_CODES.EINVAL;
          }
        },close:function(sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function(sock, addr, port) {
          if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port;
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
            }
          }
        },connect:function(sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
              } else {
                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
        },listen:function(sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
        },accept:function(listensock) {
          if (!listensock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function(sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function(sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          if (ArrayBuffer.isView(buffer)) {
            offset += buffer.byteOffset;
            buffer = buffer.buffer;
          }
  
          var data;
            data = buffer.slice(offset, offset + length);
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
        },recvmsg:function(sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
            } else {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};
  Module["SOCKFS"] = SOCKFS;
  
  
  function __inet_pton4_raw(str) {
      var b = str.split('.');
      for (var i = 0; i < 4; i++) {
        var tmp = Number(b[i]);
        if (isNaN(tmp)) return null;
        b[i] = tmp;
      }
      return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
    }
  Module["__inet_pton4_raw"] = __inet_pton4_raw;
  
  
  /** @suppress {checkTypes} */
  function jstoi_q(str) {
      return parseInt(str);
    }
  Module["jstoi_q"] = jstoi_q;function __inet_pton6_raw(str) {
      var words;
      var w, offset, z, i;
      /* http://home.deds.nl/~aeron/regex/ */
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
      var parts = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      // Z placeholder to keep track of zeros when splitting the string on ":"
      if (str.indexOf("::") === 0) {
        str = str.replace("::", "Z:"); // leading zeros case
      } else {
        str = str.replace("::", ":Z:");
      }
  
      if (str.indexOf(".") > 0) {
        // parse IPv4 embedded stress
        str = str.replace(new RegExp('[.]', 'g'), ":");
        words = str.split(":");
        words[words.length-4] = jstoi_q(words[words.length-4]) + jstoi_q(words[words.length-3])*256;
        words[words.length-3] = jstoi_q(words[words.length-2]) + jstoi_q(words[words.length-1])*256;
        words = words.slice(0, words.length-2);
      } else {
        words = str.split(":");
      }
  
      offset = 0; z = 0;
      for (w=0; w < words.length; w++) {
        if (typeof words[w] === 'string') {
          if (words[w] === 'Z') {
            // compressed zeros - write appropriate number of zero words
            for (z = 0; z < (8 - words.length+1); z++) {
              parts[w+z] = 0;
            }
            offset = z-1;
          } else {
            // parse hex to field to 16-bit value and write it in network byte-order
            parts[w+offset] = _htons(parseInt(words[w],16));
          }
        } else {
          // parsed IPv4 words
          parts[w+offset] = words[w];
        }
      }
      return [
        (parts[1] << 16) | parts[0],
        (parts[3] << 16) | parts[2],
        (parts[5] << 16) | parts[4],
        (parts[7] << 16) | parts[6]
      ];
    }
  Module["__inet_pton6_raw"] = __inet_pton6_raw;var DNS={address_map:{id:1,addrs:{},names:{}},lookup_name:function (name) {
        // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
        var res = __inet_pton4_raw(name);
        if (res !== null) {
          return name;
        }
        res = __inet_pton6_raw(name);
        if (res !== null) {
          return name;
        }
  
        // See if this name is already mapped.
        var addr;
  
        if (DNS.address_map.addrs[name]) {
          addr = DNS.address_map.addrs[name];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, 'exceeded max address mappings of 65535');
  
          addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);
  
          DNS.address_map.names[addr] = name;
          DNS.address_map.addrs[name] = addr;
        }
  
        return addr;
      },lookup_addr:function (addr) {
        if (DNS.address_map.names[addr]) {
          return DNS.address_map.names[addr];
        }
  
        return null;
      }};
  Module["DNS"] = DNS;
  
  
  var Sockets={BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},nextport:1,maxport:65535,peer:null,connections:{},portmap:{},localAddr:4261412874,addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034]};
  Module["Sockets"] = Sockets;
  
  function __inet_ntop4_raw(addr) {
      return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
    }
  Module["__inet_ntop4_raw"] = __inet_ntop4_raw;
  
  function __inet_ntop6_raw(ints) {
      //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
      //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
      //  128-bits are split into eight 16-bit words
      //  stored in network byte order (big-endian)
      //  |                80 bits               | 16 |      32 bits        |
      //  +-----------------------------------------------------------------+
      //  |               10 bytes               |  2 |      4 bytes        |
      //  +--------------------------------------+--------------------------+
      //  +               5 words                |  1 |      2 words        |
      //  +--------------------------------------+--------------------------+
      //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
      //  +--------------------------------------+----+---------------------+
      //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
      //  +--------------------------------------+----+---------------------+
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i = 0;
      var parts = [
        ints[0] & 0xffff,
        (ints[0] >> 16),
        ints[1] & 0xffff,
        (ints[1] >> 16),
        ints[2] & 0xffff,
        (ints[2] >> 16),
        ints[3] & 0xffff,
        (ints[3] >> 16)
      ];
  
      // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses
  
      var hasipv4 = true;
      var v4part = "";
      // check if the 10 high-order bytes are all zeros (first 5 words)
      for (i = 0; i < 5; i++) {
        if (parts[i] !== 0) { hasipv4 = false; break; }
      }
  
      if (hasipv4) {
        // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
        v4part = __inet_ntop4_raw(parts[6] | (parts[7] << 16));
        // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
        if (parts[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
        if (parts[5] === 0) {
          str = "::";
          //special case IPv6 addresses
          if(v4part === "0.0.0.0") v4part = ""; // any/unspecified address
          if(v4part === "0.0.0.1") v4part = "1";// loopback address
          str += v4part;
          return str;
        }
      }
  
      // Handle all other IPv6 addresses
  
      // first run to find the longest contiguous zero words
      for (word = 0; word < 8; word++) {
        if (parts[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }
  
      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          // compress contiguous zeros - to produce "::"
          if (parts[word] === 0 && word >= zstart && word < (zstart + longest) ) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0) str += ":"; //leading zeros case
            }
            continue;
          }
        }
        // converts 16-bit words from big-endian to little-endian before converting to hex string
        str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    }
  Module["__inet_ntop6_raw"] = __inet_ntop6_raw;function __read_sockaddr(sa, salen) {
      // family / port offsets are common to both sockaddr_in and sockaddr_in6
      var family = HEAP16[((sa)>>1)];
      var port = _ntohs(HEAPU16[(((sa)+(2))>>1)]);
      var addr;
  
      switch (family) {
        case 2:
          if (salen !== 16) {
            return { errno: 28 };
          }
          addr = HEAP32[(((sa)+(4))>>2)];
          addr = __inet_ntop4_raw(addr);
          break;
        case 10:
          if (salen !== 28) {
            return { errno: 28 };
          }
          addr = [
            HEAP32[(((sa)+(8))>>2)],
            HEAP32[(((sa)+(12))>>2)],
            HEAP32[(((sa)+(16))>>2)],
            HEAP32[(((sa)+(20))>>2)]
          ];
          addr = __inet_ntop6_raw(addr);
          break;
        default:
          return { errno: 5 };
      }
  
      return { family: family, addr: addr, port: port };
    }
  Module["__read_sockaddr"] = __read_sockaddr;
  
  function __write_sockaddr(sa, family, addr, port) {
      switch (family) {
        case 2:
          addr = __inet_pton4_raw(addr);
          HEAP16[((sa)>>1)]=family;
          HEAP32[(((sa)+(4))>>2)]=addr;
          HEAP16[(((sa)+(2))>>1)]=_htons(port);
          break;
        case 10:
          addr = __inet_pton6_raw(addr);
          HEAP32[((sa)>>2)]=family;
          HEAP32[(((sa)+(8))>>2)]=addr[0];
          HEAP32[(((sa)+(12))>>2)]=addr[1];
          HEAP32[(((sa)+(16))>>2)]=addr[2];
          HEAP32[(((sa)+(20))>>2)]=addr[3];
          HEAP16[(((sa)+(2))>>1)]=_htons(port);
          HEAP32[(((sa)+(4))>>2)]=0;
          HEAP32[(((sa)+(24))>>2)]=0;
          break;
        default:
          return { errno: 5 };
      }
      // kind of lame, but let's match _read_sockaddr's interface
      return {};
    }
  Module["__write_sockaddr"] = __write_sockaddr;function ___sys_socketcall(call, socketvararg) {try {
  
      // socketcalls pass the rest of the arguments in a struct
      SYSCALLS.varargs = socketvararg;
  
      var getSocketFromFD = function() {
        var socket = SOCKFS.getSocket(SYSCALLS.get());
        if (!socket) throw new FS.ErrnoError(8);
        return socket;
      };
      /** @param {boolean=} allowNull */
      var getSocketAddress = function(allowNull) {
        var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();
        if (allowNull && addrp === 0) return null;
        var info = __read_sockaddr(addrp, addrlen);
        if (info.errno) throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info;
      };
  
      switch (call) {
        case 1: { // socket
          var domain = SYSCALLS.get(), type = SYSCALLS.get(), protocol = SYSCALLS.get();
          var sock = SOCKFS.createSocket(domain, type, protocol);
          assert(sock.stream.fd < 64); // XXX ? select() assumes socket fd values are in 0..63
          return sock.stream.fd;
        }
        case 2: { // bind
          var sock = getSocketFromFD(), info = getSocketAddress();
          sock.sock_ops.bind(sock, info.addr, info.port);
          return 0;
        }
        case 3: { // connect
          var sock = getSocketFromFD(), info = getSocketAddress();
          sock.sock_ops.connect(sock, info.addr, info.port);
          return 0;
        }
        case 4: { // listen
          var sock = getSocketFromFD(), backlog = SYSCALLS.get();
          sock.sock_ops.listen(sock, backlog);
          return 0;
        }
        case 5: { // accept
          var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
          var newsock = sock.sock_ops.accept(sock);
          if (addr) {
            var res = __write_sockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport);
            assert(!res.errno);
          }
          return newsock.stream.fd;
        }
        case 6: { // getsockname
          var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
          // TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
          var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || '0.0.0.0'), sock.sport);
          assert(!res.errno);
          return 0;
        }
        case 7: { // getpeername
          var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
          if (!sock.daddr) {
            return -53; // The socket is not connected.
          }
          var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport);
          assert(!res.errno);
          return 0;
        }
        case 11: { // sendto
          var sock = getSocketFromFD(), message = SYSCALLS.get(), length = SYSCALLS.get(), flags = SYSCALLS.get(), dest = getSocketAddress(true);
          if (!dest) {
            // send, no address provided
            return FS.write(sock.stream, HEAP8,message, length);
          } else {
            // sendto an address
            return sock.sock_ops.sendmsg(sock, HEAP8,message, length, dest.addr, dest.port);
          }
        }
        case 12: { // recvfrom
          var sock = getSocketFromFD(), buf = SYSCALLS.get(), len = SYSCALLS.get(), flags = SYSCALLS.get(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
          var msg = sock.sock_ops.recvmsg(sock, len);
          if (!msg) return 0; // socket is closed
          if (addr) {
            var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port);
            assert(!res.errno);
          }
          HEAPU8.set(msg.buffer, buf);
          return msg.buffer.byteLength;
        }
        case 14: { // setsockopt
          return -50; // The option is unknown at the level indicated.
        }
        case 15: { // getsockopt
          var sock = getSocketFromFD(), level = SYSCALLS.get(), optname = SYSCALLS.get(), optval = SYSCALLS.get(), optlen = SYSCALLS.get();
          // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
          // so only supports SOL_SOCKET with SO_ERROR.
          if (level === 1) {
            if (optname === 4) {
              HEAP32[((optval)>>2)]=sock.error;
              HEAP32[((optlen)>>2)]=4;
              sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
              return 0;
            }
          }
          return -50; // The option is unknown at the level indicated.
        }
        case 16: { // sendmsg
          var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();
          var iov = HEAP32[(((message)+(8))>>2)];
          var num = HEAP32[(((message)+(12))>>2)];
          // read the address and port to send to
          var addr, port;
          var name = HEAP32[((message)>>2)];
          var namelen = HEAP32[(((message)+(4))>>2)];
          if (name) {
            var info = __read_sockaddr(name, namelen);
            if (info.errno) return -info.errno;
            port = info.port;
            addr = DNS.lookup_addr(info.addr) || info.addr;
          }
          // concatenate scatter-gather arrays into one message buffer
          var total = 0;
          for (var i = 0; i < num; i++) {
            total += HEAP32[(((iov)+((8 * i) + 4))>>2)];
          }
          var view = new Uint8Array(total);
          var offset = 0;
          for (var i = 0; i < num; i++) {
            var iovbase = HEAP32[(((iov)+((8 * i) + 0))>>2)];
            var iovlen = HEAP32[(((iov)+((8 * i) + 4))>>2)];
            for (var j = 0; j < iovlen; j++) {  
              view[offset++] = HEAP8[(((iovbase)+(j))>>0)];
            }
          }
          // write the buffer
          return sock.sock_ops.sendmsg(sock, view, 0, total, addr, port);
        }
        case 17: { // recvmsg
          var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();
          var iov = HEAP32[(((message)+(8))>>2)];
          var num = HEAP32[(((message)+(12))>>2)];
          // get the total amount of data we can read across all arrays
          var total = 0;
          for (var i = 0; i < num; i++) {
            total += HEAP32[(((iov)+((8 * i) + 4))>>2)];
          }
          // try to read total data
          var msg = sock.sock_ops.recvmsg(sock, total);
          if (!msg) return 0; // socket is closed
  
          // TODO honor flags:
          // MSG_OOB
          // Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific.
          // MSG_PEEK
          // Peeks at the incoming message.
          // MSG_WAITALL
          // Requests that the function block until the full amount of data requested can be returned. The function may return a smaller amount of data if a signal is caught, if the connection is terminated, if MSG_PEEK was specified, or if an error is pending for the socket.
  
          // write the source address out
          var name = HEAP32[((message)>>2)];
          if (name) {
            var res = __write_sockaddr(name, sock.family, DNS.lookup_name(msg.addr), msg.port);
            assert(!res.errno);
          }
          // write the buffer out to the scatter-gather arrays
          var bytesRead = 0;
          var bytesRemaining = msg.buffer.byteLength;
          for (var i = 0; bytesRemaining > 0 && i < num; i++) {
            var iovbase = HEAP32[(((iov)+((8 * i) + 0))>>2)];
            var iovlen = HEAP32[(((iov)+((8 * i) + 4))>>2)];
            if (!iovlen) {
              continue;
            }
            var length = Math.min(iovlen, bytesRemaining);
            var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
            HEAPU8.set(buf, iovbase + bytesRead);
            bytesRead += length;
            bytesRemaining -= length;
          }
  
          // TODO set msghdr.msg_flags
          // MSG_EOR
          // End of record was received (if supported by the protocol).
          // MSG_OOB
          // Out-of-band data was received.
          // MSG_TRUNC
          // Normal data was truncated.
          // MSG_CTRUNC
  
          return bytesRead;
        }
        default: {
          return -52; // unsupported feature
        }
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_socketcall"] = ___sys_socketcall;

  function ___sys_stat64(path, buf) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_stat64"] = ___sys_stat64;

  function ___sys_statfs64(path, size, buf) {try {
  
      path = SYSCALLS.getStr(path);
      assert(size === 64);
      // NOTE: None of the constants here are true. We're just returning safe and
      //       sane values.
      HEAP32[(((buf)+(4))>>2)]=4096;
      HEAP32[(((buf)+(40))>>2)]=4096;
      HEAP32[(((buf)+(8))>>2)]=1000000;
      HEAP32[(((buf)+(12))>>2)]=500000;
      HEAP32[(((buf)+(16))>>2)]=500000;
      HEAP32[(((buf)+(20))>>2)]=FS.nextInode;
      HEAP32[(((buf)+(24))>>2)]=1000000;
      HEAP32[(((buf)+(28))>>2)]=42;
      HEAP32[(((buf)+(44))>>2)]=2;  // ST_NOSUID
      HEAP32[(((buf)+(36))>>2)]=255;
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_statfs64"] = ___sys_statfs64;

  function ___sys_symlink(target, linkpath) {try {
  
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_symlink"] = ___sys_symlink;

  function ___sys_symlinkat(target, newdirfd, linkpath) {try {
  
      linkpath = SYSCALLS.calculateAt(newdirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_symlinkat"] = ___sys_symlinkat;

  function ___sys_sync() {
      return 0;
    }
  Module["___sys_sync"] = ___sys_sync;

  function ___sys_truncate64(path, zero, low, high) {try {
  
      path = SYSCALLS.getStr(path);
      var length = SYSCALLS.get64(low, high);
      FS.truncate(path, length);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_truncate64"] = ___sys_truncate64;

  function ___sys_ugetrlimit(resource, rlim) {try {
  
      HEAP32[((rlim)>>2)]=-1;  // RLIM_INFINITY
      HEAP32[(((rlim)+(4))>>2)]=-1;  // RLIM_INFINITY
      HEAP32[(((rlim)+(8))>>2)]=-1;  // RLIM_INFINITY
      HEAP32[(((rlim)+(12))>>2)]=-1;  // RLIM_INFINITY
      return 0; // just report no limits
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_ugetrlimit"] = ___sys_ugetrlimit;

  function ___sys_umask(mask) {try {
  
      var old = SYSCALLS.umask;
      SYSCALLS.umask = mask;
      return old;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_umask"] = ___sys_umask;

  function ___sys_uname(buf) {try {
  
      if (!buf) return -21
      var layout = {"__size__":390,"sysname":0,"nodename":65,"release":130,"version":195,"machine":260,"domainname":325};
      var copyString = function(element, value) {
        var offset = layout[element];
        writeAsciiToMemory(value, buf + offset);
      };
      copyString('sysname', 'Emscripten');
      copyString('nodename', 'emscripten');
      copyString('release', '1.0');
      copyString('version', '#1');
      copyString('machine', 'x86-JS');
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_uname"] = ___sys_uname;

  function ___sys_unlink(path) {try {
  
      path = SYSCALLS.getStr(path);
      FS.unlink(path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_unlink"] = ___sys_unlink;

  function ___sys_unlinkat(dirfd, path, flags) {try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_unlinkat"] = ___sys_unlinkat;

  function ___sys_utimensat(dirfd, path, times, flags) {try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path);
      var seconds = HEAP32[((times)>>2)];
      var nanoseconds = HEAP32[(((times)+(4))>>2)];
      var atime = (seconds*1000) + (nanoseconds/(1000*1000));
      times += 8;
      seconds = HEAP32[((times)>>2)];
      nanoseconds = HEAP32[(((times)+(4))>>2)];
      var mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      FS.utime(path, atime, mtime);
      return 0;  
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_utimensat"] = ___sys_utimensat;

  function ___sys_wait4(pid, wstart, options, rusage) {try {
  
      abort('cannot wait on child processes');
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_wait4"] = ___sys_wait4;

  function ___wait() {}
  Module["___wait"] = ___wait;

  function __emscripten_fetch_free(id) {
    //Note: should just be [id], but indexes off by 1 (see: #8803)
    delete Fetch.xhrs[id-1];
  }
  Module["__emscripten_fetch_free"] = __emscripten_fetch_free;

  function __emscripten_fetch_get_response_headers(id, dst, dstSizeBytes) {
      var responseHeaders = Fetch.xhrs[id-1].getAllResponseHeaders();
      var lengthBytes = lengthBytesUTF8(responseHeaders) + 1;
      stringToUTF8(responseHeaders, dst, dstSizeBytes);
      return Math.min(lengthBytes, dstSizeBytes);
  }
  Module["__emscripten_fetch_get_response_headers"] = __emscripten_fetch_get_response_headers;

  function __emscripten_fetch_get_response_headers_length(id) {
      return lengthBytesUTF8(Fetch.xhrs[id-1].getAllResponseHeaders()) + 1;
  }
  Module["__emscripten_fetch_get_response_headers_length"] = __emscripten_fetch_get_response_headers_length;

  
  var _fetch_work_queue=1129472;
  Module["_fetch_work_queue"] = _fetch_work_queue;function __emscripten_get_fetch_work_queue() {
      return _fetch_work_queue;
    }
  Module["__emscripten_get_fetch_work_queue"] = __emscripten_get_fetch_work_queue;

  
  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }
  Module["_exit"] = _exit;function __exit(a0
  ) {
  return _exit(a0);
  }
  Module["__exit"] = __exit;

  function _abort() {
      abort();
    }
  Module["_abort"] = _abort;

  function _clock() {
      if (_clock.start === undefined) _clock.start = Date.now();
      return ((Date.now() - _clock.start) * (1000000 / 1000))|0;
    }
  Module["_clock"] = _clock;


  
  var DLFCN={error:null,errorMsg:null};
  Module["DLFCN"] = DLFCN;function _dlclose(handle) {
      // int dlclose(void *handle);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlclose.html
      if (!LDSO.loadedLibs[handle]) {
        DLFCN.errorMsg = 'Tried to dlclose() unopened handle: ' + handle;
        return 1;
      } else {
        var lib_record = LDSO.loadedLibs[handle];
        if (--lib_record.refcount == 0) {
          if (lib_record.module.cleanups) {
            lib_record.module.cleanups.forEach(function(cleanup) { cleanup() });
          }
          delete LDSO.loadedLibNames[lib_record.name];
          delete LDSO.loadedLibs[handle];
        }
        return 0;
      }
    }
  Module["_dlclose"] = _dlclose;

  
  function stringToNewUTF8(jsString) {
      var length = lengthBytesUTF8(jsString)+1;
      var cString = _malloc(length);
      stringToUTF8(jsString, cString, length);
      return cString;
    }
  Module["stringToNewUTF8"] = stringToNewUTF8;function _dlerror() {
      // char *dlerror(void);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlerror.html
      if (DLFCN.errorMsg === null) {
        return 0;
      } else {
        if (DLFCN.error) _free(DLFCN.error);
        DLFCN.error = stringToNewUTF8(DLFCN.errorMsg);
        DLFCN.errorMsg = null;
        return DLFCN.error;
      }
    }
  Module["_dlerror"] = _dlerror;

  
  var ENV={};
  Module["ENV"] = ENV;function _dlopen(filenameAddr, flag) {
      // void *dlopen(const char *file, int mode);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html
      var searchpaths = [];
      var filename;
      if (filenameAddr === 0) {
        filename = '__self__';
      } else {
        filename = UTF8ToString(filenameAddr);
  
        var isValidFile = function (filename) {
          var target = FS.findObject(filename);
          return target && !target.isFolder && !target.isDevice;
        };
  
        if (!isValidFile(filename)) {
          if (ENV['LD_LIBRARY_PATH']) {
            searchpaths = ENV['LD_LIBRARY_PATH'].split(':');
          }
  
          for (var ident in searchpaths) {
            var searchfile = PATH.join2(searchpaths[ident], filename);
            if (isValidFile(searchfile)) {
              filename = searchfile;
              break;
            }
          }
        }
      }
  
      // We don't care about RTLD_NOW and RTLD_LAZY.
      var flags = {
        global:   Boolean(flag & 256),  // RTLD_GLOBAL
        nodelete: Boolean(flag & 4096), // RTLD_NODELETE
  
        fs: FS, // load libraries from provided filesystem
      }
  
      try {
        var handle = loadDynamicLibrary(filename, flags)
      } catch (e) {
        err('Error in loading dynamic library ' + filename + ": " + e);
        DLFCN.errorMsg = 'Could not load dynamic lib: ' + filename + '\n' + e;
        return 0;
      }
  
      return handle;
    }
  Module["_dlopen"] = _dlopen;

  function _dlsym(handle, symbol) {
      // void *dlsym(void *restrict handle, const char *restrict name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
      symbol = UTF8ToString(symbol);
  
      if (!LDSO.loadedLibs[handle]) {
        DLFCN.errorMsg = 'Tried to dlsym() from an unopened handle: ' + handle;
        return 0;
      }
  
      var lib = LDSO.loadedLibs[handle];
      var isMainModule = lib.module == Module;
  
      var mangled = '_' + symbol;
      var modSymbol = mangled;
      if (!isMainModule) {
        modSymbol = symbol;
      }
  
      if (!lib.module.hasOwnProperty(modSymbol)) {
        DLFCN.errorMsg = ('Tried to lookup unknown symbol "' + modSymbol +
                               '" in dynamic lib: ' + lib.name);
        return 0;
      }
  
      var result = lib.module[modSymbol];
      // Attempt to get the real "unwrapped" symbol so we have more chance of
      // getting wasm function which can be added to a table.
      if (isMainModule) {
        var asmSymbol = symbol;
        if (lib.module["asm"][asmSymbol]) {
          result = lib.module["asm"][asmSymbol];
        }
      }
      if (typeof result !== 'function')
        return result;
  
  
      // Insert the function into the wasm table.  Since we know the function
      // comes directly from the loaded wasm module we can insert it directly
      // into the table, avoiding any JS interaction.
      return addFunctionWasm(result);
    }
  Module["_dlsym"] = _dlsym;

  
  var EGL={errorCode:12288,defaultDisplayInitialized:false,currentContext:0,currentReadSurface:0,currentDrawSurface:0,contextAttributes:{alpha:false,depth:false,stencil:false,antialias:false},stringCache:{},setErrorCode:function(code) {
        EGL.errorCode = code;
      },chooseConfig:function(display, attribList, config, config_size, numConfigs) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
          EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
          return 0;
        }
  
        if (attribList) {
          // read attribList if it is non-null
          for(;;) {
            var param = HEAP32[((attribList)>>2)];
            if (param == 0x3021 /*EGL_ALPHA_SIZE*/) {
              var alphaSize = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.alpha = (alphaSize > 0);
            } else if (param == 0x3025 /*EGL_DEPTH_SIZE*/) {
              var depthSize = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.depth = (depthSize > 0);
            } else if (param == 0x3026 /*EGL_STENCIL_SIZE*/) {
              var stencilSize = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.stencil = (stencilSize > 0);
            } else if (param == 0x3031 /*EGL_SAMPLES*/) {
              var samples = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.antialias = (samples > 0);
            } else if (param == 0x3032 /*EGL_SAMPLE_BUFFERS*/) {
              var samples = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.antialias = (samples == 1);
            } else if (param == 0x3100 /*EGL_CONTEXT_PRIORITY_LEVEL_IMG*/) {
              var requestedPriority = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.lowLatency = (requestedPriority != 0x3103 /*EGL_CONTEXT_PRIORITY_LOW_IMG*/);
            } else if (param == 0x3038 /*EGL_NONE*/) {
                break;
            }
            attribList += 8;
          }
        }
  
        if ((!config || !config_size) && !numConfigs) {
          EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
          return 0;
        }
        if (numConfigs) {
          HEAP32[((numConfigs)>>2)]=1; // Total number of supported configs: 1.
        }
        if (config && config_size > 0) {
          HEAP32[((config)>>2)]=62002;
        }
  
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
      }};
  Module["EGL"] = EGL;function _eglBindAPI(api) {
      if (api == 0x30A0 /* EGL_OPENGL_ES_API */) {
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
      } else { // if (api == 0x30A1 /* EGL_OPENVG_API */ || api == 0x30A2 /* EGL_OPENGL_API */) {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0;
      }
    }
  Module["_eglBindAPI"] = _eglBindAPI;

  function _eglChooseConfig(display, attrib_list, configs, config_size, numConfigs) {
      return EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
    }
  Module["_eglChooseConfig"] = _eglChooseConfig;

  
  
  function __webgl_enable_ANGLE_instanced_arrays(ctx) {
      // Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('ANGLE_instanced_arrays');
      if (ext) {
        ctx['vertexAttribDivisor'] = function(index, divisor) { ext['vertexAttribDivisorANGLE'](index, divisor); };
        ctx['drawArraysInstanced'] = function(mode, first, count, primcount) { ext['drawArraysInstancedANGLE'](mode, first, count, primcount); };
        ctx['drawElementsInstanced'] = function(mode, count, type, indices, primcount) { ext['drawElementsInstancedANGLE'](mode, count, type, indices, primcount); };
        return 1;
      }
    }
  Module["__webgl_enable_ANGLE_instanced_arrays"] = __webgl_enable_ANGLE_instanced_arrays;
  
  function __webgl_enable_OES_vertex_array_object(ctx) {
      // Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('OES_vertex_array_object');
      if (ext) {
        ctx['createVertexArray'] = function() { return ext['createVertexArrayOES'](); };
        ctx['deleteVertexArray'] = function(vao) { ext['deleteVertexArrayOES'](vao); };
        ctx['bindVertexArray'] = function(vao) { ext['bindVertexArrayOES'](vao); };
        ctx['isVertexArray'] = function(vao) { return ext['isVertexArrayOES'](vao); };
        return 1;
      }
    }
  Module["__webgl_enable_OES_vertex_array_object"] = __webgl_enable_OES_vertex_array_object;
  
  function __webgl_enable_WEBGL_draw_buffers(ctx) {
      // Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('WEBGL_draw_buffers');
      if (ext) {
        ctx['drawBuffers'] = function(n, bufs) { ext['drawBuffersWEBGL'](n, bufs); };
        return 1;
      }
    }
  Module["__webgl_enable_WEBGL_draw_buffers"] = __webgl_enable_WEBGL_draw_buffers;var GL={counter:1,lastError:0,buffers:[],mappedBuffers:{},programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:[],currentContext:null,offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,init:function() {
        var miniTempFloatBuffer = new Float32Array(GL.MINI_TEMP_BUFFER_SIZE);
        for (var i = 0; i < GL.MINI_TEMP_BUFFER_SIZE; i++) {
          GL.miniTempBufferFloatViews[i] = miniTempFloatBuffer.subarray(0, i+1);
        }
  
        var miniTempIntBuffer = new Int32Array(GL.MINI_TEMP_BUFFER_SIZE);
        for (var i = 0; i < GL.MINI_TEMP_BUFFER_SIZE; i++) {
          GL.miniTempBufferIntViews[i] = miniTempIntBuffer.subarray(0, i+1);
        }
      },recordError:function recordError(errorCode) {
        if (!GL.lastError) {
          GL.lastError = errorCode;
        }
      },getNewId:function(table) {
        var ret = GL.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      },MINI_TEMP_BUFFER_SIZE:256,miniTempBufferFloatViews:[0],miniTempBufferIntViews:[0],getSource:function(shader, count, string, length) {
        var source = '';
        for (var i = 0; i < count; ++i) {
          var len = length ? HEAP32[(((length)+(i*4))>>2)] : -1;
          source += UTF8ToString(HEAP32[(((string)+(i*4))>>2)], len < 0 ? undefined : len);
        }
        return source;
      },createContext:function(canvas, webGLContextAttributes) {
  
  
  
  
  
        var ctx = 
          (canvas.getContext("webgl", webGLContextAttributes)
            // https://caniuse.com/#feat=webgl
            );
  
  
        if (!ctx) return 0;
  
        var handle = GL.registerContext(ctx, webGLContextAttributes);
  
  
  
        return handle;
      },registerContext:function(ctx, webGLContextAttributes) {
        // without pthreads a context is just an integer ID
        var handle = GL.getNewId(GL.contexts);
  
        var context = {
          handle: handle,
          attributes: webGLContextAttributes,
          version: webGLContextAttributes.majorVersion,
          GLctx: ctx
        };
  
  
        // Store the created context object so that we can access the context given a canvas without having to pass the parameters again.
        if (ctx.canvas) ctx.canvas.GLctxObject = context;
        GL.contexts[handle] = context;
        if (typeof webGLContextAttributes.enableExtensionsByDefault === 'undefined' || webGLContextAttributes.enableExtensionsByDefault) {
          GL.initExtensions(context);
        }
  
  
  
  
        return handle;
      },makeContextCurrent:function(contextHandle) {
  
        GL.currentContext = GL.contexts[contextHandle]; // Active Emscripten GL layer context object.
        Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx; // Active WebGL context object.
        return !(contextHandle && !GLctx);
      },getContext:function(contextHandle) {
        return GL.contexts[contextHandle];
      },deleteContext:function(contextHandle) {
        if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
        if (typeof JSEvents === 'object') JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas); // Release all JS event handlers on the DOM element that the GL context is associated with since the context is now deleted.
        if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined; // Make sure the canvas object no longer refers to the context object so there are no GC surprises.
        GL.contexts[contextHandle] = null;
      },initExtensions:function(context) {
        // If this function is called without a specific context object, init the extensions of the currently active context.
        if (!context) context = GL.currentContext;
  
        if (context.initExtensionsDone) return;
        context.initExtensionsDone = true;
  
        var GLctx = context.GLctx;
  
        // Detect the presence of a few extensions manually, this GL interop layer itself will need to know if they exist.
  
        // Extensions that are only available in WebGL 1 (the calls will be no-ops if called on a WebGL 2 context active)
        __webgl_enable_ANGLE_instanced_arrays(GLctx);
        __webgl_enable_OES_vertex_array_object(GLctx);
        __webgl_enable_WEBGL_draw_buffers(GLctx);
  
        GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
  
        // These are the 'safe' feature-enabling extensions that don't add any performance impact related to e.g. debugging, and
        // should be enabled by default so that client GLES2/GL code will not need to go through extra hoops to get its stuff working.
        // As new extensions are ratified at http://www.khronos.org/registry/webgl/extensions/ , feel free to add your new extensions
        // here, as long as they don't produce a performance impact for users that might not be using those extensions.
        // E.g. debugging-related extensions should probably be off by default.
        var automaticallyEnabledExtensions = [ // Khronos ratified WebGL extensions ordered by number (no debug extensions):
                                               "OES_texture_float", "OES_texture_half_float", "OES_standard_derivatives",
                                               "OES_vertex_array_object", "WEBGL_compressed_texture_s3tc", "WEBGL_depth_texture",
                                               "OES_element_index_uint", "EXT_texture_filter_anisotropic", "EXT_frag_depth",
                                               "WEBGL_draw_buffers", "ANGLE_instanced_arrays", "OES_texture_float_linear",
                                               "OES_texture_half_float_linear", "EXT_blend_minmax", "EXT_shader_texture_lod",
                                               "EXT_texture_norm16",
                                               // Community approved WebGL extensions ordered by number:
                                               "WEBGL_compressed_texture_pvrtc", "EXT_color_buffer_half_float", "WEBGL_color_buffer_float",
                                               "EXT_sRGB", "WEBGL_compressed_texture_etc1", "EXT_disjoint_timer_query",
                                               "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_astc", "EXT_color_buffer_float",
                                               "WEBGL_compressed_texture_s3tc_srgb", "EXT_disjoint_timer_query_webgl2",
                                               // Old style prefixed forms of extensions (but still currently used on e.g. iPhone Xs as
                                               // tested on iOS 12.4.1):
                                               "WEBKIT_WEBGL_compressed_texture_pvrtc"];
  
        function shouldEnableAutomatically(extension) {
          var ret = false;
          automaticallyEnabledExtensions.forEach(function(include) {
            if (extension.indexOf(include) != -1) {
              ret = true;
            }
          });
          return ret;
        }
  
        var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
        exts.forEach(function(ext) {
          if (automaticallyEnabledExtensions.indexOf(ext) != -1) {
            GLctx.getExtension(ext); // Calling .getExtension enables that extension permanently, no need to store the return value to be enabled.
          }
        });
      },populateUniformTable:function(program) {
        var p = GL.programs[program];
        var ptable = GL.programInfos[program] = {
          uniforms: {},
          maxUniformLength: 0, // This is eagerly computed below, since we already enumerate all uniforms anyway.
          maxAttributeLength: -1, // This is lazily computed and cached, computed when/if first asked, "-1" meaning not computed yet.
          maxUniformBlockNameLength: -1 // Lazily computed as well
        };
  
        var utable = ptable.uniforms;
        // A program's uniform table maps the string name of an uniform to an integer location of that uniform.
        // The global GL.uniforms map maps integer locations to WebGLUniformLocations.
        var numUniforms = GLctx.getProgramParameter(p, 0x8B86/*GL_ACTIVE_UNIFORMS*/);
        for (var i = 0; i < numUniforms; ++i) {
          var u = GLctx.getActiveUniform(p, i);
  
          var name = u.name;
          ptable.maxUniformLength = Math.max(ptable.maxUniformLength, name.length+1);
  
          // If we are dealing with an array, e.g. vec4 foo[3], strip off the array index part to canonicalize that "foo", "foo[]",
          // and "foo[0]" will mean the same. Loop below will populate foo[1] and foo[2].
          if (name.slice(-1) == ']') {
            name = name.slice(0, name.lastIndexOf('['));
          }
  
          // Optimize memory usage slightly: If we have an array of uniforms, e.g. 'vec3 colors[3];', then
          // only store the string 'colors' in utable, and 'colors[0]', 'colors[1]' and 'colors[2]' will be parsed as 'colors'+i.
          // Note that for the GL.uniforms table, we still need to fetch the all WebGLUniformLocations for all the indices.
          var loc = GLctx.getUniformLocation(p, name);
          if (loc) {
            var id = GL.getNewId(GL.uniforms);
            utable[name] = [u.size, id];
            GL.uniforms[id] = loc;
  
            for (var j = 1; j < u.size; ++j) {
              var n = name + '['+j+']';
              loc = GLctx.getUniformLocation(p, n);
              id = GL.getNewId(GL.uniforms);
  
              GL.uniforms[id] = loc;
            }
          }
        }
      }};
  Module["GL"] = GL;function _eglCreateContext(display, config, hmm, contextAttribs) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
  
      // EGL 1.4 spec says default EGL_CONTEXT_CLIENT_VERSION is GLES1, but this is not supported by Emscripten.
      // So user must pass EGL_CONTEXT_CLIENT_VERSION == 2 to initialize EGL.
      var glesContextVersion = 1;
      for(;;) {
        var param = HEAP32[((contextAttribs)>>2)];
        if (param == 0x3098 /*EGL_CONTEXT_CLIENT_VERSION*/) {
          glesContextVersion = HEAP32[(((contextAttribs)+(4))>>2)];
        } else if (param == 0x3038 /*EGL_NONE*/) {
          break;
        } else {
          /* EGL1.4 specifies only EGL_CONTEXT_CLIENT_VERSION as supported attribute */
          EGL.setErrorCode(0x3004 /*EGL_BAD_ATTRIBUTE*/);
          return 0;
        }
        contextAttribs += 8;
      }
      if (glesContextVersion != 2) {
        EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
        return 0; /* EGL_NO_CONTEXT */
      }
  
      EGL.contextAttributes.majorVersion = glesContextVersion - 1; // WebGL 1 is GLES 2, WebGL2 is GLES3
      EGL.contextAttributes.minorVersion = 0;
  
      EGL.context = GL.createContext(Module['canvas'], EGL.contextAttributes);
  
      if (EGL.context != 0) {
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
  
        // Run callbacks so that GL emulation works
        GL.makeContextCurrent(EGL.context);
        Module.useWebGL = true;
        Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
  
        // Note: This function only creates a context, but it shall not make it active.
        GL.makeContextCurrent(null);
        return 62004; // Magic ID for Emscripten EGLContext
      } else {
        EGL.setErrorCode(0x3009 /* EGL_BAD_MATCH */); // By the EGL 1.4 spec, an implementation that does not support GLES2 (WebGL in this case), this error code is set.
        return 0; /* EGL_NO_CONTEXT */
      }
    }
  Module["_eglCreateContext"] = _eglCreateContext;

  function _eglCreateWindowSurface(display, config, win, attrib_list) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (config != 62002 /* Magic ID for the only EGLConfig supported by Emscripten */) {
        EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
        return 0;
      }
      // TODO: Examine attrib_list! Parameters that can be present there are:
      // - EGL_RENDER_BUFFER (must be EGL_BACK_BUFFER)
      // - EGL_VG_COLORSPACE (can't be set)
      // - EGL_VG_ALPHA_FORMAT (can't be set)
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 62006; /* Magic ID for Emscripten 'default surface' */
    }
  Module["_eglCreateWindowSurface"] = _eglCreateWindowSurface;

  function _eglDestroyContext(display, context) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (context != 62004 /* Magic ID for Emscripten EGLContext */) {
        EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
        return 0;
      }
  
      GL.deleteContext(EGL.context);
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      if (EGL.currentContext == context) {
        EGL.currentContext = 0;
      }
      return 1 /* EGL_TRUE */;
    }
  Module["_eglDestroyContext"] = _eglDestroyContext;

  function _eglDestroySurface(display, surface) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (surface != 62006 /* Magic ID for the only EGLSurface supported by Emscripten */) {
        EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
        return 1;
      }
      if (EGL.currentReadSurface == surface) {
        EGL.currentReadSurface = 0;
      }
      if (EGL.currentDrawSurface == surface) {
        EGL.currentDrawSurface = 0;
      }
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1; /* Magic ID for Emscripten 'default surface' */
    }
  Module["_eglDestroySurface"] = _eglDestroySurface;

  function _eglGetConfigAttrib(display, config, attribute, value) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (config != 62002 /* Magic ID for the only EGLConfig supported by Emscripten */) {
        EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
        return 0;
      }
      if (!value) {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0;
      }
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      switch(attribute) {
      case 0x3020: // EGL_BUFFER_SIZE
        HEAP32[((value)>>2)]=EGL.contextAttributes.alpha ? 32 : 24;
        return 1;
      case 0x3021: // EGL_ALPHA_SIZE
        HEAP32[((value)>>2)]=EGL.contextAttributes.alpha ? 8 : 0;
        return 1;
      case 0x3022: // EGL_BLUE_SIZE
        HEAP32[((value)>>2)]=8;
        return 1;
      case 0x3023: // EGL_GREEN_SIZE
        HEAP32[((value)>>2)]=8;
        return 1;
      case 0x3024: // EGL_RED_SIZE
        HEAP32[((value)>>2)]=8;
        return 1;
      case 0x3025: // EGL_DEPTH_SIZE
        HEAP32[((value)>>2)]=EGL.contextAttributes.depth ? 24 : 0;
        return 1;
      case 0x3026: // EGL_STENCIL_SIZE
        HEAP32[((value)>>2)]=EGL.contextAttributes.stencil ? 8 : 0;
        return 1;
      case 0x3027: // EGL_CONFIG_CAVEAT
        // We can return here one of EGL_NONE (0x3038), EGL_SLOW_CONFIG (0x3050) or EGL_NON_CONFORMANT_CONFIG (0x3051).
        HEAP32[((value)>>2)]=0x3038;
        return 1;
      case 0x3028: // EGL_CONFIG_ID
        HEAP32[((value)>>2)]=62002;
        return 1;
      case 0x3029: // EGL_LEVEL
        HEAP32[((value)>>2)]=0;
        return 1;
      case 0x302A: // EGL_MAX_PBUFFER_HEIGHT
        HEAP32[((value)>>2)]=4096;
        return 1;
      case 0x302B: // EGL_MAX_PBUFFER_PIXELS
        HEAP32[((value)>>2)]=16777216;
        return 1;
      case 0x302C: // EGL_MAX_PBUFFER_WIDTH
        HEAP32[((value)>>2)]=4096;
        return 1;
      case 0x302D: // EGL_NATIVE_RENDERABLE
        HEAP32[((value)>>2)]=0;
        return 1;
      case 0x302E: // EGL_NATIVE_VISUAL_ID
        HEAP32[((value)>>2)]=0;
        return 1;
      case 0x302F: // EGL_NATIVE_VISUAL_TYPE
        HEAP32[((value)>>2)]=0x3038;
        return 1;
      case 0x3031: // EGL_SAMPLES
        HEAP32[((value)>>2)]=EGL.contextAttributes.antialias ? 4 : 0;
        return 1;
      case 0x3032: // EGL_SAMPLE_BUFFERS
        HEAP32[((value)>>2)]=EGL.contextAttributes.antialias ? 1 : 0;
        return 1;
      case 0x3033: // EGL_SURFACE_TYPE
        HEAP32[((value)>>2)]=0x4;
        return 1;
      case 0x3034: // EGL_TRANSPARENT_TYPE
        // If this returns EGL_TRANSPARENT_RGB (0x3052), transparency is used through color-keying. No such thing applies to Emscripten canvas.
        HEAP32[((value)>>2)]=0x3038;
        return 1;
      case 0x3035: // EGL_TRANSPARENT_BLUE_VALUE
      case 0x3036: // EGL_TRANSPARENT_GREEN_VALUE
      case 0x3037: // EGL_TRANSPARENT_RED_VALUE
        // "If EGL_TRANSPARENT_TYPE is EGL_NONE, then the values for EGL_TRANSPARENT_RED_VALUE, EGL_TRANSPARENT_GREEN_VALUE, and EGL_TRANSPARENT_BLUE_VALUE are undefined."
        HEAP32[((value)>>2)]=-1;
        return 1;
      case 0x3039: // EGL_BIND_TO_TEXTURE_RGB
      case 0x303A: // EGL_BIND_TO_TEXTURE_RGBA
        HEAP32[((value)>>2)]=0;
        return 1;
      case 0x303B: // EGL_MIN_SWAP_INTERVAL
        HEAP32[((value)>>2)]=0;
        return 1;
      case 0x303C: // EGL_MAX_SWAP_INTERVAL
        HEAP32[((value)>>2)]=1;
        return 1;
      case 0x303D: // EGL_LUMINANCE_SIZE
      case 0x303E: // EGL_ALPHA_MASK_SIZE
        HEAP32[((value)>>2)]=0;
        return 1;
      case 0x303F: // EGL_COLOR_BUFFER_TYPE
        // EGL has two types of buffers: EGL_RGB_BUFFER and EGL_LUMINANCE_BUFFER.
        HEAP32[((value)>>2)]=0x308E;
        return 1;
      case 0x3040: // EGL_RENDERABLE_TYPE
        // A bit combination of EGL_OPENGL_ES_BIT,EGL_OPENVG_BIT,EGL_OPENGL_ES2_BIT and EGL_OPENGL_BIT.
        HEAP32[((value)>>2)]=0x4;
        return 1;
      case 0x3042: // EGL_CONFORMANT
        // "EGL_CONFORMANT is a mask indicating if a client API context created with respect to the corresponding EGLConfig will pass the required conformance tests for that API."
        HEAP32[((value)>>2)]=0;
        return 1;
      default:
        EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
        return 0;
      }
    }
  Module["_eglGetConfigAttrib"] = _eglGetConfigAttrib;

  function _eglGetDisplay(nativeDisplayType) {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      // Note: As a 'conformant' implementation of EGL, we would prefer to init here only if the user
      //       calls this function with EGL_DEFAULT_DISPLAY. Other display IDs would be preferred to be unsupported
      //       and EGL_NO_DISPLAY returned. Uncomment the following code lines to do this.
      // Instead, an alternative route has been preferred, namely that the Emscripten EGL implementation
      // "emulates" X11, and eglGetDisplay is expected to accept/receive a pointer to an X11 Display object.
      // Therefore, be lax and allow anything to be passed in, and return the magic handle to our default EGLDisplay object.
  
  //    if (nativeDisplayType == 0 /* EGL_DEFAULT_DISPLAY */) {
          return 62000; // Magic ID for Emscripten 'default display'
  //    }
  //    else
  //      return 0; // EGL_NO_DISPLAY
    }
  Module["_eglGetDisplay"] = _eglGetDisplay;

  function _eglGetError() {
      return EGL.errorCode;
    }
  Module["_eglGetError"] = _eglGetError;

  function _eglGetProcAddress(name_) {
      return _emscripten_GetProcAddress(name_);
    }
  Module["_eglGetProcAddress"] = _eglGetProcAddress;

  function _eglInitialize(display, majorVersion, minorVersion) {
      if (display == 62000 /* Magic ID for Emscripten 'default display' */) {
        if (majorVersion) {
          HEAP32[((majorVersion)>>2)]=1; // Advertise EGL Major version: '1'
        }
        if (minorVersion) {
          HEAP32[((minorVersion)>>2)]=4; // Advertise EGL Minor version: '4'
        }
        EGL.defaultDisplayInitialized = true;
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
      }
      else {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
    }
  Module["_eglInitialize"] = _eglInitialize;

  function _eglMakeCurrent(display, draw, read, context) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0 /* EGL_FALSE */;
      }
      //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
      if (context != 0 && context != 62004 /* Magic ID for Emscripten EGLContext */) {
        EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
        return 0;
      }
      if ((read != 0 && read != 62006) || (draw != 0 && draw != 62006 /* Magic ID for Emscripten 'default surface' */)) {
        EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
        return 0;
      }
  
      GL.makeContextCurrent(context ? EGL.context : null);
  
      EGL.currentContext = context;
      EGL.currentDrawSurface = draw;
      EGL.currentReadSurface = read;
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1 /* EGL_TRUE */;
    }
  Module["_eglMakeCurrent"] = _eglMakeCurrent;

  function _eglQueryString(display, name) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      if (EGL.stringCache[name]) return EGL.stringCache[name];
      var ret;
      switch(name) {
        case 0x3053 /* EGL_VENDOR */: ret = allocateUTF8("Emscripten"); break;
        case 0x3054 /* EGL_VERSION */: ret = allocateUTF8("1.4 Emscripten EGL"); break;
        case 0x3055 /* EGL_EXTENSIONS */:  ret = allocateUTF8(""); break; // Currently not supporting any EGL extensions.
        case 0x308D /* EGL_CLIENT_APIS */: ret = allocateUTF8("OpenGL_ES"); break;
        default:
          EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
          return 0;
      }
      EGL.stringCache[name] = ret;
      return ret;
    }
  Module["_eglQueryString"] = _eglQueryString;

  function _eglSwapBuffers() {
  
      if (!EGL.defaultDisplayInitialized) {
        EGL.setErrorCode(0x3001 /* EGL_NOT_INITIALIZED */);
      } else if (!Module.ctx) {
        EGL.setErrorCode(0x3002 /* EGL_BAD_ACCESS */);
      } else if (Module.ctx.isContextLost()) {
        EGL.setErrorCode(0x300E /* EGL_CONTEXT_LOST */);
      } else {
        // According to documentation this does an implicit flush.
        // Due to discussion at https://github.com/emscripten-core/emscripten/pull/1871
        // the flush was removed since this _may_ result in slowing code down.
        //_glFlush();
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1 /* EGL_TRUE */;
      }
      return 0 /* EGL_FALSE */;
    }
  Module["_eglSwapBuffers"] = _eglSwapBuffers;

  function _eglSwapInterval(display, interval) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (interval == 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 0);
      else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, interval);
  
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    }
  Module["_eglSwapInterval"] = _eglSwapInterval;

  function _eglTerminate(display) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      EGL.currentContext = 0;
      EGL.currentReadSurface = 0;
      EGL.currentDrawSurface = 0;
      EGL.defaultDisplayInitialized = false;
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    }
  Module["_eglTerminate"] = _eglTerminate;

  
  function _eglWaitClient() {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    }
  Module["_eglWaitClient"] = _eglWaitClient;function _eglWaitGL(
  ) {
  return _eglWaitClient();
  }
  Module["_eglWaitGL"] = _eglWaitGL;

  function _eglWaitNative(nativeEngineId) {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    }
  Module["_eglWaitNative"] = _eglWaitNative;

  function _emscripten_cancel_main_loop() {
      Browser.mainLoop.pause();
      Browser.mainLoop.func = null;
    }
  Module["_emscripten_cancel_main_loop"] = _emscripten_cancel_main_loop;

  
  var JSEvents={keyEvent:0,mouseEvent:0,wheelEvent:0,uiEvent:0,focusEvent:0,deviceOrientationEvent:0,deviceMotionEvent:0,fullscreenChangeEvent:0,pointerlockChangeEvent:0,visibilityChangeEvent:0,touchEvent:0,previousFullscreenElement:null,previousScreenX:null,previousScreenY:null,removeEventListenersRegistered:false,removeAllEventListeners:function() {
        for(var i = JSEvents.eventHandlers.length-1; i >= 0; --i) {
          JSEvents._removeHandler(i);
        }
        JSEvents.eventHandlers = [];
        JSEvents.deferredCalls = [];
      },registerRemoveEventListeners:function() {
        if (!JSEvents.removeEventListenersRegistered) {
          __ATEXIT__.push(JSEvents.removeAllEventListeners);
          JSEvents.removeEventListenersRegistered = true;
        }
      },deferredCalls:[],deferCall:function(targetFunction, precedence, argsList) {
        function arraysHaveEqualContent(arrA, arrB) {
          if (arrA.length != arrB.length) return false;
  
          for(var i in arrA) {
            if (arrA[i] != arrB[i]) return false;
          }
          return true;
        }
        // Test if the given call was already queued, and if so, don't add it again.
        for(var i in JSEvents.deferredCalls) {
          var call = JSEvents.deferredCalls[i];
          if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
            return;
          }
        }
        JSEvents.deferredCalls.push({
          targetFunction: targetFunction,
          precedence: precedence,
          argsList: argsList
        });
  
        JSEvents.deferredCalls.sort(function(x,y) { return x.precedence < y.precedence; });
      },removeDeferredCalls:function(targetFunction) {
        for(var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
            JSEvents.deferredCalls.splice(i, 1);
            --i;
          }
        }
      },canPerformEventHandlerRequests:function() {
        return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
      },runDeferredCalls:function() {
        if (!JSEvents.canPerformEventHandlerRequests()) {
          return;
        }
        for(var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          var call = JSEvents.deferredCalls[i];
          JSEvents.deferredCalls.splice(i, 1);
          --i;
          call.targetFunction.apply(null, call.argsList);
        }
      },inEventHandler:0,currentEventHandler:null,eventHandlers:[],removeAllHandlersOnTarget:function(target, eventTypeString) {
        for(var i = 0; i < JSEvents.eventHandlers.length; ++i) {
          if (JSEvents.eventHandlers[i].target == target && 
            (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
             JSEvents._removeHandler(i--);
           }
        }
      },_removeHandler:function(i) {
        var h = JSEvents.eventHandlers[i];
        h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
        JSEvents.eventHandlers.splice(i, 1);
      },registerOrRemoveHandler:function(eventHandler) {
        var jsEventHandler = function jsEventHandler(event) {
          // Increment nesting count for the event handler.
          ++JSEvents.inEventHandler;
          JSEvents.currentEventHandler = eventHandler;
          // Process any old deferred calls the user has placed.
          JSEvents.runDeferredCalls();
          // Process the actual event, calls back to user C code handler.
          eventHandler.handlerFunc(event);
          // Process any new deferred calls that were placed right now from this event handler.
          JSEvents.runDeferredCalls();
          // Out of event handler - restore nesting count.
          --JSEvents.inEventHandler;
        };
        
        if (eventHandler.callbackfunc) {
          eventHandler.eventListenerFunc = jsEventHandler;
          eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
          JSEvents.eventHandlers.push(eventHandler);
          JSEvents.registerRemoveEventListeners();
        } else {
          for(var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == eventHandler.target
             && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
               JSEvents._removeHandler(i--);
             }
          }
        }
      },getNodeNameForTarget:function(target) {
        if (!target) return '';
        if (target == window) return '#window';
        if (target == screen) return '#screen';
        return (target && target.nodeName) ? target.nodeName : '';
      },fullscreenEnabled:function() {
        return document.fullscreenEnabled
        // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
        // TODO: If Safari at some point ships with unprefixed version, update the version check above.
        || document.webkitFullscreenEnabled
         ;
      }};
  Module["JSEvents"] = JSEvents;
  
  var __currentFullscreenStrategy={};
  Module["__currentFullscreenStrategy"] = __currentFullscreenStrategy;
  
  
  
  
  
  
  
  
  function __maybeCStringToJsString(cString) {
      // "cString > 2" checks if the input is a number, and isn't of the special
      // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).
      // In other words, if cString > 2 then it's a pointer to a valid place in
      // memory, and points to a C string.
      return cString > 2 ? UTF8ToString(cString) : cString;
    }
  Module["__maybeCStringToJsString"] = __maybeCStringToJsString;
  
  var specialHTMLTargets=[0, document, window];
  Module["specialHTMLTargets"] = specialHTMLTargets;function __findEventTarget(target) {
      target = __maybeCStringToJsString(target);
      var domElement = specialHTMLTargets[target] || document.querySelector(target);
      return domElement;
    }
  Module["__findEventTarget"] = __findEventTarget;function __findCanvasEventTarget(target) { return __findEventTarget(target); }
  Module["__findCanvasEventTarget"] = __findCanvasEventTarget;function _emscripten_get_canvas_element_size(target, width, height) {
      var canvas = __findCanvasEventTarget(target);
      if (!canvas) return -4;
      HEAP32[((width)>>2)]=canvas.width;
      HEAP32[((height)>>2)]=canvas.height;
    }
  Module["_emscripten_get_canvas_element_size"] = _emscripten_get_canvas_element_size;function __get_canvas_element_size(target) {
      var stackTop = stackSave();
      var w = stackAlloc(8);
      var h = w + 4;
  
      var targetInt = stackAlloc(target.id.length+1);
      stringToUTF8(target.id, targetInt, target.id.length+1);
      var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
      var size = [HEAP32[((w)>>2)], HEAP32[((h)>>2)]];
      stackRestore(stackTop);
      return size;
    }
  Module["__get_canvas_element_size"] = __get_canvas_element_size;
  
  
  function _emscripten_set_canvas_element_size(target, width, height) {
      var canvas = __findCanvasEventTarget(target);
      if (!canvas) return -4;
      canvas.width = width;
      canvas.height = height;
      return 0;
    }
  Module["_emscripten_set_canvas_element_size"] = _emscripten_set_canvas_element_size;function __set_canvas_element_size(target, width, height) {
      if (!target.controlTransferredOffscreen) {
        target.width = width;
        target.height = height;
      } else {
        // This function is being called from high-level JavaScript code instead of asm.js/Wasm,
        // and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
        var stackTop = stackSave();
        var targetInt = stackAlloc(target.id.length+1);
        stringToUTF8(target.id, targetInt, target.id.length+1);
        _emscripten_set_canvas_element_size(targetInt, width, height);
        stackRestore(stackTop);
      }
    }
  Module["__set_canvas_element_size"] = __set_canvas_element_size;function __registerRestoreOldStyle(canvas) {
      var canvasSize = __get_canvas_element_size(canvas);
      var oldWidth = canvasSize[0];
      var oldHeight = canvasSize[1];
      var oldCssWidth = canvas.style.width;
      var oldCssHeight = canvas.style.height;
      var oldBackgroundColor = canvas.style.backgroundColor; // Chrome reads color from here.
      var oldDocumentBackgroundColor = document.body.style.backgroundColor; // IE11 reads color from here.
      // Firefox always has black background color.
      var oldPaddingLeft = canvas.style.paddingLeft; // Chrome, FF, Safari
      var oldPaddingRight = canvas.style.paddingRight;
      var oldPaddingTop = canvas.style.paddingTop;
      var oldPaddingBottom = canvas.style.paddingBottom;
      var oldMarginLeft = canvas.style.marginLeft; // IE11
      var oldMarginRight = canvas.style.marginRight;
      var oldMarginTop = canvas.style.marginTop;
      var oldMarginBottom = canvas.style.marginBottom;
      var oldDocumentBodyMargin = document.body.style.margin;
      var oldDocumentOverflow = document.documentElement.style.overflow; // Chrome, Firefox
      var oldDocumentScroll = document.body.scroll; // IE
      var oldImageRendering = canvas.style.imageRendering;
  
      function restoreOldStyle() {
        var fullscreenElement = document.fullscreenElement
          || document.webkitFullscreenElement
          || document.msFullscreenElement
          ;
        if (!fullscreenElement) {
          document.removeEventListener('fullscreenchange', restoreOldStyle);
  
  
          // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
          // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
          document.removeEventListener('webkitfullscreenchange', restoreOldStyle);
  
  
          __set_canvas_element_size(canvas, oldWidth, oldHeight);
  
          canvas.style.width = oldCssWidth;
          canvas.style.height = oldCssHeight;
          canvas.style.backgroundColor = oldBackgroundColor; // Chrome
          // IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
          // before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
          // had explicitly set so subsequent fullscreen transitions would not set background color properly.
          if (!oldDocumentBackgroundColor) document.body.style.backgroundColor = 'white';
          document.body.style.backgroundColor = oldDocumentBackgroundColor; // IE11
          canvas.style.paddingLeft = oldPaddingLeft; // Chrome, FF, Safari
          canvas.style.paddingRight = oldPaddingRight;
          canvas.style.paddingTop = oldPaddingTop;
          canvas.style.paddingBottom = oldPaddingBottom;
          canvas.style.marginLeft = oldMarginLeft; // IE11
          canvas.style.marginRight = oldMarginRight;
          canvas.style.marginTop = oldMarginTop;
          canvas.style.marginBottom = oldMarginBottom;
          document.body.style.margin = oldDocumentBodyMargin;
          document.documentElement.style.overflow = oldDocumentOverflow; // Chrome, Firefox
          document.body.scroll = oldDocumentScroll; // IE
          canvas.style.imageRendering = oldImageRendering;
          if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
  
          if (__currentFullscreenStrategy.canvasResizedCallback) {
            dynCall_iiii(__currentFullscreenStrategy.canvasResizedCallback, 37, 0, __currentFullscreenStrategy.canvasResizedCallbackUserData);
          }
        }
      }
      document.addEventListener('fullscreenchange', restoreOldStyle);
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      document.addEventListener('webkitfullscreenchange', restoreOldStyle);
      return restoreOldStyle;
    }
  Module["__registerRestoreOldStyle"] = __registerRestoreOldStyle;
  
  function __setLetterbox(element, topBottom, leftRight) {
        // Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
        element.style.paddingLeft = element.style.paddingRight = leftRight + 'px';
        element.style.paddingTop = element.style.paddingBottom = topBottom + 'px';
    }
  Module["__setLetterbox"] = __setLetterbox;
  
  function __getBoundingClientRect(e) {
      return specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {'left':0,'top':0};
    }
  Module["__getBoundingClientRect"] = __getBoundingClientRect;function _JSEvents_resizeCanvasForFullscreen(target, strategy) {
      var restoreOldStyle = __registerRestoreOldStyle(target);
      var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
      var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
      var rect = __getBoundingClientRect(target);
      var windowedCssWidth = rect.width;
      var windowedCssHeight = rect.height;
      var canvasSize = __get_canvas_element_size(target);
      var windowedRttWidth = canvasSize[0];
      var windowedRttHeight = canvasSize[1];
  
      if (strategy.scaleMode == 3) {
        __setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
        cssWidth = windowedCssWidth;
        cssHeight = windowedCssHeight;
      } else if (strategy.scaleMode == 2) {
        if (cssWidth*windowedRttHeight < windowedRttWidth*cssHeight) {
          var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
          __setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
          cssHeight = desiredCssHeight;
        } else {
          var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
          __setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
          cssWidth = desiredCssWidth;
        }
      }
  
      // If we are adding padding, must choose a background color or otherwise Chrome will give the
      // padding a default white color. Do it only if user has not customized their own background color.
      if (!target.style.backgroundColor) target.style.backgroundColor = 'black';
      // IE11 does the same, but requires the color to be set in the document body.
      if (!document.body.style.backgroundColor) document.body.style.backgroundColor = 'black'; // IE11
      // Firefox always shows black letterboxes independent of style color.
  
      target.style.width = cssWidth + 'px';
      target.style.height = cssHeight + 'px';
  
      if (strategy.filteringMode == 1) {
        target.style.imageRendering = 'optimizeSpeed';
        target.style.imageRendering = '-moz-crisp-edges';
        target.style.imageRendering = '-o-crisp-edges';
        target.style.imageRendering = '-webkit-optimize-contrast';
        target.style.imageRendering = 'optimize-contrast';
        target.style.imageRendering = 'crisp-edges';
        target.style.imageRendering = 'pixelated';
      }
  
      var dpiScale = (strategy.canvasResolutionScaleMode == 2) ? devicePixelRatio : 1;
      if (strategy.canvasResolutionScaleMode != 0) {
        var newWidth = (cssWidth * dpiScale)|0;
        var newHeight = (cssHeight * dpiScale)|0;
        __set_canvas_element_size(target, newWidth, newHeight);
        if (target.GLctxObject) target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
      }
      return restoreOldStyle;
    }
  Module["_JSEvents_resizeCanvasForFullscreen"] = _JSEvents_resizeCanvasForFullscreen;function _JSEvents_requestFullscreen(target, strategy) {
      // EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
      if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
        _JSEvents_resizeCanvasForFullscreen(target, strategy);
      }
  
      if (target.requestFullscreen) {
        target.requestFullscreen();
      } else if (target.webkitRequestFullscreen) {
        target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else {
        return JSEvents.fullscreenEnabled() ? -3 : -1;
      }
  
      __currentFullscreenStrategy = strategy;
  
      if (strategy.canvasResizedCallback) {
        dynCall_iiii(strategy.canvasResizedCallback, 37, 0, strategy.canvasResizedCallbackUserData);
      }
  
      return 0;
    }
  Module["_JSEvents_requestFullscreen"] = _JSEvents_requestFullscreen;function _emscripten_exit_fullscreen() {
      if (!JSEvents.fullscreenEnabled()) return -1;
      // Make sure no queued up calls will fire after this.
      JSEvents.removeDeferredCalls(_JSEvents_requestFullscreen);
  
      var d = specialHTMLTargets[1];
      if (d.exitFullscreen) {
        d.fullscreenElement && d.exitFullscreen();
      } else if (d.webkitExitFullscreen) {
        d.webkitFullscreenElement && d.webkitExitFullscreen();
      } else {
        return -1;
      }
  
      return 0;
    }
  Module["_emscripten_exit_fullscreen"] = _emscripten_exit_fullscreen;

  
  function __requestPointerLock(target) {
      if (target.requestPointerLock) {
        target.requestPointerLock();
      } else if (target.msRequestPointerLock) {
        target.msRequestPointerLock();
      } else {
        // document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
        // or if the whole browser just doesn't support the feature.
        if (document.body.requestPointerLock
          || document.body.msRequestPointerLock
          ) {
          return -3;
        } else {
          return -1;
        }
      }
      return 0;
    }
  Module["__requestPointerLock"] = __requestPointerLock;function _emscripten_exit_pointerlock() {
      // Make sure no queued up calls will fire after this.
      JSEvents.removeDeferredCalls(__requestPointerLock);
  
      if (document.exitPointerLock) {
        document.exitPointerLock();
      } else if (document.msExitPointerLock) {
        document.msExitPointerLock();
      } else {
        return -1;
      }
      return 0;
    }
  Module["_emscripten_exit_pointerlock"] = _emscripten_exit_pointerlock;

  function _emscripten_force_exit(status) {
      warnOnce('emscripten_force_exit cannot actually shut down the runtime, as the build does not have EXIT_RUNTIME set');
      noExitRuntime = false;
      exit(status);
    }
  Module["_emscripten_force_exit"] = _emscripten_force_exit;

  
  function __fillBatteryEventData(eventStruct, e) {
      HEAPF64[((eventStruct)>>3)]=e.chargingTime;
      HEAPF64[(((eventStruct)+(8))>>3)]=e.dischargingTime;
      HEAPF64[(((eventStruct)+(16))>>3)]=e.level;
      HEAP32[(((eventStruct)+(24))>>2)]=e.charging;
    }
  Module["__fillBatteryEventData"] = __fillBatteryEventData;
  
  function __battery() { return navigator.battery || navigator.mozBattery || navigator.webkitBattery; }
  Module["__battery"] = __battery;function _emscripten_get_battery_status(batteryState) {
      if (!__battery()) return -1; 
      __fillBatteryEventData(batteryState, __battery());
      return 0;
    }
  Module["_emscripten_get_battery_status"] = _emscripten_get_battery_status;

  function _emscripten_get_device_pixel_ratio() {
      return devicePixelRatio;
    }
  Module["_emscripten_get_device_pixel_ratio"] = _emscripten_get_device_pixel_ratio;

  function _emscripten_get_element_css_size(target, width, height) {
      target = __findEventTarget(target);
      if (!target) return -4;
  
      var rect = __getBoundingClientRect(target);
      HEAPF64[((width)>>3)]=rect.width;
      HEAPF64[((height)>>3)]=rect.height;
  
      return 0;
    }
  Module["_emscripten_get_element_css_size"] = _emscripten_get_element_css_size;

  
  function __fillGamepadEventData(eventStruct, e) {
      HEAPF64[((eventStruct)>>3)]=e.timestamp;
      for(var i = 0; i < e.axes.length; ++i) {
        HEAPF64[(((eventStruct+i*8)+(16))>>3)]=e.axes[i];
      }
      for(var i = 0; i < e.buttons.length; ++i) {
        if (typeof(e.buttons[i]) === 'object') {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)]=e.buttons[i].value;
        } else {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)]=e.buttons[i];
        }
      }
      for(var i = 0; i < e.buttons.length; ++i) {
        if (typeof(e.buttons[i]) === 'object') {
          HEAP32[(((eventStruct+i*4)+(1040))>>2)]=e.buttons[i].pressed;
        } else {
          // Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
          /** @suppress {checkTypes} */
          HEAP32[(((eventStruct+i*4)+(1040))>>2)]=e.buttons[i] == 1;
        }
      }
      HEAP32[(((eventStruct)+(1296))>>2)]=e.connected;
      HEAP32[(((eventStruct)+(1300))>>2)]=e.index;
      HEAP32[(((eventStruct)+(8))>>2)]=e.axes.length;
      HEAP32[(((eventStruct)+(12))>>2)]=e.buttons.length;
      stringToUTF8(e.id, eventStruct + 1304, 64);
      stringToUTF8(e.mapping, eventStruct + 1368, 64);
    }
  Module["__fillGamepadEventData"] = __fillGamepadEventData;function _emscripten_get_gamepad_status(index, gamepadState) {
      if (!JSEvents.lastGamepadState) throw 'emscripten_get_gamepad_status() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';
  
      // INVALID_PARAM is returned on a Gamepad index that never was there.
      if (index < 0 || index >= JSEvents.lastGamepadState.length) return -5;
  
      // NO_DATA is returned on a Gamepad index that was removed.
      // For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
      // This is because gamepads must keep their original position in the array.
      // For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
      if (!JSEvents.lastGamepadState[index]) return -7;
  
      __fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
      return 0;
    }
  Module["_emscripten_get_gamepad_status"] = _emscripten_get_gamepad_status;

  function _emscripten_get_num_gamepads() {
      if (!JSEvents.lastGamepadState) throw 'emscripten_get_num_gamepads() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';
      // N.B. Do not call emscripten_get_num_gamepads() unless having first called emscripten_sample_gamepad_data(), and that has returned EMSCRIPTEN_RESULT_SUCCESS.
      // Otherwise the following line will throw an exception.
      return JSEvents.lastGamepadState.length;
    }
  Module["_emscripten_get_num_gamepads"] = _emscripten_get_num_gamepads;

  function _emscripten_get_sbrk_ptr() {
      return 1129312;
    }
  Module["_emscripten_get_sbrk_ptr"] = _emscripten_get_sbrk_ptr;

  function _emscripten_glActiveTexture(x0) { GLctx['activeTexture'](x0) }
  Module["_emscripten_glActiveTexture"] = _emscripten_glActiveTexture;

  function _emscripten_glAttachShader(program, shader) {
      GLctx.attachShader(GL.programs[program],
                              GL.shaders[shader]);
    }
  Module["_emscripten_glAttachShader"] = _emscripten_glAttachShader;

  function _emscripten_glBeginQueryEXT(target, id) {
      GLctx.disjointTimerQueryExt['beginQueryEXT'](target, GL.timerQueriesEXT[id]);
    }
  Module["_emscripten_glBeginQueryEXT"] = _emscripten_glBeginQueryEXT;

  function _emscripten_glBindAttribLocation(program, index, name) {
      GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
    }
  Module["_emscripten_glBindAttribLocation"] = _emscripten_glBindAttribLocation;

  function _emscripten_glBindBuffer(target, buffer) {
  
      GLctx.bindBuffer(target, GL.buffers[buffer]);
    }
  Module["_emscripten_glBindBuffer"] = _emscripten_glBindBuffer;

  function _emscripten_glBindFramebuffer(target, framebuffer) {
  
      GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
  
    }
  Module["_emscripten_glBindFramebuffer"] = _emscripten_glBindFramebuffer;

  function _emscripten_glBindRenderbuffer(target, renderbuffer) {
      GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
    }
  Module["_emscripten_glBindRenderbuffer"] = _emscripten_glBindRenderbuffer;

  function _emscripten_glBindTexture(target, texture) {
      GLctx.bindTexture(target, GL.textures[texture]);
    }
  Module["_emscripten_glBindTexture"] = _emscripten_glBindTexture;

  function _emscripten_glBindVertexArrayOES(vao) {
      GLctx['bindVertexArray'](GL.vaos[vao]);
    }
  Module["_emscripten_glBindVertexArrayOES"] = _emscripten_glBindVertexArrayOES;

  function _emscripten_glBlendColor(x0, x1, x2, x3) { GLctx['blendColor'](x0, x1, x2, x3) }
  Module["_emscripten_glBlendColor"] = _emscripten_glBlendColor;

  function _emscripten_glBlendEquation(x0) { GLctx['blendEquation'](x0) }
  Module["_emscripten_glBlendEquation"] = _emscripten_glBlendEquation;

  function _emscripten_glBlendEquationSeparate(x0, x1) { GLctx['blendEquationSeparate'](x0, x1) }
  Module["_emscripten_glBlendEquationSeparate"] = _emscripten_glBlendEquationSeparate;

  function _emscripten_glBlendFunc(x0, x1) { GLctx['blendFunc'](x0, x1) }
  Module["_emscripten_glBlendFunc"] = _emscripten_glBlendFunc;

  function _emscripten_glBlendFuncSeparate(x0, x1, x2, x3) { GLctx['blendFuncSeparate'](x0, x1, x2, x3) }
  Module["_emscripten_glBlendFuncSeparate"] = _emscripten_glBlendFuncSeparate;

  function _emscripten_glBufferData(target, size, data, usage) {
        // N.b. here first form specifies a heap subarray, second form an integer size, so the ?: code here is polymorphic. It is advised to avoid
        // randomly mixing both uses in calling code, to avoid any potential JS engine JIT issues.
        GLctx.bufferData(target, data ? HEAPU8.subarray(data, data+size) : size, usage);
    }
  Module["_emscripten_glBufferData"] = _emscripten_glBufferData;

  function _emscripten_glBufferSubData(target, offset, size, data) {
      GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data+size));
    }
  Module["_emscripten_glBufferSubData"] = _emscripten_glBufferSubData;

  function _emscripten_glCheckFramebufferStatus(x0) { return GLctx['checkFramebufferStatus'](x0) }
  Module["_emscripten_glCheckFramebufferStatus"] = _emscripten_glCheckFramebufferStatus;

  function _emscripten_glClear(x0) { GLctx['clear'](x0) }
  Module["_emscripten_glClear"] = _emscripten_glClear;

  function _emscripten_glClearColor(x0, x1, x2, x3) { GLctx['clearColor'](x0, x1, x2, x3) }
  Module["_emscripten_glClearColor"] = _emscripten_glClearColor;

  function _emscripten_glClearDepthf(x0) { GLctx['clearDepth'](x0) }
  Module["_emscripten_glClearDepthf"] = _emscripten_glClearDepthf;

  function _emscripten_glClearStencil(x0) { GLctx['clearStencil'](x0) }
  Module["_emscripten_glClearStencil"] = _emscripten_glClearStencil;

  function _emscripten_glColorMask(red, green, blue, alpha) {
      GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
    }
  Module["_emscripten_glColorMask"] = _emscripten_glColorMask;

  function _emscripten_glCompileShader(shader) {
      GLctx.compileShader(GL.shaders[shader]);
    }
  Module["_emscripten_glCompileShader"] = _emscripten_glCompileShader;

  function _emscripten_glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data) {
      GLctx['compressedTexImage2D'](target, level, internalFormat, width, height, border, data ? HEAPU8.subarray((data),(data+imageSize)) : null);
    }
  Module["_emscripten_glCompressedTexImage2D"] = _emscripten_glCompressedTexImage2D;

  function _emscripten_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data) {
      GLctx['compressedTexSubImage2D'](target, level, xoffset, yoffset, width, height, format, data ? HEAPU8.subarray((data),(data+imageSize)) : null);
    }
  Module["_emscripten_glCompressedTexSubImage2D"] = _emscripten_glCompressedTexSubImage2D;

  function _emscripten_glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }
  Module["_emscripten_glCopyTexImage2D"] = _emscripten_glCopyTexImage2D;

  function _emscripten_glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexSubImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }
  Module["_emscripten_glCopyTexSubImage2D"] = _emscripten_glCopyTexSubImage2D;

  function _emscripten_glCreateProgram() {
      var id = GL.getNewId(GL.programs);
      var program = GLctx.createProgram();
      program.name = id;
      GL.programs[id] = program;
      return id;
    }
  Module["_emscripten_glCreateProgram"] = _emscripten_glCreateProgram;

  function _emscripten_glCreateShader(shaderType) {
      var id = GL.getNewId(GL.shaders);
      GL.shaders[id] = GLctx.createShader(shaderType);
      return id;
    }
  Module["_emscripten_glCreateShader"] = _emscripten_glCreateShader;

  function _emscripten_glCullFace(x0) { GLctx['cullFace'](x0) }
  Module["_emscripten_glCullFace"] = _emscripten_glCullFace;

  function _emscripten_glDeleteBuffers(n, buffers) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((buffers)+(i*4))>>2)];
        var buffer = GL.buffers[id];
  
        // From spec: "glDeleteBuffers silently ignores 0's and names that do not
        // correspond to existing buffer objects."
        if (!buffer) continue;
  
        GLctx.deleteBuffer(buffer);
        buffer.name = 0;
        GL.buffers[id] = null;
  
        if (id == GL.currArrayBuffer) GL.currArrayBuffer = 0;
        if (id == GL.currElementArrayBuffer) GL.currElementArrayBuffer = 0;
      }
    }
  Module["_emscripten_glDeleteBuffers"] = _emscripten_glDeleteBuffers;

  function _emscripten_glDeleteFramebuffers(n, framebuffers) {
      for (var i = 0; i < n; ++i) {
        var id = HEAP32[(((framebuffers)+(i*4))>>2)];
        var framebuffer = GL.framebuffers[id];
        if (!framebuffer) continue; // GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
        GLctx.deleteFramebuffer(framebuffer);
        framebuffer.name = 0;
        GL.framebuffers[id] = null;
      }
    }
  Module["_emscripten_glDeleteFramebuffers"] = _emscripten_glDeleteFramebuffers;

  function _emscripten_glDeleteProgram(id) {
      if (!id) return;
      var program = GL.programs[id];
      if (!program) { // glDeleteProgram actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteProgram(program);
      program.name = 0;
      GL.programs[id] = null;
      GL.programInfos[id] = null;
    }
  Module["_emscripten_glDeleteProgram"] = _emscripten_glDeleteProgram;

  function _emscripten_glDeleteQueriesEXT(n, ids) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((ids)+(i*4))>>2)];
        var query = GL.timerQueriesEXT[id];
        if (!query) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
        GLctx.disjointTimerQueryExt['deleteQueryEXT'](query);
        GL.timerQueriesEXT[id] = null;
      }
    }
  Module["_emscripten_glDeleteQueriesEXT"] = _emscripten_glDeleteQueriesEXT;

  function _emscripten_glDeleteRenderbuffers(n, renderbuffers) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((renderbuffers)+(i*4))>>2)];
        var renderbuffer = GL.renderbuffers[id];
        if (!renderbuffer) continue; // GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
        GLctx.deleteRenderbuffer(renderbuffer);
        renderbuffer.name = 0;
        GL.renderbuffers[id] = null;
      }
    }
  Module["_emscripten_glDeleteRenderbuffers"] = _emscripten_glDeleteRenderbuffers;

  function _emscripten_glDeleteShader(id) {
      if (!id) return;
      var shader = GL.shaders[id];
      if (!shader) { // glDeleteShader actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteShader(shader);
      GL.shaders[id] = null;
    }
  Module["_emscripten_glDeleteShader"] = _emscripten_glDeleteShader;

  function _emscripten_glDeleteTextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((textures)+(i*4))>>2)];
        var texture = GL.textures[id];
        if (!texture) continue; // GL spec: "glDeleteTextures silently ignores 0s and names that do not correspond to existing textures".
        GLctx.deleteTexture(texture);
        texture.name = 0;
        GL.textures[id] = null;
      }
    }
  Module["_emscripten_glDeleteTextures"] = _emscripten_glDeleteTextures;

  function _emscripten_glDeleteVertexArraysOES(n, vaos) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((vaos)+(i*4))>>2)];
        GLctx['deleteVertexArray'](GL.vaos[id]);
        GL.vaos[id] = null;
      }
    }
  Module["_emscripten_glDeleteVertexArraysOES"] = _emscripten_glDeleteVertexArraysOES;

  function _emscripten_glDepthFunc(x0) { GLctx['depthFunc'](x0) }
  Module["_emscripten_glDepthFunc"] = _emscripten_glDepthFunc;

  function _emscripten_glDepthMask(flag) {
      GLctx.depthMask(!!flag);
    }
  Module["_emscripten_glDepthMask"] = _emscripten_glDepthMask;

  function _emscripten_glDepthRangef(x0, x1) { GLctx['depthRange'](x0, x1) }
  Module["_emscripten_glDepthRangef"] = _emscripten_glDepthRangef;

  function _emscripten_glDetachShader(program, shader) {
      GLctx.detachShader(GL.programs[program],
                              GL.shaders[shader]);
    }
  Module["_emscripten_glDetachShader"] = _emscripten_glDetachShader;

  function _emscripten_glDisable(x0) { GLctx['disable'](x0) }
  Module["_emscripten_glDisable"] = _emscripten_glDisable;

  function _emscripten_glDisableVertexAttribArray(index) {
      GLctx.disableVertexAttribArray(index);
    }
  Module["_emscripten_glDisableVertexAttribArray"] = _emscripten_glDisableVertexAttribArray;

  function _emscripten_glDrawArrays(mode, first, count) {
  
      GLctx.drawArrays(mode, first, count);
  
    }
  Module["_emscripten_glDrawArrays"] = _emscripten_glDrawArrays;

  function _emscripten_glDrawArraysInstancedANGLE(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_emscripten_glDrawArraysInstancedANGLE"] = _emscripten_glDrawArraysInstancedANGLE;

  
  var __tempFixedLengthArray=[];
  Module["__tempFixedLengthArray"] = __tempFixedLengthArray;function _emscripten_glDrawBuffersWEBGL(n, bufs) {
  
      var bufArray = __tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx['drawBuffers'](bufArray);
    }
  Module["_emscripten_glDrawBuffersWEBGL"] = _emscripten_glDrawBuffersWEBGL;

  function _emscripten_glDrawElements(mode, count, type, indices) {
  
      GLctx.drawElements(mode, count, type, indices);
  
    }
  Module["_emscripten_glDrawElements"] = _emscripten_glDrawElements;

  function _emscripten_glDrawElementsInstancedANGLE(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_emscripten_glDrawElementsInstancedANGLE"] = _emscripten_glDrawElementsInstancedANGLE;

  function _emscripten_glEnable(x0) { GLctx['enable'](x0) }
  Module["_emscripten_glEnable"] = _emscripten_glEnable;

  function _emscripten_glEnableVertexAttribArray(index) {
      GLctx.enableVertexAttribArray(index);
    }
  Module["_emscripten_glEnableVertexAttribArray"] = _emscripten_glEnableVertexAttribArray;

  function _emscripten_glEndQueryEXT(target) {
      GLctx.disjointTimerQueryExt['endQueryEXT'](target);
    }
  Module["_emscripten_glEndQueryEXT"] = _emscripten_glEndQueryEXT;

  function _emscripten_glFinish() { GLctx['finish']() }
  Module["_emscripten_glFinish"] = _emscripten_glFinish;

  function _emscripten_glFlush() { GLctx['flush']() }
  Module["_emscripten_glFlush"] = _emscripten_glFlush;

  function _emscripten_glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
      GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget,
                                         GL.renderbuffers[renderbuffer]);
    }
  Module["_emscripten_glFramebufferRenderbuffer"] = _emscripten_glFramebufferRenderbuffer;

  function _emscripten_glFramebufferTexture2D(target, attachment, textarget, texture, level) {
      GLctx.framebufferTexture2D(target, attachment, textarget,
                                      GL.textures[texture], level);
    }
  Module["_emscripten_glFramebufferTexture2D"] = _emscripten_glFramebufferTexture2D;

  function _emscripten_glFrontFace(x0) { GLctx['frontFace'](x0) }
  Module["_emscripten_glFrontFace"] = _emscripten_glFrontFace;

  
  function __glGenObject(n, buffers, createFunction, objectTable
      ) {
      for (var i = 0; i < n; i++) {
        var buffer = GLctx[createFunction]();
        var id = buffer && GL.getNewId(objectTable);
        if (buffer) {
          buffer.name = id;
          objectTable[id] = buffer;
        } else {
          GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        }
        HEAP32[(((buffers)+(i*4))>>2)]=id;
      }
    }
  Module["__glGenObject"] = __glGenObject;function _emscripten_glGenBuffers(n, buffers) {
      __glGenObject(n, buffers, 'createBuffer', GL.buffers
        );
    }
  Module["_emscripten_glGenBuffers"] = _emscripten_glGenBuffers;

  function _emscripten_glGenFramebuffers(n, ids) {
      __glGenObject(n, ids, 'createFramebuffer', GL.framebuffers
        );
    }
  Module["_emscripten_glGenFramebuffers"] = _emscripten_glGenFramebuffers;

  function _emscripten_glGenQueriesEXT(n, ids) {
      for (var i = 0; i < n; i++) {
        var query = GLctx.disjointTimerQueryExt['createQueryEXT']();
        if (!query) {
          GL.recordError(0x502 /* GL_INVALID_OPERATION */);
          while(i < n) HEAP32[(((ids)+(i++*4))>>2)]=0;
          return;
        }
        var id = GL.getNewId(GL.timerQueriesEXT);
        query.name = id;
        GL.timerQueriesEXT[id] = query;
        HEAP32[(((ids)+(i*4))>>2)]=id;
      }
    }
  Module["_emscripten_glGenQueriesEXT"] = _emscripten_glGenQueriesEXT;

  function _emscripten_glGenRenderbuffers(n, renderbuffers) {
      __glGenObject(n, renderbuffers, 'createRenderbuffer', GL.renderbuffers
        );
    }
  Module["_emscripten_glGenRenderbuffers"] = _emscripten_glGenRenderbuffers;

  function _emscripten_glGenTextures(n, textures) {
      __glGenObject(n, textures, 'createTexture', GL.textures
        );
    }
  Module["_emscripten_glGenTextures"] = _emscripten_glGenTextures;

  function _emscripten_glGenVertexArraysOES(n, arrays) {
      __glGenObject(n, arrays, 'createVertexArray', GL.vaos
        );
    }
  Module["_emscripten_glGenVertexArraysOES"] = _emscripten_glGenVertexArraysOES;

  function _emscripten_glGenerateMipmap(x0) { GLctx['generateMipmap'](x0) }
  Module["_emscripten_glGenerateMipmap"] = _emscripten_glGenerateMipmap;

  function _emscripten_glGetActiveAttrib(program, index, bufSize, length, size, type, name) {
      program = GL.programs[program];
      var info = GLctx.getActiveAttrib(program, index);
      if (!info) return; // If an error occurs, nothing will be written to length, size and type and name.
  
      var numBytesWrittenExclNull = (bufSize > 0 && name) ? stringToUTF8(info.name, name, bufSize) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
      if (size) HEAP32[((size)>>2)]=info.size;
      if (type) HEAP32[((type)>>2)]=info.type;
    }
  Module["_emscripten_glGetActiveAttrib"] = _emscripten_glGetActiveAttrib;

  function _emscripten_glGetActiveUniform(program, index, bufSize, length, size, type, name) {
      program = GL.programs[program];
      var info = GLctx.getActiveUniform(program, index);
      if (!info) return; // If an error occurs, nothing will be written to length, size, type and name.
  
      var numBytesWrittenExclNull = (bufSize > 0 && name) ? stringToUTF8(info.name, name, bufSize) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
      if (size) HEAP32[((size)>>2)]=info.size;
      if (type) HEAP32[((type)>>2)]=info.type;
    }
  Module["_emscripten_glGetActiveUniform"] = _emscripten_glGetActiveUniform;

  function _emscripten_glGetAttachedShaders(program, maxCount, count, shaders) {
      var result = GLctx.getAttachedShaders(GL.programs[program]);
      var len = result.length;
      if (len > maxCount) {
        len = maxCount;
      }
      HEAP32[((count)>>2)]=len;
      for (var i = 0; i < len; ++i) {
        var id = GL.shaders.indexOf(result[i]);
        HEAP32[(((shaders)+(i*4))>>2)]=id;
      }
    }
  Module["_emscripten_glGetAttachedShaders"] = _emscripten_glGetAttachedShaders;

  function _emscripten_glGetAttribLocation(program, name) {
      return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
    }
  Module["_emscripten_glGetAttribLocation"] = _emscripten_glGetAttribLocation;

  
  
  
  function readI53FromI64(ptr) {
      return HEAPU32[ptr>>2] + HEAP32[ptr+4>>2] * 4294967296;
    }
  Module["readI53FromI64"] = readI53FromI64;
  
  function readI53FromU64(ptr) {
      return HEAPU32[ptr>>2] + HEAPU32[ptr+4>>2] * 4294967296;
    }
  Module["readI53FromU64"] = readI53FromU64;function writeI53ToI64(ptr, num) {
      HEAPU32[ptr>>2] = num;
      HEAPU32[ptr+4>>2] = (num - HEAPU32[ptr>>2])/4294967296;
      var deserialized = (num >= 0) ? readI53FromU64(ptr) : readI53FromI64(ptr);
      if (deserialized != num) warnOnce('writeI53ToI64() out of range: serialized JS Number ' + num + ' to Wasm heap as bytes lo=0x' + HEAPU32[ptr>>2].toString(16) + ', hi=0x' + HEAPU32[ptr+4>>2].toString(16) + ', which deserializes back to ' + deserialized + ' instead!');
    }
  Module["writeI53ToI64"] = writeI53ToI64;function emscriptenWebGLGet(name_, p, type) {
      // Guard against user passing a null pointer.
      // Note that GLES2 spec does not say anything about how passing a null pointer should be treated.
      // Testing on desktop core GL 3, the application crashes on glGetIntegerv to a null pointer, but
      // better to report an error instead of doing anything random.
      if (!p) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = undefined;
      switch(name_) { // Handle a few trivial GLES values
        case 0x8DFA: // GL_SHADER_COMPILER
          ret = 1;
          break;
        case 0x8DF8: // GL_SHADER_BINARY_FORMATS
          if (type != 0 && type != 1) {
            GL.recordError(0x500); // GL_INVALID_ENUM
          }
          return; // Do not write anything to the out pointer, since no binary formats are supported.
        case 0x8DF9: // GL_NUM_SHADER_BINARY_FORMATS
          ret = 0;
          break;
        case 0x86A2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS
          // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be queried for length),
          // so implement it ourselves to allow C++ GLES2 code get the length.
          var formats = GLctx.getParameter(0x86A3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);
          ret = formats ? formats.length : 0;
          break;
      }
  
      if (ret === undefined) {
        var result = GLctx.getParameter(name_);
        switch (typeof(result)) {
          case "number":
            ret = result;
            break;
          case "boolean":
            ret = result ? 1 : 0;
            break;
          case "string":
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          case "object":
            if (result === null) {
              // null is a valid result for some (e.g., which buffer is bound - perhaps nothing is bound), but otherwise
              // can mean an invalid name_, which we need to report as an error
              switch(name_) {
                case 0x8894: // ARRAY_BUFFER_BINDING
                case 0x8B8D: // CURRENT_PROGRAM
                case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING
                case 0x8CA6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
                case 0x8CA7: // RENDERBUFFER_BINDING
                case 0x8069: // TEXTURE_BINDING_2D
                case 0x85B5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
                case 0x8514: { // TEXTURE_BINDING_CUBE_MAP
                  ret = 0;
                  break;
                }
                default: {
                  GL.recordError(0x500); // GL_INVALID_ENUM
                  return;
                }
              }
            } else if (result instanceof Float32Array ||
                       result instanceof Uint32Array ||
                       result instanceof Int32Array ||
                       result instanceof Array) {
              for (var i = 0; i < result.length; ++i) {
                switch (type) {
                  case 0: HEAP32[(((p)+(i*4))>>2)]=result[i]; break;
                  case 2: HEAPF32[(((p)+(i*4))>>2)]=result[i]; break;
                  case 4: HEAP8[(((p)+(i))>>0)]=result[i] ? 1 : 0; break;
                }
              }
              return;
            } else {
              try {
                ret = result.name | 0;
              } catch(e) {
                GL.recordError(0x500); // GL_INVALID_ENUM
                err('GL_INVALID_ENUM in glGet' + type + 'v: Unknown object returned from WebGL getParameter(' + name_ + ')! (error: ' + e + ')');
                return;
              }
            }
            break;
          default:
            GL.recordError(0x500); // GL_INVALID_ENUM
            err('GL_INVALID_ENUM in glGet' + type + 'v: Native code calling glGet' + type + 'v(' + name_ + ') and it returns ' + result + ' of type ' + typeof(result) + '!');
            return;
        }
      }
  
      switch (type) {
        case 1: writeI53ToI64(p, ret); break;
        case 0: HEAP32[((p)>>2)]=ret; break;
        case 2:   HEAPF32[((p)>>2)]=ret; break;
        case 4: HEAP8[((p)>>0)]=ret ? 1 : 0; break;
      }
    }
  Module["emscriptenWebGLGet"] = emscriptenWebGLGet;function _emscripten_glGetBooleanv(name_, p) {
      emscriptenWebGLGet(name_, p, 4);
    }
  Module["_emscripten_glGetBooleanv"] = _emscripten_glGetBooleanv;

  function _emscripten_glGetBufferParameteriv(target, value, data) {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
        // if data == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((data)>>2)]=GLctx.getBufferParameter(target, value);
    }
  Module["_emscripten_glGetBufferParameteriv"] = _emscripten_glGetBufferParameteriv;

  function _emscripten_glGetError() {
      var error = GLctx.getError() || GL.lastError;
      GL.lastError = 0/*GL_NO_ERROR*/;
      return error;
    }
  Module["_emscripten_glGetError"] = _emscripten_glGetError;

  function _emscripten_glGetFloatv(name_, p) {
      emscriptenWebGLGet(name_, p, 2);
    }
  Module["_emscripten_glGetFloatv"] = _emscripten_glGetFloatv;

  function _emscripten_glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
      var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
      if (result instanceof WebGLRenderbuffer ||
          result instanceof WebGLTexture) {
        result = result.name | 0;
      }
      HEAP32[((params)>>2)]=result;
    }
  Module["_emscripten_glGetFramebufferAttachmentParameteriv"] = _emscripten_glGetFramebufferAttachmentParameteriv;

  function _emscripten_glGetIntegerv(name_, p) {
      emscriptenWebGLGet(name_, p, 0);
    }
  Module["_emscripten_glGetIntegerv"] = _emscripten_glGetIntegerv;

  function _emscripten_glGetProgramInfoLog(program, maxLength, length, infoLog) {
      var log = GLctx.getProgramInfoLog(GL.programs[program]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
    }
  Module["_emscripten_glGetProgramInfoLog"] = _emscripten_glGetProgramInfoLog;

  function _emscripten_glGetProgramiv(program, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      if (program >= GL.counter) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      var ptable = GL.programInfos[program];
      if (!ptable) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        return;
      }
  
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getProgramInfoLog(GL.programs[program]);
        if (log === null) log = '(unknown error)';
        HEAP32[((p)>>2)]=log.length + 1;
      } else if (pname == 0x8B87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
        HEAP32[((p)>>2)]=ptable.maxUniformLength;
      } else if (pname == 0x8B8A /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
        if (ptable.maxAttributeLength == -1) {
          program = GL.programs[program];
          var numAttribs = GLctx.getProgramParameter(program, 0x8B89/*GL_ACTIVE_ATTRIBUTES*/);
          ptable.maxAttributeLength = 0; // Spec says if there are no active attribs, 0 must be returned.
          for (var i = 0; i < numAttribs; ++i) {
            var activeAttrib = GLctx.getActiveAttrib(program, i);
            ptable.maxAttributeLength = Math.max(ptable.maxAttributeLength, activeAttrib.name.length+1);
          }
        }
        HEAP32[((p)>>2)]=ptable.maxAttributeLength;
      } else if (pname == 0x8A35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
        if (ptable.maxUniformBlockNameLength == -1) {
          program = GL.programs[program];
          var numBlocks = GLctx.getProgramParameter(program, 0x8A36/*GL_ACTIVE_UNIFORM_BLOCKS*/);
          ptable.maxUniformBlockNameLength = 0;
          for (var i = 0; i < numBlocks; ++i) {
            var activeBlockName = GLctx.getActiveUniformBlockName(program, i);
            ptable.maxUniformBlockNameLength = Math.max(ptable.maxUniformBlockNameLength, activeBlockName.length+1);
          }
        }
        HEAP32[((p)>>2)]=ptable.maxUniformBlockNameLength;
      } else {
        HEAP32[((p)>>2)]=GLctx.getProgramParameter(GL.programs[program], pname);
      }
    }
  Module["_emscripten_glGetProgramiv"] = _emscripten_glGetProgramiv;

  function _emscripten_glGetQueryObjecti64vEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      writeI53ToI64(params, ret);
    }
  Module["_emscripten_glGetQueryObjecti64vEXT"] = _emscripten_glGetQueryObjecti64vEXT;

  function _emscripten_glGetQueryObjectivEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      HEAP32[((params)>>2)]=ret;
    }
  Module["_emscripten_glGetQueryObjectivEXT"] = _emscripten_glGetQueryObjectivEXT;

  function _emscripten_glGetQueryObjectui64vEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      writeI53ToI64(params, ret);
    }
  Module["_emscripten_glGetQueryObjectui64vEXT"] = _emscripten_glGetQueryObjectui64vEXT;

  function _emscripten_glGetQueryObjectuivEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      HEAP32[((params)>>2)]=ret;
    }
  Module["_emscripten_glGetQueryObjectuivEXT"] = _emscripten_glGetQueryObjectuivEXT;

  function _emscripten_glGetQueryivEXT(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)]=GLctx.disjointTimerQueryExt['getQueryEXT'](target, pname);
    }
  Module["_emscripten_glGetQueryivEXT"] = _emscripten_glGetQueryivEXT;

  function _emscripten_glGetRenderbufferParameteriv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)]=GLctx.getRenderbufferParameter(target, pname);
    }
  Module["_emscripten_glGetRenderbufferParameteriv"] = _emscripten_glGetRenderbufferParameteriv;

  function _emscripten_glGetShaderInfoLog(shader, maxLength, length, infoLog) {
      var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
    }
  Module["_emscripten_glGetShaderInfoLog"] = _emscripten_glGetShaderInfoLog;

  function _emscripten_glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
      var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
      HEAP32[((range)>>2)]=result.rangeMin;
      HEAP32[(((range)+(4))>>2)]=result.rangeMax;
      HEAP32[((precision)>>2)]=result.precision;
    }
  Module["_emscripten_glGetShaderPrecisionFormat"] = _emscripten_glGetShaderPrecisionFormat;

  function _emscripten_glGetShaderSource(shader, bufSize, length, source) {
      var result = GLctx.getShaderSource(GL.shaders[shader]);
      if (!result) return; // If an error occurs, nothing will be written to length or source.
      var numBytesWrittenExclNull = (bufSize > 0 && source) ? stringToUTF8(result, source, bufSize) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
    }
  Module["_emscripten_glGetShaderSource"] = _emscripten_glGetShaderSource;

  function _emscripten_glGetShaderiv(shader, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
        if (log === null) log = '(unknown error)';
        HEAP32[((p)>>2)]=log.length + 1;
      } else if (pname == 0x8B88) { // GL_SHADER_SOURCE_LENGTH
        var source = GLctx.getShaderSource(GL.shaders[shader]);
        var sourceLength = (source === null || source.length == 0) ? 0 : source.length + 1;
        HEAP32[((p)>>2)]=sourceLength;
      } else {
        HEAP32[((p)>>2)]=GLctx.getShaderParameter(GL.shaders[shader], pname);
      }
    }
  Module["_emscripten_glGetShaderiv"] = _emscripten_glGetShaderiv;

  function _emscripten_glGetString(name_) {
      if (GL.stringCache[name_]) return GL.stringCache[name_];
      var ret;
      switch(name_) {
        case 0x1F03 /* GL_EXTENSIONS */:
          var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
          exts = exts.concat(exts.map(function(e) { return "GL_" + e; }));
          ret = stringToNewUTF8(exts.join(' '));
          break;
        case 0x1F00 /* GL_VENDOR */:
        case 0x1F01 /* GL_RENDERER */:
        case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
        case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
          var s = GLctx.getParameter(name_);
          if (!s) {
            GL.recordError(0x500/*GL_INVALID_ENUM*/);
          }
          ret = stringToNewUTF8(s);
          break;
  
        case 0x1F02 /* GL_VERSION */:
          var glVersion = GLctx.getParameter(0x1F02 /*GL_VERSION*/);
          // return GLES version string corresponding to the version of the WebGL context
          {
            glVersion = 'OpenGL ES 2.0 (' + glVersion + ')';
          }
          ret = stringToNewUTF8(glVersion);
          break;
        case 0x8B8C /* GL_SHADING_LANGUAGE_VERSION */:
          var glslVersion = GLctx.getParameter(0x8B8C /*GL_SHADING_LANGUAGE_VERSION*/);
          // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
          var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
          var ver_num = glslVersion.match(ver_re);
          if (ver_num !== null) {
            if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
            glslVersion = 'OpenGL ES GLSL ES ' + ver_num[1] + ' (' + glslVersion + ')';
          }
          ret = stringToNewUTF8(glslVersion);
          break;
        default:
          GL.recordError(0x500/*GL_INVALID_ENUM*/);
          return 0;
      }
      GL.stringCache[name_] = ret;
      return ret;
    }
  Module["_emscripten_glGetString"] = _emscripten_glGetString;

  function _emscripten_glGetTexParameterfv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAPF32[((params)>>2)]=GLctx.getTexParameter(target, pname);
    }
  Module["_emscripten_glGetTexParameterfv"] = _emscripten_glGetTexParameterfv;

  function _emscripten_glGetTexParameteriv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)]=GLctx.getTexParameter(target, pname);
    }
  Module["_emscripten_glGetTexParameteriv"] = _emscripten_glGetTexParameteriv;

  function _emscripten_glGetUniformLocation(program, name) {
      name = UTF8ToString(name);
  
      var arrayIndex = 0;
      // If user passed an array accessor "[index]", parse the array index off the accessor.
      if (name[name.length - 1] == ']') {
        var leftBrace = name.lastIndexOf('[');
        arrayIndex = name[leftBrace+1] != ']' ? jstoi_q(name.slice(leftBrace + 1)) : 0; // "index]", parseInt will ignore the ']' at the end; but treat "foo[]" as "foo[0]"
        name = name.slice(0, leftBrace);
      }
  
      var uniformInfo = GL.programInfos[program] && GL.programInfos[program].uniforms[name]; // returns pair [ dimension_of_uniform_array, uniform_location ]
      if (uniformInfo && arrayIndex >= 0 && arrayIndex < uniformInfo[0]) { // Check if user asked for an out-of-bounds element, i.e. for 'vec4 colors[3];' user could ask for 'colors[10]' which should return -1.
        return uniformInfo[1] + arrayIndex;
      } else {
        return -1;
      }
    }
  Module["_emscripten_glGetUniformLocation"] = _emscripten_glGetUniformLocation;

  
  /** @suppress{checkTypes} */
  function emscriptenWebGLGetUniform(program, location, params, type) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var data = GLctx.getUniform(GL.programs[program], GL.uniforms[location]);
      if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 0: HEAP32[((params)>>2)]=data; break;
          case 2: HEAPF32[((params)>>2)]=data; break;
          default: throw 'internal emscriptenWebGLGetUniform() error, bad type: ' + type;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 0: HEAP32[(((params)+(i*4))>>2)]=data[i]; break;
            case 2: HEAPF32[(((params)+(i*4))>>2)]=data[i]; break;
            default: throw 'internal emscriptenWebGLGetUniform() error, bad type: ' + type;
          }
        }
      }
    }
  Module["emscriptenWebGLGetUniform"] = emscriptenWebGLGetUniform;function _emscripten_glGetUniformfv(program, location, params) {
      emscriptenWebGLGetUniform(program, location, params, 2);
    }
  Module["_emscripten_glGetUniformfv"] = _emscripten_glGetUniformfv;

  function _emscripten_glGetUniformiv(program, location, params) {
      emscriptenWebGLGetUniform(program, location, params, 0);
    }
  Module["_emscripten_glGetUniformiv"] = _emscripten_glGetUniformiv;

  function _emscripten_glGetVertexAttribPointerv(index, pname, pointer) {
      if (!pointer) {
        // GLES2 specification does not specify how to behave if pointer is a null pointer. Since calling this function does not make sense
        // if pointer == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((pointer)>>2)]=GLctx.getVertexAttribOffset(index, pname);
    }
  Module["_emscripten_glGetVertexAttribPointerv"] = _emscripten_glGetVertexAttribPointerv;

  
  /** @suppress{checkTypes} */
  function emscriptenWebGLGetVertexAttrib(index, pname, params, type) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var data = GLctx.getVertexAttrib(index, pname);
      if (pname == 0x889F/*VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*/) {
        HEAP32[((params)>>2)]=data && data["name"];
      } else if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 0: HEAP32[((params)>>2)]=data; break;
          case 2: HEAPF32[((params)>>2)]=data; break;
          case 5: HEAP32[((params)>>2)]=Math.fround(data); break;
          default: throw 'internal emscriptenWebGLGetVertexAttrib() error, bad type: ' + type;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 0: HEAP32[(((params)+(i*4))>>2)]=data[i]; break;
            case 2: HEAPF32[(((params)+(i*4))>>2)]=data[i]; break;
            case 5: HEAP32[(((params)+(i*4))>>2)]=Math.fround(data[i]); break;
            default: throw 'internal emscriptenWebGLGetVertexAttrib() error, bad type: ' + type;
          }
        }
      }
    }
  Module["emscriptenWebGLGetVertexAttrib"] = emscriptenWebGLGetVertexAttrib;function _emscripten_glGetVertexAttribfv(index, pname, params) {
      // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
      // otherwise the results are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
    }
  Module["_emscripten_glGetVertexAttribfv"] = _emscripten_glGetVertexAttribfv;

  function _emscripten_glGetVertexAttribiv(index, pname, params) {
      // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
      // otherwise the results are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
    }
  Module["_emscripten_glGetVertexAttribiv"] = _emscripten_glGetVertexAttribiv;

  function _emscripten_glHint(x0, x1) { GLctx['hint'](x0, x1) }
  Module["_emscripten_glHint"] = _emscripten_glHint;

  function _emscripten_glIsBuffer(buffer) {
      var b = GL.buffers[buffer];
      if (!b) return 0;
      return GLctx.isBuffer(b);
    }
  Module["_emscripten_glIsBuffer"] = _emscripten_glIsBuffer;

  function _emscripten_glIsEnabled(x0) { return GLctx['isEnabled'](x0) }
  Module["_emscripten_glIsEnabled"] = _emscripten_glIsEnabled;

  function _emscripten_glIsFramebuffer(framebuffer) {
      var fb = GL.framebuffers[framebuffer];
      if (!fb) return 0;
      return GLctx.isFramebuffer(fb);
    }
  Module["_emscripten_glIsFramebuffer"] = _emscripten_glIsFramebuffer;

  function _emscripten_glIsProgram(program) {
      program = GL.programs[program];
      if (!program) return 0;
      return GLctx.isProgram(program);
    }
  Module["_emscripten_glIsProgram"] = _emscripten_glIsProgram;

  function _emscripten_glIsQueryEXT(id) {
      var query = GL.timerQueriesEXT[id];
      if (!query) return 0;
      return GLctx.disjointTimerQueryExt['isQueryEXT'](query);
    }
  Module["_emscripten_glIsQueryEXT"] = _emscripten_glIsQueryEXT;

  function _emscripten_glIsRenderbuffer(renderbuffer) {
      var rb = GL.renderbuffers[renderbuffer];
      if (!rb) return 0;
      return GLctx.isRenderbuffer(rb);
    }
  Module["_emscripten_glIsRenderbuffer"] = _emscripten_glIsRenderbuffer;

  function _emscripten_glIsShader(shader) {
      var s = GL.shaders[shader];
      if (!s) return 0;
      return GLctx.isShader(s);
    }
  Module["_emscripten_glIsShader"] = _emscripten_glIsShader;

  function _emscripten_glIsTexture(id) {
      var texture = GL.textures[id];
      if (!texture) return 0;
      return GLctx.isTexture(texture);
    }
  Module["_emscripten_glIsTexture"] = _emscripten_glIsTexture;

  function _emscripten_glIsVertexArrayOES(array) {
  
      var vao = GL.vaos[array];
      if (!vao) return 0;
      return GLctx['isVertexArray'](vao);
    }
  Module["_emscripten_glIsVertexArrayOES"] = _emscripten_glIsVertexArrayOES;

  function _emscripten_glLineWidth(x0) { GLctx['lineWidth'](x0) }
  Module["_emscripten_glLineWidth"] = _emscripten_glLineWidth;

  function _emscripten_glLinkProgram(program) {
      GLctx.linkProgram(GL.programs[program]);
      GL.populateUniformTable(program);
    }
  Module["_emscripten_glLinkProgram"] = _emscripten_glLinkProgram;

  function _emscripten_glPixelStorei(pname, param) {
      if (pname == 0xCF5 /* GL_UNPACK_ALIGNMENT */) {
        GL.unpackAlignment = param;
      }
      GLctx.pixelStorei(pname, param);
    }
  Module["_emscripten_glPixelStorei"] = _emscripten_glPixelStorei;

  function _emscripten_glPolygonOffset(x0, x1) { GLctx['polygonOffset'](x0, x1) }
  Module["_emscripten_glPolygonOffset"] = _emscripten_glPolygonOffset;

  function _emscripten_glQueryCounterEXT(id, target) {
      GLctx.disjointTimerQueryExt['queryCounterEXT'](GL.timerQueriesEXT[id], target);
    }
  Module["_emscripten_glQueryCounterEXT"] = _emscripten_glQueryCounterEXT;

  
  
  function __computeUnpackAlignedImageSize(width, height, sizePerPixel, alignment) {
      function roundedToNextMultipleOf(x, y) {
        return (x + y - 1) & -y;
      }
      var plainRowSize = width * sizePerPixel;
      var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
      return height * alignedRowSize;
    }
  Module["__computeUnpackAlignedImageSize"] = __computeUnpackAlignedImageSize;
  
  function __colorChannelsInGlTextureFormat(format) {
      // Micro-optimizations for size: map format to size by subtracting smallest enum value (0x1902) from all values first.
      // Also omit the most common size value (1) from the list, which is assumed by formats not on the list.
      var colorChannels = {
        // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
        // 0x1906 /* GL_ALPHA */ - 0x1902: 1,
        5: 3,
        6: 4,
        // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
        8: 2,
        29502: 3,
        29504: 4,
      };
      return colorChannels[format - 0x1902]||1;
    }
  Module["__colorChannelsInGlTextureFormat"] = __colorChannelsInGlTextureFormat;
  
  function __heapObjectForWebGLType(type) {
      // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
      // smaller values for the heap, for shorter generated code size.
      // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
      // (since most types are HEAPU16)
      type -= 0x1400;
  
      if (type == 1) return HEAPU8;
  
  
      if (type == 4) return HEAP32;
  
      if (type == 6) return HEAPF32;
  
      if (type == 5
        || type == 28922
        )
        return HEAPU32;
  
      return HEAPU16;
    }
  Module["__heapObjectForWebGLType"] = __heapObjectForWebGLType;
  
  function __heapAccessShiftForWebGLHeap(heap) {
      return 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
    }
  Module["__heapAccessShiftForWebGLHeap"] = __heapAccessShiftForWebGLHeap;function emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) {
      var heap = __heapObjectForWebGLType(type);
      var shift = __heapAccessShiftForWebGLHeap(heap);
      var byteSize = 1<<shift;
      var sizePerPixel = __colorChannelsInGlTextureFormat(format) * byteSize;
      var bytes = __computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
      return heap.subarray(pixels >> shift, pixels + bytes >> shift);
    }
  Module["emscriptenWebGLGetTexPixelData"] = emscriptenWebGLGetTexPixelData;function _emscripten_glReadPixels(x, y, width, height, format, type, pixels) {
      var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
      if (!pixelData) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        return;
      }
      GLctx.readPixels(x, y, width, height, format, type, pixelData);
    }
  Module["_emscripten_glReadPixels"] = _emscripten_glReadPixels;

  function _emscripten_glReleaseShaderCompiler() {
      // NOP (as allowed by GLES 2.0 spec)
    }
  Module["_emscripten_glReleaseShaderCompiler"] = _emscripten_glReleaseShaderCompiler;

  function _emscripten_glRenderbufferStorage(x0, x1, x2, x3) { GLctx['renderbufferStorage'](x0, x1, x2, x3) }
  Module["_emscripten_glRenderbufferStorage"] = _emscripten_glRenderbufferStorage;

  function _emscripten_glSampleCoverage(value, invert) {
      GLctx.sampleCoverage(value, !!invert);
    }
  Module["_emscripten_glSampleCoverage"] = _emscripten_glSampleCoverage;

  function _emscripten_glScissor(x0, x1, x2, x3) { GLctx['scissor'](x0, x1, x2, x3) }
  Module["_emscripten_glScissor"] = _emscripten_glScissor;

  function _emscripten_glShaderBinary() {
      GL.recordError(0x500/*GL_INVALID_ENUM*/);
    }
  Module["_emscripten_glShaderBinary"] = _emscripten_glShaderBinary;

  function _emscripten_glShaderSource(shader, count, string, length) {
      var source = GL.getSource(shader, count, string, length);
  
  
      GLctx.shaderSource(GL.shaders[shader], source);
    }
  Module["_emscripten_glShaderSource"] = _emscripten_glShaderSource;

  function _emscripten_glStencilFunc(x0, x1, x2) { GLctx['stencilFunc'](x0, x1, x2) }
  Module["_emscripten_glStencilFunc"] = _emscripten_glStencilFunc;

  function _emscripten_glStencilFuncSeparate(x0, x1, x2, x3) { GLctx['stencilFuncSeparate'](x0, x1, x2, x3) }
  Module["_emscripten_glStencilFuncSeparate"] = _emscripten_glStencilFuncSeparate;

  function _emscripten_glStencilMask(x0) { GLctx['stencilMask'](x0) }
  Module["_emscripten_glStencilMask"] = _emscripten_glStencilMask;

  function _emscripten_glStencilMaskSeparate(x0, x1) { GLctx['stencilMaskSeparate'](x0, x1) }
  Module["_emscripten_glStencilMaskSeparate"] = _emscripten_glStencilMaskSeparate;

  function _emscripten_glStencilOp(x0, x1, x2) { GLctx['stencilOp'](x0, x1, x2) }
  Module["_emscripten_glStencilOp"] = _emscripten_glStencilOp;

  function _emscripten_glStencilOpSeparate(x0, x1, x2, x3) { GLctx['stencilOpSeparate'](x0, x1, x2, x3) }
  Module["_emscripten_glStencilOpSeparate"] = _emscripten_glStencilOpSeparate;

  function _emscripten_glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
      GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
    }
  Module["_emscripten_glTexImage2D"] = _emscripten_glTexImage2D;

  function _emscripten_glTexParameterf(x0, x1, x2) { GLctx['texParameterf'](x0, x1, x2) }
  Module["_emscripten_glTexParameterf"] = _emscripten_glTexParameterf;

  function _emscripten_glTexParameterfv(target, pname, params) {
      var param = HEAPF32[((params)>>2)];
      GLctx.texParameterf(target, pname, param);
    }
  Module["_emscripten_glTexParameterfv"] = _emscripten_glTexParameterfv;

  function _emscripten_glTexParameteri(x0, x1, x2) { GLctx['texParameteri'](x0, x1, x2) }
  Module["_emscripten_glTexParameteri"] = _emscripten_glTexParameteri;

  function _emscripten_glTexParameteriv(target, pname, params) {
      var param = HEAP32[((params)>>2)];
      GLctx.texParameteri(target, pname, param);
    }
  Module["_emscripten_glTexParameteriv"] = _emscripten_glTexParameteriv;

  function _emscripten_glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
      var pixelData = null;
      if (pixels) pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
      GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
    }
  Module["_emscripten_glTexSubImage2D"] = _emscripten_glTexSubImage2D;

  function _emscripten_glUniform1f(location, v0) {
      GLctx.uniform1f(GL.uniforms[location], v0);
    }
  Module["_emscripten_glUniform1f"] = _emscripten_glUniform1f;

  function _emscripten_glUniform1fv(location, count, value) {
  
  
      if (count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*4)>>2);
      }
      GLctx.uniform1fv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform1fv"] = _emscripten_glUniform1fv;

  function _emscripten_glUniform1i(location, v0) {
      GLctx.uniform1i(GL.uniforms[location], v0);
    }
  Module["_emscripten_glUniform1i"] = _emscripten_glUniform1i;

  function _emscripten_glUniform1iv(location, count, value) {
  
  
      if (count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*4)>>2);
      }
      GLctx.uniform1iv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform1iv"] = _emscripten_glUniform1iv;

  function _emscripten_glUniform2f(location, v0, v1) {
      GLctx.uniform2f(GL.uniforms[location], v0, v1);
    }
  Module["_emscripten_glUniform2f"] = _emscripten_glUniform2f;

  function _emscripten_glUniform2fv(location, count, value) {
  
  
      if (2*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*8)>>2);
      }
      GLctx.uniform2fv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform2fv"] = _emscripten_glUniform2fv;

  function _emscripten_glUniform2i(location, v0, v1) {
      GLctx.uniform2i(GL.uniforms[location], v0, v1);
    }
  Module["_emscripten_glUniform2i"] = _emscripten_glUniform2i;

  function _emscripten_glUniform2iv(location, count, value) {
  
  
      if (2*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*8)>>2);
      }
      GLctx.uniform2iv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform2iv"] = _emscripten_glUniform2iv;

  function _emscripten_glUniform3f(location, v0, v1, v2) {
      GLctx.uniform3f(GL.uniforms[location], v0, v1, v2);
    }
  Module["_emscripten_glUniform3f"] = _emscripten_glUniform3f;

  function _emscripten_glUniform3fv(location, count, value) {
  
  
      if (3*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*12)>>2);
      }
      GLctx.uniform3fv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform3fv"] = _emscripten_glUniform3fv;

  function _emscripten_glUniform3i(location, v0, v1, v2) {
      GLctx.uniform3i(GL.uniforms[location], v0, v1, v2);
    }
  Module["_emscripten_glUniform3i"] = _emscripten_glUniform3i;

  function _emscripten_glUniform3iv(location, count, value) {
  
  
      if (3*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAP32[(((value)+(4*i+8))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*12)>>2);
      }
      GLctx.uniform3iv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform3iv"] = _emscripten_glUniform3iv;

  function _emscripten_glUniform4f(location, v0, v1, v2, v3) {
      GLctx.uniform4f(GL.uniforms[location], v0, v1, v2, v3);
    }
  Module["_emscripten_glUniform4f"] = _emscripten_glUniform4f;

  function _emscripten_glUniform4fv(location, count, value) {
  
  
      if (4*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[4*count-1];
        // hoist the heap out of the loop for size and for pthreads+growth.
        var heap = HEAPF32;
        value >>= 2;
        for (var i = 0; i < 4 * count; i += 4) {
          var dst = value + i;
          view[i] = heap[dst];
          view[i + 1] = heap[dst + 1];
          view[i + 2] = heap[dst + 2];
          view[i + 3] = heap[dst + 3];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*16)>>2);
      }
      GLctx.uniform4fv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform4fv"] = _emscripten_glUniform4fv;

  function _emscripten_glUniform4i(location, v0, v1, v2, v3) {
      GLctx.uniform4i(GL.uniforms[location], v0, v1, v2, v3);
    }
  Module["_emscripten_glUniform4i"] = _emscripten_glUniform4i;

  function _emscripten_glUniform4iv(location, count, value) {
  
  
      if (4*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAP32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAP32[(((value)+(4*i+12))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*16)>>2);
      }
      GLctx.uniform4iv(GL.uniforms[location], view);
    }
  Module["_emscripten_glUniform4iv"] = _emscripten_glUniform4iv;

  function _emscripten_glUniformMatrix2fv(location, count, transpose, value) {
  
  
      if (4*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAPF32[(((value)+(4*i+12))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*16)>>2);
      }
      GLctx.uniformMatrix2fv(GL.uniforms[location], !!transpose, view);
    }
  Module["_emscripten_glUniformMatrix2fv"] = _emscripten_glUniformMatrix2fv;

  function _emscripten_glUniformMatrix3fv(location, count, transpose, value) {
  
  
      if (9*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[9*count-1];
        for (var i = 0; i < 9*count; i += 9) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAPF32[(((value)+(4*i+12))>>2)];
          view[i+4] = HEAPF32[(((value)+(4*i+16))>>2)];
          view[i+5] = HEAPF32[(((value)+(4*i+20))>>2)];
          view[i+6] = HEAPF32[(((value)+(4*i+24))>>2)];
          view[i+7] = HEAPF32[(((value)+(4*i+28))>>2)];
          view[i+8] = HEAPF32[(((value)+(4*i+32))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*36)>>2);
      }
      GLctx.uniformMatrix3fv(GL.uniforms[location], !!transpose, view);
    }
  Module["_emscripten_glUniformMatrix3fv"] = _emscripten_glUniformMatrix3fv;

  function _emscripten_glUniformMatrix4fv(location, count, transpose, value) {
  
  
      if (16*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[16*count-1];
        // hoist the heap out of the loop for size and for pthreads+growth.
        var heap = HEAPF32;
        value >>= 2;
        for (var i = 0; i < 16 * count; i += 16) {
          var dst = value + i;
          view[i] = heap[dst];
          view[i + 1] = heap[dst + 1];
          view[i + 2] = heap[dst + 2];
          view[i + 3] = heap[dst + 3];
          view[i + 4] = heap[dst + 4];
          view[i + 5] = heap[dst + 5];
          view[i + 6] = heap[dst + 6];
          view[i + 7] = heap[dst + 7];
          view[i + 8] = heap[dst + 8];
          view[i + 9] = heap[dst + 9];
          view[i + 10] = heap[dst + 10];
          view[i + 11] = heap[dst + 11];
          view[i + 12] = heap[dst + 12];
          view[i + 13] = heap[dst + 13];
          view[i + 14] = heap[dst + 14];
          view[i + 15] = heap[dst + 15];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*64)>>2);
      }
      GLctx.uniformMatrix4fv(GL.uniforms[location], !!transpose, view);
    }
  Module["_emscripten_glUniformMatrix4fv"] = _emscripten_glUniformMatrix4fv;

  function _emscripten_glUseProgram(program) {
      GLctx.useProgram(GL.programs[program]);
    }
  Module["_emscripten_glUseProgram"] = _emscripten_glUseProgram;

  function _emscripten_glValidateProgram(program) {
      GLctx.validateProgram(GL.programs[program]);
    }
  Module["_emscripten_glValidateProgram"] = _emscripten_glValidateProgram;

  function _emscripten_glVertexAttrib1f(x0, x1) { GLctx['vertexAttrib1f'](x0, x1) }
  Module["_emscripten_glVertexAttrib1f"] = _emscripten_glVertexAttrib1f;

  function _emscripten_glVertexAttrib1fv(index, v) {
  
      GLctx.vertexAttrib1f(index, HEAPF32[v>>2]);
    }
  Module["_emscripten_glVertexAttrib1fv"] = _emscripten_glVertexAttrib1fv;

  function _emscripten_glVertexAttrib2f(x0, x1, x2) { GLctx['vertexAttrib2f'](x0, x1, x2) }
  Module["_emscripten_glVertexAttrib2f"] = _emscripten_glVertexAttrib2f;

  function _emscripten_glVertexAttrib2fv(index, v) {
  
      GLctx.vertexAttrib2f(index, HEAPF32[v>>2], HEAPF32[v+4>>2]);
    }
  Module["_emscripten_glVertexAttrib2fv"] = _emscripten_glVertexAttrib2fv;

  function _emscripten_glVertexAttrib3f(x0, x1, x2, x3) { GLctx['vertexAttrib3f'](x0, x1, x2, x3) }
  Module["_emscripten_glVertexAttrib3f"] = _emscripten_glVertexAttrib3f;

  function _emscripten_glVertexAttrib3fv(index, v) {
  
      GLctx.vertexAttrib3f(index, HEAPF32[v>>2], HEAPF32[v+4>>2], HEAPF32[v+8>>2]);
    }
  Module["_emscripten_glVertexAttrib3fv"] = _emscripten_glVertexAttrib3fv;

  function _emscripten_glVertexAttrib4f(x0, x1, x2, x3, x4) { GLctx['vertexAttrib4f'](x0, x1, x2, x3, x4) }
  Module["_emscripten_glVertexAttrib4f"] = _emscripten_glVertexAttrib4f;

  function _emscripten_glVertexAttrib4fv(index, v) {
  
      GLctx.vertexAttrib4f(index, HEAPF32[v>>2], HEAPF32[v+4>>2], HEAPF32[v+8>>2], HEAPF32[v+12>>2]);
    }
  Module["_emscripten_glVertexAttrib4fv"] = _emscripten_glVertexAttrib4fv;

  function _emscripten_glVertexAttribDivisorANGLE(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_emscripten_glVertexAttribDivisorANGLE"] = _emscripten_glVertexAttribDivisorANGLE;

  function _emscripten_glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
      GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
    }
  Module["_emscripten_glVertexAttribPointer"] = _emscripten_glVertexAttribPointer;

  function _emscripten_glViewport(x0, x1, x2, x3) { GLctx['viewport'](x0, x1, x2, x3) }
  Module["_emscripten_glViewport"] = _emscripten_glViewport;

  function _emscripten_has_asyncify() {
      return 0;
    }
  Module["_emscripten_has_asyncify"] = _emscripten_has_asyncify;

  function _emscripten_is_main_browser_thread() {
      return !ENVIRONMENT_IS_WORKER;
    }
  Module["_emscripten_is_main_browser_thread"] = _emscripten_is_main_browser_thread;

  
  
  
  var setjmpId=0;
  Module["setjmpId"] = setjmpId;function _saveSetjmp(env, label, table, size) {
      // Not particularly fast: slow table lookup of setjmpId to label. But setjmp
      // prevents relooping anyhow, so slowness is to be expected. And typical case
      // is 1 setjmp per invocation, or less.
      env = env|0;
      label = label|0;
      table = table|0;
      size = size|0;
      var i = 0;
      setjmpId = (setjmpId+1)|0;
      HEAP32[((env)>>2)]=setjmpId;
      while ((i|0) < (size|0)) {
        if (((HEAP32[(((table)+((i<<3)))>>2)])|0) == 0) {
          HEAP32[(((table)+((i<<3)))>>2)]=setjmpId;
          HEAP32[(((table)+((i<<3)+4))>>2)]=label;
          // prepare next slot
          HEAP32[(((table)+((i<<3)+8))>>2)]=0;
          setTempRet0((size) | 0);
          return table | 0;
        }
        i = i+1|0;
      }
      // grow the table
      size = (size*2)|0;
      table = _realloc(table|0, 8*(size+1|0)|0) | 0;
      table = _saveSetjmp(env|0, label|0, table|0, size|0) | 0;
      setTempRet0((size) | 0);
      return table | 0;
    }
  Module["_saveSetjmp"] = _saveSetjmp;
  
  function _testSetjmp(id, table, size) {
      id = id|0;
      table = table|0;
      size = size|0;
      var i = 0, curr = 0;
      while ((i|0) < (size|0)) {
        curr = ((HEAP32[(((table)+((i<<3)))>>2)])|0);
        if ((curr|0) == 0) break;
        if ((curr|0) == (id|0)) {
          return ((HEAP32[(((table)+((i<<3)+4))>>2)])|0);
        }
        i = i+1|0;
      }
      return 0;
    }
  Module["_testSetjmp"] = _testSetjmp;function _longjmp(env, value) {
      _setThrew(env, value || 1);
      throw 'longjmp';
    }
  Module["_longjmp"] = _longjmp;function _emscripten_longjmp(env, value) {
      _longjmp(env, value);
    }
  Module["_emscripten_longjmp"] = _emscripten_longjmp;

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }
  Module["_emscripten_memcpy_big"] = _emscripten_memcpy_big;

  
  function __emscripten_do_request_fullscreen(target, strategy) {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = __findEventTarget(target);
      if (!target) return -4;
  
      if (!target.requestFullscreen
        && !target.webkitRequestFullscreen
        ) {
        return -3;
      }
  
      var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
  
      // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
      if (!canPerformRequests) {
        if (strategy.deferUntilInEventHandler) {
          JSEvents.deferCall(_JSEvents_requestFullscreen, 1 /* priority over pointer lock */, [target, strategy]);
          return 1;
        } else {
          return -2;
        }
      }
  
      return _JSEvents_requestFullscreen(target, strategy);
    }
  Module["__emscripten_do_request_fullscreen"] = __emscripten_do_request_fullscreen;function _emscripten_request_fullscreen_strategy(target, deferUntilInEventHandler, fullscreenStrategy) {
      var strategy = {
        scaleMode: HEAP32[((fullscreenStrategy)>>2)],
        canvasResolutionScaleMode: HEAP32[(((fullscreenStrategy)+(4))>>2)],
        filteringMode: HEAP32[(((fullscreenStrategy)+(8))>>2)],
        deferUntilInEventHandler: deferUntilInEventHandler,
        canvasResizedCallback: HEAP32[(((fullscreenStrategy)+(12))>>2)],
        canvasResizedCallbackUserData: HEAP32[(((fullscreenStrategy)+(16))>>2)]
      };
  
      return __emscripten_do_request_fullscreen(target, strategy);
    }
  Module["_emscripten_request_fullscreen_strategy"] = _emscripten_request_fullscreen_strategy;

  function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
      target = __findEventTarget(target);
      if (!target) return -4;
      if (!target.requestPointerLock
        && !target.msRequestPointerLock
        ) {
        return -1;
      }
  
      var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
  
      // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
      if (!canPerformRequests) {
        if (deferUntilInEventHandler) {
          JSEvents.deferCall(__requestPointerLock, 2 /* priority below fullscreen */, [target]);
          return 1;
        } else {
          return -2;
        }
      }
  
      return __requestPointerLock(target);
    }
  Module["_emscripten_request_pointerlock"] = _emscripten_request_pointerlock;

  
  function _emscripten_get_heap_size() {
      return HEAPU8.length;
    }
  Module["_emscripten_get_heap_size"] = _emscripten_get_heap_size;
  
  function abortOnCannotGrowMemory(requestedSize) {
      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
    }
  Module["abortOnCannotGrowMemory"] = abortOnCannotGrowMemory;function _emscripten_resize_heap(requestedSize) {
      requestedSize = requestedSize >>> 0;
      abortOnCannotGrowMemory(requestedSize);
    }
  Module["_emscripten_resize_heap"] = _emscripten_resize_heap;

  function _emscripten_run_script(ptr) {
      eval(UTF8ToString(ptr));
    }
  Module["_emscripten_run_script"] = _emscripten_run_script;

  function _emscripten_sample_gamepad_data() {
      return (JSEvents.lastGamepadState = (navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : null)))
        ? 0 : -1;
    }
  Module["_emscripten_sample_gamepad_data"] = _emscripten_sample_gamepad_data;

  
  function __registerBeforeUnloadEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString) {
      var beforeUnloadEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        // Note: This is always called on the main browser thread, since it needs synchronously return a value!
        var confirmationMessage = dynCall_iiii(callbackfunc, eventTypeId, 0, userData);
        
        if (confirmationMessage) {
          confirmationMessage = UTF8ToString(confirmationMessage);
        }
        if (confirmationMessage) {
          e.preventDefault();
          e.returnValue = confirmationMessage;
          return confirmationMessage;
        }
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: beforeUnloadEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerBeforeUnloadEventCallback"] = __registerBeforeUnloadEventCallback;function _emscripten_set_beforeunload_callback_on_thread(userData, callbackfunc, targetThread) {
      if (typeof onbeforeunload === 'undefined') return -1;
      // beforeunload callback can only be registered on the main browser thread, because the page will go away immediately after returning from the handler,
      // and there is no time to start proxying it anywhere.
      if (targetThread !== 1) return -5;
      __registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
      return 0;
    }
  Module["_emscripten_set_beforeunload_callback_on_thread"] = _emscripten_set_beforeunload_callback_on_thread;

  
  function __registerFocusEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.focusEvent) JSEvents.focusEvent = _malloc( 256 );
  
      var focusEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var nodeName = JSEvents.getNodeNameForTarget(e.target);
        var id = e.target.id ? e.target.id : '';
  
        var focusEvent = JSEvents.focusEvent;
        stringToUTF8(nodeName, focusEvent + 0, 128);
        stringToUTF8(id, focusEvent + 128, 128);
  
        if (dynCall_iiii(callbackfunc, eventTypeId, focusEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: focusEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerFocusEventCallback"] = __registerFocusEventCallback;function _emscripten_set_blur_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
      return 0;
    }
  Module["_emscripten_set_blur_callback_on_thread"] = _emscripten_set_blur_callback_on_thread;


  function _emscripten_set_element_css_size(target, width, height) {
      target = __findEventTarget(target);
      if (!target) return -4;
  
      target.style.width = width + "px";
      target.style.height = height + "px";
  
      return 0;
    }
  Module["_emscripten_set_element_css_size"] = _emscripten_set_element_css_size;

  function _emscripten_set_focus_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
      return 0;
    }
  Module["_emscripten_set_focus_callback_on_thread"] = _emscripten_set_focus_callback_on_thread;

  
  
  function __fillFullscreenChangeEventData(eventStruct) {
      var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
      var isFullscreen = !!fullscreenElement;
      /** @suppress{checkTypes} */
      HEAP32[((eventStruct)>>2)]=isFullscreen;
      HEAP32[(((eventStruct)+(4))>>2)]=JSEvents.fullscreenEnabled();
      // If transitioning to fullscreen, report info about the element that is now fullscreen.
      // If transitioning to windowed mode, report info about the element that just was fullscreen.
      var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
      var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
      var id = (reportedElement && reportedElement.id) ? reportedElement.id : '';
      stringToUTF8(nodeName, eventStruct + 8, 128);
      stringToUTF8(id, eventStruct + 136, 128);
      HEAP32[(((eventStruct)+(264))>>2)]=reportedElement ? reportedElement.clientWidth : 0;
      HEAP32[(((eventStruct)+(268))>>2)]=reportedElement ? reportedElement.clientHeight : 0;
      HEAP32[(((eventStruct)+(272))>>2)]=screen.width;
      HEAP32[(((eventStruct)+(276))>>2)]=screen.height;
      if (isFullscreen) {
        JSEvents.previousFullscreenElement = fullscreenElement;
      }
    }
  Module["__fillFullscreenChangeEventData"] = __fillFullscreenChangeEventData;function __registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.fullscreenChangeEvent) JSEvents.fullscreenChangeEvent = _malloc( 280 );
  
      var fullscreenChangeEventhandlerFunc = function(ev) {
        var e = ev || event;
  
        var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
  
        __fillFullscreenChangeEventData(fullscreenChangeEvent);
  
        if (dynCall_iiii(callbackfunc, eventTypeId, fullscreenChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: fullscreenChangeEventhandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerFullscreenChangeEventCallback"] = __registerFullscreenChangeEventCallback;function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = __findEventTarget(target);
      if (!target) return -4;
      __registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
  
  
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      __registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
  
      return 0;
    }
  Module["_emscripten_set_fullscreenchange_callback_on_thread"] = _emscripten_set_fullscreenchange_callback_on_thread;

  
  function __registerGamepadEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.gamepadEvent) JSEvents.gamepadEvent = _malloc( 1432 );
  
      var gamepadEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var gamepadEvent = JSEvents.gamepadEvent;
        __fillGamepadEventData(gamepadEvent, e["gamepad"]);
  
        if (dynCall_iiii(callbackfunc, eventTypeId, gamepadEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: gamepadEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerGamepadEventCallback"] = __registerGamepadEventCallback;function _emscripten_set_gamepadconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      if (!navigator.getGamepads && !navigator.webkitGetGamepads) return -1;
      __registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
      return 0;
    }
  Module["_emscripten_set_gamepadconnected_callback_on_thread"] = _emscripten_set_gamepadconnected_callback_on_thread;

  function _emscripten_set_gamepaddisconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      if (!navigator.getGamepads && !navigator.webkitGetGamepads) return -1;
      __registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
      return 0;
    }
  Module["_emscripten_set_gamepaddisconnected_callback_on_thread"] = _emscripten_set_gamepaddisconnected_callback_on_thread;

  
  function __registerKeyEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.keyEvent) JSEvents.keyEvent = _malloc( 164 );
  
      var keyEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var keyEventData = JSEvents.keyEvent;
        stringToUTF8(e.key ? e.key : "", keyEventData + 0, 32);
        stringToUTF8(e.code ? e.code : "", keyEventData + 32, 32);
        HEAP32[(((keyEventData)+(64))>>2)]=e.location;
        HEAP32[(((keyEventData)+(68))>>2)]=e.ctrlKey;
        HEAP32[(((keyEventData)+(72))>>2)]=e.shiftKey;
        HEAP32[(((keyEventData)+(76))>>2)]=e.altKey;
        HEAP32[(((keyEventData)+(80))>>2)]=e.metaKey;
        HEAP32[(((keyEventData)+(84))>>2)]=e.repeat;
        stringToUTF8(e.locale ? e.locale : "", keyEventData + 88, 32);
        stringToUTF8(e.char ? e.char : "", keyEventData + 120, 32);
        HEAP32[(((keyEventData)+(152))>>2)]=e.charCode;
        HEAP32[(((keyEventData)+(156))>>2)]=e.keyCode;
        HEAP32[(((keyEventData)+(160))>>2)]=e.which;
  
        if (dynCall_iiii(callbackfunc, eventTypeId, keyEventData, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: keyEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerKeyEventCallback"] = __registerKeyEventCallback;function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
      return 0;
    }
  Module["_emscripten_set_keydown_callback_on_thread"] = _emscripten_set_keydown_callback_on_thread;

  function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
      return 0;
    }
  Module["_emscripten_set_keypress_callback_on_thread"] = _emscripten_set_keypress_callback_on_thread;

  function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
      return 0;
    }
  Module["_emscripten_set_keyup_callback_on_thread"] = _emscripten_set_keyup_callback_on_thread;


  
  
  function __fillMouseEventData(eventStruct, e, target) {
      HEAP32[((eventStruct)>>2)]=e.screenX;
      HEAP32[(((eventStruct)+(4))>>2)]=e.screenY;
      HEAP32[(((eventStruct)+(8))>>2)]=e.clientX;
      HEAP32[(((eventStruct)+(12))>>2)]=e.clientY;
      HEAP32[(((eventStruct)+(16))>>2)]=e.ctrlKey;
      HEAP32[(((eventStruct)+(20))>>2)]=e.shiftKey;
      HEAP32[(((eventStruct)+(24))>>2)]=e.altKey;
      HEAP32[(((eventStruct)+(28))>>2)]=e.metaKey;
      HEAP16[(((eventStruct)+(32))>>1)]=e.button;
      HEAP16[(((eventStruct)+(34))>>1)]=e.buttons;
      var movementX = e["movementX"]
        || (e.screenX-JSEvents.previousScreenX)
        ;
      var movementY = e["movementY"]
        || (e.screenY-JSEvents.previousScreenY)
        ;
  
      HEAP32[(((eventStruct)+(36))>>2)]=movementX;
      HEAP32[(((eventStruct)+(40))>>2)]=movementY;
  
      var rect = __getBoundingClientRect(target);
      HEAP32[(((eventStruct)+(44))>>2)]=e.clientX - rect.left;
      HEAP32[(((eventStruct)+(48))>>2)]=e.clientY - rect.top;
  
      // wheel and mousewheel events contain wrong screenX/screenY on chrome/opera
        // https://github.com/emscripten-core/emscripten/pull/4997
      // https://bugs.chromium.org/p/chromium/issues/detail?id=699956
      if (e.type !== 'wheel' && e.type !== 'mousewheel') {
        JSEvents.previousScreenX = e.screenX;
        JSEvents.previousScreenY = e.screenY;
      }
    }
  Module["__fillMouseEventData"] = __fillMouseEventData;function __registerMouseEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc( 64 );
      target = __findEventTarget(target);
  
      var mouseEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        // TODO: Make this access thread safe, or this could update live while app is reading it.
        __fillMouseEventData(JSEvents.mouseEvent, e, target);
  
        if (dynCall_iiii(callbackfunc, eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: eventTypeString != 'mousemove' && eventTypeString != 'mouseenter' && eventTypeString != 'mouseleave', // Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: mouseEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerMouseEventCallback"] = __registerMouseEventCallback;function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
      return 0;
    }
  Module["_emscripten_set_mousedown_callback_on_thread"] = _emscripten_set_mousedown_callback_on_thread;

  function _emscripten_set_mouseenter_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
      return 0;
    }
  Module["_emscripten_set_mouseenter_callback_on_thread"] = _emscripten_set_mouseenter_callback_on_thread;

  function _emscripten_set_mouseleave_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
      return 0;
    }
  Module["_emscripten_set_mouseleave_callback_on_thread"] = _emscripten_set_mouseleave_callback_on_thread;

  function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
      return 0;
    }
  Module["_emscripten_set_mousemove_callback_on_thread"] = _emscripten_set_mousemove_callback_on_thread;

  function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
      return 0;
    }
  Module["_emscripten_set_mouseup_callback_on_thread"] = _emscripten_set_mouseup_callback_on_thread;

  
  
  function __fillPointerlockChangeEventData(eventStruct) {
      var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
      var isPointerlocked = !!pointerLockElement;
      /** @suppress {checkTypes} */
      HEAP32[((eventStruct)>>2)]=isPointerlocked;
      var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
      var id = (pointerLockElement && pointerLockElement.id) ? pointerLockElement.id : '';
      stringToUTF8(nodeName, eventStruct + 4, 128);
      stringToUTF8(id, eventStruct + 132, 128);
    }
  Module["__fillPointerlockChangeEventData"] = __fillPointerlockChangeEventData;function __registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.pointerlockChangeEvent) JSEvents.pointerlockChangeEvent = _malloc( 260 );
  
      var pointerlockChangeEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
        __fillPointerlockChangeEventData(pointerlockChangeEvent);
  
        if (dynCall_iiii(callbackfunc, eventTypeId, pointerlockChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: pointerlockChangeEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerPointerlockChangeEventCallback"] = __registerPointerlockChangeEventCallback;/** @suppress {missingProperties} */
  function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
      if (!document || !document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
        return -1;
      }
  
      target = __findEventTarget(target);
      if (!target) return -4;
      __registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
      __registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
      __registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
      __registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
      return 0;
    }
  Module["_emscripten_set_pointerlockchange_callback_on_thread"] = _emscripten_set_pointerlockchange_callback_on_thread;

  
  function __registerUiEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.uiEvent) JSEvents.uiEvent = _malloc( 36 );
  
      target = __findEventTarget(target);
  
      var uiEventHandlerFunc = function(ev) {
        var e = ev || event;
        if (e.target != target) {
          // Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
          // was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
          // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
          // causing a new scroll, etc..
          return;
        }
        var uiEvent = JSEvents.uiEvent;
        var b = document.body; // Take document.body to a variable, Closure compiler does not outline access to it on its own.
        HEAP32[((uiEvent)>>2)]=e.detail;
        HEAP32[(((uiEvent)+(4))>>2)]=b.clientWidth;
        HEAP32[(((uiEvent)+(8))>>2)]=b.clientHeight;
        HEAP32[(((uiEvent)+(12))>>2)]=innerWidth;
        HEAP32[(((uiEvent)+(16))>>2)]=innerHeight;
        HEAP32[(((uiEvent)+(20))>>2)]=outerWidth;
        HEAP32[(((uiEvent)+(24))>>2)]=outerHeight;
        HEAP32[(((uiEvent)+(28))>>2)]=pageXOffset;
        HEAP32[(((uiEvent)+(32))>>2)]=pageYOffset;
        if (dynCall_iiii(callbackfunc, eventTypeId, uiEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: uiEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerUiEventCallback"] = __registerUiEventCallback;function _emscripten_set_resize_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
      return 0;
    }
  Module["_emscripten_set_resize_callback_on_thread"] = _emscripten_set_resize_callback_on_thread;

  
  function __registerTouchEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.touchEvent) JSEvents.touchEvent = _malloc( 1684 );
  
      target = __findEventTarget(target);
  
      var touchEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var touches = {};
        for(var i = 0; i < e.touches.length; ++i) {
          var touch = e.touches[i];
          touch.changed = false;
          touches[touch.identifier] = touch;
        }
        for(var i = 0; i < e.changedTouches.length; ++i) {
          var touch = e.changedTouches[i];
          touches[touch.identifier] = touch;
          touch.changed = true;
        }
        for(var i = 0; i < e.targetTouches.length; ++i) {
          var touch = e.targetTouches[i];
          touches[touch.identifier].onTarget = true;
        }
  
        var touchEvent = JSEvents.touchEvent;
        var ptr = touchEvent;
        HEAP32[(((ptr)+(4))>>2)]=e.ctrlKey;
        HEAP32[(((ptr)+(8))>>2)]=e.shiftKey;
        HEAP32[(((ptr)+(12))>>2)]=e.altKey;
        HEAP32[(((ptr)+(16))>>2)]=e.metaKey;
        ptr += 20; // Advance to the start of the touch array.
        var targetRect = __getBoundingClientRect(target);
        var numTouches = 0;
        for(var i in touches) {
          var t = touches[i];
          HEAP32[((ptr)>>2)]=t.identifier;
          HEAP32[(((ptr)+(4))>>2)]=t.screenX;
          HEAP32[(((ptr)+(8))>>2)]=t.screenY;
          HEAP32[(((ptr)+(12))>>2)]=t.clientX;
          HEAP32[(((ptr)+(16))>>2)]=t.clientY;
          HEAP32[(((ptr)+(20))>>2)]=t.pageX;
          HEAP32[(((ptr)+(24))>>2)]=t.pageY;
          HEAP32[(((ptr)+(28))>>2)]=t.changed;
          HEAP32[(((ptr)+(32))>>2)]=t.onTarget;
          HEAP32[(((ptr)+(36))>>2)]=t.clientX - targetRect.left;
          HEAP32[(((ptr)+(40))>>2)]=t.clientY - targetRect.top;
  
          ptr += 52;
  
          if (++numTouches >= 32) {
            break;
          }
        }
        HEAP32[((touchEvent)>>2)]=numTouches;
  
        if (dynCall_iiii(callbackfunc, eventTypeId, touchEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: eventTypeString == 'touchstart' || eventTypeString == 'touchend',
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: touchEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerTouchEventCallback"] = __registerTouchEventCallback;function _emscripten_set_touchcancel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
      return 0;
    }
  Module["_emscripten_set_touchcancel_callback_on_thread"] = _emscripten_set_touchcancel_callback_on_thread;

  function _emscripten_set_touchend_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
      return 0;
    }
  Module["_emscripten_set_touchend_callback_on_thread"] = _emscripten_set_touchend_callback_on_thread;

  function _emscripten_set_touchmove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
      return 0;
    }
  Module["_emscripten_set_touchmove_callback_on_thread"] = _emscripten_set_touchmove_callback_on_thread;

  function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
      return 0;
    }
  Module["_emscripten_set_touchstart_callback_on_thread"] = _emscripten_set_touchstart_callback_on_thread;

  
  
  function __fillVisibilityChangeEventData(eventStruct) {
      var visibilityStates = [ "hidden", "visible", "prerender", "unloaded" ];
      var visibilityState = visibilityStates.indexOf(document.visibilityState);
  
      // Assigning a boolean to HEAP32 with expected type coercion.
      /** @suppress {checkTypes} */
      HEAP32[((eventStruct)>>2)]=document.hidden;
      HEAP32[(((eventStruct)+(4))>>2)]=visibilityState;
    }
  Module["__fillVisibilityChangeEventData"] = __fillVisibilityChangeEventData;function __registerVisibilityChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.visibilityChangeEvent) JSEvents.visibilityChangeEvent = _malloc( 8 );
  
      var visibilityChangeEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var visibilityChangeEvent = JSEvents.visibilityChangeEvent;
  
        __fillVisibilityChangeEventData(visibilityChangeEvent);
  
        if (dynCall_iiii(callbackfunc, eventTypeId, visibilityChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: visibilityChangeEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerVisibilityChangeEventCallback"] = __registerVisibilityChangeEventCallback;function _emscripten_set_visibilitychange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      __registerVisibilityChangeEventCallback(specialHTMLTargets[1], userData, useCapture, callbackfunc, 21, "visibilitychange", targetThread);
      return 0;
    }
  Module["_emscripten_set_visibilitychange_callback_on_thread"] = _emscripten_set_visibilitychange_callback_on_thread;

  
  function __registerWheelEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.wheelEvent) JSEvents.wheelEvent = _malloc( 96 );
  
      // The DOM Level 3 events spec event 'wheel'
      var wheelHandlerFunc = function(ev) {
        var e = ev || event;
        var wheelEvent = JSEvents.wheelEvent;
        __fillMouseEventData(wheelEvent, e, target);
        HEAPF64[(((wheelEvent)+(64))>>3)]=e["deltaX"];
        HEAPF64[(((wheelEvent)+(72))>>3)]=e["deltaY"];
        HEAPF64[(((wheelEvent)+(80))>>3)]=e["deltaZ"];
        HEAP32[(((wheelEvent)+(88))>>2)]=e["deltaMode"];
        if (dynCall_iiii(callbackfunc, eventTypeId, wheelEvent, userData)) e.preventDefault();
      };
      // The 'mousewheel' event as implemented in Safari 6.0.5
      var mouseWheelHandlerFunc = function(ev) {
        var e = ev || event;
        __fillMouseEventData(JSEvents.wheelEvent, e, target);
        HEAPF64[(((JSEvents.wheelEvent)+(64))>>3)]=e["wheelDeltaX"] || 0;
        /* 1. Invert to unify direction with the DOM Level 3 wheel event. 2. MSIE does not provide wheelDeltaY, so wheelDelta is used as a fallback. */
        var wheelDeltaY = -(e["wheelDeltaY"] || e["wheelDelta"])
        HEAPF64[(((JSEvents.wheelEvent)+(72))>>3)]=wheelDeltaY;
        HEAPF64[(((JSEvents.wheelEvent)+(80))>>3)]=0 /* Not available */;
        HEAP32[(((JSEvents.wheelEvent)+(88))>>2)]=0 /* DOM_DELTA_PIXEL */;
        var shouldCancel = dynCall_iiii(callbackfunc, eventTypeId, JSEvents.wheelEvent, userData);
        if (shouldCancel) {
          e.preventDefault();
        }
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: (eventTypeString == 'wheel') ? wheelHandlerFunc : mouseWheelHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerWheelEventCallback"] = __registerWheelEventCallback;function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      target = __findEventTarget(target);
      if (typeof target.onwheel !== 'undefined') {
        __registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
        return 0;
      } else if (typeof target.onmousewheel !== 'undefined') {
        __registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "mousewheel", targetThread);
        return 0;
      } else {
        return -1;
      }
    }
  Module["_emscripten_set_wheel_callback_on_thread"] = _emscripten_set_wheel_callback_on_thread;

  function _emscripten_sleep() {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_sleep';
    }
  Module["_emscripten_sleep"] = _emscripten_sleep;

  
  var Fetch={xhrs:[],setu64:function(addr, val) {
      HEAPU32[addr >> 2] = val;
      HEAPU32[addr + 4 >> 2] = (val / 4294967296)|0;
    },openDatabase:function(dbname, dbversion, onsuccess, onerror) {
      try {
        var openRequest = indexedDB.open(dbname, dbversion);
      } catch (e) { return onerror(e); }
  
      openRequest.onupgradeneeded = function(event) {
        var db = event.target.result;
        if (db.objectStoreNames.contains('FILES')) {
          db.deleteObjectStore('FILES');
        }
        db.createObjectStore('FILES');
      };
      openRequest.onsuccess = function(event) { onsuccess(event.target.result); };
      openRequest.onerror = function(error) { onerror(error); };
    },staticInit:function() {
      var isMainThread = true;
  
      var onsuccess = function(db) {
        Fetch.dbInstance = db;
  
        if (isMainThread) {
          removeRunDependency('library_fetch_init');
        }
      };
      var onerror = function() {
        Fetch.dbInstance = false;
  
        if (isMainThread) {
          removeRunDependency('library_fetch_init');
        }
      };
      Fetch.openDatabase('emscripten_filesystem', 1, onsuccess, onerror);
  
      if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) addRunDependency('library_fetch_init');
    }};
  Module["Fetch"] = Fetch;
  
  function __emscripten_fetch_xhr(fetch, onsuccess, onerror, onprogress, onreadystatechange) {
    var url = HEAPU32[fetch + 8 >> 2];
    if (!url) {
      onerror(fetch, 0, 'no url specified!');
      return;
    }
    var url_ = UTF8ToString(url);
  
    var fetch_attr = fetch + 112;
    var requestMethod = UTF8ToString(fetch_attr);
    if (!requestMethod) requestMethod = 'GET';
    var userData = HEAPU32[fetch_attr + 32 >> 2];
    var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2];
    var timeoutMsecs = HEAPU32[fetch_attr + 56 >> 2];
    var withCredentials = !!HEAPU32[fetch_attr + 60 >> 2];
    var destinationPath = HEAPU32[fetch_attr + 64 >> 2];
    var userName = HEAPU32[fetch_attr + 68 >> 2];
    var password = HEAPU32[fetch_attr + 72 >> 2];
    var requestHeaders = HEAPU32[fetch_attr + 76 >> 2];
    var overriddenMimeType = HEAPU32[fetch_attr + 80 >> 2];
    var dataPtr = HEAPU32[fetch_attr + 84 >> 2];
    var dataLength = HEAPU32[fetch_attr + 88 >> 2];
  
    var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
    var fetchAttrStreamData = !!(fetchAttributes & 2);
    var fetchAttrPersistFile = !!(fetchAttributes & 4);
    var fetchAttrAppend = !!(fetchAttributes & 8);
    var fetchAttrReplace = !!(fetchAttributes & 16);
    var fetchAttrSynchronous = !!(fetchAttributes & 64);
    var fetchAttrWaitable = !!(fetchAttributes & 128);
  
    var userNameStr = userName ? UTF8ToString(userName) : undefined;
    var passwordStr = password ? UTF8ToString(password) : undefined;
    var overriddenMimeTypeStr = overriddenMimeType ? UTF8ToString(overriddenMimeType) : undefined;
  
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = withCredentials;
    xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
    if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; // XHR timeout field is only accessible in async XHRs, and must be set after .open() but before .send().
    xhr.url_ = url_; // Save the url for debugging purposes (and for comparing to the responseURL that server side advertised)
    assert(!fetchAttrStreamData, 'streaming uses moz-chunked-arraybuffer which is no longer supported; TODO: rewrite using fetch()');
    xhr.responseType = 'arraybuffer';
  
    if (overriddenMimeType) {
      xhr.overrideMimeType(overriddenMimeTypeStr);
    }
    if (requestHeaders) {
      for(;;) {
        var key = HEAPU32[requestHeaders >> 2];
        if (!key) break;
        var value = HEAPU32[requestHeaders + 4 >> 2];
        if (!value) break;
        requestHeaders += 8;
        var keyStr = UTF8ToString(key);
        var valueStr = UTF8ToString(value);
        xhr.setRequestHeader(keyStr, valueStr);
      }
    }
    Fetch.xhrs.push(xhr);
    var id = Fetch.xhrs.length;
    HEAPU32[fetch + 0 >> 2] = id;
    var data = (dataPtr && dataLength) ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
    // TODO: Support specifying custom headers to the request.
  
    xhr.onload = function(e) {
      var len = xhr.response ? xhr.response.byteLength : 0;
      var ptr = 0;
      var ptrLen = 0;
      if (fetchAttrLoadToMemory && !fetchAttrStreamData) {
        ptrLen = len;
        // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
        // freed when emscripten_fetch_close() is called.
        ptr = _malloc(ptrLen);
        HEAPU8.set(new Uint8Array(xhr.response), ptr);
      }
      HEAPU32[fetch + 12 >> 2] = ptr;
      Fetch.setu64(fetch + 16, ptrLen);
      Fetch.setu64(fetch + 24, 0);
      if (len) {
        // If the final XHR.onload handler receives the bytedata to compute total length, report that,
        // otherwise don't write anything out here, which will retain the latest byte size reported in
        // the most recent XHR.onprogress handler.
        Fetch.setu64(fetch + 32, len);
      }
      HEAPU16[fetch + 40 >> 1] = xhr.readyState;
      if (xhr.readyState === 4 && xhr.status === 0) {
        if (len > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we got data bytes.
        else xhr.status = 404; // Conversely, no data bytes is 404.
      }
      HEAPU16[fetch + 42 >> 1] = xhr.status;
      if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
      if (xhr.status >= 200 && xhr.status < 300) {
        if (onsuccess) onsuccess(fetch, xhr, e);
      } else {
        if (onerror) onerror(fetch, xhr, e);
      }
    };
    xhr.onerror = function(e) {
      var status = xhr.status; // XXX TODO: Overwriting xhr.status doesn't work here, so don't override anywhere else either.
      if (xhr.readyState === 4 && status === 0) status = 404; // If no error recorded, pretend it was 404 Not Found.
      HEAPU32[fetch + 12 >> 2] = 0;
      Fetch.setu64(fetch + 16, 0);
      Fetch.setu64(fetch + 24, 0);
      Fetch.setu64(fetch + 32, 0);
      HEAPU16[fetch + 40 >> 1] = xhr.readyState;
      HEAPU16[fetch + 42 >> 1] = status;
      if (onerror) onerror(fetch, xhr, e);
    };
    xhr.ontimeout = function(e) {
      if (onerror) onerror(fetch, xhr, e);
    };
    xhr.onprogress = function(e) {
      var ptrLen = (fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response) ? xhr.response.byteLength : 0;
      var ptr = 0;
      if (fetchAttrLoadToMemory && fetchAttrStreamData) {
        // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
        // freed when emscripten_fetch_close() is called.
        ptr = _malloc(ptrLen);
        HEAPU8.set(new Uint8Array(xhr.response), ptr);
      }
      HEAPU32[fetch + 12 >> 2] = ptr;
      Fetch.setu64(fetch + 16, ptrLen);
      Fetch.setu64(fetch + 24, e.loaded - ptrLen);
      Fetch.setu64(fetch + 32, e.total);
      HEAPU16[fetch + 40 >> 1] = xhr.readyState;
      if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we get data bytes
      HEAPU16[fetch + 42 >> 1] = xhr.status;
      if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
      if (onprogress) onprogress(fetch, xhr, e);
    };
    xhr.onreadystatechange = function(e) {
      HEAPU16[fetch + 40 >> 1] = xhr.readyState;
      if (xhr.readyState >= 2) {
        HEAPU16[fetch + 42 >> 1] = xhr.status;
      }
      if (onreadystatechange) onreadystatechange(fetch, xhr, e);
    };
    try {
      xhr.send(data);
    } catch(e) {
      if (onerror) onerror(fetch, xhr, e);
    }
  }
  Module["__emscripten_fetch_xhr"] = __emscripten_fetch_xhr;
  
  function __emscripten_fetch_cache_data(db, fetch, data, onsuccess, onerror) {
    if (!db) {
      onerror(fetch, 0, 'IndexedDB not available!');
      return;
    }
  
    var fetch_attr = fetch + 112;
    var destinationPath = HEAPU32[fetch_attr + 64 >> 2];
    if (!destinationPath) destinationPath = HEAPU32[fetch + 8 >> 2];
    var destinationPathStr = UTF8ToString(destinationPath);
  
    try {
      var transaction = db.transaction(['FILES'], 'readwrite');
      var packages = transaction.objectStore('FILES');
      var putRequest = packages.put(data, destinationPathStr);
      putRequest.onsuccess = function(event) {
        HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + 42 >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
        stringToUTF8("OK", fetch + 44, 64);
        onsuccess(fetch, 0, destinationPathStr);
      };
      putRequest.onerror = function(error) {
        // Most likely we got an error if IndexedDB is unwilling to store any more data for this page.
        // TODO: Can we identify and break down different IndexedDB-provided errors and convert those
        // to more HTTP status codes for more information?
        HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + 42 >> 1] = 413; // Mimic XHR HTTP status code 413 "Payload Too Large"
        stringToUTF8("Payload Too Large", fetch + 44, 64);
        onerror(fetch, 0, error);
      };
    } catch(e) {
      onerror(fetch, 0, e);
    }
  }
  Module["__emscripten_fetch_cache_data"] = __emscripten_fetch_cache_data;
  
  function __emscripten_fetch_load_cached_data(db, fetch, onsuccess, onerror) {
    if (!db) {
      onerror(fetch, 0, 'IndexedDB not available!');
      return;
    }
  
    var fetch_attr = fetch + 112;
    var path = HEAPU32[fetch_attr + 64 >> 2];
    if (!path) path = HEAPU32[fetch + 8 >> 2];
    var pathStr = UTF8ToString(path);
  
    try {
      var transaction = db.transaction(['FILES'], 'readonly');
      var packages = transaction.objectStore('FILES');
      var getRequest = packages.get(pathStr);
      getRequest.onsuccess = function(event) {
        if (event.target.result) {
          var value = event.target.result;
          var len = value.byteLength || value.length;
          // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
          // freed when emscripten_fetch_close() is called.
          var ptr = _malloc(len);
          HEAPU8.set(new Uint8Array(value), ptr);
          HEAPU32[fetch + 12 >> 2] = ptr;
          Fetch.setu64(fetch + 16, len);
          Fetch.setu64(fetch + 24, 0);
          Fetch.setu64(fetch + 32, len);
          HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
          HEAPU16[fetch + 42 >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
          stringToUTF8("OK", fetch + 44, 64);
          onsuccess(fetch, 0, value);
        } else {
          // Succeeded to load, but the load came back with the value of undefined, treat that as an error since we never store undefined in db.
          HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
          HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
          stringToUTF8("Not Found", fetch + 44, 64);
          onerror(fetch, 0, 'no data');
        }
      };
      getRequest.onerror = function(error) {
        HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
        stringToUTF8("Not Found", fetch + 44, 64);
        onerror(fetch, 0, error);
      };
    } catch(e) {
      onerror(fetch, 0, e);
    }
  }
  Module["__emscripten_fetch_load_cached_data"] = __emscripten_fetch_load_cached_data;
  
  function __emscripten_fetch_delete_cached_data(db, fetch, onsuccess, onerror) {
    if (!db) {
      onerror(fetch, 0, 'IndexedDB not available!');
      return;
    }
  
    var fetch_attr = fetch + 112;
    var path = HEAPU32[fetch_attr + 64 >> 2];
    if (!path) path = HEAPU32[fetch + 8 >> 2];
    var pathStr = UTF8ToString(path);
  
    try {
      var transaction = db.transaction(['FILES'], 'readwrite');
      var packages = transaction.objectStore('FILES');
      var request = packages.delete(pathStr);
      request.onsuccess = function(event) {
        var value = event.target.result;
        HEAPU32[fetch + 12 >> 2] = 0;
        Fetch.setu64(fetch + 16, 0);
        Fetch.setu64(fetch + 24, 0);
        Fetch.setu64(fetch + 32, 0);
        HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + 42 >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
        stringToUTF8("OK", fetch + 44, 64);
        onsuccess(fetch, 0, value);
      };
      request.onerror = function(error) {
        HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
        stringToUTF8("Not Found", fetch + 44, 64);
        onerror(fetch, 0, error);
      };
    } catch(e) {
      onerror(fetch, 0, e);
    }
  }
  Module["__emscripten_fetch_delete_cached_data"] = __emscripten_fetch_delete_cached_data;function _emscripten_start_fetch(fetch, successcb, errorcb, progresscb, readystatechangecb) {
    if (typeof noExitRuntime !== 'undefined') noExitRuntime = true; // If we are the main Emscripten runtime, we should not be closing down.
  
    var fetch_attr = fetch + 112;
    var requestMethod = UTF8ToString(fetch_attr);
    var onsuccess = HEAPU32[fetch_attr + 36 >> 2];
    var onerror = HEAPU32[fetch_attr + 40 >> 2];
    var onprogress = HEAPU32[fetch_attr + 44 >> 2];
    var onreadystatechange = HEAPU32[fetch_attr + 48 >> 2];
    var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2];
    var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
    var fetchAttrStreamData = !!(fetchAttributes & 2);
    var fetchAttrPersistFile = !!(fetchAttributes & 4);
    var fetchAttrNoDownload = !!(fetchAttributes & 32);
    var fetchAttrAppend = !!(fetchAttributes & 8);
    var fetchAttrReplace = !!(fetchAttributes & 16);
  
    var reportSuccess = function(fetch, xhr, e) {
      if (onsuccess) dynCall_vi(onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
  
    var reportProgress = function(fetch, xhr, e) {
      if (onprogress) dynCall_vi(onprogress, fetch);
      else if (progresscb) progresscb(fetch);
    };
  
    var reportError = function(fetch, xhr, e) {
      if (onerror) dynCall_vi(onerror, fetch);
      else if (errorcb) errorcb(fetch);
    };
  
    var reportReadyStateChange = function(fetch, xhr, e) {
      if (onreadystatechange) dynCall_vi(onreadystatechange, fetch);
      else if (readystatechangecb) readystatechangecb(fetch);
    };
  
    var performUncachedXhr = function(fetch, xhr, e) {
      __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress, reportReadyStateChange);
    };
  
    var cacheResultAndReportSuccess = function(fetch, xhr, e) {
      var storeSuccess = function(fetch, xhr, e) {
        if (onsuccess) dynCall_vi(onsuccess, fetch);
        else if (successcb) successcb(fetch);
      };
      var storeError = function(fetch, xhr, e) {
        if (onsuccess) dynCall_vi(onsuccess, fetch);
        else if (successcb) successcb(fetch);
      };
      __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
    };
  
    var performCachedXhr = function(fetch, xhr, e) {
      __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress, reportReadyStateChange);
    };
  
    if (requestMethod === 'EM_IDB_STORE') {
      // TODO(?): Here we perform a clone of the data, because storing shared typed arrays to IndexedDB does not seem to be allowed.
      var ptr = HEAPU32[fetch_attr + 84 >> 2];
      __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, HEAPU8.slice(ptr, ptr + HEAPU32[fetch_attr + 88 >> 2]), reportSuccess, reportError);
    } else if (requestMethod === 'EM_IDB_DELETE') {
      __emscripten_fetch_delete_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (!fetchAttrReplace) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, fetchAttrNoDownload ? reportError : (fetchAttrPersistFile ? performCachedXhr : performUncachedXhr));
    } else if (!fetchAttrNoDownload) {
      __emscripten_fetch_xhr(fetch, fetchAttrPersistFile ? cacheResultAndReportSuccess : reportSuccess, reportError, reportProgress, reportReadyStateChange);
    } else {
      return 0; // todo: free
    }
    return fetch;
  }
  Module["_emscripten_start_fetch"] = _emscripten_start_fetch;

  
  
  function __getExecutableName() {
      return thisProgram || './this.program';
    }
  Module["__getExecutableName"] = __getExecutableName;function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          // Browser language detection #8751
          'LANG': ((typeof navigator === 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8',
          '_': __getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  Module["getEnvStrings"] = getEnvStrings;function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAP32[(((__environ)+(i * 4))>>2)]=ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }
  Module["_environ_get"] = _environ_get;

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAP32[((penviron_count)>>2)]=strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAP32[((penviron_buf_size)>>2)]=bufSize;
      return 0;
    }
  Module["_environ_sizes_get"] = _environ_sizes_get;


  function _fd_close(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }
  Module["_fd_close"] = _fd_close;

  function _fd_fdstat_get(fd, pbuf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)]=type;
      // TODO HEAP16[(((pbuf)+(2))>>1)]=?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)]=tempI64[0],HEAP32[(((pbuf)+(12))>>2)]=tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)]=tempI64[0],HEAP32[(((pbuf)+(20))>>2)]=tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }
  Module["_fd_fdstat_get"] = _fd_fdstat_get;

  function _fd_read(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)]=num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }
  Module["_fd_read"] = _fd_read;

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)]=tempI64[0],HEAP32[(((newOffset)+(4))>>2)]=tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }
  Module["_fd_seek"] = _fd_seek;

  function _fd_sync(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (stream.stream_ops && stream.stream_ops.fsync) {
        return -stream.stream_ops.fsync(stream);
      }
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }
  Module["_fd_sync"] = _fd_sync;

  function _fd_write(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)]=num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }
  Module["_fd_write"] = _fd_write;

  function _fork() {
      // pid_t fork(void);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fork.html
      // We don't support multiple processes.
      setErrNo(6);
      return -1;
    }
  Module["_fork"] = _fork;

  function _fp$eglBindAPI$ii(
  ) {
  if (!Module['_fp$eglBindAPI$ii']) abort("external function 'fp$eglBindAPI$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglBindAPI$ii'].apply(null, arguments);
  }

  function _fp$eglChooseConfig$iiiiii(
  ) {
  if (!Module['_fp$eglChooseConfig$iiiiii']) abort("external function 'fp$eglChooseConfig$iiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglChooseConfig$iiiiii'].apply(null, arguments);
  }

  function _fp$eglCreateContext$iiiii(
  ) {
  if (!Module['_fp$eglCreateContext$iiiii']) abort("external function 'fp$eglCreateContext$iiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglCreateContext$iiiii'].apply(null, arguments);
  }

  function _fp$eglCreateWindowSurface$iiiii(
  ) {
  if (!Module['_fp$eglCreateWindowSurface$iiiii']) abort("external function 'fp$eglCreateWindowSurface$iiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglCreateWindowSurface$iiiii'].apply(null, arguments);
  }

  function _fp$eglDestroyContext$iii(
  ) {
  if (!Module['_fp$eglDestroyContext$iii']) abort("external function 'fp$eglDestroyContext$iii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglDestroyContext$iii'].apply(null, arguments);
  }

  function _fp$eglDestroySurface$iii(
  ) {
  if (!Module['_fp$eglDestroySurface$iii']) abort("external function 'fp$eglDestroySurface$iii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglDestroySurface$iii'].apply(null, arguments);
  }

  function _fp$eglGetConfigAttrib$iiiii(
  ) {
  if (!Module['_fp$eglGetConfigAttrib$iiiii']) abort("external function 'fp$eglGetConfigAttrib$iiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglGetConfigAttrib$iiiii'].apply(null, arguments);
  }

  function _fp$eglGetDisplay$ii(
  ) {
  if (!Module['_fp$eglGetDisplay$ii']) abort("external function 'fp$eglGetDisplay$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglGetDisplay$ii'].apply(null, arguments);
  }

  function _fp$eglGetError$i(
  ) {
  if (!Module['_fp$eglGetError$i']) abort("external function 'fp$eglGetError$i' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglGetError$i'].apply(null, arguments);
  }

  function _fp$eglGetProcAddress$ii(
  ) {
  if (!Module['_fp$eglGetProcAddress$ii']) abort("external function 'fp$eglGetProcAddress$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglGetProcAddress$ii'].apply(null, arguments);
  }

  function _fp$eglInitialize$iiii(
  ) {
  if (!Module['_fp$eglInitialize$iiii']) abort("external function 'fp$eglInitialize$iiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglInitialize$iiii'].apply(null, arguments);
  }

  function _fp$eglMakeCurrent$iiiii(
  ) {
  if (!Module['_fp$eglMakeCurrent$iiiii']) abort("external function 'fp$eglMakeCurrent$iiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglMakeCurrent$iiiii'].apply(null, arguments);
  }

  function _fp$eglQueryString$iii(
  ) {
  if (!Module['_fp$eglQueryString$iii']) abort("external function 'fp$eglQueryString$iii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglQueryString$iii'].apply(null, arguments);
  }

  function _fp$eglSwapBuffers$iii(
  ) {
  if (!Module['_fp$eglSwapBuffers$iii']) abort("external function 'fp$eglSwapBuffers$iii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglSwapBuffers$iii'].apply(null, arguments);
  }

  function _fp$eglSwapInterval$iii(
  ) {
  if (!Module['_fp$eglSwapInterval$iii']) abort("external function 'fp$eglSwapInterval$iii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglSwapInterval$iii'].apply(null, arguments);
  }

  function _fp$eglTerminate$ii(
  ) {
  if (!Module['_fp$eglTerminate$ii']) abort("external function 'fp$eglTerminate$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglTerminate$ii'].apply(null, arguments);
  }

  function _fp$eglWaitGL$i(
  ) {
  if (!Module['_fp$eglWaitGL$i']) abort("external function 'fp$eglWaitGL$i' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglWaitGL$i'].apply(null, arguments);
  }

  function _fp$eglWaitNative$ii(
  ) {
  if (!Module['_fp$eglWaitNative$ii']) abort("external function 'fp$eglWaitNative$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$eglWaitNative$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glActiveTexture$vi(
  ) {
  if (!Module['_fp$emscripten_glActiveTexture$vi']) abort("external function 'fp$emscripten_glActiveTexture$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glActiveTexture$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glAttachShader$vii(
  ) {
  if (!Module['_fp$emscripten_glAttachShader$vii']) abort("external function 'fp$emscripten_glAttachShader$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glAttachShader$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBeginQueryEXT$vii(
  ) {
  if (!Module['_fp$emscripten_glBeginQueryEXT$vii']) abort("external function 'fp$emscripten_glBeginQueryEXT$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBeginQueryEXT$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBindAttribLocation$viii(
  ) {
  if (!Module['_fp$emscripten_glBindAttribLocation$viii']) abort("external function 'fp$emscripten_glBindAttribLocation$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBindAttribLocation$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glBindBuffer$vii(
  ) {
  if (!Module['_fp$emscripten_glBindBuffer$vii']) abort("external function 'fp$emscripten_glBindBuffer$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBindBuffer$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBindFramebuffer$vii(
  ) {
  if (!Module['_fp$emscripten_glBindFramebuffer$vii']) abort("external function 'fp$emscripten_glBindFramebuffer$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBindFramebuffer$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBindRenderbuffer$vii(
  ) {
  if (!Module['_fp$emscripten_glBindRenderbuffer$vii']) abort("external function 'fp$emscripten_glBindRenderbuffer$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBindRenderbuffer$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBindTexture$vii(
  ) {
  if (!Module['_fp$emscripten_glBindTexture$vii']) abort("external function 'fp$emscripten_glBindTexture$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBindTexture$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBindVertexArrayOES$vi(
  ) {
  if (!Module['_fp$emscripten_glBindVertexArrayOES$vi']) abort("external function 'fp$emscripten_glBindVertexArrayOES$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBindVertexArrayOES$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glBlendColor$vffff(
  ) {
  if (!Module['_fp$emscripten_glBlendColor$vffff']) abort("external function 'fp$emscripten_glBlendColor$vffff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBlendColor$vffff'].apply(null, arguments);
  }

  function _fp$emscripten_glBlendEquation$vi(
  ) {
  if (!Module['_fp$emscripten_glBlendEquation$vi']) abort("external function 'fp$emscripten_glBlendEquation$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBlendEquation$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glBlendEquationSeparate$vii(
  ) {
  if (!Module['_fp$emscripten_glBlendEquationSeparate$vii']) abort("external function 'fp$emscripten_glBlendEquationSeparate$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBlendEquationSeparate$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBlendFunc$vii(
  ) {
  if (!Module['_fp$emscripten_glBlendFunc$vii']) abort("external function 'fp$emscripten_glBlendFunc$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBlendFunc$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glBlendFuncSeparate$viiii(
  ) {
  if (!Module['_fp$emscripten_glBlendFuncSeparate$viiii']) abort("external function 'fp$emscripten_glBlendFuncSeparate$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBlendFuncSeparate$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glBufferData$viiii(
  ) {
  if (!Module['_fp$emscripten_glBufferData$viiii']) abort("external function 'fp$emscripten_glBufferData$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBufferData$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glBufferSubData$viiii(
  ) {
  if (!Module['_fp$emscripten_glBufferSubData$viiii']) abort("external function 'fp$emscripten_glBufferSubData$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glBufferSubData$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glCheckFramebufferStatus$ii(
  ) {
  if (!Module['_fp$emscripten_glCheckFramebufferStatus$ii']) abort("external function 'fp$emscripten_glCheckFramebufferStatus$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCheckFramebufferStatus$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glClear$vi(
  ) {
  if (!Module['_fp$emscripten_glClear$vi']) abort("external function 'fp$emscripten_glClear$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glClear$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glClearColor$vffff(
  ) {
  if (!Module['_fp$emscripten_glClearColor$vffff']) abort("external function 'fp$emscripten_glClearColor$vffff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glClearColor$vffff'].apply(null, arguments);
  }

  function _fp$emscripten_glClearDepthf$vf(
  ) {
  if (!Module['_fp$emscripten_glClearDepthf$vf']) abort("external function 'fp$emscripten_glClearDepthf$vf' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glClearDepthf$vf'].apply(null, arguments);
  }

  function _fp$emscripten_glClearStencil$vi(
  ) {
  if (!Module['_fp$emscripten_glClearStencil$vi']) abort("external function 'fp$emscripten_glClearStencil$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glClearStencil$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glColorMask$viiii(
  ) {
  if (!Module['_fp$emscripten_glColorMask$viiii']) abort("external function 'fp$emscripten_glColorMask$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glColorMask$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glCompileShader$vi(
  ) {
  if (!Module['_fp$emscripten_glCompileShader$vi']) abort("external function 'fp$emscripten_glCompileShader$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCompileShader$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glCompressedTexImage2D$viiiiiiii(
  ) {
  if (!Module['_fp$emscripten_glCompressedTexImage2D$viiiiiiii']) abort("external function 'fp$emscripten_glCompressedTexImage2D$viiiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCompressedTexImage2D$viiiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii(
  ) {
  if (!Module['_fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii']) abort("external function 'fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glCopyTexImage2D$viiiiiiii(
  ) {
  if (!Module['_fp$emscripten_glCopyTexImage2D$viiiiiiii']) abort("external function 'fp$emscripten_glCopyTexImage2D$viiiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCopyTexImage2D$viiiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glCopyTexSubImage2D$viiiiiiii(
  ) {
  if (!Module['_fp$emscripten_glCopyTexSubImage2D$viiiiiiii']) abort("external function 'fp$emscripten_glCopyTexSubImage2D$viiiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCopyTexSubImage2D$viiiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glCreateProgram$i(
  ) {
  if (!Module['_fp$emscripten_glCreateProgram$i']) abort("external function 'fp$emscripten_glCreateProgram$i' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCreateProgram$i'].apply(null, arguments);
  }

  function _fp$emscripten_glCreateShader$ii(
  ) {
  if (!Module['_fp$emscripten_glCreateShader$ii']) abort("external function 'fp$emscripten_glCreateShader$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCreateShader$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glCullFace$vi(
  ) {
  if (!Module['_fp$emscripten_glCullFace$vi']) abort("external function 'fp$emscripten_glCullFace$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glCullFace$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteBuffers$vii(
  ) {
  if (!Module['_fp$emscripten_glDeleteBuffers$vii']) abort("external function 'fp$emscripten_glDeleteBuffers$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteBuffers$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteFramebuffers$vii(
  ) {
  if (!Module['_fp$emscripten_glDeleteFramebuffers$vii']) abort("external function 'fp$emscripten_glDeleteFramebuffers$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteFramebuffers$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteProgram$vi(
  ) {
  if (!Module['_fp$emscripten_glDeleteProgram$vi']) abort("external function 'fp$emscripten_glDeleteProgram$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteProgram$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteQueriesEXT$vii(
  ) {
  if (!Module['_fp$emscripten_glDeleteQueriesEXT$vii']) abort("external function 'fp$emscripten_glDeleteQueriesEXT$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteQueriesEXT$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteRenderbuffers$vii(
  ) {
  if (!Module['_fp$emscripten_glDeleteRenderbuffers$vii']) abort("external function 'fp$emscripten_glDeleteRenderbuffers$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteRenderbuffers$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteShader$vi(
  ) {
  if (!Module['_fp$emscripten_glDeleteShader$vi']) abort("external function 'fp$emscripten_glDeleteShader$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteShader$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteTextures$vii(
  ) {
  if (!Module['_fp$emscripten_glDeleteTextures$vii']) abort("external function 'fp$emscripten_glDeleteTextures$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteTextures$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDeleteVertexArraysOES$vii(
  ) {
  if (!Module['_fp$emscripten_glDeleteVertexArraysOES$vii']) abort("external function 'fp$emscripten_glDeleteVertexArraysOES$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDeleteVertexArraysOES$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDepthFunc$vi(
  ) {
  if (!Module['_fp$emscripten_glDepthFunc$vi']) abort("external function 'fp$emscripten_glDepthFunc$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDepthFunc$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glDepthMask$vi(
  ) {
  if (!Module['_fp$emscripten_glDepthMask$vi']) abort("external function 'fp$emscripten_glDepthMask$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDepthMask$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glDepthRangef$vff(
  ) {
  if (!Module['_fp$emscripten_glDepthRangef$vff']) abort("external function 'fp$emscripten_glDepthRangef$vff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDepthRangef$vff'].apply(null, arguments);
  }

  function _fp$emscripten_glDetachShader$vii(
  ) {
  if (!Module['_fp$emscripten_glDetachShader$vii']) abort("external function 'fp$emscripten_glDetachShader$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDetachShader$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDisable$vi(
  ) {
  if (!Module['_fp$emscripten_glDisable$vi']) abort("external function 'fp$emscripten_glDisable$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDisable$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glDisableVertexAttribArray$vi(
  ) {
  if (!Module['_fp$emscripten_glDisableVertexAttribArray$vi']) abort("external function 'fp$emscripten_glDisableVertexAttribArray$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDisableVertexAttribArray$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glDrawArrays$viii(
  ) {
  if (!Module['_fp$emscripten_glDrawArrays$viii']) abort("external function 'fp$emscripten_glDrawArrays$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDrawArrays$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glDrawArraysInstancedANGLE$viiii(
  ) {
  if (!Module['_fp$emscripten_glDrawArraysInstancedANGLE$viiii']) abort("external function 'fp$emscripten_glDrawArraysInstancedANGLE$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDrawArraysInstancedANGLE$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glDrawBuffersWEBGL$vii(
  ) {
  if (!Module['_fp$emscripten_glDrawBuffersWEBGL$vii']) abort("external function 'fp$emscripten_glDrawBuffersWEBGL$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDrawBuffersWEBGL$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glDrawElements$viiii(
  ) {
  if (!Module['_fp$emscripten_glDrawElements$viiii']) abort("external function 'fp$emscripten_glDrawElements$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDrawElements$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glDrawElementsInstancedANGLE$viiiii(
  ) {
  if (!Module['_fp$emscripten_glDrawElementsInstancedANGLE$viiiii']) abort("external function 'fp$emscripten_glDrawElementsInstancedANGLE$viiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glDrawElementsInstancedANGLE$viiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glEnable$vi(
  ) {
  if (!Module['_fp$emscripten_glEnable$vi']) abort("external function 'fp$emscripten_glEnable$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glEnable$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glEnableVertexAttribArray$vi(
  ) {
  if (!Module['_fp$emscripten_glEnableVertexAttribArray$vi']) abort("external function 'fp$emscripten_glEnableVertexAttribArray$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glEnableVertexAttribArray$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glEndQueryEXT$vi(
  ) {
  if (!Module['_fp$emscripten_glEndQueryEXT$vi']) abort("external function 'fp$emscripten_glEndQueryEXT$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glEndQueryEXT$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glFinish$v(
  ) {
  if (!Module['_fp$emscripten_glFinish$v']) abort("external function 'fp$emscripten_glFinish$v' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glFinish$v'].apply(null, arguments);
  }

  function _fp$emscripten_glFlush$v(
  ) {
  if (!Module['_fp$emscripten_glFlush$v']) abort("external function 'fp$emscripten_glFlush$v' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glFlush$v'].apply(null, arguments);
  }

  function _fp$emscripten_glFramebufferRenderbuffer$viiii(
  ) {
  if (!Module['_fp$emscripten_glFramebufferRenderbuffer$viiii']) abort("external function 'fp$emscripten_glFramebufferRenderbuffer$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glFramebufferRenderbuffer$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glFramebufferTexture2D$viiiii(
  ) {
  if (!Module['_fp$emscripten_glFramebufferTexture2D$viiiii']) abort("external function 'fp$emscripten_glFramebufferTexture2D$viiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glFramebufferTexture2D$viiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glFrontFace$vi(
  ) {
  if (!Module['_fp$emscripten_glFrontFace$vi']) abort("external function 'fp$emscripten_glFrontFace$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glFrontFace$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glGenBuffers$vii(
  ) {
  if (!Module['_fp$emscripten_glGenBuffers$vii']) abort("external function 'fp$emscripten_glGenBuffers$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGenBuffers$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGenFramebuffers$vii(
  ) {
  if (!Module['_fp$emscripten_glGenFramebuffers$vii']) abort("external function 'fp$emscripten_glGenFramebuffers$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGenFramebuffers$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGenQueriesEXT$vii(
  ) {
  if (!Module['_fp$emscripten_glGenQueriesEXT$vii']) abort("external function 'fp$emscripten_glGenQueriesEXT$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGenQueriesEXT$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGenRenderbuffers$vii(
  ) {
  if (!Module['_fp$emscripten_glGenRenderbuffers$vii']) abort("external function 'fp$emscripten_glGenRenderbuffers$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGenRenderbuffers$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGenTextures$vii(
  ) {
  if (!Module['_fp$emscripten_glGenTextures$vii']) abort("external function 'fp$emscripten_glGenTextures$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGenTextures$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGenVertexArraysOES$vii(
  ) {
  if (!Module['_fp$emscripten_glGenVertexArraysOES$vii']) abort("external function 'fp$emscripten_glGenVertexArraysOES$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGenVertexArraysOES$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGenerateMipmap$vi(
  ) {
  if (!Module['_fp$emscripten_glGenerateMipmap$vi']) abort("external function 'fp$emscripten_glGenerateMipmap$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGenerateMipmap$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glGetActiveAttrib$viiiiiii(
  ) {
  if (!Module['_fp$emscripten_glGetActiveAttrib$viiiiiii']) abort("external function 'fp$emscripten_glGetActiveAttrib$viiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetActiveAttrib$viiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetActiveUniform$viiiiiii(
  ) {
  if (!Module['_fp$emscripten_glGetActiveUniform$viiiiiii']) abort("external function 'fp$emscripten_glGetActiveUniform$viiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetActiveUniform$viiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetAttachedShaders$viiii(
  ) {
  if (!Module['_fp$emscripten_glGetAttachedShaders$viiii']) abort("external function 'fp$emscripten_glGetAttachedShaders$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetAttachedShaders$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetAttribLocation$iii(
  ) {
  if (!Module['_fp$emscripten_glGetAttribLocation$iii']) abort("external function 'fp$emscripten_glGetAttribLocation$iii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetAttribLocation$iii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetBooleanv$vii(
  ) {
  if (!Module['_fp$emscripten_glGetBooleanv$vii']) abort("external function 'fp$emscripten_glGetBooleanv$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetBooleanv$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetBufferParameteriv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetBufferParameteriv$viii']) abort("external function 'fp$emscripten_glGetBufferParameteriv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetBufferParameteriv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetError$i(
  ) {
  if (!Module['_fp$emscripten_glGetError$i']) abort("external function 'fp$emscripten_glGetError$i' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetError$i'].apply(null, arguments);
  }

  function _fp$emscripten_glGetFloatv$vii(
  ) {
  if (!Module['_fp$emscripten_glGetFloatv$vii']) abort("external function 'fp$emscripten_glGetFloatv$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetFloatv$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii(
  ) {
  if (!Module['_fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii']) abort("external function 'fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetIntegerv$vii(
  ) {
  if (!Module['_fp$emscripten_glGetIntegerv$vii']) abort("external function 'fp$emscripten_glGetIntegerv$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetIntegerv$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetProgramInfoLog$viiii(
  ) {
  if (!Module['_fp$emscripten_glGetProgramInfoLog$viiii']) abort("external function 'fp$emscripten_glGetProgramInfoLog$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetProgramInfoLog$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetProgramiv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetProgramiv$viii']) abort("external function 'fp$emscripten_glGetProgramiv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetProgramiv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetQueryObjecti64vEXT$viii(
  ) {
  if (!Module['_fp$emscripten_glGetQueryObjecti64vEXT$viii']) abort("external function 'fp$emscripten_glGetQueryObjecti64vEXT$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetQueryObjecti64vEXT$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetQueryObjectivEXT$viii(
  ) {
  if (!Module['_fp$emscripten_glGetQueryObjectivEXT$viii']) abort("external function 'fp$emscripten_glGetQueryObjectivEXT$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetQueryObjectivEXT$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetQueryObjectui64vEXT$viii(
  ) {
  if (!Module['_fp$emscripten_glGetQueryObjectui64vEXT$viii']) abort("external function 'fp$emscripten_glGetQueryObjectui64vEXT$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetQueryObjectui64vEXT$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetQueryObjectuivEXT$viii(
  ) {
  if (!Module['_fp$emscripten_glGetQueryObjectuivEXT$viii']) abort("external function 'fp$emscripten_glGetQueryObjectuivEXT$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetQueryObjectuivEXT$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetQueryivEXT$viii(
  ) {
  if (!Module['_fp$emscripten_glGetQueryivEXT$viii']) abort("external function 'fp$emscripten_glGetQueryivEXT$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetQueryivEXT$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetRenderbufferParameteriv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetRenderbufferParameteriv$viii']) abort("external function 'fp$emscripten_glGetRenderbufferParameteriv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetRenderbufferParameteriv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetShaderInfoLog$viiii(
  ) {
  if (!Module['_fp$emscripten_glGetShaderInfoLog$viiii']) abort("external function 'fp$emscripten_glGetShaderInfoLog$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetShaderInfoLog$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetShaderPrecisionFormat$viiii(
  ) {
  if (!Module['_fp$emscripten_glGetShaderPrecisionFormat$viiii']) abort("external function 'fp$emscripten_glGetShaderPrecisionFormat$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetShaderPrecisionFormat$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetShaderSource$viiii(
  ) {
  if (!Module['_fp$emscripten_glGetShaderSource$viiii']) abort("external function 'fp$emscripten_glGetShaderSource$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetShaderSource$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetShaderiv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetShaderiv$viii']) abort("external function 'fp$emscripten_glGetShaderiv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetShaderiv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetString$ii(
  ) {
  if (!Module['_fp$emscripten_glGetString$ii']) abort("external function 'fp$emscripten_glGetString$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetString$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetTexParameterfv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetTexParameterfv$viii']) abort("external function 'fp$emscripten_glGetTexParameterfv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetTexParameterfv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetTexParameteriv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetTexParameteriv$viii']) abort("external function 'fp$emscripten_glGetTexParameteriv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetTexParameteriv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetUniformLocation$iii(
  ) {
  if (!Module['_fp$emscripten_glGetUniformLocation$iii']) abort("external function 'fp$emscripten_glGetUniformLocation$iii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetUniformLocation$iii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetUniformfv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetUniformfv$viii']) abort("external function 'fp$emscripten_glGetUniformfv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetUniformfv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetUniformiv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetUniformiv$viii']) abort("external function 'fp$emscripten_glGetUniformiv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetUniformiv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetVertexAttribPointerv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetVertexAttribPointerv$viii']) abort("external function 'fp$emscripten_glGetVertexAttribPointerv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetVertexAttribPointerv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetVertexAttribfv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetVertexAttribfv$viii']) abort("external function 'fp$emscripten_glGetVertexAttribfv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetVertexAttribfv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glGetVertexAttribiv$viii(
  ) {
  if (!Module['_fp$emscripten_glGetVertexAttribiv$viii']) abort("external function 'fp$emscripten_glGetVertexAttribiv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glGetVertexAttribiv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glHint$vii(
  ) {
  if (!Module['_fp$emscripten_glHint$vii']) abort("external function 'fp$emscripten_glHint$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glHint$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsBuffer$ii(
  ) {
  if (!Module['_fp$emscripten_glIsBuffer$ii']) abort("external function 'fp$emscripten_glIsBuffer$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsBuffer$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsEnabled$ii(
  ) {
  if (!Module['_fp$emscripten_glIsEnabled$ii']) abort("external function 'fp$emscripten_glIsEnabled$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsEnabled$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsFramebuffer$ii(
  ) {
  if (!Module['_fp$emscripten_glIsFramebuffer$ii']) abort("external function 'fp$emscripten_glIsFramebuffer$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsFramebuffer$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsProgram$ii(
  ) {
  if (!Module['_fp$emscripten_glIsProgram$ii']) abort("external function 'fp$emscripten_glIsProgram$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsProgram$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsQueryEXT$ii(
  ) {
  if (!Module['_fp$emscripten_glIsQueryEXT$ii']) abort("external function 'fp$emscripten_glIsQueryEXT$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsQueryEXT$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsRenderbuffer$ii(
  ) {
  if (!Module['_fp$emscripten_glIsRenderbuffer$ii']) abort("external function 'fp$emscripten_glIsRenderbuffer$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsRenderbuffer$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsShader$ii(
  ) {
  if (!Module['_fp$emscripten_glIsShader$ii']) abort("external function 'fp$emscripten_glIsShader$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsShader$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsTexture$ii(
  ) {
  if (!Module['_fp$emscripten_glIsTexture$ii']) abort("external function 'fp$emscripten_glIsTexture$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsTexture$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glIsVertexArrayOES$ii(
  ) {
  if (!Module['_fp$emscripten_glIsVertexArrayOES$ii']) abort("external function 'fp$emscripten_glIsVertexArrayOES$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glIsVertexArrayOES$ii'].apply(null, arguments);
  }

  function _fp$emscripten_glLineWidth$vf(
  ) {
  if (!Module['_fp$emscripten_glLineWidth$vf']) abort("external function 'fp$emscripten_glLineWidth$vf' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glLineWidth$vf'].apply(null, arguments);
  }

  function _fp$emscripten_glLinkProgram$vi(
  ) {
  if (!Module['_fp$emscripten_glLinkProgram$vi']) abort("external function 'fp$emscripten_glLinkProgram$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glLinkProgram$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glPixelStorei$vii(
  ) {
  if (!Module['_fp$emscripten_glPixelStorei$vii']) abort("external function 'fp$emscripten_glPixelStorei$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glPixelStorei$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glPolygonOffset$vff(
  ) {
  if (!Module['_fp$emscripten_glPolygonOffset$vff']) abort("external function 'fp$emscripten_glPolygonOffset$vff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glPolygonOffset$vff'].apply(null, arguments);
  }

  function _fp$emscripten_glQueryCounterEXT$vii(
  ) {
  if (!Module['_fp$emscripten_glQueryCounterEXT$vii']) abort("external function 'fp$emscripten_glQueryCounterEXT$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glQueryCounterEXT$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glReadPixels$viiiiiii(
  ) {
  if (!Module['_fp$emscripten_glReadPixels$viiiiiii']) abort("external function 'fp$emscripten_glReadPixels$viiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glReadPixels$viiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glReleaseShaderCompiler$v(
  ) {
  if (!Module['_fp$emscripten_glReleaseShaderCompiler$v']) abort("external function 'fp$emscripten_glReleaseShaderCompiler$v' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glReleaseShaderCompiler$v'].apply(null, arguments);
  }

  function _fp$emscripten_glRenderbufferStorage$viiii(
  ) {
  if (!Module['_fp$emscripten_glRenderbufferStorage$viiii']) abort("external function 'fp$emscripten_glRenderbufferStorage$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glRenderbufferStorage$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glSampleCoverage$vfi(
  ) {
  if (!Module['_fp$emscripten_glSampleCoverage$vfi']) abort("external function 'fp$emscripten_glSampleCoverage$vfi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glSampleCoverage$vfi'].apply(null, arguments);
  }

  function _fp$emscripten_glScissor$viiii(
  ) {
  if (!Module['_fp$emscripten_glScissor$viiii']) abort("external function 'fp$emscripten_glScissor$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glScissor$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glShaderBinary$viiiii(
  ) {
  if (!Module['_fp$emscripten_glShaderBinary$viiiii']) abort("external function 'fp$emscripten_glShaderBinary$viiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glShaderBinary$viiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glShaderSource$viiii(
  ) {
  if (!Module['_fp$emscripten_glShaderSource$viiii']) abort("external function 'fp$emscripten_glShaderSource$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glShaderSource$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glStencilFunc$viii(
  ) {
  if (!Module['_fp$emscripten_glStencilFunc$viii']) abort("external function 'fp$emscripten_glStencilFunc$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glStencilFunc$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glStencilFuncSeparate$viiii(
  ) {
  if (!Module['_fp$emscripten_glStencilFuncSeparate$viiii']) abort("external function 'fp$emscripten_glStencilFuncSeparate$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glStencilFuncSeparate$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glStencilMask$vi(
  ) {
  if (!Module['_fp$emscripten_glStencilMask$vi']) abort("external function 'fp$emscripten_glStencilMask$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glStencilMask$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glStencilMaskSeparate$vii(
  ) {
  if (!Module['_fp$emscripten_glStencilMaskSeparate$vii']) abort("external function 'fp$emscripten_glStencilMaskSeparate$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glStencilMaskSeparate$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glStencilOp$viii(
  ) {
  if (!Module['_fp$emscripten_glStencilOp$viii']) abort("external function 'fp$emscripten_glStencilOp$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glStencilOp$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glStencilOpSeparate$viiii(
  ) {
  if (!Module['_fp$emscripten_glStencilOpSeparate$viiii']) abort("external function 'fp$emscripten_glStencilOpSeparate$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glStencilOpSeparate$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glTexImage2D$viiiiiiiii(
  ) {
  if (!Module['_fp$emscripten_glTexImage2D$viiiiiiiii']) abort("external function 'fp$emscripten_glTexImage2D$viiiiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glTexImage2D$viiiiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glTexParameterf$viif(
  ) {
  if (!Module['_fp$emscripten_glTexParameterf$viif']) abort("external function 'fp$emscripten_glTexParameterf$viif' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glTexParameterf$viif'].apply(null, arguments);
  }

  function _fp$emscripten_glTexParameterfv$viii(
  ) {
  if (!Module['_fp$emscripten_glTexParameterfv$viii']) abort("external function 'fp$emscripten_glTexParameterfv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glTexParameterfv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glTexParameteri$viii(
  ) {
  if (!Module['_fp$emscripten_glTexParameteri$viii']) abort("external function 'fp$emscripten_glTexParameteri$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glTexParameteri$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glTexParameteriv$viii(
  ) {
  if (!Module['_fp$emscripten_glTexParameteriv$viii']) abort("external function 'fp$emscripten_glTexParameteriv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glTexParameteriv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glTexSubImage2D$viiiiiiiii(
  ) {
  if (!Module['_fp$emscripten_glTexSubImage2D$viiiiiiiii']) abort("external function 'fp$emscripten_glTexSubImage2D$viiiiiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glTexSubImage2D$viiiiiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform1f$vif(
  ) {
  if (!Module['_fp$emscripten_glUniform1f$vif']) abort("external function 'fp$emscripten_glUniform1f$vif' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform1f$vif'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform1fv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform1fv$viii']) abort("external function 'fp$emscripten_glUniform1fv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform1fv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform1i$vii(
  ) {
  if (!Module['_fp$emscripten_glUniform1i$vii']) abort("external function 'fp$emscripten_glUniform1i$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform1i$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform1iv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform1iv$viii']) abort("external function 'fp$emscripten_glUniform1iv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform1iv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform2f$viff(
  ) {
  if (!Module['_fp$emscripten_glUniform2f$viff']) abort("external function 'fp$emscripten_glUniform2f$viff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform2f$viff'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform2fv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform2fv$viii']) abort("external function 'fp$emscripten_glUniform2fv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform2fv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform2i$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform2i$viii']) abort("external function 'fp$emscripten_glUniform2i$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform2i$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform2iv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform2iv$viii']) abort("external function 'fp$emscripten_glUniform2iv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform2iv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform3f$vifff(
  ) {
  if (!Module['_fp$emscripten_glUniform3f$vifff']) abort("external function 'fp$emscripten_glUniform3f$vifff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform3f$vifff'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform3fv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform3fv$viii']) abort("external function 'fp$emscripten_glUniform3fv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform3fv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform3i$viiii(
  ) {
  if (!Module['_fp$emscripten_glUniform3i$viiii']) abort("external function 'fp$emscripten_glUniform3i$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform3i$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform3iv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform3iv$viii']) abort("external function 'fp$emscripten_glUniform3iv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform3iv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform4f$viffff(
  ) {
  if (!Module['_fp$emscripten_glUniform4f$viffff']) abort("external function 'fp$emscripten_glUniform4f$viffff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform4f$viffff'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform4fv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform4fv$viii']) abort("external function 'fp$emscripten_glUniform4fv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform4fv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform4i$viiiii(
  ) {
  if (!Module['_fp$emscripten_glUniform4i$viiiii']) abort("external function 'fp$emscripten_glUniform4i$viiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform4i$viiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniform4iv$viii(
  ) {
  if (!Module['_fp$emscripten_glUniform4iv$viii']) abort("external function 'fp$emscripten_glUniform4iv$viii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniform4iv$viii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniformMatrix2fv$viiii(
  ) {
  if (!Module['_fp$emscripten_glUniformMatrix2fv$viiii']) abort("external function 'fp$emscripten_glUniformMatrix2fv$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniformMatrix2fv$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniformMatrix3fv$viiii(
  ) {
  if (!Module['_fp$emscripten_glUniformMatrix3fv$viiii']) abort("external function 'fp$emscripten_glUniformMatrix3fv$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniformMatrix3fv$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glUniformMatrix4fv$viiii(
  ) {
  if (!Module['_fp$emscripten_glUniformMatrix4fv$viiii']) abort("external function 'fp$emscripten_glUniformMatrix4fv$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUniformMatrix4fv$viiii'].apply(null, arguments);
  }

  function _fp$emscripten_glUseProgram$vi(
  ) {
  if (!Module['_fp$emscripten_glUseProgram$vi']) abort("external function 'fp$emscripten_glUseProgram$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glUseProgram$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glValidateProgram$vi(
  ) {
  if (!Module['_fp$emscripten_glValidateProgram$vi']) abort("external function 'fp$emscripten_glValidateProgram$vi' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glValidateProgram$vi'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib1f$vif(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib1f$vif']) abort("external function 'fp$emscripten_glVertexAttrib1f$vif' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib1f$vif'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib1fv$vii(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib1fv$vii']) abort("external function 'fp$emscripten_glVertexAttrib1fv$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib1fv$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib2f$viff(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib2f$viff']) abort("external function 'fp$emscripten_glVertexAttrib2f$viff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib2f$viff'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib2fv$vii(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib2fv$vii']) abort("external function 'fp$emscripten_glVertexAttrib2fv$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib2fv$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib3f$vifff(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib3f$vifff']) abort("external function 'fp$emscripten_glVertexAttrib3f$vifff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib3f$vifff'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib3fv$vii(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib3fv$vii']) abort("external function 'fp$emscripten_glVertexAttrib3fv$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib3fv$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib4f$viffff(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib4f$viffff']) abort("external function 'fp$emscripten_glVertexAttrib4f$viffff' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib4f$viffff'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttrib4fv$vii(
  ) {
  if (!Module['_fp$emscripten_glVertexAttrib4fv$vii']) abort("external function 'fp$emscripten_glVertexAttrib4fv$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttrib4fv$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttribDivisorANGLE$vii(
  ) {
  if (!Module['_fp$emscripten_glVertexAttribDivisorANGLE$vii']) abort("external function 'fp$emscripten_glVertexAttribDivisorANGLE$vii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttribDivisorANGLE$vii'].apply(null, arguments);
  }

  function _fp$emscripten_glVertexAttribPointer$viiiiii(
  ) {
  if (!Module['_fp$emscripten_glVertexAttribPointer$viiiiii']) abort("external function 'fp$emscripten_glVertexAttribPointer$viiiiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glVertexAttribPointer$viiiiii'].apply(null, arguments);
  }

  function _fp$emscripten_glViewport$viiii(
  ) {
  if (!Module['_fp$emscripten_glViewport$viiii']) abort("external function 'fp$emscripten_glViewport$viiii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$emscripten_glViewport$viiii'].apply(null, arguments);
  }

  function _fp$nlr_pop$v(
  ) {
  if (!Module['_fp$nlr_pop$v']) abort("external function 'fp$nlr_pop$v' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$nlr_pop$v'].apply(null, arguments);
  }

  function _fp$nlr_push_tail$ii(
  ) {
  if (!Module['_fp$nlr_push_tail$ii']) abort("external function 'fp$nlr_push_tail$ii' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_fp$nlr_push_tail$ii'].apply(null, arguments);
  }

  function _getTempRet0() {
      return (getTempRet0() | 0);
    }
  Module["_getTempRet0"] = _getTempRet0;

  function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
      var info = __read_sockaddr(sa, salen);
      if (info.errno) {
        return -6;
      }
      var port = info.port;
      var addr = info.addr;
  
      var overflowed = false;
  
      if (node && nodelen) {
        var lookup;
        if ((flags & 1) || !(lookup = DNS.lookup_addr(addr))) {
          if (flags & 8) {
            return -2;
          }
        } else {
          addr = lookup;
        }
        var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
  
        if (numBytesWrittenExclNull+1 >= nodelen) {
          overflowed = true;
        }
      }
  
      if (serv && servlen) {
        port = '' + port;
        var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
  
        if (numBytesWrittenExclNull+1 >= servlen) {
          overflowed = true;
        }
      }
  
      if (overflowed) {
        // Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
        return -12;
      }
  
      return 0;
    }
  Module["_getnameinfo"] = _getnameinfo;

  function _gettimeofday(ptr) {
      var now = Date.now();
      HEAP32[((ptr)>>2)]=(now/1000)|0; // seconds
      HEAP32[(((ptr)+(4))>>2)]=((now % 1000)*1000)|0; // microseconds
      return 0;
    }
  Module["_gettimeofday"] = _gettimeofday;

  
  var ___tm_timezone=(stringToUTF8("GMT", 1129376, 4), 1129376);
  Module["___tm_timezone"] = ___tm_timezone;function _gmtime_r(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)]=date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)]=date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)]=date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)]=date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)]=date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)]=date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)]=date.getUTCDay();
      HEAP32[(((tmPtr)+(36))>>2)]=0;
      HEAP32[(((tmPtr)+(32))>>2)]=0;
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      HEAP32[(((tmPtr)+(40))>>2)]=___tm_timezone;
  
      return tmPtr;
    }
  Module["_gmtime_r"] = _gmtime_r;

  function _inet_addr(ptr) {
      var addr = __inet_pton4_raw(UTF8ToString(ptr));
      if (addr === null) {
        return -1;
      }
      return addr;
    }
  Module["_inet_addr"] = _inet_addr;

  
  var ___tm_current=1129328;
  Module["___tm_current"] = ___tm_current;
  
  
  function _tzset() {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (_tzset.called) return;
      _tzset.called = true;
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by getTimezoneOffset().
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAP32[((__get_timezone())>>2)]=(new Date()).getTimezoneOffset() * 60;
  
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      HEAP32[((__get_daylight())>>2)]=Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
        // Northern hemisphere
        HEAP32[((__get_tzname())>>2)]=winterNamePtr;
        HEAP32[(((__get_tzname())+(4))>>2)]=summerNamePtr;
      } else {
        HEAP32[((__get_tzname())>>2)]=summerNamePtr;
        HEAP32[(((__get_tzname())+(4))>>2)]=winterNamePtr;
      }
    }
  Module["_tzset"] = _tzset;function _localtime_r(time, tmPtr) {
      _tzset();
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)]=date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)]=date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)]=date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)]=date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)]=date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)]=date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      HEAP32[(((tmPtr)+(36))>>2)]=-(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)]=dst;
  
      var zonePtr = HEAP32[(((__get_tzname())+(dst ? 4 : 0))>>2)];
      HEAP32[(((tmPtr)+(40))>>2)]=zonePtr;
  
      return tmPtr;
    }
  Module["_localtime_r"] = _localtime_r;function _localtime(time) {
      return _localtime_r(time, ___tm_current);
    }
  Module["_localtime"] = _localtime;

  
  function _usleep(useconds) {
      // int usleep(useconds_t useconds);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/usleep.html
      // We're single-threaded, so use a busy loop. Super-ugly.
      var start = _emscripten_get_now();
      while (_emscripten_get_now() - start < useconds / 1000) {
        // Do nothing.
      }
    }
  Module["_usleep"] = _usleep;function _nanosleep(rqtp, rmtp) {
      // int nanosleep(const struct timespec  *rqtp, struct timespec *rmtp);
      if (rqtp === 0) {
        setErrNo(28);
        return -1;
      }
      var seconds = HEAP32[((rqtp)>>2)];
      var nanoseconds = HEAP32[(((rqtp)+(4))>>2)];
      if (nanoseconds < 0 || nanoseconds > 999999999 || seconds < 0) {
        setErrNo(28);
        return -1;
      }
      if (rmtp !== 0) {
        HEAP32[((rmtp)>>2)]=0;
        HEAP32[(((rmtp)+(4))>>2)]=0;
      }
      return _usleep((seconds * 1e6) + (nanoseconds / 1000));
    }
  Module["_nanosleep"] = _nanosleep;

  function _nlr_pop(
  ) {
  if (!Module['_nlr_pop']) abort("external function 'nlr_pop' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_nlr_pop'].apply(null, arguments);
  }

  function _nlr_push_tail(
  ) {
  if (!Module['_nlr_push_tail']) abort("external function 'nlr_push_tail' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_nlr_push_tail'].apply(null, arguments);
  }

  function _ogg_page_bos(
  ) {
  if (!Module['_ogg_page_bos']) abort("external function 'ogg_page_bos' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_page_bos'].apply(null, arguments);
  }

  function _ogg_page_continued(
  ) {
  if (!Module['_ogg_page_continued']) abort("external function 'ogg_page_continued' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_page_continued'].apply(null, arguments);
  }

  function _ogg_page_eos(
  ) {
  if (!Module['_ogg_page_eos']) abort("external function 'ogg_page_eos' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_page_eos'].apply(null, arguments);
  }

  function _ogg_page_granulepos(
  ) {
  if (!Module['_ogg_page_granulepos']) abort("external function 'ogg_page_granulepos' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_page_granulepos'].apply(null, arguments);
  }

  function _ogg_page_serialno(
  ) {
  if (!Module['_ogg_page_serialno']) abort("external function 'ogg_page_serialno' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_page_serialno'].apply(null, arguments);
  }

  function _ogg_stream_clear(
  ) {
  if (!Module['_ogg_stream_clear']) abort("external function 'ogg_stream_clear' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_stream_clear'].apply(null, arguments);
  }

  function _ogg_stream_init(
  ) {
  if (!Module['_ogg_stream_init']) abort("external function 'ogg_stream_init' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_stream_init'].apply(null, arguments);
  }

  function _ogg_stream_packetout(
  ) {
  if (!Module['_ogg_stream_packetout']) abort("external function 'ogg_stream_packetout' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_stream_packetout'].apply(null, arguments);
  }

  function _ogg_stream_packetpeek(
  ) {
  if (!Module['_ogg_stream_packetpeek']) abort("external function 'ogg_stream_packetpeek' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_stream_packetpeek'].apply(null, arguments);
  }

  function _ogg_stream_pagein(
  ) {
  if (!Module['_ogg_stream_pagein']) abort("external function 'ogg_stream_pagein' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_stream_pagein'].apply(null, arguments);
  }

  function _ogg_stream_reset(
  ) {
  if (!Module['_ogg_stream_reset']) abort("external function 'ogg_stream_reset' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_stream_reset'].apply(null, arguments);
  }

  function _ogg_stream_reset_serialno(
  ) {
  if (!Module['_ogg_stream_reset_serialno']) abort("external function 'ogg_stream_reset_serialno' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_stream_reset_serialno'].apply(null, arguments);
  }

  function _ogg_sync_buffer(
  ) {
  if (!Module['_ogg_sync_buffer']) abort("external function 'ogg_sync_buffer' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_sync_buffer'].apply(null, arguments);
  }

  function _ogg_sync_clear(
  ) {
  if (!Module['_ogg_sync_clear']) abort("external function 'ogg_sync_clear' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_sync_clear'].apply(null, arguments);
  }

  function _ogg_sync_init(
  ) {
  if (!Module['_ogg_sync_init']) abort("external function 'ogg_sync_init' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_sync_init'].apply(null, arguments);
  }

  function _ogg_sync_pageseek(
  ) {
  if (!Module['_ogg_sync_pageseek']) abort("external function 'ogg_sync_pageseek' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_sync_pageseek'].apply(null, arguments);
  }

  function _ogg_sync_reset(
  ) {
  if (!Module['_ogg_sync_reset']) abort("external function 'ogg_sync_reset' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_sync_reset'].apply(null, arguments);
  }

  function _ogg_sync_wrote(
  ) {
  if (!Module['_ogg_sync_wrote']) abort("external function 'ogg_sync_wrote' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_ogg_sync_wrote'].apply(null, arguments);
  }

  function _oggpack_adv(
  ) {
  if (!Module['_oggpack_adv']) abort("external function 'oggpack_adv' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_adv'].apply(null, arguments);
  }

  function _oggpack_bytes(
  ) {
  if (!Module['_oggpack_bytes']) abort("external function 'oggpack_bytes' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_bytes'].apply(null, arguments);
  }

  function _oggpack_get_buffer(
  ) {
  if (!Module['_oggpack_get_buffer']) abort("external function 'oggpack_get_buffer' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_get_buffer'].apply(null, arguments);
  }

  function _oggpack_look(
  ) {
  if (!Module['_oggpack_look']) abort("external function 'oggpack_look' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_look'].apply(null, arguments);
  }

  function _oggpack_read(
  ) {
  if (!Module['_oggpack_read']) abort("external function 'oggpack_read' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_read'].apply(null, arguments);
  }

  function _oggpack_readinit(
  ) {
  if (!Module['_oggpack_readinit']) abort("external function 'oggpack_readinit' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_readinit'].apply(null, arguments);
  }

  function _oggpack_reset(
  ) {
  if (!Module['_oggpack_reset']) abort("external function 'oggpack_reset' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_reset'].apply(null, arguments);
  }

  function _oggpack_write(
  ) {
  if (!Module['_oggpack_write']) abort("external function 'oggpack_write' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_write'].apply(null, arguments);
  }

  function _oggpack_writeclear(
  ) {
  if (!Module['_oggpack_writeclear']) abort("external function 'oggpack_writeclear' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_writeclear'].apply(null, arguments);
  }

  function _oggpack_writeinit(
  ) {
  if (!Module['_oggpack_writeinit']) abort("external function 'oggpack_writeinit' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_writeinit'].apply(null, arguments);
  }

  function _oggpack_writetrunc(
  ) {
  if (!Module['_oggpack_writetrunc']) abort("external function 'oggpack_writetrunc' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_oggpack_writetrunc'].apply(null, arguments);
  }

  function _pthread_cleanup_pop() {
      assert(_pthread_cleanup_push.level == __ATEXIT__.length, 'cannot pop if something else added meanwhile!');
      __ATEXIT__.pop();
      _pthread_cleanup_push.level = __ATEXIT__.length;
    }
  Module["_pthread_cleanup_pop"] = _pthread_cleanup_pop;

  function _pthread_cleanup_push(routine, arg) {
      __ATEXIT__.push(function() { dynCall_vi(routine, arg) })
      _pthread_cleanup_push.level = __ATEXIT__.length;
    }
  Module["_pthread_cleanup_push"] = _pthread_cleanup_push;

  function _pthread_setcancelstate() { return 0; }
  Module["_pthread_setcancelstate"] = _pthread_setcancelstate;

  function _pthread_sigmask(how, set, oldset) {
      err('pthread_sigmask() is not supported: this is a no-op.');
      return 0;
    }
  Module["_pthread_sigmask"] = _pthread_sigmask;

  
  function _round(d) {
      d = +d;
      return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);
    }
  Module["_round"] = _round;

  function _roundf(d) {
      d = +d;
      return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);
    }
  Module["_roundf"] = _roundf;


  function _setTempRet0($i) {
      setTempRet0(($i) | 0);
    }
  Module["_setTempRet0"] = _setTempRet0;

  function _setitimer() {
      throw 'setitimer() is not implemented yet';
    }
  Module["_setitimer"] = _setitimer;

  function _sigaction(signum, act, oldact) {
      //int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
      err('Calling stub instead of sigaction()');
      return 0;
    }
  Module["_sigaction"] = _sigaction;

  function _sigfillset(set) {
      HEAP32[((set)>>2)]=-1>>>0;
      return 0;
    }
  Module["_sigfillset"] = _sigfillset;

  
  var __sigalrm_handler=0;
  Module["__sigalrm_handler"] = __sigalrm_handler;function _signal(sig, func) {
      if (sig == 14 /*SIGALRM*/) {
        __sigalrm_handler = func;
      } else {
        err('Calling stub instead of signal()');
      }
      return 0;
    }
  Module["_signal"] = _signal;

  
  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  Module["__isLeapYear"] = __isLeapYear;
  
  function __arraySum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
        // no-op
      }
      return sum;
    }
  Module["__arraySum"] = __arraySum;
  
  
  var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];
  Module["__MONTH_DAYS_LEAP"] = __MONTH_DAYS_LEAP;
  
  var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];
  Module["__MONTH_DAYS_REGULAR"] = __MONTH_DAYS_REGULAR;function __addDays(date, days) {
      var newDate = new Date(date.getTime());
      while(days > 0) {
        var leap = __isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
  
        if (days > daysInCurrentMonth-newDate.getDate()) {
          // we spill over to next month
          days -= (daysInCurrentMonth-newDate.getDate()+1);
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth+1)
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear()+1);
          }
        } else {
          // we stay in current month
          newDate.setDate(newDate.getDate()+days);
          return newDate;
        }
      }
  
      return newDate;
    }
  Module["__addDays"] = __addDays;function _strftime(s, maxsize, format, tm) {
      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html
  
      var tm_zone = HEAP32[(((tm)+(40))>>2)];
  
      var date = {
        tm_sec: HEAP32[((tm)>>2)],
        tm_min: HEAP32[(((tm)+(4))>>2)],
        tm_hour: HEAP32[(((tm)+(8))>>2)],
        tm_mday: HEAP32[(((tm)+(12))>>2)],
        tm_mon: HEAP32[(((tm)+(16))>>2)],
        tm_year: HEAP32[(((tm)+(20))>>2)],
        tm_wday: HEAP32[(((tm)+(24))>>2)],
        tm_yday: HEAP32[(((tm)+(28))>>2)],
        tm_isdst: HEAP32[(((tm)+(32))>>2)],
        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],
        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''
      };
  
      var pattern = UTF8ToString(format);
  
      // expand format
      var EXPANSION_RULES_1 = {
        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y
        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d
        '%h': '%b',                       // Equivalent to %b
        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation
        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation
        '%T': '%H:%M:%S',                 // Replaced by the time
        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation
        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation
        // Modified Conversion Specifiers
        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.
        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.
        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.
        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.
        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.
        '%EY': '%Y',                      // Replaced by the full alternative year representation.
        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.
        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.
        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.
        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.
        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.
        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.
        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.
        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.
      };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
      }
  
      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  
      function leadingSomething(value, digits, character) {
        var str = typeof value === 'number' ? value.toString() : (value || '');
        while (str.length < digits) {
          str = character[0]+str;
        }
        return str;
      }
  
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, '0');
      }
  
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : (value > 0 ? 1 : 0);
        }
  
        var compare;
        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {
            compare = sgn(date1.getDate()-date2.getDate());
          }
        }
        return compare;
      }
  
      function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0: // Sunday
              return new Date(janFourth.getFullYear()-1, 11, 29);
            case 1: // Monday
              return janFourth;
            case 2: // Tuesday
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3: // Wednesday
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4: // Thursday
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5: // Friday
              return new Date(janFourth.getFullYear()-1, 11, 31);
            case 6: // Saturday
              return new Date(janFourth.getFullYear()-1, 11, 30);
          }
      }
  
      function getWeekBasedYear(date) {
          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            // this date is after the start of the first week of this year
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear()+1;
            } else {
              return thisDate.getFullYear();
            }
          } else {
            return thisDate.getFullYear()-1;
          }
      }
  
      var EXPANSION_RULES_2 = {
        '%a': function(date) {
          return WEEKDAYS[date.tm_wday].substring(0,3);
        },
        '%A': function(date) {
          return WEEKDAYS[date.tm_wday];
        },
        '%b': function(date) {
          return MONTHS[date.tm_mon].substring(0,3);
        },
        '%B': function(date) {
          return MONTHS[date.tm_mon];
        },
        '%C': function(date) {
          var year = date.tm_year+1900;
          return leadingNulls((year/100)|0,2);
        },
        '%d': function(date) {
          return leadingNulls(date.tm_mday, 2);
        },
        '%e': function(date) {
          return leadingSomething(date.tm_mday, 2, ' ');
        },
        '%g': function(date) {
          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.
          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes
          // January 4th, which is also the week that includes the first Thursday of the year, and
          // is also the first week that contains at least four days in the year.
          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of
          // the last week of the preceding year; thus, for Saturday 2nd January 1999,
          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,
          // or 31st is a Monday, it and any following days are part of week 1 of the following year.
          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.
  
          return getWeekBasedYear(date).toString().substring(2);
        },
        '%G': function(date) {
          return getWeekBasedYear(date);
        },
        '%H': function(date) {
          return leadingNulls(date.tm_hour, 2);
        },
        '%I': function(date) {
          var twelveHour = date.tm_hour;
          if (twelveHour == 0) twelveHour = 12;
          else if (twelveHour > 12) twelveHour -= 12;
          return leadingNulls(twelveHour, 2);
        },
        '%j': function(date) {
          // Day of the year (001-366)
          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);
        },
        '%m': function(date) {
          return leadingNulls(date.tm_mon+1, 2);
        },
        '%M': function(date) {
          return leadingNulls(date.tm_min, 2);
        },
        '%n': function() {
          return '\n';
        },
        '%p': function(date) {
          if (date.tm_hour >= 0 && date.tm_hour < 12) {
            return 'AM';
          } else {
            return 'PM';
          }
        },
        '%S': function(date) {
          return leadingNulls(date.tm_sec, 2);
        },
        '%t': function() {
          return '\t';
        },
        '%u': function(date) {
          return date.tm_wday || 7;
        },
        '%U': function(date) {
          // Replaced by the week number of the year as a decimal number [00,53].
          // The first Sunday of January is the first day of week 1;
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janFirst = new Date(date.tm_year+1900, 0, 1);
          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7-janFirst.getDay());
          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);
  
          // is target date after the first Sunday?
          if (compareByDay(firstSunday, endDate) < 0) {
            // calculate difference in days between first Sunday and endDate
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;
            var firstSundayUntilEndJanuary = 31-firstSunday.getDate();
            var days = firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();
            return leadingNulls(Math.ceil(days/7), 2);
          }
  
          return compareByDay(firstSunday, janFirst) === 0 ? '01': '00';
        },
        '%V': function(date) {
          // Replaced by the week number of the year (Monday as the first day of the week)
          // as a decimal number [01,53]. If the week containing 1 January has four
          // or more days in the new year, then it is considered week 1.
          // Otherwise, it is the last week of the previous year, and the next week is week 1.
          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
          var janFourthThisYear = new Date(date.tm_year+1900, 0, 4);
          var janFourthNextYear = new Date(date.tm_year+1901, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          var endDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
            // if given date is before this years first week, then it belongs to the 53rd week of last year
            return '53';
          }
  
          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
            // if given date is after next years first week, then it belongs to the 01th week of next year
            return '01';
          }
  
          // given date is in between CW 01..53 of this calendar year
          var daysDifference;
          if (firstWeekStartThisYear.getFullYear() < date.tm_year+1900) {
            // first CW of this year starts last year
            daysDifference = date.tm_yday+32-firstWeekStartThisYear.getDate()
          } else {
            // first CW of this year starts this year
            daysDifference = date.tm_yday+1-firstWeekStartThisYear.getDate();
          }
          return leadingNulls(Math.ceil(daysDifference/7), 2);
        },
        '%w': function(date) {
          return date.tm_wday;
        },
        '%W': function(date) {
          // Replaced by the week number of the year as a decimal number [00,53].
          // The first Monday of January is the first day of week 1;
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janFirst = new Date(date.tm_year, 0, 1);
          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7-janFirst.getDay()+1);
          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);
  
          // is target date after the first Monday?
          if (compareByDay(firstMonday, endDate) < 0) {
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;
            var firstMondayUntilEndJanuary = 31-firstMonday.getDate();
            var days = firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();
            return leadingNulls(Math.ceil(days/7), 2);
          }
          return compareByDay(firstMonday, janFirst) === 0 ? '01': '00';
        },
        '%y': function(date) {
          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
          return (date.tm_year+1900).toString().substring(2);
        },
        '%Y': function(date) {
          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
          return date.tm_year+1900;
        },
        '%z': function(date) {
          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
          // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
          var off = date.tm_gmtoff;
          var ahead = off >= 0;
          off = Math.abs(off) / 60;
          // convert from minutes into hhmm format (which means 60 minutes = 100 units)
          off = (off / 60)*100 + (off % 60);
          return (ahead ? '+' : '-') + String("0000" + off).slice(-4);
        },
        '%Z': function(date) {
          return date.tm_zone;
        },
        '%%': function() {
          return '%';
        }
      };
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.indexOf(rule) >= 0) {
          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));
        }
      }
  
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      }
  
      writeArrayToMemory(bytes, s);
      return bytes.length-1;
    }
  Module["_strftime"] = _strftime;

  function _system(command) {
      // int system(const char *command);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
      // Can't call external programs.
      if (!command) return 0; // no shell available
      setErrNo(6);
      return -1;
    }
  Module["_system"] = _system;


  function _time(ptr) {
      var ret = (Date.now()/1000)|0;
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }
  Module["_time"] = _time;

  
  function _wait(stat_loc) {
      // pid_t wait(int *stat_loc);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/wait.html
      // Makes no sense in a single-process environment.
      setErrNo(12);
      return -1;
    }
  Module["_wait"] = _wait;function _waitpid(a0
  ) {
  return _wait(a0);
  }
  Module["_waitpid"] = _waitpid;

  function ___stack_pointer(
  ) {
  if (!Module['___stack_pointer']) abort("external function '__stack_pointer' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['___stack_pointer'].apply(null, arguments);
  }

  function ___memory_base(
  ) {
  if (!Module['___memory_base']) abort("external function '__memory_base' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['___memory_base'].apply(null, arguments);
  }

  function ___table_base(
  ) {
  if (!Module['___table_base']) abort("external function '__table_base' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['___table_base'].apply(null, arguments);
  }

  function readAsmConstArgs(sigPtr, buf) {
      if (!readAsmConstArgs.array) {
        readAsmConstArgs.array = [];
      }
      var args = readAsmConstArgs.array;
      args.length = 0;
      var ch;
      while (ch = HEAPU8[sigPtr++]) {
        if (ch === 100/*'d'*/ || ch === 102/*'f'*/) {
          buf = (buf + 7) & ~7;
          args.push(HEAPF64[(buf >> 3)]);
          buf += 8;
        } else
        if (ch === 105 /*'i'*/)
        {
          buf = (buf + 3) & ~3;
          args.push(HEAP32[(buf >> 2)]);
          buf += 4;
        }
        else abort("unexpected char in asm const signature " + ch);
      }
      return args;
    }
  Module["readAsmConstArgs"] = readAsmConstArgs;





  function _utime(path, times) {
      // int utime(const char *path, const struct utimbuf *times);
      // http://pubs.opengroup.org/onlinepubs/009695399/basedefs/utime.h.html
      var time;
      if (times) {
        // NOTE: We don't keep track of access timestamps.
        var offset = 4;
        time = HEAP32[(((times)+(offset))>>2)];
        time *= 1000;
      } else {
        time = Date.now();
      }
      path = UTF8ToString(path);
      try {
        FS.utime(path, time, time);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  Module["_utime"] = _utime;

  function _utimes(path, times) {
      var time;
      if (times) {
        var offset = 8 + 0;
        time = HEAP32[(((times)+(offset))>>2)] * 1000;
        offset = 8 + 4;
        time += HEAP32[(((times)+(offset))>>2)] / 1000;
      } else {
        time = Date.now();
      }
      path = UTF8ToString(path);
      try {
        FS.utime(path, time, time);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  Module["_utimes"] = _utimes;

  function _flock(fd, operation) {
      // int flock(int fd, int operation);
      // Pretend to succeed
      return 0;
    }
  Module["_flock"] = _flock;

  function _chroot(path) {
      // int chroot(const char *path);
      // http://pubs.opengroup.org/onlinepubs/7908799/xsh/chroot.html
      setErrNo(2);
      return -1;
    }
  Module["_chroot"] = _chroot;

  function _fpathconf(fildes, name) {
      // long fpathconf(int fildes, int name);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/encrypt.html
      // NOTE: The first parameter is ignored, so pathconf == fpathconf.
      // The constants here aren't real values. Just mimicking glibc.
      switch (name) {
        case 0:
          return 32000;
        case 1:
        case 2:
        case 3:
          return 255;
        case 4:
        case 5:
        case 16:
        case 17:
        case 18:
          return 4096;
        case 6:
        case 7:
        case 20:
          return 1;
        case 8:
          return 0;
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
        case 15:
        case 19:
          return -1;
        case 13:
          return 64;
      }
      setErrNo(28);
      return -1;
    }
  Module["_fpathconf"] = _fpathconf;

  function _pathconf(a0,a1
  ) {
  return _fpathconf(a0,a1);
  }
  Module["_pathconf"] = _pathconf;

  function _confstr(name, buf, len) {
      // size_t confstr(int name, char *buf, size_t len);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/confstr.html
      var value;
      switch (name) {
        case 0:
          value = ENV['PATH'] || '/';
          break;
        case 1:
          // Mimicking glibc.
          value = 'POSIX_V6_ILP32_OFF32\nPOSIX_V6_ILP32_OFFBIG';
          break;
        case 2:
          // This JS implementation was tested against this glibc version.
          value = 'glibc 2.14';
          break;
        case 3:
          // We don't support pthreads.
          value = '';
          break;
        case 1118:
        case 1122:
        case 1124:
        case 1125:
        case 1126:
        case 1128:
        case 1129:
        case 1130:
          value = '';
          break;
        case 1116:
        case 1117:
        case 1121:
          value = '-m32';
          break;
        case 1120:
          value = '-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64';
          break;
        default:
          setErrNo(28);
          return 0;
      }
      if (len == 0 || buf == 0) {
        return value.length + 1;
      } else {
        var length = Math.min(len, value.length);
        for (var i = 0; i < length; i++) {
          HEAP8[(((buf)+(i))>>0)]=value.charCodeAt(i);
        }
        if (len > length) HEAP8[(((buf)+(i++))>>0)]=0;
        return i;
      }
    }
  Module["_confstr"] = _confstr;

  function _execl(path, arg0, varArgs) {
      // int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/exec.html
      // We don't support executing external code.
      setErrNo(45);
      return -1;
    }
  Module["_execl"] = _execl;

  function _execle(a0,a1,a2
  ) {
  return _execl(a0,a1,a2);
  }
  Module["_execle"] = _execle;

  function _execlp(a0,a1,a2
  ) {
  return _execl(a0,a1,a2);
  }
  Module["_execlp"] = _execlp;

  function _execv(a0,a1,a2
  ) {
  return _execl(a0,a1,a2);
  }
  Module["_execv"] = _execv;

  function _execve(a0,a1,a2
  ) {
  return _execl(a0,a1,a2);
  }
  Module["_execve"] = _execve;

  function _execvp(a0,a1,a2
  ) {
  return _execl(a0,a1,a2);
  }
  Module["_execvp"] = _execvp;

  function ___execvpe(a0,a1,a2
  ) {
  return _execl(a0,a1,a2);
  }
  Module["___execvpe"] = ___execvpe;

  function _fexecve(a0,a1,a2
  ) {
  return _execl(a0,a1,a2);
  }
  Module["_fexecve"] = _fexecve;



  function __Exit(a0
  ) {
  return _exit(a0);
  }
  Module["__Exit"] = __Exit;


  function _vfork(
  ) {
  return _fork();
  }
  Module["_vfork"] = _vfork;

  function _posix_spawn(
  ) {
  return _fork();
  }
  Module["_posix_spawn"] = _posix_spawn;

  function _posix_spawnp(
  ) {
  return _fork();
  }
  Module["_posix_spawnp"] = _posix_spawnp;

  
  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return 16384;
        case 85:
          var maxHeapSize = HEAPU8.length;
          return maxHeapSize / 16384;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
        case 79:
          return 200809;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: {
          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
      }
      setErrNo(28);
      return -1;
    }
  Module["_sysconf"] = _sysconf;function _setgroups(ngroups, gidset) {
      // int setgroups(int ngroups, const gid_t *gidset);
      // https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man2/setgroups.2.html
      if (ngroups < 1 || ngroups > _sysconf(3)) {
        setErrNo(28);
        return -1;
      } else {
        // We have just one process/user/group, so it makes no sense to set groups.
        setErrNo(63);
        return -1;
      }
    }
  Module["_setgroups"] = _setgroups;





  function emscripten_realloc_buffer(size) {
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1 /*success*/;
      } catch(e) {
        console.error('emscripten_realloc_buffer: Attempted to grow heap from ' + buffer.byteLength  + ' bytes to ' + size + ' bytes, but got error: ' + e);
      }
    }
  Module["emscripten_realloc_buffer"] = emscripten_realloc_buffer;


  function _emscripten_notify_memory_growth(memoryIndex) {
      assert(memoryIndex == 0);
      updateGlobalBufferAndViews(wasmMemory.buffer);
    }
  Module["_emscripten_notify_memory_growth"] = _emscripten_notify_memory_growth;


  var _abs=Math_abs;
  Module["_abs"] = _abs;


  function __ZSt9terminatev() {
      _exit(-1234);
    }
  Module["__ZSt9terminatev"] = __ZSt9terminatev;

  function _atexit(func, arg) {
      warnOnce('atexit() called, but EXIT_RUNTIME is not set, so atexits() will not be called. set EXIT_RUNTIME to 1 (see the FAQ)');
      __ATEXIT__.unshift({ func: func, arg: arg });
    }
  Module["_atexit"] = _atexit;

  function ___cxa_atexit(a0,a1
  ) {
  return _atexit(a0,a1);
  }
  Module["___cxa_atexit"] = ___cxa_atexit;

  function ___cxa_thread_atexit(a0,a1
  ) {
  return _atexit(a0,a1);
  }
  Module["___cxa_thread_atexit"] = ___cxa_thread_atexit;

  function ___cxa_thread_atexit_impl(a0,a1
  ) {
  return _atexit(a0,a1);
  }
  Module["___cxa_thread_atexit_impl"] = ___cxa_thread_atexit_impl;



  function _getloadavg(loadavg, nelem) {
      // int getloadavg(double loadavg[], int nelem);
      // http://linux.die.net/man/3/getloadavg
      var limit = Math.min(nelem, 3);
      var doubleSize = 8;
      for (var i = 0; i < limit; i++) {
        HEAPF64[(((loadavg)+(i * doubleSize))>>3)]=0.1;
      }
      return limit;
    }
  Module["_getloadavg"] = _getloadavg;


  function _llvm_memcpy_i32(a0,a1,a2
  ) {
  return _memcpy(a0,a1,a2);
  }
  Module["_llvm_memcpy_i32"] = _llvm_memcpy_i32;

  function _llvm_memcpy_i64(a0,a1,a2
  ) {
  return _memcpy(a0,a1,a2);
  }
  Module["_llvm_memcpy_i64"] = _llvm_memcpy_i64;

  function _llvm_memcpy_p0i8_p0i8_i32(a0,a1,a2
  ) {
  return _memcpy(a0,a1,a2);
  }
  Module["_llvm_memcpy_p0i8_p0i8_i32"] = _llvm_memcpy_p0i8_p0i8_i32;

  function _llvm_memcpy_p0i8_p0i8_i64(a0,a1,a2
  ) {
  return _memcpy(a0,a1,a2);
  }
  Module["_llvm_memcpy_p0i8_p0i8_i64"] = _llvm_memcpy_p0i8_p0i8_i64;

  function _llvm_memmove_i32(a0,a1,a2
  ) {
  return _memmove(a0,a1,a2);
  }
  Module["_llvm_memmove_i32"] = _llvm_memmove_i32;

  function _llvm_memmove_i64(a0,a1,a2
  ) {
  return _memmove(a0,a1,a2);
  }
  Module["_llvm_memmove_i64"] = _llvm_memmove_i64;

  function _llvm_memmove_p0i8_p0i8_i32(a0,a1,a2
  ) {
  return _memmove(a0,a1,a2);
  }
  Module["_llvm_memmove_p0i8_p0i8_i32"] = _llvm_memmove_p0i8_p0i8_i32;

  function _llvm_memmove_p0i8_p0i8_i64(a0,a1,a2
  ) {
  return _memmove(a0,a1,a2);
  }
  Module["_llvm_memmove_p0i8_p0i8_i64"] = _llvm_memmove_p0i8_p0i8_i64;

  function _llvm_memset_i32(a0,a1,a2
  ) {
  return _memset(a0,a1,a2);
  }
  Module["_llvm_memset_i32"] = _llvm_memset_i32;

  function _llvm_memset_p0i8_i32(a0,a1,a2
  ) {
  return _memset(a0,a1,a2);
  }
  Module["_llvm_memset_p0i8_i32"] = _llvm_memset_p0i8_i32;

  function _llvm_memset_p0i8_i64(a0,a1,a2
  ) {
  return _memset(a0,a1,a2);
  }
  Module["_llvm_memset_p0i8_i64"] = _llvm_memset_p0i8_i64;

  function ___builtin_prefetch(){}
  Module["___builtin_prefetch"] = ___builtin_prefetch;

  function _llvm_va_end() {}
  Module["_llvm_va_end"] = _llvm_va_end;

  function _llvm_va_copy(ppdest, ppsrc) {
      // copy the list start
      HEAP8[((ppdest)>>0)]=HEAP8[((ppsrc)>>0)];HEAP8[(((ppdest)+(1))>>0)]=HEAP8[(((ppsrc)+(1))>>0)];HEAP8[(((ppdest)+(2))>>0)]=HEAP8[(((ppsrc)+(2))>>0)];HEAP8[(((ppdest)+(3))>>0)]=HEAP8[(((ppsrc)+(3))>>0)];
  
      // copy the list's current offset (will be advanced with each call to va_arg)
      HEAP8[((ppdest+4)>>0)]=HEAP8[((ppsrc+4)>>0)];HEAP8[(((ppdest+4)+(1))>>0)]=HEAP8[(((ppsrc+4)+(1))>>0)];HEAP8[(((ppdest+4)+(2))>>0)]=HEAP8[(((ppsrc+4)+(2))>>0)];HEAP8[(((ppdest+4)+(3))>>0)]=HEAP8[(((ppsrc+4)+(3))>>0)];
    }
  Module["_llvm_va_copy"] = _llvm_va_copy;

  function _llvm_bswap_i16(x) {
      x = x|0;
      return (((x&0xff)<<8) | ((x>>8)&0xff))|0;
    }
  Module["_llvm_bswap_i16"] = _llvm_bswap_i16;

  function _llvm_bswap_i32(x) {
      x = x|0;
      return (((x&0xff)<<24) | (((x>>8)&0xff)<<16) | (((x>>16)&0xff)<<8) | (x>>>24))|0;
    }
  Module["_llvm_bswap_i32"] = _llvm_bswap_i32;

  function _llvm_bswap_i64(l, h) {
      var retl = _llvm_bswap_i32(h)>>>0;
      var reth = _llvm_bswap_i32(l)>>>0;
      return ((setTempRet0(reth),retl)|0);
    }
  Module["_llvm_bswap_i64"] = _llvm_bswap_i64;

  function _llvm_ctlz_i8(x, isZeroUndef) {
      x = x | 0;
      isZeroUndef = isZeroUndef | 0;
      return (Math_clz32(x & 0xff) | 0) - 24 | 0;
    }
  Module["_llvm_ctlz_i8"] = _llvm_ctlz_i8;

  function _llvm_ctlz_i16(x, isZeroUndef) {
      x = x | 0;
      isZeroUndef = isZeroUndef | 0;
      return (Math_clz32(x & 0xffff) | 0) - 16 | 0
    }
  Module["_llvm_ctlz_i16"] = _llvm_ctlz_i16;

  function _llvm_ctlz_i64(l, h, isZeroUndef) {
      l = l | 0;
      h = h | 0;
      isZeroUndef = isZeroUndef | 0;
      var ret = 0;
      ret = Math_clz32(h) | 0;
      if ((ret | 0) == 32) ret = ret + (Math_clz32(l) | 0) | 0;
      setTempRet0((0) | 0);
      return ret | 0;
    }
  Module["_llvm_ctlz_i64"] = _llvm_ctlz_i64;

  function _llvm_cttz_i32(x) { // Note: Currently doesn't take isZeroUndef()
      x = x | 0;
      return (x ? (31 - (Math_clz32((x ^ (x - 1))) | 0) | 0) : 32) | 0;
    }
  Module["_llvm_cttz_i32"] = _llvm_cttz_i32;

  function _llvm_cttz_i64(l, h) {
      var ret = _llvm_cttz_i32(l);
      if (ret == 32) ret += _llvm_cttz_i32(h);
      return ((setTempRet0(0),ret)|0);
    }
  Module["_llvm_cttz_i64"] = _llvm_cttz_i64;

  function _llvm_ctpop_i32(x) {
      // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
      // http://bits.stephan-brumme.com/countBits.html
      x = x | 0;
      x = x - ((x >>> 1) & 0x55555555) | 0;
      x = (x & 0x33333333) + ((x >>> 2) & 0x33333333) | 0;
      return (Math_imul((x + (x >>> 4) & 252645135 /* 0xF0F0F0F, but hits uglify parse bug? */), 0x1010101) >>> 24) | 0;
    }
  Module["_llvm_ctpop_i32"] = _llvm_ctpop_i32;

  function _llvm_ctpop_i64(l, h) {
      l = l | 0;
      h = h | 0;
      return (_llvm_ctpop_i32(l) | 0) + (_llvm_ctpop_i32(h) | 0) | 0;
    }
  Module["_llvm_ctpop_i64"] = _llvm_ctpop_i64;

  function _llvm_trap() {
      abort('trap!');
    }
  Module["_llvm_trap"] = _llvm_trap;

  function _llvm_prefetch(){}
  Module["_llvm_prefetch"] = _llvm_prefetch;

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }
  Module["___assert_fail"] = ___assert_fail;

  function ___assert_func(filename, line, func, condition) {
      abort('Assertion failed: ' + (condition ? UTF8ToString(condition) : 'unknown condition') + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }
  Module["___assert_func"] = ___assert_func;

  
  function ___cxa_call_unexpected(exception) {
      err('Unexpected exception thrown, this is not properly supported - aborting');
      ABORT = true;
      throw exception;
    }
  Module["___cxa_call_unexpected"] = ___cxa_call_unexpected;function _terminate(a0
  ) {
  return ___cxa_call_unexpected(a0);
  }
  Module["_terminate"] = _terminate;

  function ___gxx_personality_v0() {
    }
  Module["___gxx_personality_v0"] = ___gxx_personality_v0;

  function ___gcc_personality_v0() {
    }
  Module["___gcc_personality_v0"] = ___gcc_personality_v0;

  function _llvm_stacksave() {
      var self = _llvm_stacksave;
      if (!self.LLVM_SAVEDSTACKS) {
        self.LLVM_SAVEDSTACKS = [];
      }
      self.LLVM_SAVEDSTACKS.push(stackSave());
      return self.LLVM_SAVEDSTACKS.length-1;
    }
  Module["_llvm_stacksave"] = _llvm_stacksave;

  function _llvm_stackrestore(p) {
      var self = _llvm_stacksave;
      var ret = self.LLVM_SAVEDSTACKS[p];
      self.LLVM_SAVEDSTACKS.splice(p, 1);
      stackRestore(ret);
    }
  Module["_llvm_stackrestore"] = _llvm_stackrestore;

  function _llvm_flt_rounds() {
      return -1; // 'indeterminable' for FLT_ROUNDS
    }
  Module["_llvm_flt_rounds"] = _llvm_flt_rounds;

  function _llvm_objectsize_i32() { return -1 }
  Module["_llvm_objectsize_i32"] = _llvm_objectsize_i32;

  function _llvm_bitreverse_i32(x) {
      x = x|0;
      x = ((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1);
      x = ((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2);
      x = ((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4);
      x = ((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8);
      return (x >>> 16) | (x << 16);
    }
  Module["_llvm_bitreverse_i32"] = _llvm_bitreverse_i32;

  function _llvm_mono_load_i8_p0i8(ptr) {
      return HEAP8[((ptr)>>0)];
    }
  Module["_llvm_mono_load_i8_p0i8"] = _llvm_mono_load_i8_p0i8;

  function _llvm_mono_store_i8_p0i8(value, ptr) {
      HEAP8[((ptr)>>0)]=value;
    }
  Module["_llvm_mono_store_i8_p0i8"] = _llvm_mono_store_i8_p0i8;

  function _llvm_mono_load_i16_p0i16(ptr) {
      return HEAP16[((ptr)>>1)];
    }
  Module["_llvm_mono_load_i16_p0i16"] = _llvm_mono_load_i16_p0i16;

  function _llvm_mono_store_i16_p0i16(value, ptr) {
      HEAP16[((ptr)>>1)]=value;
    }
  Module["_llvm_mono_store_i16_p0i16"] = _llvm_mono_store_i16_p0i16;

  function _llvm_mono_load_i32_p0i32(ptr) {
      return HEAP32[((ptr)>>2)];
    }
  Module["_llvm_mono_load_i32_p0i32"] = _llvm_mono_load_i32_p0i32;

  function _llvm_mono_store_i32_p0i32(value, ptr) {
      HEAP32[((ptr)>>2)]=value;
    }
  Module["_llvm_mono_store_i32_p0i32"] = _llvm_mono_store_i32_p0i32;


































  var _llvm_fabs_f32=Math_abs;
  Module["_llvm_fabs_f32"] = _llvm_fabs_f32;

  var _llvm_fabs_f64=Math_abs;
  Module["_llvm_fabs_f64"] = _llvm_fabs_f64;










  var _llvm_sqrt_f32=Math_sqrt;
  Module["_llvm_sqrt_f32"] = _llvm_sqrt_f32;

  var _llvm_sqrt_f64=Math_sqrt;
  Module["_llvm_sqrt_f64"] = _llvm_sqrt_f64;

  var _llvm_pow_f32=Math_pow;
  Module["_llvm_pow_f32"] = _llvm_pow_f32;

  var _llvm_pow_f64=Math_pow;
  Module["_llvm_pow_f64"] = _llvm_pow_f64;

  var _llvm_powi_f32=Math_pow;
  Module["_llvm_powi_f32"] = _llvm_powi_f32;

  var _llvm_powi_f64=Math_pow;
  Module["_llvm_powi_f64"] = _llvm_powi_f64;

  var _llvm_log_f32=Math_log;
  Module["_llvm_log_f32"] = _llvm_log_f32;

  var _llvm_log_f64=Math_log;
  Module["_llvm_log_f64"] = _llvm_log_f64;

  var _llvm_exp_f32=Math_exp;
  Module["_llvm_exp_f32"] = _llvm_exp_f32;

  var _llvm_exp_f64=Math_exp;
  Module["_llvm_exp_f64"] = _llvm_exp_f64;

  var _llvm_cos_f32=Math_cos;
  Module["_llvm_cos_f32"] = _llvm_cos_f32;

  var _llvm_cos_f64=Math_cos;
  Module["_llvm_cos_f64"] = _llvm_cos_f64;

  var _llvm_sin_f32=Math_sin;
  Module["_llvm_sin_f32"] = _llvm_sin_f32;

  var _llvm_sin_f64=Math_sin;
  Module["_llvm_sin_f64"] = _llvm_sin_f64;

  var _llvm_trunc_f32=Math_trunc;
  Module["_llvm_trunc_f32"] = _llvm_trunc_f32;

  var _llvm_trunc_f64=Math_trunc;
  Module["_llvm_trunc_f64"] = _llvm_trunc_f64;

  var _llvm_ceil_f32=Math_ceil;
  Module["_llvm_ceil_f32"] = _llvm_ceil_f32;

  var _llvm_ceil_f64=Math_ceil;
  Module["_llvm_ceil_f64"] = _llvm_ceil_f64;

  var _llvm_floor_f32=Math_floor;
  Module["_llvm_floor_f32"] = _llvm_floor_f32;

  var _llvm_floor_f64=Math_floor;
  Module["_llvm_floor_f64"] = _llvm_floor_f64;

  function _llvm_exp2_f32(x) {
      return Math.pow(2, x);
    }
  Module["_llvm_exp2_f32"] = _llvm_exp2_f32;

  function _llvm_exp2_f64(a0
  ) {
  return _llvm_exp2_f32(a0);
  }
  Module["_llvm_exp2_f64"] = _llvm_exp2_f64;

  function _llvm_log2_f32(x) {
      return Math.log(x) / Math.LN2; // TODO: Math.log2, when browser support is there
    }
  Module["_llvm_log2_f32"] = _llvm_log2_f32;

  function _llvm_log2_f64(a0
  ) {
  return _llvm_log2_f32(a0);
  }
  Module["_llvm_log2_f64"] = _llvm_log2_f64;

  function _llvm_log10_f32(x) {
      return Math.log(x) / Math.LN10; // TODO: Math.log10, when browser support is there
    }
  Module["_llvm_log10_f32"] = _llvm_log10_f32;

  function _llvm_log10_f64(a0
  ) {
  return _llvm_log10_f32(a0);
  }
  Module["_llvm_log10_f64"] = _llvm_log10_f64;

  function _llvm_copysign_f32(x, y) {
      return y < 0 || (y === 0 && 1/y < 0) ? -Math_abs(x) : Math_abs(x);
    }
  Module["_llvm_copysign_f32"] = _llvm_copysign_f32;

  function _llvm_copysign_f64(x, y) {
      return y < 0 || (y === 0 && 1/y < 0) ? -Math_abs(x) : Math_abs(x);
    }
  Module["_llvm_copysign_f64"] = _llvm_copysign_f64;



  function _llvm_round_f64(d) {
      d = +d;
      return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);
    }
  Module["_llvm_round_f64"] = _llvm_round_f64;

  function _llvm_round_f32(f) {
      f = +f;
      return f >= +0 ? +Math_floor(f + +0.5) : +Math_ceil(f - +0.5); // TODO: use fround?
    }
  Module["_llvm_round_f32"] = _llvm_round_f32;


  function _llvm_rint_f32(f) {
      f = +f;
      return (f - +Math_floor(f) != .5) ? +_roundf(f) : +_roundf(f / +2) * +2;
    }
  Module["_llvm_rint_f32"] = _llvm_rint_f32;

  function _llvm_rint_f64(f) {
      f = +f;
      return (f - +Math_floor(f) != .5) ? +_round(f) : +_round(f / +2) * +2;
    }
  Module["_llvm_rint_f64"] = _llvm_rint_f64;

  function _llvm_nearbyint_f32(f) {
      f = +f;
      return (f - +Math_floor(f) != .5) ? +_roundf(f) : +_roundf(f / +2) * +2;
    }
  Module["_llvm_nearbyint_f32"] = _llvm_nearbyint_f32;

  function _llvm_nearbyint_f64(f) {
      f = +f;
      return (f - +Math_floor(f) != .5) ? +_round(f) : +_round(f / +2) * +2;
    }
  Module["_llvm_nearbyint_f64"] = _llvm_nearbyint_f64;

  function _llvm_minnum_f32(x, y) {
      x = +x;
      y = +y;
      if (x != x) return +y;
      if (y != y) return +x;
      return +Math_min(+x, +y);
    }
  Module["_llvm_minnum_f32"] = _llvm_minnum_f32;

  function _llvm_minnum_f64(x, y) {
      x = +x;
      y = +y;
      if (x != x) return +y;
      if (y != y) return +x;
      return +Math_min(+x, +y);
    }
  Module["_llvm_minnum_f64"] = _llvm_minnum_f64;

  function _llvm_maxnum_f32(x, y) {
      x = +x;
      y = +y;
      if (x != x) return +y;
      if (y != y) return +x;
      return +Math_max(+x, +y);
    }
  Module["_llvm_maxnum_f32"] = _llvm_maxnum_f32;

  function _llvm_maxnum_f64(x, y) {
      x = +x;
      y = +y;
      if (x != x) return +y;
      if (y != y) return +x;
      return +Math_max(+x, +y);
    }
  Module["_llvm_maxnum_f64"] = _llvm_maxnum_f64;






  function _dladdr(addr, info) {
      // report all function pointers as coming from this program itself XXX not really correct in any way
      var fname = stringToNewUTF8(__getExecutableName()); // XXX leak
      HEAP32[((info)>>2)]=fname;
      HEAP32[(((info)+(4))>>2)]=0;
      HEAP32[(((info)+(8))>>2)]=0;
      HEAP32[(((info)+(12))>>2)]=0;
      return 1;
    }
  Module["_dladdr"] = _dladdr;

  function _getpwuid() { throw 'getpwuid: TODO' }
  Module["_getpwuid"] = _getpwuid;



  function _difftime(time1, time0) {
      return time1 - time0;
    }
  Module["_difftime"] = _difftime;



  var ___tm_formatted=1129392;
  Module["___tm_formatted"] = ___tm_formatted;

  function _mktime(tmPtr) {
      _tzset();
      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
  
      // There's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  Date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = HEAP32[(((tmPtr)+(32))>>2)];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
      if (dst < 0) {
        // Attention: some regions don't have DST at all.
        HEAP32[(((tmPtr)+(32))>>2)]=Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if ((dst > 0) != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);
      }
  
      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
  
      return (date.getTime() / 1000)|0;
    }
  Module["_mktime"] = _mktime;

  function _timelocal(a0
  ) {
  return _mktime(a0);
  }
  Module["_timelocal"] = _timelocal;

  function _gmtime(time) {
      return _gmtime_r(time, ___tm_current);
    }
  Module["_gmtime"] = _gmtime;


  function _timegm(tmPtr) {
      _tzset();
      var time = Date.UTC(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
      var date = new Date(time);
  
      HEAP32[(((tmPtr)+(24))>>2)]=date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
  
      return (date.getTime() / 1000)|0;
    }
  Module["_timegm"] = _timegm;



  
  function _asctime_r(tmPtr, buf) {
      var date = {
        tm_sec: HEAP32[((tmPtr)>>2)],
        tm_min: HEAP32[(((tmPtr)+(4))>>2)],
        tm_hour: HEAP32[(((tmPtr)+(8))>>2)],
        tm_mday: HEAP32[(((tmPtr)+(12))>>2)],
        tm_mon: HEAP32[(((tmPtr)+(16))>>2)],
        tm_year: HEAP32[(((tmPtr)+(20))>>2)],
        tm_wday: HEAP32[(((tmPtr)+(24))>>2)]
      };
      var days = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];
      var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
      var s = days[date.tm_wday] + ' ' + months[date.tm_mon] +
          (date.tm_mday < 10 ? '  ' : ' ') + date.tm_mday +
          (date.tm_hour < 10 ? ' 0' : ' ') + date.tm_hour +
          (date.tm_min < 10 ? ':0' : ':') + date.tm_min +
          (date.tm_sec < 10 ? ':0' : ':') + date.tm_sec +
          ' ' + (1900 + date.tm_year) + "\n";
  
      // asctime_r is specced to behave in an undefined manner if the algorithm would attempt
      // to write out more than 26 bytes (including the null terminator).
      // See http://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html
      // Our undefined behavior is to truncate the write to at most 26 bytes, including null terminator.
      stringToUTF8(s, buf, 26);
      return buf;
    }
  Module["_asctime_r"] = _asctime_r;function _asctime(tmPtr) {
      return _asctime_r(tmPtr, ___tm_formatted);
    }
  Module["_asctime"] = _asctime;


  
  function _ctime_r(time, buf) {
      var stack = stackSave();
      var rv = _asctime_r(_localtime_r(time, stackAlloc(44)), buf);
      stackRestore(stack);
      return rv;
    }
  Module["_ctime_r"] = _ctime_r;function _ctime(timer) {
      return _ctime_r(timer, ___tm_current);
    }
  Module["_ctime"] = _ctime;


  function _dysize(year) {
      var leap = ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)));
      return leap ? 366 : 365;
    }
  Module["_dysize"] = _dysize;


  function _stime(when) {
      setErrNo(63);
      return -1;
    }
  Module["_stime"] = _stime;








  function _strftime_l(s, maxsize, format, tm) {
      return _strftime(s, maxsize, format, tm); // no locale support yet
    }
  Module["_strftime_l"] = _strftime_l;

  function _strptime(buf, format, tm) {
      // char *strptime(const char *restrict buf, const char *restrict format, struct tm *restrict tm);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html
      var pattern = UTF8ToString(format);
  
      // escape special characters
      // TODO: not sure we really need to escape all of these in JS regexps
      var SPECIAL_CHARS = '\\!@#$^&*()+=-[]/{}|:<>?,.';
      for (var i=0, ii=SPECIAL_CHARS.length; i<ii; ++i) {
        pattern = pattern.replace(new RegExp('\\'+SPECIAL_CHARS[i], 'g'), '\\'+SPECIAL_CHARS[i]);
      }
  
      // reduce number of matchers
      var EQUIVALENT_MATCHERS = {
        '%A':  '%a',
        '%B':  '%b',
        '%c':  '%a %b %d %H:%M:%S %Y',
        '%D':  '%m\\/%d\\/%y',
        '%e':  '%d',
        '%F':  '%Y-%m-%d',
        '%h':  '%b',
        '%R':  '%H\\:%M',
        '%r':  '%I\\:%M\\:%S\\s%p',
        '%T':  '%H\\:%M\\:%S',
        '%x':  '%m\\/%d\\/(?:%y|%Y)',
        '%X':  '%H\\:%M\\:%S'
      };
      for (var matcher in EQUIVALENT_MATCHERS) {
        pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
      }
  
      // TODO: take care of locale
  
      var DATE_PATTERNS = {
        /* weeday name */     '%a': '(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)',
        /* month name */      '%b': '(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)',
        /* century */         '%C': '\\d\\d',
        /* day of month */    '%d': '0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31',
        /* hour (24hr) */     '%H': '\\d(?!\\d)|[0,1]\\d|20|21|22|23',
        /* hour (12hr) */     '%I': '\\d(?!\\d)|0\\d|10|11|12',
        /* day of year */     '%j': '00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d',
        /* month */           '%m': '0[1-9]|[1-9](?!\\d)|10|11|12',
        /* minutes */         '%M': '0\\d|\\d(?!\\d)|[1-5]\\d',
        /* whitespace */      '%n': '\\s',
        /* AM/PM */           '%p': 'AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.',
        /* seconds */         '%S': '0\\d|\\d(?!\\d)|[1-5]\\d|60',
        /* week number */     '%U': '0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53',
        /* week number */     '%W': '0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53',
        /* weekday number */  '%w': '[0-6]',
        /* 2-digit year */    '%y': '\\d\\d',
        /* 4-digit year */    '%Y': '\\d\\d\\d\\d',
        /* % */               '%%': '%',
        /* whitespace */      '%t': '\\s',
      };
  
      var MONTH_NUMBERS = {JAN: 0, FEB: 1, MAR: 2, APR: 3, MAY: 4, JUN: 5, JUL: 6, AUG: 7, SEP: 8, OCT: 9, NOV: 10, DEC: 11};
      var DAY_NUMBERS_SUN_FIRST = {SUN: 0, MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6};
      var DAY_NUMBERS_MON_FIRST = {MON: 0, TUE: 1, WED: 2, THU: 3, FRI: 4, SAT: 5, SUN: 6};
  
      for (var datePattern in DATE_PATTERNS) {
        pattern = pattern.replace(datePattern, '('+datePattern+DATE_PATTERNS[datePattern]+')');
      }
  
      // take care of capturing groups
      var capture = [];
      for (var i=pattern.indexOf('%'); i>=0; i=pattern.indexOf('%')) {
        capture.push(pattern[i+1]);
        pattern = pattern.replace(new RegExp('\\%'+pattern[i+1], 'g'), '');
      }
  
      var matches = new RegExp('^'+pattern, "i").exec(UTF8ToString(buf))
      // out(UTF8ToString(buf)+ ' is matched by '+((new RegExp('^'+pattern)).source)+' into: '+JSON.stringify(matches));
  
      function initDate() {
        function fixup(value, min, max) {
          return (typeof value !== 'number' || isNaN(value)) ? min : (value>=min ? (value<=max ? value: max): min);
        };
        return {
          year: fixup(HEAP32[(((tm)+(20))>>2)] + 1900 , 1970, 9999),
          month: fixup(HEAP32[(((tm)+(16))>>2)], 0, 11),
          day: fixup(HEAP32[(((tm)+(12))>>2)], 1, 31),
          hour: fixup(HEAP32[(((tm)+(8))>>2)], 0, 23),
          min: fixup(HEAP32[(((tm)+(4))>>2)], 0, 59),
          sec: fixup(HEAP32[((tm)>>2)], 0, 59)
        };
      };
  
      if (matches) {
        var date = initDate();
        var value;
  
        var getMatch = function(symbol) {
          var pos = capture.indexOf(symbol);
          // check if symbol appears in regexp
          if (pos >= 0) {
            // return matched value or null (falsy!) for non-matches
            return matches[pos+1];
          }
          return;
        };
  
        // seconds
        if ((value=getMatch('S'))) {
          date.sec = jstoi_q(value);
        }
  
        // minutes
        if ((value=getMatch('M'))) {
          date.min = jstoi_q(value);
        }
  
        // hours
        if ((value=getMatch('H'))) {
          // 24h clock
          date.hour = jstoi_q(value);
        } else if ((value = getMatch('I'))) {
          // AM/PM clock
          var hour = jstoi_q(value);
          if ((value=getMatch('p'))) {
            hour += value.toUpperCase()[0] === 'P' ? 12 : 0;
          }
          date.hour = hour;
        }
  
        // year
        if ((value=getMatch('Y'))) {
          // parse from four-digit year
          date.year = jstoi_q(value);
        } else if ((value=getMatch('y'))) {
          // parse from two-digit year...
          var year = jstoi_q(value);
          if ((value=getMatch('C'))) {
            // ...and century
            year += jstoi_q(value)*100;
          } else {
            // ...and rule-of-thumb
            year += year<69 ? 2000 : 1900;
          }
          date.year = year;
        }
  
        // month
        if ((value=getMatch('m'))) {
          // parse from month number
          date.month = jstoi_q(value)-1;
        } else if ((value=getMatch('b'))) {
          // parse from month name
          date.month = MONTH_NUMBERS[value.substring(0,3).toUpperCase()] || 0;
          // TODO: derive month from day in year+year, week number+day of week+year
        }
  
        // day
        if ((value=getMatch('d'))) {
          // get day of month directly
          date.day = jstoi_q(value);
        } else if ((value=getMatch('j'))) {
          // get day of month from day of year ...
          var day = jstoi_q(value);
          var leapYear = __isLeapYear(date.year);
          for (var month=0; month<12; ++month) {
            var daysUntilMonth = __arraySum(leapYear ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, month-1);
            if (day<=daysUntilMonth+(leapYear ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[month]) {
              date.day = day-daysUntilMonth;
            }
          }
        } else if ((value=getMatch('a'))) {
          // get day of month from weekday ...
          var weekDay = value.substring(0,3).toUpperCase();
          if ((value=getMatch('U'))) {
            // ... and week number (Sunday being first day of week)
            // Week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
            // All days in a new year preceding the first Sunday are considered to be in week 0.
            var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
            var weekNumber = jstoi_q(value);
  
            // January 1st
            var janFirst = new Date(date.year, 0, 1);
            var endDate;
            if (janFirst.getDay() === 0) {
              // Jan 1st is a Sunday, and, hence in the 1st CW
              endDate = __addDays(janFirst, weekDayNumber+7*(weekNumber-1));
            } else {
              // Jan 1st is not a Sunday, and, hence still in the 0th CW
              endDate = __addDays(janFirst, 7-janFirst.getDay()+weekDayNumber+7*(weekNumber-1));
            }
            date.day = endDate.getDate();
            date.month = endDate.getMonth();
          } else if ((value=getMatch('W'))) {
            // ... and week number (Monday being first day of week)
            // Week number of the year (Monday as the first day of the week) as a decimal number [00,53].
            // All days in a new year preceding the first Monday are considered to be in week 0.
            var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
            var weekNumber = jstoi_q(value);
  
            // January 1st
            var janFirst = new Date(date.year, 0, 1);
            var endDate;
            if (janFirst.getDay()===1) {
              // Jan 1st is a Monday, and, hence in the 1st CW
               endDate = __addDays(janFirst, weekDayNumber+7*(weekNumber-1));
            } else {
              // Jan 1st is not a Monday, and, hence still in the 0th CW
              endDate = __addDays(janFirst, 7-janFirst.getDay()+1+weekDayNumber+7*(weekNumber-1));
            }
  
            date.day = endDate.getDate();
            date.month = endDate.getMonth();
          }
        }
  
        /*
        tm_sec  int seconds after the minute  0-61*
        tm_min  int minutes after the hour  0-59
        tm_hour int hours since midnight  0-23
        tm_mday int day of the month  1-31
        tm_mon  int months since January  0-11
        tm_year int years since 1900
        tm_wday int days since Sunday 0-6
        tm_yday int days since January 1  0-365
        tm_isdst  int Daylight Saving Time flag
        */
  
        var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
        HEAP32[((tm)>>2)]=fullDate.getSeconds();
        HEAP32[(((tm)+(4))>>2)]=fullDate.getMinutes();
        HEAP32[(((tm)+(8))>>2)]=fullDate.getHours();
        HEAP32[(((tm)+(12))>>2)]=fullDate.getDate();
        HEAP32[(((tm)+(16))>>2)]=fullDate.getMonth();
        HEAP32[(((tm)+(20))>>2)]=fullDate.getFullYear()-1900;
        HEAP32[(((tm)+(24))>>2)]=fullDate.getDay();
        HEAP32[(((tm)+(28))>>2)]=__arraySum(__isLeapYear(fullDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, fullDate.getMonth()-1)+fullDate.getDate()-1;
        HEAP32[(((tm)+(32))>>2)]=0;
  
        // we need to convert the matched sequence into an integer array to take care of UTF-8 characters > 0x7F
        // TODO: not sure that intArrayFromString handles all unicode characters correctly
        return buf+intArrayFromString(matches[0]).length-1;
      }
  
      return 0;
    }
  Module["_strptime"] = _strptime;

  function _strptime_l(buf, format, tm) {
      return _strptime(buf, format, tm); // no locale support yet
    }
  Module["_strptime_l"] = _strptime_l;

  function _getdate(string) {
      // struct tm *getdate(const char *string);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/getdate.html
      // TODO: Implement.
      return 0;
    }
  Module["_getdate"] = _getdate;

  function _timespec_get(ts, base) {
      //int timespec_get(struct timespec *ts, int base);
      if (base !== 1) {
        // There is no other implemented value than TIME_UTC; all other values are considered erroneous.
        setErrNo(28);
        return 0;
      }
      var ret = _clock_gettime(0, ts);
      return ret < 0 ? 0 : base;
    }
  Module["_timespec_get"] = _timespec_get;



  
  function _emscripten_get_now_res() { // return resolution of get_now, in nanoseconds
      // Modern environment where performance.now() is supported:
      return 1000; // microseconds (1/1000 of a millisecond)
    }
  Module["_emscripten_get_now_res"] = _emscripten_get_now_res;function _clock_getres(clk_id, res) {
      // int clock_getres(clockid_t clk_id, struct timespec *res);
      var nsec;
      if (clk_id === 0) {
        nsec = 1000 * 1000; // educated guess that it's milliseconds
      } else if (clk_id === 1 && _emscripten_get_now_is_monotonic) {
        nsec = _emscripten_get_now_res();
      } else {
        setErrNo(28);
        return -1;
      }
      HEAP32[((res)>>2)]=(nsec/1000000000)|0;
      HEAP32[(((res)+(4))>>2)]=nsec // resolution is nanoseconds
      return 0;
    }
  Module["_clock_getres"] = _clock_getres;

  function _clock_getcpuclockid(pid, clk_id) {
      if (pid < 0) return 71;
      if (pid !== 0 && pid !== 42) return 52;
      if (clk_id) HEAP32[((clk_id)>>2)]=2;
      return 0;
    }
  Module["_clock_getcpuclockid"] = _clock_getcpuclockid;


  function _ftime(p) {
      var millis = Date.now();
      HEAP32[((p)>>2)]=(millis/1000)|0;
      HEAP16[(((p)+(4))>>1)]=millis % 1000;
      HEAP16[(((p)+(6))>>1)]=0; // Obsolete field
      HEAP16[(((p)+(8))>>1)]=0; // Obsolete field
      return 0;
    }
  Module["_ftime"] = _ftime;

  function _times(buffer) {
      // clock_t times(struct tms *buffer);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/times.html
      // NOTE: This is fake, since we can't calculate real CPU time usage in JS.
      if (buffer !== 0) {
        _memset(buffer, 0, 16);
      }
      return 0;
    }
  Module["_times"] = _times;

  function _makedev(maj, min) {
      return ((maj) << 8 | (min));
    }
  Module["_makedev"] = _makedev;

  function _gnu_dev_makedev(a0,a1
  ) {
  return _makedev(a0,a1);
  }
  Module["_gnu_dev_makedev"] = _gnu_dev_makedev;

  function _major(dev) {
      return ((dev) >> 8);
    }
  Module["_major"] = _major;

  function _gnu_dev_major(a0
  ) {
  return _major(a0);
  }
  Module["_gnu_dev_major"] = _gnu_dev_major;

  function _minor(dev) {
      return ((dev) & 0xff);
    }
  Module["_minor"] = _minor;

  function _gnu_dev_minor(a0
  ) {
  return _minor(a0);
  }
  Module["_gnu_dev_minor"] = _gnu_dev_minor;







  function _waitid(a0
  ) {
  return _wait(a0);
  }
  Module["_waitid"] = _waitid;


  function _wait3(a0
  ) {
  return _wait(a0);
  }
  Module["_wait3"] = _wait3;

  function _wait4(a0
  ) {
  return _wait(a0);
  }
  Module["_wait4"] = _wait4;





  var _in6addr_any=1129440;
  Module["_in6addr_any"] = _in6addr_any;

  var _in6addr_loopback=1129456;
  Module["_in6addr_loopback"] = _in6addr_loopback;




  function __inet_pton6(src, dst) {
      var ints = __inet_pton6_raw(UTF8ToString(src));
      if (ints === null) {
        return 0;
      }
      for (var i = 0; i < 4; i++) {
        HEAP32[(((dst)+(i*4))>>2)]=ints[i];
      }
      return 1;
    }
  Module["__inet_pton6"] = __inet_pton6;





  
  function _gethostbyname(name) {
      name = UTF8ToString(name);
  
      // generate hostent
      var ret = _malloc(20); // XXX possibly leaked, as are others here
      var nameBuf = _malloc(name.length+1);
      stringToUTF8(name, nameBuf, name.length+1);
      HEAP32[((ret)>>2)]=nameBuf;
      var aliasesBuf = _malloc(4);
      HEAP32[((aliasesBuf)>>2)]=0;
      HEAP32[(((ret)+(4))>>2)]=aliasesBuf;
      var afinet = 2;
      HEAP32[(((ret)+(8))>>2)]=afinet;
      HEAP32[(((ret)+(12))>>2)]=4;
      var addrListBuf = _malloc(12);
      HEAP32[((addrListBuf)>>2)]=addrListBuf+8;
      HEAP32[(((addrListBuf)+(4))>>2)]=0;
      HEAP32[(((addrListBuf)+(8))>>2)]=__inet_pton4_raw(DNS.lookup_name(name));
      HEAP32[(((ret)+(16))>>2)]=addrListBuf;
      return ret;
    }
  Module["_gethostbyname"] = _gethostbyname;function _gethostbyaddr(addr, addrlen, type) {
      if (type !== 2) {
        setErrNo(5);
        // TODO: set h_errno
        return null;
      }
      addr = HEAP32[((addr)>>2)]; // addr is in_addr
      var host = __inet_ntop4_raw(addr);
      var lookup = DNS.lookup_addr(host);
      if (lookup) {
        host = lookup;
      }
      var hostp = allocate(intArrayFromString(host), 'i8', ALLOC_STACK);
      return _gethostbyname(hostp);
    }
  Module["_gethostbyaddr"] = _gethostbyaddr;


  function _gethostbyname_r(name, ret, buf, buflen, out, err) {
      var data = _gethostbyname(name);
      _memcpy(ret, data, 20);
      _free(data);
      HEAP32[((err)>>2)]=0;
      HEAP32[((out)>>2)]=ret;
      return 0;
    }
  Module["_gethostbyname_r"] = _gethostbyname_r;

  function _getaddrinfo(node, service, hint, out) {
      // Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
      // hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
      // really should provide a linked list of suitable addrinfo values.
      var addrs = [];
      var canon = null;
      var addr = 0;
      var port = 0;
      var flags = 0;
      var family = 0;
      var type = 0;
      var proto = 0;
      var ai, last;
  
      function allocaddrinfo(family, type, proto, canon, addr, port) {
        var sa, salen, ai;
        var res;
  
        salen = family === 10 ?
          28 :
          16;
        addr = family === 10 ?
          __inet_ntop6_raw(addr) :
          __inet_ntop4_raw(addr);
        sa = _malloc(salen);
        res = __write_sockaddr(sa, family, addr, port);
        assert(!res.errno);
  
        ai = _malloc(32);
        HEAP32[(((ai)+(4))>>2)]=family;
        HEAP32[(((ai)+(8))>>2)]=type;
        HEAP32[(((ai)+(12))>>2)]=proto;
        HEAP32[(((ai)+(24))>>2)]=canon;
        HEAP32[(((ai)+(20))>>2)]=sa;
        if (family === 10) {
          HEAP32[(((ai)+(16))>>2)]=28;
        } else {
          HEAP32[(((ai)+(16))>>2)]=16;
        }
        HEAP32[(((ai)+(28))>>2)]=0;
  
        return ai;
      }
  
      if (hint) {
        flags = HEAP32[((hint)>>2)];
        family = HEAP32[(((hint)+(4))>>2)];
        type = HEAP32[(((hint)+(8))>>2)];
        proto = HEAP32[(((hint)+(12))>>2)];
      }
      if (type && !proto) {
        proto = type === 2 ? 17 : 6;
      }
      if (!type && proto) {
        type = proto === 17 ? 2 : 1;
      }
  
      // If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
      // now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
      if (proto === 0) {
        proto = 6;
      }
      if (type === 0) {
        type = 1;
      }
  
      if (!node && !service) {
        return -2;
      }
      if (flags & ~(1|2|4|
          1024|8|16|32)) {
        return -1;
      }
      if (hint !== 0 && (HEAP32[((hint)>>2)] & 2) && !node) {
        return -1;
      }
      if (flags & 32) {
        // TODO
        return -2;
      }
      if (type !== 0 && type !== 1 && type !== 2) {
        return -7;
      }
      if (family !== 0 && family !== 2 && family !== 10) {
        return -6;
      }
  
      if (service) {
        service = UTF8ToString(service);
        port = parseInt(service, 10);
  
        if (isNaN(port)) {
          if (flags & 1024) {
            return -2;
          }
          // TODO support resolving well-known service names from:
          // http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
          return -8;
        }
      }
  
      if (!node) {
        if (family === 0) {
          family = 2;
        }
        if ((flags & 1) === 0) {
          if (family === 2) {
            addr = _htonl(2130706433);
          } else {
            addr = [0, 0, 0, 1];
          }
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAP32[((out)>>2)]=ai;
        return 0;
      }
  
      //
      // try as a numeric address
      //
      node = UTF8ToString(node);
      addr = __inet_pton4_raw(node);
      if (addr !== null) {
        // incoming node is a valid ipv4 address
        if (family === 0 || family === 2) {
          family = 2;
        }
        else if (family === 10 && (flags & 8)) {
          addr = [0, 0, _htonl(0xffff), addr];
          family = 10;
        } else {
          return -2;
        }
      } else {
        addr = __inet_pton6_raw(node);
        if (addr !== null) {
          // incoming node is a valid ipv6 address
          if (family === 0 || family === 10) {
            family = 10;
          } else {
            return -2;
          }
        }
      }
      if (addr != null) {
        ai = allocaddrinfo(family, type, proto, node, addr, port);
        HEAP32[((out)>>2)]=ai;
        return 0;
      }
      if (flags & 4) {
        return -2;
      }
  
      //
      // try as a hostname
      //
      // resolve the hostname to a temporary fake address
      node = DNS.lookup_name(node);
      addr = __inet_pton4_raw(node);
      if (family === 0) {
        family = 2;
      } else if (family === 10) {
        addr = [0, 0, _htonl(0xffff), addr];
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAP32[((out)>>2)]=ai;
      return 0;
    }
  Module["_getaddrinfo"] = _getaddrinfo;


  var GAI_ERRNO_MESSAGES={};
  Module["GAI_ERRNO_MESSAGES"] = GAI_ERRNO_MESSAGES;

  function _gai_strerror(val) {
      var buflen = 256;
  
      // On first call to gai_strerror we initialise the buffer and populate the error messages.
      if (!_gai_strerror.buffer) {
          _gai_strerror.buffer = _malloc(buflen);
  
          GAI_ERRNO_MESSAGES['0'] = 'Success';
          GAI_ERRNO_MESSAGES['' + -1] = 'Invalid value for \'ai_flags\' field';
          GAI_ERRNO_MESSAGES['' + -2] = 'NAME or SERVICE is unknown';
          GAI_ERRNO_MESSAGES['' + -3] = 'Temporary failure in name resolution';
          GAI_ERRNO_MESSAGES['' + -4] = 'Non-recoverable failure in name res';
          GAI_ERRNO_MESSAGES['' + -6] = '\'ai_family\' not supported';
          GAI_ERRNO_MESSAGES['' + -7] = '\'ai_socktype\' not supported';
          GAI_ERRNO_MESSAGES['' + -8] = 'SERVICE not supported for \'ai_socktype\'';
          GAI_ERRNO_MESSAGES['' + -10] = 'Memory allocation failure';
          GAI_ERRNO_MESSAGES['' + -11] = 'System error returned in \'errno\'';
          GAI_ERRNO_MESSAGES['' + -12] = 'Argument buffer overflow';
      }
  
      var msg = 'Unknown error';
  
      if (val in GAI_ERRNO_MESSAGES) {
        if (GAI_ERRNO_MESSAGES[val].length > buflen - 1) {
          msg = 'Message too long'; // EMSGSIZE message. This should never occur given the GAI_ERRNO_MESSAGES above.
        } else {
          msg = GAI_ERRNO_MESSAGES[val];
        }
      }
  
      writeAsciiToMemory(msg, _gai_strerror.buffer);
      return _gai_strerror.buffer;
    }
  Module["_gai_strerror"] = _gai_strerror;

  var Protocols={list:[],map:{}};
  Module["Protocols"] = Protocols;

  function _setprotoent(stayopen) {
      // void setprotoent(int stayopen);
  
      // Allocate and populate a protoent structure given a name, protocol number and array of aliases
      function allocprotoent(name, proto, aliases) {
        // write name into buffer
        var nameBuf = _malloc(name.length + 1);
        writeAsciiToMemory(name, nameBuf);
  
        // write aliases into buffer
        var j = 0;
        var length = aliases.length;
        var aliasListBuf = _malloc((length + 1) * 4); // Use length + 1 so we have space for the terminating NULL ptr.
  
        for (var i = 0; i < length; i++, j += 4) {
          var alias = aliases[i];
          var aliasBuf = _malloc(alias.length + 1);
          writeAsciiToMemory(alias, aliasBuf);
          HEAP32[(((aliasListBuf)+(j))>>2)]=aliasBuf;
        }
        HEAP32[(((aliasListBuf)+(j))>>2)]=0; // Terminating NULL pointer.
  
        // generate protoent
        var pe = _malloc(12);
        HEAP32[((pe)>>2)]=nameBuf;
        HEAP32[(((pe)+(4))>>2)]=aliasListBuf;
        HEAP32[(((pe)+(8))>>2)]=proto;
        return pe;
      };
  
      // Populate the protocol 'database'. The entries are limited to tcp and udp, though it is fairly trivial
      // to add extra entries from /etc/protocols if desired - though not sure if that'd actually be useful.
      var list = Protocols.list;
      var map  = Protocols.map;
      if (list.length === 0) {
          var entry = allocprotoent('tcp', 6, ['TCP']);
          list.push(entry);
          map['tcp'] = map['6'] = entry;
          entry = allocprotoent('udp', 17, ['UDP']);
          list.push(entry);
          map['udp'] = map['17'] = entry;
      }
  
      _setprotoent.index = 0;
    }
  Module["_setprotoent"] = _setprotoent;

  function _endprotoent() {
      // void endprotoent(void);
      // We're not using a real protocol database so we don't do a real close.
    }
  Module["_endprotoent"] = _endprotoent;

  function _getprotoent(number) {
      // struct protoent *getprotoent(void);
      // reads the  next  entry  from  the  protocols 'database' or return NULL if 'eof'
      if (_setprotoent.index === Protocols.list.length) {
        return 0;
      } else {
        var result = Protocols.list[_setprotoent.index++];
        return result;
      }
    }
  Module["_getprotoent"] = _getprotoent;

  function _getprotobyname(name) {
      // struct protoent *getprotobyname(const char *);
      name = UTF8ToString(name);
      _setprotoent(true);
      var result = Protocols.map[name];
      return result;
    }
  Module["_getprotobyname"] = _getprotobyname;

  function _getprotobynumber(number) {
      // struct protoent *getprotobynumber(int proto);
      _setprotoent(true);
      var result = Protocols.map[number];
      return result;
    }
  Module["_getprotobynumber"] = _getprotobynumber;


  function _getpwnam() { throw 'getpwnam: TODO' }
  Module["_getpwnam"] = _getpwnam;

  function _getpwnam_r() { throw 'getpwnam_r: TODO' }
  Module["_getpwnam_r"] = _getpwnam_r;

  function _getpwuid_r() { throw 'getpwuid_r: TODO' }
  Module["_getpwuid_r"] = _getpwuid_r;

  function _setpwent() { throw 'setpwent: TODO' }
  Module["_setpwent"] = _setpwent;

  function _getpwent() { throw 'getpwent: TODO' }
  Module["_getpwent"] = _getpwent;

  function _endpwent() { throw 'endpwent: TODO' }
  Module["_endpwent"] = _endpwent;

  function _getgrgid() { throw 'getgrgid: TODO' }
  Module["_getgrgid"] = _getgrgid;

  function _getgrgid_r() { throw 'getgrgid_r: TODO' }
  Module["_getgrgid_r"] = _getgrgid_r;

  function _getgrnam() { throw 'getgrnam: TODO' }
  Module["_getgrnam"] = _getgrnam;

  function _getgrnam_r() { throw 'getgrnam_r: TODO' }
  Module["_getgrnam_r"] = _getgrnam_r;

  function _getgrent() { throw 'getgrent: TODO' }
  Module["_getgrent"] = _getgrent;

  function _endgrent() { throw 'endgrent: TODO' }
  Module["_endgrent"] = _endgrent;

  function _setgrent() { throw 'setgrent: TODO' }
  Module["_setgrent"] = _setgrent;


  /** @suppress{checkTypes} */
  function _emscripten_run_script_int(ptr) {
      return eval(UTF8ToString(ptr))|0;
    }
  Module["_emscripten_run_script_int"] = _emscripten_run_script_int;

  function _emscripten_run_script_string(ptr) {
      var s = eval(UTF8ToString(ptr));
      if (s == null) {
        return 0;
      }
      s += '';
      var me = _emscripten_run_script_string;
      var len = lengthBytesUTF8(s);
      if (!me.bufferSize || me.bufferSize < len+1) {
        if (me.bufferSize) _free(me.buffer);
        me.bufferSize = len+1;
        me.buffer = _malloc(me.bufferSize);
      }
      stringToUTF8(s, me.buffer, me.bufferSize);
      return me.buffer;
    }
  Module["_emscripten_run_script_string"] = _emscripten_run_script_string;

  function _emscripten_random() {
      return Math.random();
    }
  Module["_emscripten_random"] = _emscripten_random;




  function __emscripten_traverse_stack(args) {
      if (!args || !args.callee || !args.callee.name) {
        return [null, '', ''];
      }
  
      var funstr = args.callee.toString();
      var funcname = args.callee.name;
      var str = '(';
      var first = true;
      for (var i in args) {
        var a = args[i];
        if (!first) {
          str += ", ";
        }
        first = false;
        if (typeof a === 'number' || typeof a === 'string') {
          str += a;
        } else {
          str += '(' + typeof a + ')';
        }
      }
      str += ')';
      var caller = args.callee.caller;
      args = caller ? caller.arguments : [];
      if (first)
        str = '';
      return [args, funcname, str];
    }
  Module["__emscripten_traverse_stack"] = __emscripten_traverse_stack;

  /** @param {number=} flags */
  function _emscripten_get_callstack_js(flags) {
      var callstack = jsStackTrace();
  
      // Find the symbols in the callstack that corresponds to the functions that report callstack information, and remove everything up to these from the output.
      var iThisFunc = callstack.lastIndexOf('_emscripten_log');
      var iThisFunc2 = callstack.lastIndexOf('_emscripten_get_callstack');
      var iNextLine = callstack.indexOf('\n', Math.max(iThisFunc, iThisFunc2))+1;
      callstack = callstack.slice(iNextLine);
  
      // If user requested to see the original source stack, but no source map information is available, just fall back to showing the JS stack.
      if (flags & 8/*EM_LOG_C_STACK*/ && typeof emscripten_source_map === 'undefined') {
        warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');
        flags ^= 8/*EM_LOG_C_STACK*/;
        flags |= 16/*EM_LOG_JS_STACK*/;
      }
  
      var stack_args = null;
      if (flags & 128 /*EM_LOG_FUNC_PARAMS*/) {
        // To get the actual parameters to the functions, traverse the stack via the unfortunately deprecated 'arguments.callee' method, if it works:
        stack_args = __emscripten_traverse_stack(arguments);
        while (stack_args[1].indexOf('_emscripten_') >= 0)
          stack_args = __emscripten_traverse_stack(stack_args[0]);
      }
  
      // Process all lines:
      var lines = callstack.split('\n');
      callstack = '';
      var newFirefoxRe = new RegExp('\\s*(.*?)@(.*?):([0-9]+):([0-9]+)'); // New FF30 with column info: extract components of form '       Object._main@http://server.com:4324:12'
      var firefoxRe = new RegExp('\\s*(.*?)@(.*):(.*)(:(.*))?'); // Old FF without column info: extract components of form '       Object._main@http://server.com:4324'
      var chromeRe = new RegExp('\\s*at (.*?) \\\((.*):(.*):(.*)\\\)'); // Extract components of form '    at Object._main (http://server.com/file.html:4324:12)'
  
      for (var l in lines) {
        var line = lines[l];
  
        var jsSymbolName = '';
        var file = '';
        var lineno = 0;
        var column = 0;
  
        var parts = chromeRe.exec(line);
        if (parts && parts.length == 5) {
          jsSymbolName = parts[1];
          file = parts[2];
          lineno = parts[3];
          column = parts[4];
        } else {
          parts = newFirefoxRe.exec(line);
          if (!parts) parts = firefoxRe.exec(line);
          if (parts && parts.length >= 4) {
            jsSymbolName = parts[1];
            file = parts[2];
            lineno = parts[3];
            column = parts[4]|0; // Old Firefox doesn't carry column information, but in new FF30, it is present. See https://bugzilla.mozilla.org/show_bug.cgi?id=762556
          } else {
            // Was not able to extract this line for demangling/sourcemapping purposes. Output it as-is.
            callstack += line + '\n';
            continue;
          }
        }
  
        // Try to demangle the symbol, but fall back to showing the original JS symbol name if not available.
        var cSymbolName = (flags & 32/*EM_LOG_DEMANGLE*/) ? demangle(jsSymbolName) : jsSymbolName;
        if (!cSymbolName) {
          cSymbolName = jsSymbolName;
        }
  
        var haveSourceMap = false;
  
        if (flags & 8/*EM_LOG_C_STACK*/) {
          var orig = emscripten_source_map.originalPositionFor({line: lineno, column: column});
          haveSourceMap = (orig && orig.source);
          if (haveSourceMap) {
            if (flags & 64/*EM_LOG_NO_PATHS*/) {
              orig.source = orig.source.substring(orig.source.replace(/\\/g, "/").lastIndexOf('/')+1);
            }
            callstack += '    at ' + cSymbolName + ' (' + orig.source + ':' + orig.line + ':' + orig.column + ')\n';
          }
        }
        if ((flags & 16/*EM_LOG_JS_STACK*/) || !haveSourceMap) {
          if (flags & 64/*EM_LOG_NO_PATHS*/) {
            file = file.substring(file.replace(/\\/g, "/").lastIndexOf('/')+1);
          }
          callstack += (haveSourceMap ? ('     = '+jsSymbolName) : ('    at '+cSymbolName)) + ' (' + file + ':' + lineno + ':' + column + ')\n';
        }
  
        // If we are still keeping track with the callstack by traversing via 'arguments.callee', print the function parameters as well.
        if (flags & 128 /*EM_LOG_FUNC_PARAMS*/ && stack_args[0]) {
          if (stack_args[1] == jsSymbolName && stack_args[2].length > 0) {
            callstack = callstack.replace(/\s+$/, '');
            callstack += ' with values: ' + stack_args[1] + stack_args[2] + '\n';
          }
          stack_args = __emscripten_traverse_stack(stack_args[0]);
        }
      }
      // Trim extra whitespace at the end of the output.
      callstack = callstack.replace(/\s+$/, '');
      return callstack;
    }
  Module["_emscripten_get_callstack_js"] = _emscripten_get_callstack_js;

  function _emscripten_get_callstack(flags, str, maxbytes) {
      var callstack = _emscripten_get_callstack_js(flags);
      // User can query the required amount of bytes to hold the callstack.
      if (!str || maxbytes <= 0) {
        return lengthBytesUTF8(callstack)+1;
      }
      // Output callstack string as C string to HEAP.
      var bytesWrittenExcludingNull = stringToUTF8(callstack, str, maxbytes);
  
      // Return number of bytes written, including null.
      return bytesWrittenExcludingNull+1;
    }
  Module["_emscripten_get_callstack"] = _emscripten_get_callstack;

  function _emscripten_log_js(flags, str) {
      if (flags & 24/*EM_LOG_C_STACK | EM_LOG_JS_STACK*/) {
        str = str.replace(/\s+$/, ''); // Ensure the message and the callstack are joined cleanly with exactly one newline.
        str += (str.length > 0 ? '\n' : '') + _emscripten_get_callstack_js(flags);
      }
  
      if (flags & 1 /*EM_LOG_CONSOLE*/) {
        if (flags & 4 /*EM_LOG_ERROR*/) {
          console.error(str);
        } else if (flags & 2 /*EM_LOG_WARN*/) {
          console.warn(str);
        } else if (flags & 512 /*EM_LOG_INFO*/) {
          console.info(str);
        } else if (flags & 256 /*EM_LOG_DEBUG*/) {
          console.debug(str);
        } else {
          console.log(str);
        }
      } else if (flags & 6 /*EM_LOG_ERROR|EM_LOG_WARN*/) {
        err(str);
      } else {
        out(str);
      }
    }
  Module["_emscripten_log_js"] = _emscripten_log_js;

  
  
  function reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }
  Module["reallyNegative"] = reallyNegative;
  
  function convertI32PairToI53(lo, hi) {
      // This function should not be getting called with too large unsigned numbers
      // in high part (if hi >= 0x7FFFFFFFF, one should have been calling
      // convertU32PairToI53())
      assert(hi === (hi|0));
      return (lo >>> 0) + hi * 4294967296;
    }
  Module["convertI32PairToI53"] = convertI32PairToI53;
  
  function convertU32PairToI53(lo, hi) {
      return (lo >>> 0) + (hi >>> 0) * 4294967296;
    }
  Module["convertU32PairToI53"] = convertU32PairToI53;function formatString(format, varargs) {
      assert((varargs & 3) === 0);
      var textIndex = format;
      var argIndex = varargs;
      // This must be called before reading a double or i64 vararg. It will bump the pointer properly.
      // It also does an assert on i32 values, so it's nice to call it before all varargs calls.
      function prepVararg(ptr, type) {
        if (type === 'double' || type === 'i64') {
          // move so the load is aligned
          if (ptr & 7) {
            assert((ptr & 7) === 4);
            ptr += 4;
          }
        } else {
          assert((ptr & 3) === 0);
        }
        return ptr;
      }
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        argIndex = prepVararg(argIndex, type);
        if (type === 'double') {
          ret = HEAPF64[((argIndex)>>3)];
          argIndex += 8;
        } else if (type == 'i64') {
          ret = [HEAP32[((argIndex)>>2)],
                 HEAP32[(((argIndex)+(4))>>2)]];
          argIndex += 8;
        } else {
          assert((argIndex & 3) === 0);
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[((argIndex)>>2)];
          argIndex += 4;
        }
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[((textIndex)>>0)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)>>0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)>>0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)>>0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)>>0)];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)>>0)];
  
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              currArg = getNextArg('i' + (argSize * 8));
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = next == 117 ? convertU32PairToI53(currArg[0], currArg[1]) : convertI32PairToI53(currArg[0], currArg[1]);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
  
              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }
  
              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }
  
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
  
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
  
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
  
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
  
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
  
                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }
  
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
  
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
  
              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)>>0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[((i)>>0)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }
  Module["formatString"] = formatString;function _emscripten_log(flags, format, varargs) {
      var str = '';
      var result = formatString(format, varargs);
      for (var i = 0 ; i < result.length; ++i) {
        str += String.fromCharCode(result[i]);
      }
      _emscripten_log_js(flags, str);
    }
  Module["_emscripten_log"] = _emscripten_log;

  function _emscripten_get_compiler_setting(name) {
      name = UTF8ToString(name);
  
      var ret = getCompilerSetting(name);
      if (typeof ret === 'number') return ret;
  
      if (!_emscripten_get_compiler_setting.cache) _emscripten_get_compiler_setting.cache = {};
      var cache = _emscripten_get_compiler_setting.cache;
      var fullname = name + '__str';
      var fullret = cache[fullname];
      if (fullret) return fullret;
      return cache[fullname] = allocate(intArrayFromString(ret + ''), 'i8', ALLOC_NORMAL);
    }
  Module["_emscripten_get_compiler_setting"] = _emscripten_get_compiler_setting;


  function _emscripten_debugger() {
      debugger;
    }
  Module["_emscripten_debugger"] = _emscripten_debugger;

  function _emscripten_print_double(x, to, max) {
      var str = x + '';
      if (to) return stringToUTF8(str, to, max);
      else return lengthBytesUTF8(str);
    }
  Module["_emscripten_print_double"] = _emscripten_print_double;

  function _emscripten_generate_pc(frame) {
      abort('Cannot use emscripten_generate_pc (needed by __builtin_return_address) without -s USE_OFFSET_CONVERTER');
      var match;
  
      if (match = /\bwasm-function\[\d+\]:(0x[0-9a-f]+)/.exec(frame)) {
        // some engines give the binary offset directly, so we use that as return address
        return +match[1];
      } else if (match = /\bwasm-function\[(\d+)\]:(\d+)/.exec(frame)) {
        // other engines only give function index and offset in the function,
        // so we try using the offset converter. If that doesn't work,
        // we pack index and offset into a "return address"
        return wasmOffsetConverter.convert(+match[1], +match[2]);
      } else if (match = /:(\d+):\d+(?:\)|$)/.exec(frame)) {
        // if we are in js, we can use the js line number as the "return address"
        // this should work for wasm2js and fastcomp
        // we tag the high bit to distinguish this from wasm addresses
        return 0x80000000 | +match[1];
      } else {
        // return 0 if we can't find any
        return 0;
      }
    }
  Module["_emscripten_generate_pc"] = _emscripten_generate_pc;

  function _emscripten_return_address(level) {
      var callstack = new Error().stack.split('\n');
      if (callstack[0] == 'Error') {
        callstack.shift();
      }
      // skip this function and the caller to get caller's return address
      return _emscripten_generate_pc(callstack[level + 2]);
    }
  Module["_emscripten_return_address"] = _emscripten_return_address;

  var UNWIND_CACHE={};
  Module["UNWIND_CACHE"] = UNWIND_CACHE;

  
  function __emscripten_save_in_unwind_cache(callstack) {
      callstack.forEach(function (frame) {
        var pc = _emscripten_generate_pc(frame);
        if (pc) {
          UNWIND_CACHE[pc] = frame;
        }
      });
    }
  Module["__emscripten_save_in_unwind_cache"] = __emscripten_save_in_unwind_cache;function _emscripten_stack_snapshot() {
      var callstack = new Error().stack.split('\n');
      if (callstack[0] == 'Error') {
        callstack.shift();
      }
      __emscripten_save_in_unwind_cache(callstack);
  
      // Caches the stack snapshot so that emscripten_stack_unwind_buffer() can unwind from this spot.
      UNWIND_CACHE.last_addr = _emscripten_generate_pc(callstack[2]);
      UNWIND_CACHE.last_stack = callstack;
      return UNWIND_CACHE.last_addr;
    }
  Module["_emscripten_stack_snapshot"] = _emscripten_stack_snapshot;


  function _emscripten_stack_unwind_buffer(addr, buffer, count) {
      var stack;
      if (UNWIND_CACHE.last_addr == addr) {
        stack = UNWIND_CACHE.last_stack;
      } else {
        stack = new Error().stack.split('\n');
        if (stack[0] == 'Error') {
          stack.shift();
        }
        __emscripten_save_in_unwind_cache(stack);
      }
  
      var offset = 2;
      while (stack[offset] && _emscripten_generate_pc(stack[offset]) != addr) {
        ++offset;
      }
  
      for (var i = 0; i < count && stack[i+offset]; ++i) {
        HEAP32[(((buffer)+(i*4))>>2)]=_emscripten_generate_pc(stack[i + offset]);
      }
      return i;
    }
  Module["_emscripten_stack_unwind_buffer"] = _emscripten_stack_unwind_buffer;

  
  /** @suppress{checkTypes} */
  function _emscripten_with_builtin_malloc(func) {
      var prev_malloc = typeof _malloc !== 'undefined' ? _malloc : undefined;
      var prev_memalign = typeof _memalign !== 'undefined' ? _memalign : undefined;
      var prev_free = typeof _free !== 'undefined' ? _free : undefined;
      _malloc = _emscripten_builtin_malloc;
      _memalign = _emscripten_builtin_memalign;
      _free = _emscripten_builtin_free;
      try {
        return func();
      } finally {
        _malloc = prev_malloc;
        _memalign = prev_memalign;
        _free = prev_free;
      }
    }
  Module["_emscripten_with_builtin_malloc"] = _emscripten_with_builtin_malloc;function _emscripten_pc_get_function(pc) {
      abort('Cannot use emscripten_pc_get_function without -s USE_OFFSET_CONVERTER');
      var name;
      if (pc & 0x80000000) {
        // If this is a JavaScript function, try looking it up in the unwind cache.
        var frame = UNWIND_CACHE[pc];
        if (!frame) return 0;
  
        var match;
        if (match = /^\s+at (.*) \(.*\)$/.exec(frame)) {
          name = match[1];
        } else if (match = /^(.+?)@/.exec(frame)) {
          name = match[1];
        } else {
          return 0;
        }
      } else {
        name = wasmOffsetConverter.getName(pc);
      }
      _emscripten_with_builtin_malloc(function () {
        if (_emscripten_pc_get_function.ret) _free(_emscripten_pc_get_function.ret);
        _emscripten_pc_get_function.ret = allocateUTF8(name);
      });
      return _emscripten_pc_get_function.ret;
    }
  Module["_emscripten_pc_get_function"] = _emscripten_pc_get_function;

  function _emscripten_pc_get_source_js(pc) {
      if (UNWIND_CACHE.last_get_source_pc == pc) return UNWIND_CACHE.last_source;
  
      var match;
      var source;
  
      if (!source) {
        var frame = UNWIND_CACHE[pc];
        if (!frame) return null;
        // Example: at callMain (a.out.js:6335:22)
        if (match = /\((.*):(\d+):(\d+)\)$/.exec(frame)) {
          source = {file: match[1], line: match[2], column: match[3]};
        // Example: main@a.out.js:1337:42
        } else if (match = /@(.*):(\d+):(\d+)/.exec(frame)) {
          source = {file: match[1], line: match[2], column: match[3]};
        }
      }
      UNWIND_CACHE.last_get_source_pc = pc;
      UNWIND_CACHE.last_source = source;
      return source;
    }
  Module["_emscripten_pc_get_source_js"] = _emscripten_pc_get_source_js;

  function _emscripten_pc_get_file(pc) {
      var result = _emscripten_pc_get_source_js(pc);
      if (!result) return 0;
  
      _emscripten_with_builtin_malloc(function () {
        if (_emscripten_pc_get_file.ret) _free(_emscripten_pc_get_file.ret);
        _emscripten_pc_get_file.ret = allocateUTF8(result.file);
      });
      return _emscripten_pc_get_file.ret;
    }
  Module["_emscripten_pc_get_file"] = _emscripten_pc_get_file;

  function _emscripten_pc_get_line(pc) {
      var result = _emscripten_pc_get_source_js(pc);
      return result ? result.line : 0;
    }
  Module["_emscripten_pc_get_line"] = _emscripten_pc_get_line;

  function _emscripten_pc_get_column(pc) {
      var result = _emscripten_pc_get_source_js(pc);
      return result ? result.column || 0 : 0;
    }
  Module["_emscripten_pc_get_column"] = _emscripten_pc_get_column;

  function _emscripten_get_module_name(buf, length) {
      return stringToUTF8(wasmBinaryFile, buf, length);
    }
  Module["_emscripten_get_module_name"] = _emscripten_get_module_name;


  function _emscripten_builtin_mmap2(addr, len, prot, flags, fd, off) {
      return _emscripten_with_builtin_malloc(function () {
        return syscallMmap2(addr, len, prot, flags, fd, off);
      });
    }
  Module["_emscripten_builtin_mmap2"] = _emscripten_builtin_mmap2;

  function _emscripten_builtin_munmap(addr, len) {
      return _emscripten_with_builtin_malloc(function () {
        return syscallMunmap(addr, len);
      });
    }
  Module["_emscripten_builtin_munmap"] = _emscripten_builtin_munmap;

  function _emscripten_get_stack_top() {
      return STACKTOP;
    }
  Module["_emscripten_get_stack_top"] = _emscripten_get_stack_top;

  function _emscripten_get_stack_base() {
      return STACK_BASE;
    }
  Module["_emscripten_get_stack_base"] = _emscripten_get_stack_base;



  function jstoi_s(str) {
      return Number(str);
    }
  Module["jstoi_s"] = jstoi_s;

  function _i64Add(a, b, c, d) {
      /*
        x = a + b*2^32
        y = c + d*2^32
        result = l + h*2^32
      */
      a = a|0; b = b|0; c = c|0; d = d|0;
      var l = 0, h = 0;
      l = (a + c)>>>0;
      h = (b + d + (((l>>>0) < (a>>>0))|0))>>>0; // Add carry from low word to high word on overflow.
      return ((setTempRet0((h) | 0),l|0)|0);
    }
  Module["_i64Add"] = _i64Add;

  function _i64Subtract(a, b, c, d) {
      a = a|0; b = b|0; c = c|0; d = d|0;
      var l = 0, h = 0;
      l = (a - c)>>>0;
      h = (b - d)>>>0;
      h = (b - d - (((c>>>0) > (a>>>0))|0))>>>0; // Borrow one from high word to low word on underflow.
      return ((setTempRet0((h) | 0),l|0)|0);
    }
  Module["_i64Subtract"] = _i64Subtract;

  function _bitshift64Shl(low, high, bits) {
      low = low|0; high = high|0; bits = bits|0;
      var ander = 0;
      if ((bits|0) < 32) {
        ander = ((1 << bits) - 1)|0;
        setTempRet0(((high << bits) | ((low&(ander << (32 - bits))) >>> (32 - bits))) | 0);
        return low << bits;
      }
      setTempRet0((low << (bits - 32)) | 0);
      return 0;
    }
  Module["_bitshift64Shl"] = _bitshift64Shl;

  function _bitshift64Ashr(low, high, bits) {
      low = low|0; high = high|0; bits = bits|0;
      var ander = 0;
      if ((bits|0) < 32) {
        ander = ((1 << bits) - 1)|0;
        setTempRet0((high >> bits) | 0);
        return (low >>> bits) | ((high&ander) << (32 - bits));
      }
      setTempRet0(((high|0) < 0 ? -1 : 0) | 0);
      return (high >> (bits - 32))|0;
    }
  Module["_bitshift64Ashr"] = _bitshift64Ashr;

  function _bitshift64Lshr(low, high, bits) {
      low = low|0; high = high|0; bits = bits|0;
      var ander = 0;
      if ((bits|0) < 32) {
        ander = ((1 << bits) - 1)|0;
        setTempRet0((high >>> bits) | 0);
        return (low >>> bits) | ((high&ander) << (32 - bits));
      }
      setTempRet0((0) | 0);
      return (high >>> (bits - 32))|0;
    }
  Module["_bitshift64Lshr"] = _bitshift64Lshr;

  function __Unwind_Backtrace(func, arg) {
      var trace = _emscripten_get_callstack_js();
      var parts = trace.split('\n');
      for (var i = 0; i < parts.length; i++) {
        var ret = dynCall_iii(func, 0, arg);
        if (ret !== 0) return;
      }
    }
  Module["__Unwind_Backtrace"] = __Unwind_Backtrace;

  function __Unwind_GetIPInfo() {
      abort('Unwind_GetIPInfo');
    }
  Module["__Unwind_GetIPInfo"] = __Unwind_GetIPInfo;

  function __Unwind_FindEnclosingFunction() {
      return 0; // we cannot succeed
    }
  Module["__Unwind_FindEnclosingFunction"] = __Unwind_FindEnclosingFunction;

  
  
  var ___exception_infos={};
  Module["___exception_infos"] = ___exception_infos;
  
  var ___exception_last=0;
  Module["___exception_last"] = ___exception_last;
  
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return __ZSt18uncaught_exceptionv.uncaught_exceptions > 0;
    }
  Module["__ZSt18uncaught_exceptionv"] = __ZSt18uncaught_exceptionv;function ___cxa_throw(ptr, type, destructor) {
      ___exception_infos[ptr] = {
        ptr: ptr,
        adjusted: [ptr],
        type: type,
        destructor: destructor,
        refcount: 0,
        caught: false,
        rethrown: false
      };
      ___exception_last = ptr;
      if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exceptions++;
      }
      throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch." + " (note: in dynamic linking, if a side module wants exceptions, the main module must be built with that support)";
    }
  Module["___cxa_throw"] = ___cxa_throw;function __Unwind_RaiseException(ex) {
      err('Warning: _Unwind_RaiseException is not correctly implemented');
      return ___cxa_throw(ex, 0, 0);
    }
  Module["__Unwind_RaiseException"] = __Unwind_RaiseException;

  function __Unwind_DeleteException(ex) {
      err('TODO: Unwind_DeleteException');
    }
  Module["__Unwind_DeleteException"] = __Unwind_DeleteException;

  function _emscripten_autodebug_i64(line, valuel, valueh) {
      out('AD:' + [line, valuel, valueh]);
    }
  Module["_emscripten_autodebug_i64"] = _emscripten_autodebug_i64;

  function _emscripten_autodebug_i32(line, value) {
      out('AD:' + [line, value]);
    }
  Module["_emscripten_autodebug_i32"] = _emscripten_autodebug_i32;

  function _emscripten_autodebug_i16(line, value) {
      out('AD:' + [line, value]);
    }
  Module["_emscripten_autodebug_i16"] = _emscripten_autodebug_i16;

  function _emscripten_autodebug_i8(line, value) {
      out('AD:' + [line, value]);
    }
  Module["_emscripten_autodebug_i8"] = _emscripten_autodebug_i8;

  function _emscripten_autodebug_float(line, value) {
      out('AD:' + [line, value]);
    }
  Module["_emscripten_autodebug_float"] = _emscripten_autodebug_float;

  function _emscripten_autodebug_double(line, value) {
      out('AD:' + [line, value]);
    }
  Module["_emscripten_autodebug_double"] = _emscripten_autodebug_double;

  function _emscripten_scan_stack(func) {
      var base = STACK_BASE; // TODO verify this is right on pthreads
      var end = stackSave();
      dynCall_vii(func, Math.min(base, end), Math.max(base, end));
    }
  Module["_emscripten_scan_stack"] = _emscripten_scan_stack;

  function _emscripten_prep_setjmp() {}
  Module["_emscripten_prep_setjmp"] = _emscripten_prep_setjmp;

  function _emscripten_cleanup_setjmp() {}
  Module["_emscripten_cleanup_setjmp"] = _emscripten_cleanup_setjmp;

  function _emscripten_check_longjmp() {}
  Module["_emscripten_check_longjmp"] = _emscripten_check_longjmp;

  function _emscripten_get_longjmp_result() {}
  Module["_emscripten_get_longjmp_result"] = _emscripten_get_longjmp_result;

  function _emscripten_setjmp() {}
  Module["_emscripten_setjmp"] = _emscripten_setjmp;

  function _emscripten_preinvoke() {}
  Module["_emscripten_preinvoke"] = _emscripten_preinvoke;

  function _emscripten_postinvoke() {}
  Module["_emscripten_postinvoke"] = _emscripten_postinvoke;

  function _emscripten_resume() {}
  Module["_emscripten_resume"] = _emscripten_resume;

  function _emscripten_landingpad() {}
  Module["_emscripten_landingpad"] = _emscripten_landingpad;

  function _getHigh32() {}
  Module["_getHigh32"] = _getHigh32;

  function _setHigh32() {}
  Module["_setHigh32"] = _setHigh32;

  function _FtoILow() {}
  Module["_FtoILow"] = _FtoILow;

  function _FtoIHigh() {}
  Module["_FtoIHigh"] = _FtoIHigh;

  function _DtoILow() {}
  Module["_DtoILow"] = _DtoILow;

  function _DtoIHigh() {}
  Module["_DtoIHigh"] = _DtoIHigh;

  function _BDtoILow() {}
  Module["_BDtoILow"] = _BDtoILow;

  function _BDtoIHigh() {}
  Module["_BDtoIHigh"] = _BDtoIHigh;

  function _SItoF() {}
  Module["_SItoF"] = _SItoF;

  function _UItoF() {}
  Module["_UItoF"] = _UItoF;

  function _SItoD() {}
  Module["_SItoD"] = _SItoD;

  function _UItoD() {}
  Module["_UItoD"] = _UItoD;

  function _BItoD() {}
  Module["_BItoD"] = _BItoD;

  function _llvm_dbg_value() {}
  Module["_llvm_dbg_value"] = _llvm_dbg_value;

  function _llvm_debugtrap() {}
  Module["_llvm_debugtrap"] = _llvm_debugtrap;

  function _llvm_ctlz_i32() {}
  Module["_llvm_ctlz_i32"] = _llvm_ctlz_i32;

  function _emscripten_asm_const() {}
  Module["_emscripten_asm_const"] = _emscripten_asm_const;

  function _emscripten_asm_const_int() {}
  Module["_emscripten_asm_const_int"] = _emscripten_asm_const_int;

  function _emscripten_asm_const_double() {}
  Module["_emscripten_asm_const_double"] = _emscripten_asm_const_double;

  function _emscripten_asm_const_int_sync_on_main_thread() {}
  Module["_emscripten_asm_const_int_sync_on_main_thread"] = _emscripten_asm_const_int_sync_on_main_thread;

  function _emscripten_asm_const_double_sync_on_main_thread() {}
  Module["_emscripten_asm_const_double_sync_on_main_thread"] = _emscripten_asm_const_double_sync_on_main_thread;

  function _emscripten_asm_const_async_on_main_thread() {}
  Module["_emscripten_asm_const_async_on_main_thread"] = _emscripten_asm_const_async_on_main_thread;











  function _sigemptyset(set) {
      HEAP32[((set)>>2)]=0;
      return 0;
    }
  Module["_sigemptyset"] = _sigemptyset;


  function _sigaddset(set, signum) {
      HEAP32[((set)>>2)]=HEAP32[((set)>>2)]| (1 << (signum-1));
      return 0;
    }
  Module["_sigaddset"] = _sigaddset;

  function _sigdelset(set, signum) {
      HEAP32[((set)>>2)]=HEAP32[((set)>>2)]& (~(1 << (signum-1)));
      return 0;
    }
  Module["_sigdelset"] = _sigdelset;

  function _sigismember(set, signum) {
      return HEAP32[((set)>>2)] & (1 << (signum-1));
    }
  Module["_sigismember"] = _sigismember;


  function _sigprocmask() {
      err('Calling stub instead of sigprocmask()');
      return 0;
    }
  Module["_sigprocmask"] = _sigprocmask;

  function ___libc_current_sigrtmin() {
      err('Calling stub instead of __libc_current_sigrtmin');
      return 0;
    }
  Module["___libc_current_sigrtmin"] = ___libc_current_sigrtmin;

  function ___libc_current_sigrtmax() {
      err('Calling stub instead of __libc_current_sigrtmax');
      return 0;
    }
  Module["___libc_current_sigrtmax"] = ___libc_current_sigrtmax;

  function _kill(pid, sig) {
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/kill.html
      // Makes no sense in a single-process environment.
  	  // Should kill itself somtimes depending on `pid`
      err('Calling stub instead of kill()');
      setErrNo(ERRNO_CODES.EPERM);
      return -1;
    }
  Module["_kill"] = _kill;

  function _killpg() {
      err('Calling stub instead of killpg()');
      setErrNo(ERRNO_CODES.EPERM);
      return -1;
    }
  Module["_killpg"] = _killpg;

  function _siginterrupt() {
      err('Calling stub instead of siginterrupt()');
      return 0;
    }
  Module["_siginterrupt"] = _siginterrupt;

  function _raise(sig) {
      err('Calling stub instead of raise()');
    setErrNo(ERRNO_CODES.ENOSYS);
      warnOnce('raise() returning an error as we do not support it');
      return -1;
    }
  Module["_raise"] = _raise;

  function _alarm(seconds) {
      setTimeout(function() {
        if (__sigalrm_handler) dynCall_vi(__sigalrm_handler, 0);
      }, seconds*1000);
    }
  Module["_alarm"] = _alarm;



  function _getitimer() {
      throw 'getitimer() is not implemented yet';
    }
  Module["_getitimer"] = _getitimer;


  function _siglongjmp(env, value) {
      // We cannot wrap the sigsetjmp, but I hope that
      // in most cases siglongjmp will be called later.
  
      // siglongjmp can be called very many times, so don't flood the stderr.
      warnOnce("Calling longjmp() instead of siglongjmp()");
      _longjmp(env, value);
    }
  Module["_siglongjmp"] = _siglongjmp;

  function _sigpending(set) {
      HEAP32[((set)>>2)]=0;
      return 0;
    }
  Module["_sigpending"] = _sigpending;




  function ___sys_exit(status) {try {
  
      exit(status);
      // no return
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_exit"] = ___sys_exit;


  function ___sys_write(fd, buf, count) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return FS.write(stream, HEAP8,buf, count);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_write"] = ___sys_write;























  function ___sys_getpgrp() {
      return 42;
    }
  Module["___sys_getpgrp"] = ___sys_getpgrp;











  function ___sys_setitimer(which, new_value, old_value) {
      return -52; // unsupported feature
    }
  Module["___sys_setitimer"] = ___sys_setitimer;

















  var ___sys_rt_sigqueueinfo__nothrow=true;
  Module["___sys_rt_sigqueueinfo__nothrow"] = ___sys_rt_sigqueueinfo__nothrow;

  function ___sys_rt_sigqueueinfo(tgid, pid, uinfo) {
      return 0;
    }
  Module["___sys_rt_sigqueueinfo"] = ___sys_rt_sigqueueinfo;












  var ___sys_getuid32__nothrow=true;
  Module["___sys_getuid32__nothrow"] = ___sys_getuid32__nothrow;


  var ___sys_getgid32__nothrow=true;
  Module["___sys_getgid32__nothrow"] = ___sys_getgid32__nothrow;


  var ___sys_geteuid32__nothrow=true;
  Module["___sys_geteuid32__nothrow"] = ___sys_geteuid32__nothrow;





  var ___sys_setreuid32__nothrow=true;
  Module["___sys_setreuid32__nothrow"] = ___sys_setreuid32__nothrow;

  
  function ___sys_setregid32(ruid, euid) {
      if (uid !== 0) return -63;
      return 0;
    }
  Module["___sys_setregid32"] = ___sys_setregid32;function ___sys_setreuid32(a0,a1
  ) {
  return ___sys_setregid32(a0,a1);
  }
  Module["___sys_setreuid32"] = ___sys_setreuid32;


  var ___sys_setuid32__nothrow=true;
  Module["___sys_setuid32__nothrow"] = ___sys_setuid32__nothrow;

  
  function ___sys_setgid32(uid) {
      if (uid !== 0) return -63;
      return 0;
    }
  Module["___sys_setgid32"] = ___sys_setgid32;function ___sys_setuid32(a0
  ) {
  return ___sys_setgid32(a0);
  }
  Module["___sys_setuid32"] = ___sys_setuid32;



  var ___sys_setresuid32__nothrow=true;
  Module["___sys_setresuid32__nothrow"] = ___sys_setresuid32__nothrow;

  
  function ___sys_setresgid32(ruid, euid, suid) {
      if (euid !== 0) return -63;
      return 0;
    }
  Module["___sys_setresgid32"] = ___sys_setresgid32;function ___sys_setresuid32(a0,a1,a2
  ) {
  return ___sys_setresgid32(a0,a1,a2);
  }
  Module["___sys_setresuid32"] = ___sys_setresuid32;


  var ___sys_getresuid32__nothrow=true;
  Module["___sys_getresuid32__nothrow"] = ___sys_getresuid32__nothrow;







  function ___sys_exit_group(status) {
      exit(status);
      return 0;
    }
  Module["___sys_exit_group"] = ___sys_exit_group;



  var ___sys_fadvise64_64__nothrow=true;
  Module["___sys_fadvise64_64__nothrow"] = ___sys_fadvise64_64__nothrow;













  function ___sys_faccessat(dirfd, path, amode, flags) {try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doAccess(path, amode);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
  Module["___sys_faccessat"] = ___sys_faccessat;





























  function _emscripten_set_click_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 4, "click", targetThread);
      return 0;
    }
  Module["_emscripten_set_click_callback_on_thread"] = _emscripten_set_click_callback_on_thread;



  function _emscripten_set_dblclick_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 7, "dblclick", targetThread);
      return 0;
    }
  Module["_emscripten_set_dblclick_callback_on_thread"] = _emscripten_set_dblclick_callback_on_thread;




  function _emscripten_set_mouseover_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 35, "mouseover", targetThread);
      return 0;
    }
  Module["_emscripten_set_mouseover_callback_on_thread"] = _emscripten_set_mouseover_callback_on_thread;

  function _emscripten_set_mouseout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerMouseEventCallback(target, userData, useCapture, callbackfunc, 36, "mouseout", targetThread);
      return 0;
    }
  Module["_emscripten_set_mouseout_callback_on_thread"] = _emscripten_set_mouseout_callback_on_thread;

  function _emscripten_get_mouse_status(mouseState) {
      if (!JSEvents.mouseEvent) return -7;
      // HTML5 does not really have a polling API for mouse events, so implement one manually by
      // returning the data from the most recently received event. This requires that user has registered
      // at least some no-op function as an event handler to any of the mouse function.
      HEAP8.set(HEAP8.subarray(JSEvents.mouseEvent, JSEvents.mouseEvent + 64), mouseState);
      return 0;
    }
  Module["_emscripten_get_mouse_status"] = _emscripten_get_mouse_status;





  function _emscripten_set_scroll_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerUiEventCallback(target, userData, useCapture, callbackfunc, 11, "scroll", targetThread);
      return 0;
    }
  Module["_emscripten_set_scroll_callback_on_thread"] = _emscripten_set_scroll_callback_on_thread;




  function _emscripten_set_focusin_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerFocusEventCallback(target, userData, useCapture, callbackfunc, 14, "focusin", targetThread);
      return 0;
    }
  Module["_emscripten_set_focusin_callback_on_thread"] = _emscripten_set_focusin_callback_on_thread;

  function _emscripten_set_focusout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerFocusEventCallback(target, userData, useCapture, callbackfunc, 15, "focusout", targetThread);
      return 0;
    }
  Module["_emscripten_set_focusout_callback_on_thread"] = _emscripten_set_focusout_callback_on_thread;

  function __fillDeviceOrientationEventData(eventStruct, e, target) {
      HEAPF64[((eventStruct)>>3)]=e.alpha;
      HEAPF64[(((eventStruct)+(8))>>3)]=e.beta;
      HEAPF64[(((eventStruct)+(16))>>3)]=e.gamma;
      HEAP32[(((eventStruct)+(24))>>2)]=e.absolute;
    }
  Module["__fillDeviceOrientationEventData"] = __fillDeviceOrientationEventData;

  function __registerDeviceOrientationEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.deviceOrientationEvent) JSEvents.deviceOrientationEvent = _malloc( 32 );
  
      var deviceOrientationEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        __fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent, e, target); // TODO: Thread-safety with respect to emscripten_get_deviceorientation_status()
  
        if (dynCall_iiii(callbackfunc, eventTypeId, JSEvents.deviceOrientationEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: deviceOrientationEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerDeviceOrientationEventCallback"] = __registerDeviceOrientationEventCallback;

  function _emscripten_set_deviceorientation_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      __registerDeviceOrientationEventCallback(2, userData, useCapture, callbackfunc, 16, "deviceorientation", targetThread);
      return 0;
    }
  Module["_emscripten_set_deviceorientation_callback_on_thread"] = _emscripten_set_deviceorientation_callback_on_thread;

  function _emscripten_get_deviceorientation_status(orientationState) {
      if (!JSEvents.deviceOrientationEvent) return -7;
      // HTML5 does not really have a polling API for device orientation events, so implement one manually by
      // returning the data from the most recently received event. This requires that user has registered
      // at least some no-op function as an event handler.
      HEAP32.set(HEAP32.subarray(JSEvents.deviceOrientationEvent, 32), orientationState);
      return 0;
    }
  Module["_emscripten_get_deviceorientation_status"] = _emscripten_get_deviceorientation_status;

  function __fillDeviceMotionEventData(eventStruct, e, target) {
      var supportedFields = 0;
      var a = e['acceleration'];
      supportedFields |= a && 1;
      var ag = e['accelerationIncludingGravity'];
      supportedFields |= ag && 2;
      var rr = e['rotationRate'];
      supportedFields |= rr && 4;
      a = a || {};
      ag = ag || {};
      rr = rr || {};
      HEAPF64[((eventStruct)>>3)]=a["x"];
      HEAPF64[(((eventStruct)+(8))>>3)]=a["y"];
      HEAPF64[(((eventStruct)+(16))>>3)]=a["z"];
      HEAPF64[(((eventStruct)+(24))>>3)]=ag["x"];
      HEAPF64[(((eventStruct)+(32))>>3)]=ag["y"];
      HEAPF64[(((eventStruct)+(40))>>3)]=ag["z"];
      HEAPF64[(((eventStruct)+(48))>>3)]=rr["alpha"];
      HEAPF64[(((eventStruct)+(56))>>3)]=rr["beta"];
      HEAPF64[(((eventStruct)+(64))>>3)]=rr["gamma"];
    }
  Module["__fillDeviceMotionEventData"] = __fillDeviceMotionEventData;

  function __registerDeviceMotionEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.deviceMotionEvent) JSEvents.deviceMotionEvent = _malloc( 80 );
  
      var deviceMotionEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        __fillDeviceMotionEventData(JSEvents.deviceMotionEvent, e, target); // TODO: Thread-safety with respect to emscripten_get_devicemotion_status()
  
        if (dynCall_iiii(callbackfunc, eventTypeId, JSEvents.deviceMotionEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: deviceMotionEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerDeviceMotionEventCallback"] = __registerDeviceMotionEventCallback;

  function _emscripten_set_devicemotion_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      __registerDeviceMotionEventCallback(2, userData, useCapture, callbackfunc, 17, "devicemotion", targetThread);
      return 0;
    }
  Module["_emscripten_set_devicemotion_callback_on_thread"] = _emscripten_set_devicemotion_callback_on_thread;

  function _emscripten_get_devicemotion_status(motionState) {
      if (!JSEvents.deviceMotionEvent) return -7;
      // HTML5 does not really have a polling API for device motion events, so implement one manually by
      // returning the data from the most recently received event. This requires that user has registered
      // at least some no-op function as an event handler.
      HEAP32.set(HEAP32.subarray(JSEvents.deviceMotionEvent, 80), motionState);
      return 0;
    }
  Module["_emscripten_get_devicemotion_status"] = _emscripten_get_devicemotion_status;

  function __screenOrientation() {
      if (!screen) return undefined;
      return screen.orientation || screen.mozOrientation || screen.webkitOrientation || screen.msOrientation;
    }
  Module["__screenOrientation"] = __screenOrientation;

  function __fillOrientationChangeEventData(eventStruct) {
      var orientations  = ["portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
      var orientations2 = ["portrait",         "portrait",           "landscape",         "landscape"];
  
      var orientationString = __screenOrientation();
      var orientation = orientations.indexOf(orientationString);
      if (orientation == -1) {
        orientation = orientations2.indexOf(orientationString);
      }
  
      HEAP32[((eventStruct)>>2)]=1 << orientation;
      HEAP32[(((eventStruct)+(4))>>2)]=orientation;
    }
  Module["__fillOrientationChangeEventData"] = __fillOrientationChangeEventData;

  function __registerOrientationChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.orientationChangeEvent) JSEvents.orientationChangeEvent = _malloc( 8 );
  
      var orientationChangeEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var orientationChangeEvent = JSEvents.orientationChangeEvent;
  
        __fillOrientationChangeEventData(orientationChangeEvent);
  
        if (dynCall_iiii(callbackfunc, eventTypeId, orientationChangeEvent, userData)) e.preventDefault();
      };
  
      if (eventTypeString == "orientationchange" && screen.mozOrientation !== undefined) {
        eventTypeString = "mozorientationchange";
      }
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: orientationChangeEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerOrientationChangeEventCallback"] = __registerOrientationChangeEventCallback;

  function _emscripten_set_orientationchange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      if (!screen || !screen['addEventListener']) return -1;
      __registerOrientationChangeEventCallback(screen, userData, useCapture, callbackfunc, 18, "orientationchange", targetThread);
      return 0;
    }
  Module["_emscripten_set_orientationchange_callback_on_thread"] = _emscripten_set_orientationchange_callback_on_thread;

  function _emscripten_get_orientation_status(orientationChangeEvent) {
      if (!__screenOrientation() && typeof orientation === 'undefined') return -1;
      __fillOrientationChangeEventData(orientationChangeEvent);
      return 0;
    }
  Module["_emscripten_get_orientation_status"] = _emscripten_get_orientation_status;

  function _emscripten_lock_orientation(allowedOrientations) {
      var orientations = [];
      if (allowedOrientations & 1) orientations.push("portrait-primary");
      if (allowedOrientations & 2) orientations.push("portrait-secondary");
      if (allowedOrientations & 4) orientations.push("landscape-primary");
      if (allowedOrientations & 8) orientations.push("landscape-secondary");
      var succeeded;
      if (screen.lockOrientation) {
        succeeded = screen.lockOrientation(orientations);
      } else if (screen.mozLockOrientation) {
        succeeded = screen.mozLockOrientation(orientations);
      } else if (screen.webkitLockOrientation) {
        succeeded = screen.webkitLockOrientation(orientations);
      } else if (screen.msLockOrientation) {
        succeeded = screen.msLockOrientation(orientations);
      } else {
        return -1;
      }
      if (succeeded) {
        return 0;
      } else {
        return -6;
      }
    }
  Module["_emscripten_lock_orientation"] = _emscripten_lock_orientation;

  function _emscripten_unlock_orientation() {
      if (screen.unlockOrientation) {
        screen.unlockOrientation();
      } else if (screen.mozUnlockOrientation) {
        screen.mozUnlockOrientation();
      } else if (screen.webkitUnlockOrientation) {
        screen.webkitUnlockOrientation();
      } else if (screen.msUnlockOrientation) {
        screen.msUnlockOrientation();
      } else {
        return -1;
      }
      return 0;
    }
  Module["_emscripten_unlock_orientation"] = _emscripten_unlock_orientation;




  function _emscripten_get_fullscreen_status(fullscreenStatus) {
      if (!JSEvents.fullscreenEnabled()) return -1;
      __fillFullscreenChangeEventData(fullscreenStatus);
      return 0;
    }
  Module["_emscripten_get_fullscreen_status"] = _emscripten_get_fullscreen_status;




  function __hideEverythingExceptGivenElement(onlyVisibleElement) {
      var child = onlyVisibleElement;
      var parent = child.parentNode;
      var hiddenElements = [];
      while (child != document.body) {
        var children = parent.children;
        for (var i = 0; i < children.length; ++i) {
          if (children[i] != child) {
            hiddenElements.push({ node: children[i], displayState: children[i].style.display });
            children[i].style.display = 'none';
          }
        }
        child = parent;
        parent = parent.parentNode;
      }
      return hiddenElements;
    }
  Module["__hideEverythingExceptGivenElement"] = __hideEverythingExceptGivenElement;

  function __restoreHiddenElements(hiddenElements) {
      for (var i = 0; i < hiddenElements.length; ++i) {
        hiddenElements[i].node.style.display = hiddenElements[i].displayState;
      }
    }
  Module["__restoreHiddenElements"] = __restoreHiddenElements;



  var __restoreOldWindowedStyle=null;
  Module["__restoreOldWindowedStyle"] = __restoreOldWindowedStyle;

  function __softFullscreenResizeWebGLRenderTarget() {
      var dpr = devicePixelRatio;
      var inHiDPIFullscreenMode = __currentFullscreenStrategy.canvasResolutionScaleMode == 2;
      var inAspectRatioFixedFullscreenMode = __currentFullscreenStrategy.scaleMode == 2;
      var inPixelPerfectFullscreenMode = __currentFullscreenStrategy.canvasResolutionScaleMode != 0;
      var inCenteredWithoutScalingFullscreenMode = __currentFullscreenStrategy.scaleMode == 3;
      var screenWidth = inHiDPIFullscreenMode ? Math.round(innerWidth*dpr) : innerWidth;
      var screenHeight = inHiDPIFullscreenMode ? Math.round(innerHeight*dpr) : innerHeight;
      var w = screenWidth;
      var h = screenHeight;
      var canvas = __currentFullscreenStrategy.target;
      var canvasSize = __get_canvas_element_size(canvas);
      var x = canvasSize[0];
      var y = canvasSize[1];
      var topMargin;
  
      if (inAspectRatioFixedFullscreenMode) {
        if (w*y < x*h) h = (w * y / x) | 0;
        else if (w*y > x*h) w = (h * x / y) | 0;
        topMargin = ((screenHeight - h) / 2) | 0;
      }
  
      if (inPixelPerfectFullscreenMode) {
        __set_canvas_element_size(canvas, w, h);
        if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, w, h);
      }
  
      // Back to CSS pixels.
      if (inHiDPIFullscreenMode) {
        topMargin /= dpr;
        w /= dpr;
        h /= dpr;
        // Round to nearest 4 digits of precision.
        w = Math.round(w*1e4)/1e4;
        h = Math.round(h*1e4)/1e4;
        topMargin = Math.round(topMargin*1e4)/1e4;
      }
  
      if (inCenteredWithoutScalingFullscreenMode) {
        var t = (innerHeight - jstoi_q(canvas.style.height)) / 2;
        var b = (innerWidth - jstoi_q(canvas.style.width)) / 2;
        __setLetterbox(canvas, t, b);
      } else {
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        var b = (innerWidth - w) / 2;
        __setLetterbox(canvas, topMargin, b);
      }
  
      if (!inCenteredWithoutScalingFullscreenMode && __currentFullscreenStrategy.canvasResizedCallback) {
        dynCall_iiii(__currentFullscreenStrategy.canvasResizedCallback, 37, 0, __currentFullscreenStrategy.canvasResizedCallbackUserData);
      }
    }
  Module["__softFullscreenResizeWebGLRenderTarget"] = __softFullscreenResizeWebGLRenderTarget;


  function _emscripten_request_fullscreen(target, deferUntilInEventHandler) {
      var strategy = {
        // These options perform no added logic, but just bare request fullscreen.
        scaleMode: 0,
        canvasResolutionScaleMode: 0,
        filteringMode: 0,
        deferUntilInEventHandler: deferUntilInEventHandler,
        canvasResizedCallbackTargetThread: 2
      };
      return __emscripten_do_request_fullscreen(target, strategy);
    }
  Module["_emscripten_request_fullscreen"] = _emscripten_request_fullscreen;


  function _emscripten_enter_soft_fullscreen(target, fullscreenStrategy) {
      target = __findEventTarget(target);
      if (!target) return -4;
  
      var strategy = {
          scaleMode: HEAP32[((fullscreenStrategy)>>2)],
          canvasResolutionScaleMode: HEAP32[(((fullscreenStrategy)+(4))>>2)],
          filteringMode: HEAP32[(((fullscreenStrategy)+(8))>>2)],
          canvasResizedCallback: HEAP32[(((fullscreenStrategy)+(12))>>2)],
          canvasResizedCallbackUserData: HEAP32[(((fullscreenStrategy)+(16))>>2)],
          target: target,
          softFullscreen: true
      };
  
      var restoreOldStyle = _JSEvents_resizeCanvasForFullscreen(target, strategy);
  
      document.documentElement.style.overflow = 'hidden';  // Firefox, Chrome
      document.body.scroll = "no"; // IE11
      document.body.style.margin = '0px'; // Override default document margin area on all browsers.
  
      var hiddenElements = __hideEverythingExceptGivenElement(target);
  
      function restoreWindowedState() {
        restoreOldStyle();
        __restoreHiddenElements(hiddenElements);
        removeEventListener('resize', __softFullscreenResizeWebGLRenderTarget);
        if (strategy.canvasResizedCallback) {
          dynCall_iiii(strategy.canvasResizedCallback, 37, 0, strategy.canvasResizedCallbackUserData);
        }
        __currentFullscreenStrategy = 0;
      }
      __restoreOldWindowedStyle = restoreWindowedState;
      __currentFullscreenStrategy = strategy;
      addEventListener('resize', __softFullscreenResizeWebGLRenderTarget);
  
      // Inform the caller that the canvas size has changed.
      if (strategy.canvasResizedCallback) {
        dynCall_iiii(strategy.canvasResizedCallback, 37, 0, strategy.canvasResizedCallbackUserData);
      }
  
      return 0;
    }
  Module["_emscripten_enter_soft_fullscreen"] = _emscripten_enter_soft_fullscreen;

  function _emscripten_exit_soft_fullscreen() {
      if (__restoreOldWindowedStyle) __restoreOldWindowedStyle();
      __restoreOldWindowedStyle = null;
  
      return 0;
    }
  Module["_emscripten_exit_soft_fullscreen"] = _emscripten_exit_soft_fullscreen;





  function __registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
  
      var pointerlockErrorEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        if (dynCall_iiii(callbackfunc, eventTypeId, 0, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: pointerlockErrorEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerPointerlockErrorEventCallback"] = __registerPointerlockErrorEventCallback;

  /** @suppress {missingProperties} */
  function _emscripten_set_pointerlockerror_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
      if (!document || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
        return -1;
      }
  
      target = __findEventTarget(target);
  
      if (!target) return -4;
      __registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "pointerlockerror", targetThread);
      __registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mozpointerlockerror", targetThread);
      __registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "webkitpointerlockerror", targetThread);
      __registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mspointerlockerror", targetThread);
      return 0;
    }
  Module["_emscripten_set_pointerlockerror_callback_on_thread"] = _emscripten_set_pointerlockerror_callback_on_thread;

  /** @suppress {missingProperties} */
  function _emscripten_get_pointerlock_status(pointerlockStatus) {
      if (pointerlockStatus) __fillPointerlockChangeEventData(pointerlockStatus);
      if (!document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
        return -1;
      }
      return 0;
    }
  Module["_emscripten_get_pointerlock_status"] = _emscripten_get_pointerlock_status;




  function _emscripten_vibrate(msecs) {
      if (!navigator.vibrate) return -1;    
      navigator.vibrate(msecs);
      return 0;
    }
  Module["_emscripten_vibrate"] = _emscripten_vibrate;

  function _emscripten_vibrate_pattern(msecsArray, numEntries) {
      if (!navigator.vibrate) return -1;
  
      var vibrateList = [];
      for(var i = 0; i < numEntries; ++i) {
        var msecs = HEAP32[(((msecsArray)+(i*4))>>2)];
        vibrateList.push(msecs);
      }
      navigator.vibrate(vibrateList);
      return 0;
    }
  Module["_emscripten_vibrate_pattern"] = _emscripten_vibrate_pattern;




  function _emscripten_get_visibility_status(visibilityStatus) {
      if (typeof document.visibilityState === 'undefined' && typeof document.hidden === 'undefined') {
        return -1;
      }
      __fillVisibilityChangeEventData(visibilityStatus);  
      return 0;
    }
  Module["_emscripten_get_visibility_status"] = _emscripten_get_visibility_status;

















  function __registerBatteryEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.batteryEvent) JSEvents.batteryEvent = _malloc( 32 );
  
      var batteryEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var batteryEvent = JSEvents.batteryEvent;
        __fillBatteryEventData(batteryEvent, __battery());
  
        if (dynCall_iiii(callbackfunc, eventTypeId, batteryEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: batteryEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerBatteryEventCallback"] = __registerBatteryEventCallback;

  function _emscripten_set_batterychargingchange_callback_on_thread(userData, callbackfunc, targetThread) {
      if (!__battery()) return -1; 
      __registerBatteryEventCallback(__battery(), userData, true, callbackfunc, 29, "chargingchange", targetThread);
      return 0;
    }
  Module["_emscripten_set_batterychargingchange_callback_on_thread"] = _emscripten_set_batterychargingchange_callback_on_thread;

  function _emscripten_set_batterylevelchange_callback_on_thread(userData, callbackfunc, targetThread) {
      if (!__battery()) return -1; 
      __registerBatteryEventCallback(__battery(), userData, true, callbackfunc, 30, "levelchange", targetThread);
      return 0;
    }
  Module["_emscripten_set_batterylevelchange_callback_on_thread"] = _emscripten_set_batterylevelchange_callback_on_thread;


  function _emscripten_webgl_init_context_attributes(attributes) {
      assert(attributes);
      var a = attributes >> 2;
      for(var i = 0; i < (56>>2); ++i) {
        HEAP32[a+i] = 0;
      }
  
      HEAP32[a + (0>>2)] =
      HEAP32[a + (4>>2)] = 
      HEAP32[a + (12>>2)] = 
      HEAP32[a + (16>>2)] = 
      HEAP32[a + (32>>2)] = 
      HEAP32[a + (40>>2)] = 1;
  
    }
  Module["_emscripten_webgl_init_context_attributes"] = _emscripten_webgl_init_context_attributes;

  var __emscripten_webgl_power_preferences=['default', 'low-power', 'high-performance'];
  Module["__emscripten_webgl_power_preferences"] = __emscripten_webgl_power_preferences;

  
  function _emscripten_webgl_do_create_context(target, attributes) {
      assert(attributes);
      var contextAttributes = {};
      var a = attributes >> 2;
      contextAttributes['alpha'] = !!HEAP32[a + (0>>2)];
      contextAttributes['depth'] = !!HEAP32[a + (4>>2)];
      contextAttributes['stencil'] = !!HEAP32[a + (8>>2)];
      contextAttributes['antialias'] = !!HEAP32[a + (12>>2)];
      contextAttributes['premultipliedAlpha'] = !!HEAP32[a + (16>>2)];
      contextAttributes['preserveDrawingBuffer'] = !!HEAP32[a + (20>>2)];
      var powerPreference = HEAP32[a + (24>>2)];
      contextAttributes['powerPreference'] = __emscripten_webgl_power_preferences[powerPreference];
      contextAttributes['failIfMajorPerformanceCaveat'] = !!HEAP32[a + (28>>2)];
      contextAttributes.majorVersion = HEAP32[a + (32>>2)];
      contextAttributes.minorVersion = HEAP32[a + (36>>2)];
      contextAttributes.enableExtensionsByDefault = HEAP32[a + (40>>2)];
      contextAttributes.explicitSwapControl = HEAP32[a + (44>>2)];
      contextAttributes.proxyContextToMainThread = HEAP32[a + (48>>2)];
      contextAttributes.renderViaOffscreenBackBuffer = HEAP32[a + (52>>2)];
  
      var canvas = __findCanvasEventTarget(target);
  
  
  
      if (!canvas) {
        return -4;
      }
  
      if (contextAttributes.explicitSwapControl) {
        return -1;
      }
  
  
      var contextHandle = GL.createContext(canvas, contextAttributes);
      return contextHandle;
    }
  Module["_emscripten_webgl_do_create_context"] = _emscripten_webgl_do_create_context;function _emscripten_webgl_create_context(a0,a1
  ) {
  return _emscripten_webgl_do_create_context(a0,a1);
  }
  Module["_emscripten_webgl_create_context"] = _emscripten_webgl_create_context;

  
  function _emscripten_webgl_do_get_current_context() {
      return GL.currentContext ? GL.currentContext.handle : 0;
    }
  Module["_emscripten_webgl_do_get_current_context"] = _emscripten_webgl_do_get_current_context;function _emscripten_webgl_get_current_context(
  ) {
  return _emscripten_webgl_do_get_current_context();
  }
  Module["_emscripten_webgl_get_current_context"] = _emscripten_webgl_get_current_context;

  
  function _emscripten_webgl_do_commit_frame() {
      if (!GL.currentContext || !GL.currentContext.GLctx) {
        return -3;
      }
  
      if (!GL.currentContext.attributes.explicitSwapControl) {
        return -3;
      }
      // We would do GL.currentContext.GLctx.commit(); here, but the current implementation
      // in browsers has removed it - swap is implicit, so this function is a no-op for now
      // (until/unless the spec changes).
      return 0;
    }
  Module["_emscripten_webgl_do_commit_frame"] = _emscripten_webgl_do_commit_frame;function _emscripten_webgl_commit_frame(
  ) {
  return _emscripten_webgl_do_commit_frame();
  }
  Module["_emscripten_webgl_commit_frame"] = _emscripten_webgl_commit_frame;


  function _emscripten_webgl_make_context_current(contextHandle) {
      var success = GL.makeContextCurrent(contextHandle);
      return success ? 0 : -5;
    }
  Module["_emscripten_webgl_make_context_current"] = _emscripten_webgl_make_context_current;


  function _emscripten_webgl_get_drawing_buffer_size_calling_thread(contextHandle, width, height) {
      var GLContext = GL.getContext(contextHandle);
  
      if (!GLContext || !GLContext.GLctx || !width || !height) {
        return -5;
      }
      HEAP32[((width)>>2)]=GLContext.GLctx.drawingBufferWidth;
      HEAP32[((height)>>2)]=GLContext.GLctx.drawingBufferHeight;
      return 0;
    }
  Module["_emscripten_webgl_get_drawing_buffer_size_calling_thread"] = _emscripten_webgl_get_drawing_buffer_size_calling_thread;

  function _emscripten_webgl_get_drawing_buffer_size(a0,a1,a2
  ) {
  return _emscripten_webgl_get_drawing_buffer_size_calling_thread(a0,a1,a2);
  }
  Module["_emscripten_webgl_get_drawing_buffer_size"] = _emscripten_webgl_get_drawing_buffer_size;


  function _emscripten_webgl_get_context_attributes(c, a) {
      if (!a) return -5;
      c = GL.contexts[c];
      if (!c) return -3;
      var t = c.GLctx;
      if (!t) return -3;
      t = t.getContextAttributes();
  
      HEAP32[((a)>>2)]=t.alpha;
      HEAP32[(((a)+(4))>>2)]=t.depth;
      HEAP32[(((a)+(8))>>2)]=t.stencil;
      HEAP32[(((a)+(12))>>2)]=t.antialias;
      HEAP32[(((a)+(16))>>2)]=t.premultipliedAlpha;
      HEAP32[(((a)+(20))>>2)]=t.preserveDrawingBuffer;
      var power = t['powerPreference'] && __emscripten_webgl_power_preferences.indexOf(t['powerPreference']);
      HEAP32[(((a)+(24))>>2)]=power;
      HEAP32[(((a)+(28))>>2)]=t.failIfMajorPerformanceCaveat;
      HEAP32[(((a)+(32))>>2)]=c.version;
      HEAP32[(((a)+(36))>>2)]=0;
      HEAP32[(((a)+(40))>>2)]=c.attributes.enableExtensionsByDefault;
      return 0;
    }
  Module["_emscripten_webgl_get_context_attributes"] = _emscripten_webgl_get_context_attributes;

  function _emscripten_webgl_destroy_context_calling_thread(contextHandle) {
      if (GL.currentContext == contextHandle) GL.currentContext = null;
      GL.deleteContext(contextHandle);
    }
  Module["_emscripten_webgl_destroy_context_calling_thread"] = _emscripten_webgl_destroy_context_calling_thread;

  function _emscripten_webgl_destroy_context(a0
  ) {
  return _emscripten_webgl_destroy_context_calling_thread(a0);
  }
  Module["_emscripten_webgl_destroy_context"] = _emscripten_webgl_destroy_context;

  function _emscripten_webgl_enable_extension_calling_thread(contextHandle, extension) {
      var context = GL.getContext(contextHandle);
      var extString = UTF8ToString(extension);
      if (extString.indexOf('GL_') == 0) extString = extString.substr(3); // Allow enabling extensions both with "GL_" prefix and without.
  
      // Switch-board that pulls in code for all GL extensions, even if those are not used :/
      // Build with -s GL_SUPPORT_SIMPLE_ENABLE_EXTENSIONS = 0 to avoid this.
  
      // Obtain function entry points to WebGL 1 extension related functions.
      if (extString == 'ANGLE_instanced_arrays') __webgl_enable_ANGLE_instanced_arrays(GLctx);
      if (extString == 'OES_vertex_array_object') __webgl_enable_OES_vertex_array_object(GLctx);
      if (extString == 'WEBGL_draw_buffers') __webgl_enable_WEBGL_draw_buffers(GLctx);
  
  
  
      var ext = context.GLctx.getExtension(extString);
      return !!ext;
    }
  Module["_emscripten_webgl_enable_extension_calling_thread"] = _emscripten_webgl_enable_extension_calling_thread;

  function _emscripten_supports_offscreencanvas() {
      return 0;
    }
  Module["_emscripten_supports_offscreencanvas"] = _emscripten_supports_offscreencanvas;

  function _emscripten_webgl_enable_extension(a0,a1
  ) {
  return _emscripten_webgl_enable_extension_calling_thread(a0,a1);
  }
  Module["_emscripten_webgl_enable_extension"] = _emscripten_webgl_enable_extension;

  function __registerWebGlEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
  
  
      var webGlEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        if (dynCall_iiii(callbackfunc, eventTypeId, 0, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: __findEventTarget(target),
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: webGlEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  Module["__registerWebGlEventCallback"] = __registerWebGlEventCallback;

  function _emscripten_set_webglcontextlost_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 31, "webglcontextlost", targetThread);
      return 0;
    }
  Module["_emscripten_set_webglcontextlost_callback_on_thread"] = _emscripten_set_webglcontextlost_callback_on_thread;

  function _emscripten_set_webglcontextrestored_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      __registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 32, "webglcontextrestored", targetThread);
      return 0;
    }
  Module["_emscripten_set_webglcontextrestored_callback_on_thread"] = _emscripten_set_webglcontextrestored_callback_on_thread;

  function _emscripten_is_webgl_context_lost(target) {
      return !GL.contexts[target] || GL.contexts[target].GLctx.isContextLost(); // No context ~> lost context.
    }
  Module["_emscripten_is_webgl_context_lost"] = _emscripten_is_webgl_context_lost;







  function _emscripten_html5_remove_all_event_listeners() {
      JSEvents.removeAllEventListeners();
    }
  Module["_emscripten_html5_remove_all_event_listeners"] = _emscripten_html5_remove_all_event_listeners;

  function _emscripten_request_animation_frame(cb, userData) {
      return requestAnimationFrame(function(timeStamp) {
        dynCall_idi(cb, timeStamp, userData);
      });
    }
  Module["_emscripten_request_animation_frame"] = _emscripten_request_animation_frame;

  function _emscripten_cancel_animation_frame(id) {
      cancelAnimationFrame(id);
    }
  Module["_emscripten_cancel_animation_frame"] = _emscripten_cancel_animation_frame;

  function _emscripten_request_animation_frame_loop(cb, userData) {
      function tick(timeStamp) {
        if (dynCall_idi(cb, timeStamp, userData)) {
          requestAnimationFrame(tick);
        }
      }
      return requestAnimationFrame(tick);
    }
  Module["_emscripten_request_animation_frame_loop"] = _emscripten_request_animation_frame_loop;

  function __polyfill_set_immediate() { /* nop, used for its postset to ensure setImmediate() polyfill is not duplicated between emscripten_set_immediate() and emscripten_set_immediate_loop() if application links to both of them.*/ }
  Module["__polyfill_set_immediate"] = __polyfill_set_immediate;

  function _emscripten_set_immediate(cb, userData) {
      __polyfill_set_immediate();
      return setImmediate(function() {
        dynCall_vi(cb, userData);
      });
    }
  Module["_emscripten_set_immediate"] = _emscripten_set_immediate;

  function _emscripten_clear_immediate(id) {
      clearImmediate(id);
    }
  Module["_emscripten_clear_immediate"] = _emscripten_clear_immediate;

  function _emscripten_set_immediate_loop(cb, userData) {
      __polyfill_set_immediate();
      function tick() {
        if (dynCall_ii(cb, userData)) {
          setImmediate(tick);
        }
      }
      return setImmediate(tick);
    }
  Module["_emscripten_set_immediate_loop"] = _emscripten_set_immediate_loop;

  function _emscripten_set_timeout(cb, msecs, userData) {
      return setTimeout(function() {
        dynCall_vi(cb, userData);
      }, msecs);
    }
  Module["_emscripten_set_timeout"] = _emscripten_set_timeout;

  function _emscripten_clear_timeout(id) {
      clearTimeout(id);
    }
  Module["_emscripten_clear_timeout"] = _emscripten_clear_timeout;

  function _emscripten_set_timeout_loop(cb, msecs, userData) {
      function tick() {
        var t = performance.now();
        var n = t + msecs;
        if (dynCall_idi(cb, t, userData)) {
          setTimeout(tick,
            // Save a little bit of code space: modern browsers should treat negative setTimeout as timeout of 0 (https://stackoverflow.com/questions/8430966/is-calling-settimeout-with-a-negative-delay-ok)
            t - performance.now()
            );
        }
      }
      return setTimeout(tick, 0);
    }
  Module["_emscripten_set_timeout_loop"] = _emscripten_set_timeout_loop;

  function _emscripten_set_interval(cb, msecs, userData) {
      return setInterval(function() {
        dynCall_vi(cb, userData)
      }, msecs);
    }
  Module["_emscripten_set_interval"] = _emscripten_set_interval;

  function _emscripten_clear_interval(id) {
      clearInterval(id);
    }
  Module["_emscripten_clear_interval"] = _emscripten_clear_interval;

  function _emscripten_date_now() {
      return Date.now();
    }
  Module["_emscripten_date_now"] = _emscripten_date_now;

  function _emscripten_performance_now() {
      return performance.now();
    }
  Module["_emscripten_performance_now"] = _emscripten_performance_now;

  function _emscripten_console_log(str) {
      assert(typeof str === 'number');
      console.log(UTF8ToString(str));
    }
  Module["_emscripten_console_log"] = _emscripten_console_log;

  function _emscripten_console_warn(str) {
      assert(typeof str === 'number');
      console.warn(UTF8ToString(str));
    }
  Module["_emscripten_console_warn"] = _emscripten_console_warn;

  function _emscripten_console_error(str) {
      assert(typeof str === 'number');
      console.error(UTF8ToString(str));
    }
  Module["_emscripten_console_error"] = _emscripten_console_error;

  function _emscripten_throw_number(number) {
      throw number;
    }
  Module["_emscripten_throw_number"] = _emscripten_throw_number;

  function _emscripten_throw_string(str) {
      assert(typeof str === 'number');
      throw UTF8ToString(str);
    }
  Module["_emscripten_throw_string"] = _emscripten_throw_string;

  function _emscripten_unwind_to_js_event_loop() {
      throw 'unwind';
    }
  Module["_emscripten_unwind_to_js_event_loop"] = _emscripten_unwind_to_js_event_loop;






  function _proc_exit(code) {
      _exit(code);
    }
  Module["_proc_exit"] = _proc_exit;




  function _args_sizes_get(pargc, pargv_buf_size) {
      HEAP32[((pargc)>>2)]=mainArgs.length;
      var bufSize = 0;
      mainArgs.forEach(function(arg) {
        bufSize += arg.length + 1;
      });
      HEAP32[((pargv_buf_size)>>2)]=bufSize;
      return 0;
    }
  Module["_args_sizes_get"] = _args_sizes_get;

  function _args_get(argv, argv_buf) {
      var bufSize = 0;
      mainArgs.forEach(function(arg, i) {
        var ptr = argv_buf + bufSize;
        HEAP32[(((argv)+(i * 4))>>2)]=ptr;
        writeAsciiToMemory(arg, ptr);
        bufSize += arg.length + 1;
      });
      return 0;
    }
  Module["_args_get"] = _args_get;

  function _clock_time_get(clk_id, precision_low, precision_high, ptime) {
      
      var now;
      if (clk_id === 0) {
        now = Date.now();
      } else if (clk_id === 1 && _emscripten_get_now_is_monotonic) {
        now = _emscripten_get_now();
      } else {
        setErrNo(28);
        return -1;
      }
      // "now" is in ms, and wasi times are in ns.
      var nsec = Math.round(now * 1000 * 1000);
      HEAP32[((ptime)>>2)]=nsec >>> 0;
      HEAP32[(((ptime)+(4))>>2)]=(nsec / Math.pow(2, 32)) >>> 0;
      return 0;
    }
  Module["_clock_time_get"] = _clock_time_get;

  function _clock_res_get(clk_id, pres) {
      var nsec;
      if (clk_id === 0) {
        nsec = 1000 * 1000; // educated guess that it's milliseconds
      } else if (clk_id === 1 && _emscripten_get_now_is_monotonic) {
        nsec = _emscripten_get_now_res();
      } else {
        setErrNo(28);
        return -1;
      }
      HEAP32[((pres)>>2)]=nsec >>> 0;
      HEAP32[(((pres)+(4))>>2)]=(nsec / Math.pow(2, 32)) >>> 0;
      return 0;
    }
  Module["_clock_res_get"] = _clock_res_get;


  function writeI53ToI64Clamped(ptr, num) {
      if (num > 0x7FFFFFFFFFFFFFFF) {
        HEAPU32[ptr>>2] = 0xFFFFFFFF;
        HEAPU32[ptr+4>>2] = 0x7FFFFFFF;
      } else if (num < -0x8000000000000000) {
        HEAPU32[ptr>>2] = 0;
        HEAPU32[ptr+4>>2] = 0x80000000;
      } else {
        HEAPU32[ptr>>2] = num;
        HEAPU32[ptr+4>>2] = (num - HEAPU32[ptr>>2])/4294967296;
      }
    }
  Module["writeI53ToI64Clamped"] = writeI53ToI64Clamped;

  function writeI53ToI64Signaling(ptr, num) {
      if (num > 0x7FFFFFFFFFFFFFFF || num < -0x8000000000000000) {
        throw 'RangeError in writeI53ToI64Signaling(): input value ' + num + ' is out of range of int64';
      }
      HEAPU32[ptr>>2] = num;
      HEAPU32[ptr+4>>2] = (num - HEAPU32[ptr>>2])/4294967296;
    }
  Module["writeI53ToI64Signaling"] = writeI53ToI64Signaling;

  function writeI53ToU64Clamped(ptr, num) {
      if (num > 0xFFFFFFFFFFFFFFFF) HEAPU32[ptr>>2] = HEAPU32[ptr+4>>2] = 0xFFFFFFFF;
      else if (num < 0) HEAPU32[ptr>>2] = HEAPU32[ptr+4>>2] = 0;
      else {
        HEAPU32[ptr>>2] = num;
        HEAPU32[ptr+4>>2] = (num - HEAPU32[ptr>>2])/4294967296;
      }
    }
  Module["writeI53ToU64Clamped"] = writeI53ToU64Clamped;

  function writeI53ToU64Signaling(ptr, num) {
      if (num < 0 || num > 0xFFFFFFFFFFFFFFFF) {
        throw 'RangeError in writeI53ToU64Signaling(): input value ' + num + ' is out of range of uint64';
      }
      HEAPU32[ptr>>2] = num;
      HEAPU32[ptr+4>>2] = (num - HEAPU32[ptr>>2])/4294967296;
    }
  Module["writeI53ToU64Signaling"] = writeI53ToU64Signaling;






  var ___exception_caught= [];
  Module["___exception_caught"] = ___exception_caught;


  function ___exception_deAdjust(adjusted) {
      if (!adjusted || ___exception_infos[adjusted]) return adjusted;
      for (var key in ___exception_infos) {
        var ptr = +key; // the iteration key is a string, and if we throw this, it must be an integer as that is what we look for
        var adj = ___exception_infos[ptr].adjusted;
        var len = adj.length;
        for (var i = 0; i < len; i++) {
          if (adj[i] === adjusted) {
            return ptr;
          }
        }
      }
      return adjusted;
    }
  Module["___exception_deAdjust"] = ___exception_deAdjust;

  function ___exception_addRef(ptr) {
      if (!ptr) return;
      var info = ___exception_infos[ptr];
      info.refcount++;
    }
  Module["___exception_addRef"] = ___exception_addRef;

  
  function ___cxa_free_exception(ptr) {
      try {
        return _free(ptr);
      } catch(e) {
        err('exception during cxa_free_exception: ' + e);
      }
    }
  Module["___cxa_free_exception"] = ___cxa_free_exception;function ___exception_decRef(ptr) {
      if (!ptr) return;
      var info = ___exception_infos[ptr];
      assert(info.refcount > 0);
      info.refcount--;
      // A rethrown exception can reach refcount 0; it must not be discarded
      // Its next handler will clear the rethrown flag and addRef it, prior to
      // final decRef and destruction here
      if (info.refcount === 0 && !info.rethrown) {
        if (info.destructor) {
          // In Wasm, destructors return 'this' as in ARM
          Module['dynCall_ii'](info.destructor, ptr);
        }
        delete ___exception_infos[ptr];
        ___cxa_free_exception(ptr);
      }
    }
  Module["___exception_decRef"] = ___exception_decRef;

  function ___exception_clearRef(ptr) {
      if (!ptr) return;
      var info = ___exception_infos[ptr];
      info.refcount = 0;
    }
  Module["___exception_clearRef"] = ___exception_clearRef;

  function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }
  Module["___cxa_allocate_exception"] = ___cxa_allocate_exception;


  function ___cxa_increment_exception_refcount(ptr) {
      ___exception_addRef(___exception_deAdjust(ptr));
    }
  Module["___cxa_increment_exception_refcount"] = ___cxa_increment_exception_refcount;

  function ___cxa_decrement_exception_refcount(ptr) {
      ___exception_decRef(___exception_deAdjust(ptr));
    }
  Module["___cxa_decrement_exception_refcount"] = ___cxa_decrement_exception_refcount;


  function ___cxa_rethrow() {
      var ptr = ___exception_caught.pop();
      ptr = ___exception_deAdjust(ptr);
      if (!___exception_infos[ptr].rethrown) {
        // Only pop if the corresponding push was through rethrow_primary_exception
        ___exception_caught.push(ptr);
        ___exception_infos[ptr].rethrown = true;
      }
      ___exception_last = ptr;
      throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch." + " (note: in dynamic linking, if a side module wants exceptions, the main module must be built with that support)";
    }
  Module["___cxa_rethrow"] = ___cxa_rethrow;

  function _llvm_eh_exception() {
      return ___exception_last;
    }
  Module["_llvm_eh_exception"] = _llvm_eh_exception;

  var _llvm_eh_selector__jsargs=true;
  Module["_llvm_eh_selector__jsargs"] = _llvm_eh_selector__jsargs;

  function _llvm_eh_selector(unused_exception_value, personality/*, varargs*/) {
      var type = ___exception_last;
      for (var i = 2; i < arguments.length; i++) {
        if (arguments[i] ==  type) return type;
      }
      return 0;
    }
  Module["_llvm_eh_selector"] = _llvm_eh_selector;

  function _llvm_eh_typeid_for(type) {
      return type;
    }
  Module["_llvm_eh_typeid_for"] = _llvm_eh_typeid_for;

  function ___cxa_begin_catch(ptr) {
      var info = ___exception_infos[ptr];
      if (info && !info.caught) {
        info.caught = true;
        __ZSt18uncaught_exceptionv.uncaught_exceptions--;
      }
      if (info) info.rethrown = false;
      ___exception_caught.push(ptr);
      ___exception_addRef(___exception_deAdjust(ptr));
      return ptr;
    }
  Module["___cxa_begin_catch"] = ___cxa_begin_catch;

  function ___cxa_end_catch() {
      // Clear state flag.
      _setThrew(0);
      // Call destructor if one is registered then clear it.
      var ptr = ___exception_caught.pop();
      if (ptr) {
        ___exception_decRef(___exception_deAdjust(ptr));
        ___exception_last = 0; // XXX in decRef?
      }
    }
  Module["___cxa_end_catch"] = ___cxa_end_catch;

  function ___cxa_get_exception_ptr(ptr) {
      // TODO: use info.adjusted?
      return ptr;
    }
  Module["___cxa_get_exception_ptr"] = ___cxa_get_exception_ptr;


  function ___cxa_uncaught_exceptions() {
      return __ZSt18uncaught_exceptionv.uncaught_exceptions;
    }
  Module["___cxa_uncaught_exceptions"] = ___cxa_uncaught_exceptions;


  function ___cxa_current_primary_exception() {
      var ret = ___exception_caught[___exception_caught.length-1] || 0;
      if (ret) ___exception_addRef(___exception_deAdjust(ret));
      return ret;
    }
  Module["___cxa_current_primary_exception"] = ___cxa_current_primary_exception;

  function ___cxa_rethrow_primary_exception(ptr) {
      if (!ptr) return;
      ptr = ___exception_deAdjust(ptr);
      ___exception_caught.push(ptr);
      ___exception_infos[ptr].rethrown = true;
      ___cxa_rethrow();
    }
  Module["___cxa_rethrow_primary_exception"] = ___cxa_rethrow_primary_exception;

  
  function ___resumeException(ptr) {
      if (!___exception_last) { ___exception_last = ptr; }
      throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch." + " (note: in dynamic linking, if a side module wants exceptions, the main module must be built with that support)";
    }
  Module["___resumeException"] = ___resumeException;function ___cxa_find_matching_catch() {
      var thrown = ___exception_last;
      if (!thrown) {
        // just pass through the null ptr
        return ((setTempRet0(0),0)|0);
      }
      var info = ___exception_infos[thrown];
      var throwntype = info.type;
      if (!throwntype) {
        // just pass through the thrown ptr
        return ((setTempRet0(0),thrown)|0);
      }
      var typeArray = Array.prototype.slice.call(arguments);
  
      var pointer = Module['___cxa_is_pointer_type'](throwntype);
      // can_catch receives a **, add indirection
      var buffer = 0;
      HEAP32[((buffer)>>2)]=thrown;
      thrown = buffer;
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {
          thrown = HEAP32[((thrown)>>2)]; // undo indirection
          info.adjusted.push(thrown);
          return ((setTempRet0(typeArray[i]),thrown)|0);
        }
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      thrown = HEAP32[((thrown)>>2)]; // undo indirection
      return ((setTempRet0(throwntype),thrown)|0);
    }
  Module["___cxa_find_matching_catch"] = ___cxa_find_matching_catch;



  function _emscripten_async_wget(url, file, onload, onerror) {
      noExitRuntime = true;
  
      var _url = UTF8ToString(url);
      var _file = UTF8ToString(file);
      _file = PATH_FS.resolve(_file);
      function doCallback(callback) {
        if (callback) {
          var stack = stackSave();
          dynCall_vi(callback, allocate(intArrayFromString(_file), 'i8', ALLOC_STACK));
          stackRestore(stack);
        }
      }
      var destinationDirectory = PATH.dirname(_file);
      FS.createPreloadedFile(
        destinationDirectory,
        PATH.basename(_file),
        _url, true, true,
        function() {
          doCallback(onload);
        },
        function() {
          doCallback(onerror);
        },
        false, // dontCreateFile
        false, // canOwn
        function() { // preFinish
          // if a file exists there, we overwrite it
          try {
            FS.unlink(_file);
          } catch (e) {}
          // if the destination directory does not yet exist, create it
          FS.mkdirTree(destinationDirectory);
        }
      );
    }
  Module["_emscripten_async_wget"] = _emscripten_async_wget;

  function _emscripten_async_wget_data(url, arg, onload, onerror) {
      Browser.asyncLoad(UTF8ToString(url), function(byteArray) {
        var buffer = _malloc(byteArray.length);
        HEAPU8.set(byteArray, buffer);
        dynCall_viii(onload, arg, buffer, byteArray.length);
        _free(buffer);
      }, function() {
        if (onerror) dynCall_vi(onerror, arg);
      }, true /* no need for run dependency, this is async but will not do any prepare etc. step */ );
    }
  Module["_emscripten_async_wget_data"] = _emscripten_async_wget_data;

  function _emscripten_async_wget2(url, file, request, param, arg, onload, onerror, onprogress) {
      noExitRuntime = true;
  
      var _url = UTF8ToString(url);
      var _file = UTF8ToString(file);
      _file = PATH_FS.resolve(_file);
      var _request = UTF8ToString(request);
      var _param = UTF8ToString(param);
      var index = _file.lastIndexOf('/');
  
      var http = new XMLHttpRequest();
      http.open(_request, _url, true);
      http.responseType = 'arraybuffer';
  
      var handle = Browser.getNextWgetRequestHandle();
  
      var destinationDirectory = PATH.dirname(_file);
  
      // LOAD
      http.onload = function http_onload(e) {
        if (http.status >= 200 && http.status < 300) {
          // if a file exists there, we overwrite it
          try {
            FS.unlink(_file);
          } catch (e) {}
          // if the destination directory does not yet exist, create it
          FS.mkdirTree(destinationDirectory);
  
          FS.createDataFile( _file.substr(0, index), _file.substr(index + 1), new Uint8Array(/** @type{ArrayBuffer}*/(http.response)), true, true, false);
          if (onload) {
            var stack = stackSave();
            dynCall_viii(onload, handle, arg, allocate(intArrayFromString(_file), 'i8', ALLOC_STACK));
            stackRestore(stack);
          }
        } else {
          if (onerror) dynCall_viii(onerror, handle, arg, http.status);
        }
  
        delete Browser.wgetRequests[handle];
      };
  
      // ERROR
      http.onerror = function http_onerror(e) {
        if (onerror) dynCall_viii(onerror, handle, arg, http.status);
        delete Browser.wgetRequests[handle];
      };
  
      // PROGRESS
      http.onprogress = function http_onprogress(e) {
        if (e.lengthComputable || (e.lengthComputable === undefined && e.total != 0)) {
          var percentComplete = (e.loaded / e.total)*100;
          if (onprogress) dynCall_viii(onprogress, handle, arg, percentComplete);
        }
      };
  
      // ABORT
      http.onabort = function http_onabort(e) {
        delete Browser.wgetRequests[handle];
      };
  
      if (_request == "POST") {
        //Send the proper header information along with the request
        http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        http.send(_param);
      } else {
        http.send(null);
      }
  
      Browser.wgetRequests[handle] = http;
  
      return handle;
    }
  Module["_emscripten_async_wget2"] = _emscripten_async_wget2;

  function _emscripten_async_wget2_data(url, request, param, arg, free, onload, onerror, onprogress) {
      var _url = UTF8ToString(url);
      var _request = UTF8ToString(request);
      var _param = UTF8ToString(param);
  
      var http = new XMLHttpRequest();
      http.open(_request, _url, true);
      http.responseType = 'arraybuffer';
  
      var handle = Browser.getNextWgetRequestHandle();
  
      // LOAD
      http.onload = function http_onload(e) {
        if (http.status >= 200 && http.status < 300 || (http.status === 0 && _url.substr(0,4).toLowerCase() != "http")) {
          var byteArray = new Uint8Array(/** @type{ArrayBuffer} */(http.response));
          var buffer = _malloc(byteArray.length);
          HEAPU8.set(byteArray, buffer);
          if (onload) dynCall_viiii(onload, handle, arg, buffer, byteArray.length);
          if (free) _free(buffer);
        } else {
          if (onerror) dynCall_viiii(onerror, handle, arg, http.status, http.statusText);
        }
        delete Browser.wgetRequests[handle];
      };
  
      // ERROR
      http.onerror = function http_onerror(e) {
        if (onerror) {
          dynCall_viiii(onerror, handle, arg, http.status, http.statusText);
        }
        delete Browser.wgetRequests[handle];
      };
  
      // PROGRESS
      http.onprogress = function http_onprogress(e) {
        if (onprogress) dynCall_viiii(onprogress, handle, arg, e.loaded, e.lengthComputable || e.lengthComputable === undefined ? e.total : 0);
      };
  
      // ABORT
      http.onabort = function http_onabort(e) {
        delete Browser.wgetRequests[handle];
      };
  
      if (_request == "POST") {
        //Send the proper header information along with the request
        http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        http.send(_param);
      } else {
        http.send(null);
      }
  
      Browser.wgetRequests[handle] = http;
  
      return handle;
    }
  Module["_emscripten_async_wget2_data"] = _emscripten_async_wget2_data;

  function _emscripten_async_wget2_abort(handle) {
      var http = Browser.wgetRequests[handle];
      if (http) {
        http.abort();
      }
    }
  Module["_emscripten_async_wget2_abort"] = _emscripten_async_wget2_abort;

  function _emscripten_run_preload_plugins(file, onload, onerror) {
      noExitRuntime = true;
  
      var _file = UTF8ToString(file);
      var data = FS.analyzePath(_file);
      if (!data.exists) return -1;
      FS.createPreloadedFile(
        PATH.dirname(_file),
        PATH.basename(_file),
        new Uint8Array(data.object.contents), true, true,
        function() {
          if (onload) dynCall_vi(onload, file);
        },
        function() {
          if (onerror) dynCall_vi(onerror, file);
        },
        true // don'tCreateFile - it's already there
      );
      return 0;
    }
  Module["_emscripten_run_preload_plugins"] = _emscripten_run_preload_plugins;

  function _emscripten_run_preload_plugins_data(data, size, suffix, arg, onload, onerror) {
      noExitRuntime = true;
  
      var _suffix = UTF8ToString(suffix);
      if (!Browser.asyncPrepareDataCounter) Browser.asyncPrepareDataCounter = 0;
      var name = 'prepare_data_' + (Browser.asyncPrepareDataCounter++) + '.' + _suffix;
      var lengthAsUTF8 = lengthBytesUTF8(name);
      var cname = _malloc(lengthAsUTF8+1);
      stringToUTF8(name, cname, lengthAsUTF8+1);
      FS.createPreloadedFile(
        '/',
        name,
        HEAPU8.subarray((data),(data + size)),
        true, true,
        function() {
          if (onload) dynCall_vii(onload, arg, cname);
        },
        function() {
          if (onerror) dynCall_vi(onerror, arg);
        },
        true // don'tCreateFile - it's already there
      );
    }
  Module["_emscripten_run_preload_plugins_data"] = _emscripten_run_preload_plugins_data;

  function _emscripten_async_run_script(script, millis) {
      noExitRuntime = true;
  
      // TODO: cache these to avoid generating garbage
      Browser.safeSetTimeout(function() {
        _emscripten_run_script(script);
      }, millis);
    }
  Module["_emscripten_async_run_script"] = _emscripten_async_run_script;

  function _emscripten_async_load_script(url, onload, onerror) {
      onload = getFuncWrapper(onload, 'v');
      onerror = getFuncWrapper(onerror, 'v');
  
      noExitRuntime = true;
  
      assert(runDependencies === 0, 'async_load_script must be run when no other dependencies are active');
      var script = document.createElement('script');
      if (onload) {
        script.onload = function script_onload() {
          if (runDependencies > 0) {
            dependenciesFulfilled = onload;
          } else {
            onload();
          }
        };
      }
      if (onerror) script.onerror = onerror;
      script.src = UTF8ToString(url);
      document.body.appendChild(script);
    }
  Module["_emscripten_async_load_script"] = _emscripten_async_load_script;

  function _emscripten_get_main_loop_timing(mode, value) {
      if (mode) HEAP32[((mode)>>2)]=Browser.mainLoop.timingMode;
      if (value) HEAP32[((value)>>2)]=Browser.mainLoop.timingValue;
    }
  Module["_emscripten_get_main_loop_timing"] = _emscripten_get_main_loop_timing;



  function _emscripten_set_main_loop_arg(func, arg, fps, simulateInfiniteLoop) {
      _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg);
    }
  Module["_emscripten_set_main_loop_arg"] = _emscripten_set_main_loop_arg;


  function _emscripten_pause_main_loop() {
      Browser.mainLoop.pause();
    }
  Module["_emscripten_pause_main_loop"] = _emscripten_pause_main_loop;

  function _emscripten_resume_main_loop() {
      Browser.mainLoop.resume();
    }
  Module["_emscripten_resume_main_loop"] = _emscripten_resume_main_loop;

  function __emscripten_push_main_loop_blocker(func, arg, name) {
      Browser.mainLoop.queue.push({ func: function() {
        dynCall_vi(func, arg);
      }, name: UTF8ToString(name), counted: true });
      Browser.mainLoop.updateStatus();
    }
  Module["__emscripten_push_main_loop_blocker"] = __emscripten_push_main_loop_blocker;

  function __emscripten_push_uncounted_main_loop_blocker(func, arg, name) {
      Browser.mainLoop.queue.push({ func: function() {
        dynCall_vi(func, arg);
      }, name: UTF8ToString(name), counted: false });
      Browser.mainLoop.updateStatus();
    }
  Module["__emscripten_push_uncounted_main_loop_blocker"] = __emscripten_push_uncounted_main_loop_blocker;

  function _emscripten_set_main_loop_expected_blockers(num) {
      Browser.mainLoop.expectedBlockers = num;
      Browser.mainLoop.remainingBlockers = num;
      Browser.mainLoop.updateStatus();
    }
  Module["_emscripten_set_main_loop_expected_blockers"] = _emscripten_set_main_loop_expected_blockers;

  function _emscripten_async_call(func, arg, millis) {
      noExitRuntime = true;
  
      function wrapper() {
        getFuncWrapper(func, 'vi')(arg);
      }
  
      if (millis >= 0) {
        Browser.safeSetTimeout(wrapper, millis);
      } else {
        Browser.safeRequestAnimationFrame(wrapper);
      }
    }
  Module["_emscripten_async_call"] = _emscripten_async_call;

  function _emscripten_exit_with_live_runtime() {
      noExitRuntime = true;
      throw 'unwind';
    }
  Module["_emscripten_exit_with_live_runtime"] = _emscripten_exit_with_live_runtime;


  function _emscripten_hide_mouse() {
      var styleSheet = document.styleSheets[0];
      var rules = styleSheet.cssRules;
      for (var i = 0; i < rules.length; i++) {
        if (rules[i].cssText.substr(0, 6) == 'canvas') {
          styleSheet.deleteRule(i);
          i--;
        }
      }
      styleSheet.insertRule('canvas.emscripten { border: 1px solid black; cursor: none; }', 0);
    }
  Module["_emscripten_hide_mouse"] = _emscripten_hide_mouse;

  function _emscripten_set_canvas_size(width, height) {
      Browser.setCanvasSize(width, height);
    }
  Module["_emscripten_set_canvas_size"] = _emscripten_set_canvas_size;

  function _emscripten_get_canvas_size(width, height, isFullscreen) {
      var canvas = Module['canvas'];
      HEAP32[((width)>>2)]=canvas.width;
      HEAP32[((height)>>2)]=canvas.height;
      HEAP32[((isFullscreen)>>2)]=Browser.isFullscreen ? 1 : 0;
    }
  Module["_emscripten_get_canvas_size"] = _emscripten_get_canvas_size;

  function _emscripten_create_worker(url) {
      url = UTF8ToString(url);
      var id = Browser.workers.length;
      var info = {
        worker: new Worker(url),
        callbacks: [],
        awaited: 0,
        buffer: 0,
        bufferSize: 0
      };
      info.worker.onmessage = function info_worker_onmessage(msg) {
        if (ABORT) return;
        var info = Browser.workers[id];
        if (!info) return; // worker was destroyed meanwhile
        var callbackId = msg.data['callbackId'];
        var callbackInfo = info.callbacks[callbackId];
        if (!callbackInfo) return; // no callback or callback removed meanwhile
        // Don't trash our callback state if we expect additional calls.
        if (msg.data['finalResponse']) {
          info.awaited--;
          info.callbacks[callbackId] = null; // TODO: reuse callbackIds, compress this
        }
        var data = msg.data['data'];
        if (data) {
          if (!data.byteLength) data = new Uint8Array(data);
          if (!info.buffer || info.bufferSize < data.length) {
            if (info.buffer) _free(info.buffer);
            info.bufferSize = data.length;
            info.buffer = _malloc(data.length);
          }
          HEAPU8.set(data, info.buffer);
          callbackInfo.func(info.buffer, data.length, callbackInfo.arg);
        } else {
          callbackInfo.func(0, 0, callbackInfo.arg);
        }
      };
      Browser.workers.push(info);
      return id;
    }
  Module["_emscripten_create_worker"] = _emscripten_create_worker;

  function _emscripten_destroy_worker(id) {
      var info = Browser.workers[id];
      info.worker.terminate();
      if (info.buffer) _free(info.buffer);
      Browser.workers[id] = null;
    }
  Module["_emscripten_destroy_worker"] = _emscripten_destroy_worker;

  function _emscripten_call_worker(id, funcName, data, size, callback, arg) {
      noExitRuntime = true; // should we only do this if there is a callback?
  
      funcName = UTF8ToString(funcName);
      var info = Browser.workers[id];
      var callbackId = -1;
      if (callback) {
        callbackId = info.callbacks.length;
        info.callbacks.push({
          func: getFuncWrapper(callback, 'viii'),
          arg: arg
        });
        info.awaited++;
      }
      var transferObject = {
        'funcName': funcName,
        'callbackId': callbackId,
        'data': data ? new Uint8Array(HEAPU8.subarray((data),(data + size))) : 0
      };
      if (data) {
        info.worker.postMessage(transferObject, [transferObject.data.buffer]);
      } else {
        info.worker.postMessage(transferObject);
      }
    }
  Module["_emscripten_call_worker"] = _emscripten_call_worker;

  function _emscripten_worker_respond_provisionally(data, size) {
      if (workerResponded) throw 'already responded with final response!';
      var transferObject = {
        'callbackId': workerCallbackId,
        'finalResponse': false,
        'data': data ? new Uint8Array(HEAPU8.subarray((data),(data + size))) : 0
      };
      if (data) {
        postMessage(transferObject, [transferObject.data.buffer]);
      } else {
        postMessage(transferObject);
      }
    }
  Module["_emscripten_worker_respond_provisionally"] = _emscripten_worker_respond_provisionally;

  function _emscripten_worker_respond(data, size) {
      if (workerResponded) throw 'already responded with final response!';
      workerResponded = true;
      var transferObject = {
        'callbackId': workerCallbackId,
        'finalResponse': true,
        'data': data ? new Uint8Array(HEAPU8.subarray((data),(data + size))) : 0
      };
      if (data) {
        postMessage(transferObject, [transferObject.data.buffer]);
      } else {
        postMessage(transferObject);
      }
    }
  Module["_emscripten_worker_respond"] = _emscripten_worker_respond;

  function _emscripten_get_worker_queue_size(id) {
      var info = Browser.workers[id];
      if (!info) return -1;
      return info.awaited;
    }
  Module["_emscripten_get_worker_queue_size"] = _emscripten_get_worker_queue_size;

  function _emscripten_get_preloaded_image_data(path, w, h) {
      if ((path | 0) === path) path = UTF8ToString(path);
  
      path = PATH_FS.resolve(path);
  
      var canvas = Module["preloadedImages"][path];
      if (canvas) {
        var ctx = canvas.getContext("2d");
        var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var buf = _malloc(canvas.width * canvas.height * 4);
  
        HEAPU8.set(image.data, buf);
  
        HEAP32[((w)>>2)]=canvas.width;
        HEAP32[((h)>>2)]=canvas.height;
        return buf;
      }
  
      return 0;
    }
  Module["_emscripten_get_preloaded_image_data"] = _emscripten_get_preloaded_image_data;

  function _emscripten_get_preloaded_image_data_from_FILE(file, w, h) {
      var fd = Module['_fileno'](file);
      var stream = FS.getStream(fd);
      if (stream) {
        return _emscripten_get_preloaded_image_data(stream.path, w, h);
      }
  
      return 0;
    }
  Module["_emscripten_get_preloaded_image_data_from_FILE"] = _emscripten_get_preloaded_image_data_from_FILE;






  function ___set_network_callback(event, userData, callback) {
      function _callback(data) {
        try {
          if (event === 'error') {
            var sp = stackSave();
            var msg = allocate(intArrayFromString(data[2]), 'i8', ALLOC_STACK);
            dynCall_viiii(callback, data[0], data[1], msg, userData);
            stackRestore(sp);
          } else {
            dynCall_vii(callback, data, userData);
          }
        } catch (e) {
          if (e instanceof ExitStatus) {
            return;
          } else {
            if (e && typeof e === 'object' && e.stack) err('exception thrown: ' + [e, e.stack]);
            throw e;
          }
        }
      };
  
      noExitRuntime = true;
      Module['websocket']['on'](event, callback ? _callback : null);
    }
  Module["___set_network_callback"] = ___set_network_callback;

  function _emscripten_set_socket_error_callback(userData, callback) {
      ___set_network_callback('error', userData, callback);
    }
  Module["_emscripten_set_socket_error_callback"] = _emscripten_set_socket_error_callback;

  function _emscripten_set_socket_open_callback(userData, callback) {
      ___set_network_callback('open', userData, callback);
    }
  Module["_emscripten_set_socket_open_callback"] = _emscripten_set_socket_open_callback;

  function _emscripten_set_socket_listen_callback(userData, callback) {
      ___set_network_callback('listen', userData, callback);
    }
  Module["_emscripten_set_socket_listen_callback"] = _emscripten_set_socket_listen_callback;

  function _emscripten_set_socket_connection_callback(userData, callback) {
      ___set_network_callback('connection', userData, callback);
    }
  Module["_emscripten_set_socket_connection_callback"] = _emscripten_set_socket_connection_callback;

  function _emscripten_set_socket_message_callback(userData, callback) {
      ___set_network_callback('message', userData, callback);
    }
  Module["_emscripten_set_socket_message_callback"] = _emscripten_set_socket_message_callback;

  function _emscripten_set_socket_close_callback(userData, callback) {
      ___set_network_callback('close', userData, callback);
    }
  Module["_emscripten_set_socket_close_callback"] = _emscripten_set_socket_close_callback;





  function _emscripten_webgl_enable_ANGLE_instanced_arrays(ctx) {
      return __webgl_enable_ANGLE_instanced_arrays(GL.contexts[ctx].GLctx);
    }
  Module["_emscripten_webgl_enable_ANGLE_instanced_arrays"] = _emscripten_webgl_enable_ANGLE_instanced_arrays;


  function _emscripten_webgl_enable_OES_vertex_array_object(ctx) {
      return __webgl_enable_OES_vertex_array_object(GL.contexts[ctx].GLctx);
    }
  Module["_emscripten_webgl_enable_OES_vertex_array_object"] = _emscripten_webgl_enable_OES_vertex_array_object;


  function _emscripten_webgl_enable_WEBGL_draw_buffers(ctx) {
      return __webgl_enable_WEBGL_draw_buffers(GL.contexts[ctx].GLctx);
    }
  Module["_emscripten_webgl_enable_WEBGL_draw_buffers"] = _emscripten_webgl_enable_WEBGL_draw_buffers;


  function _glPixelStorei(pname, param) {
      if (pname == 0xCF5 /* GL_UNPACK_ALIGNMENT */) {
        GL.unpackAlignment = param;
      }
      GLctx.pixelStorei(pname, param);
    }
  Module["_glPixelStorei"] = _glPixelStorei;

  function _glGetString(name_) {
      if (GL.stringCache[name_]) return GL.stringCache[name_];
      var ret;
      switch(name_) {
        case 0x1F03 /* GL_EXTENSIONS */:
          var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
          exts = exts.concat(exts.map(function(e) { return "GL_" + e; }));
          ret = stringToNewUTF8(exts.join(' '));
          break;
        case 0x1F00 /* GL_VENDOR */:
        case 0x1F01 /* GL_RENDERER */:
        case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
        case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
          var s = GLctx.getParameter(name_);
          if (!s) {
            GL.recordError(0x500/*GL_INVALID_ENUM*/);
          }
          ret = stringToNewUTF8(s);
          break;
  
        case 0x1F02 /* GL_VERSION */:
          var glVersion = GLctx.getParameter(0x1F02 /*GL_VERSION*/);
          // return GLES version string corresponding to the version of the WebGL context
          {
            glVersion = 'OpenGL ES 2.0 (' + glVersion + ')';
          }
          ret = stringToNewUTF8(glVersion);
          break;
        case 0x8B8C /* GL_SHADING_LANGUAGE_VERSION */:
          var glslVersion = GLctx.getParameter(0x8B8C /*GL_SHADING_LANGUAGE_VERSION*/);
          // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
          var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
          var ver_num = glslVersion.match(ver_re);
          if (ver_num !== null) {
            if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
            glslVersion = 'OpenGL ES GLSL ES ' + ver_num[1] + ' (' + glslVersion + ')';
          }
          ret = stringToNewUTF8(glslVersion);
          break;
        default:
          GL.recordError(0x500/*GL_INVALID_ENUM*/);
          return 0;
      }
      GL.stringCache[name_] = ret;
      return ret;
    }
  Module["_glGetString"] = _glGetString;


  function _glGetIntegerv(name_, p) {
      emscriptenWebGLGet(name_, p, 0);
    }
  Module["_glGetIntegerv"] = _glGetIntegerv;

  function _glGetFloatv(name_, p) {
      emscriptenWebGLGet(name_, p, 2);
    }
  Module["_glGetFloatv"] = _glGetFloatv;

  function _glGetBooleanv(name_, p) {
      emscriptenWebGLGet(name_, p, 4);
    }
  Module["_glGetBooleanv"] = _glGetBooleanv;

  function _glDeleteTextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((textures)+(i*4))>>2)];
        var texture = GL.textures[id];
        if (!texture) continue; // GL spec: "glDeleteTextures silently ignores 0s and names that do not correspond to existing textures".
        GLctx.deleteTexture(texture);
        texture.name = 0;
        GL.textures[id] = null;
      }
    }
  Module["_glDeleteTextures"] = _glDeleteTextures;

  function _glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data) {
      GLctx['compressedTexImage2D'](target, level, internalFormat, width, height, border, data ? HEAPU8.subarray((data),(data+imageSize)) : null);
    }
  Module["_glCompressedTexImage2D"] = _glCompressedTexImage2D;

  function _glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data) {
      GLctx['compressedTexSubImage2D'](target, level, xoffset, yoffset, width, height, format, data ? HEAPU8.subarray((data),(data+imageSize)) : null);
    }
  Module["_glCompressedTexSubImage2D"] = _glCompressedTexSubImage2D;




  function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
      GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
    }
  Module["_glTexImage2D"] = _glTexImage2D;

  function _glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
      var pixelData = null;
      if (pixels) pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
      GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
    }
  Module["_glTexSubImage2D"] = _glTexSubImage2D;

  function _glReadPixels(x, y, width, height, format, type, pixels) {
      var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
      if (!pixelData) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        return;
      }
      GLctx.readPixels(x, y, width, height, format, type, pixelData);
    }
  Module["_glReadPixels"] = _glReadPixels;

  function _glBindTexture(target, texture) {
      GLctx.bindTexture(target, GL.textures[texture]);
    }
  Module["_glBindTexture"] = _glBindTexture;

  function _glGetTexParameterfv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAPF32[((params)>>2)]=GLctx.getTexParameter(target, pname);
    }
  Module["_glGetTexParameterfv"] = _glGetTexParameterfv;

  function _glGetTexParameteriv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)]=GLctx.getTexParameter(target, pname);
    }
  Module["_glGetTexParameteriv"] = _glGetTexParameteriv;

  function _glTexParameterfv(target, pname, params) {
      var param = HEAPF32[((params)>>2)];
      GLctx.texParameterf(target, pname, param);
    }
  Module["_glTexParameterfv"] = _glTexParameterfv;

  function _glTexParameteriv(target, pname, params) {
      var param = HEAP32[((params)>>2)];
      GLctx.texParameteri(target, pname, param);
    }
  Module["_glTexParameteriv"] = _glTexParameteriv;

  function _glIsTexture(id) {
      var texture = GL.textures[id];
      if (!texture) return 0;
      return GLctx.isTexture(texture);
    }
  Module["_glIsTexture"] = _glIsTexture;


  function _glGenBuffers(n, buffers) {
      __glGenObject(n, buffers, 'createBuffer', GL.buffers
        );
    }
  Module["_glGenBuffers"] = _glGenBuffers;

  function _glGenTextures(n, textures) {
      __glGenObject(n, textures, 'createTexture', GL.textures
        );
    }
  Module["_glGenTextures"] = _glGenTextures;

  function _glDeleteBuffers(n, buffers) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((buffers)+(i*4))>>2)];
        var buffer = GL.buffers[id];
  
        // From spec: "glDeleteBuffers silently ignores 0's and names that do not
        // correspond to existing buffer objects."
        if (!buffer) continue;
  
        GLctx.deleteBuffer(buffer);
        buffer.name = 0;
        GL.buffers[id] = null;
  
        if (id == GL.currArrayBuffer) GL.currArrayBuffer = 0;
        if (id == GL.currElementArrayBuffer) GL.currElementArrayBuffer = 0;
      }
    }
  Module["_glDeleteBuffers"] = _glDeleteBuffers;

  function _glGetBufferParameteriv(target, value, data) {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
        // if data == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((data)>>2)]=GLctx.getBufferParameter(target, value);
    }
  Module["_glGetBufferParameteriv"] = _glGetBufferParameteriv;

  function _glBufferData(target, size, data, usage) {
        // N.b. here first form specifies a heap subarray, second form an integer size, so the ?: code here is polymorphic. It is advised to avoid
        // randomly mixing both uses in calling code, to avoid any potential JS engine JIT issues.
        GLctx.bufferData(target, data ? HEAPU8.subarray(data, data+size) : size, usage);
    }
  Module["_glBufferData"] = _glBufferData;

  function _glBufferSubData(target, offset, size, data) {
      GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data+size));
    }
  Module["_glBufferSubData"] = _glBufferSubData;

  function _glGenQueriesEXT(n, ids) {
      for (var i = 0; i < n; i++) {
        var query = GLctx.disjointTimerQueryExt['createQueryEXT']();
        if (!query) {
          GL.recordError(0x502 /* GL_INVALID_OPERATION */);
          while(i < n) HEAP32[(((ids)+(i++*4))>>2)]=0;
          return;
        }
        var id = GL.getNewId(GL.timerQueriesEXT);
        query.name = id;
        GL.timerQueriesEXT[id] = query;
        HEAP32[(((ids)+(i*4))>>2)]=id;
      }
    }
  Module["_glGenQueriesEXT"] = _glGenQueriesEXT;

  function _glDeleteQueriesEXT(n, ids) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((ids)+(i*4))>>2)];
        var query = GL.timerQueriesEXT[id];
        if (!query) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
        GLctx.disjointTimerQueryExt['deleteQueryEXT'](query);
        GL.timerQueriesEXT[id] = null;
      }
    }
  Module["_glDeleteQueriesEXT"] = _glDeleteQueriesEXT;

  function _glIsQueryEXT(id) {
      var query = GL.timerQueriesEXT[id];
      if (!query) return 0;
      return GLctx.disjointTimerQueryExt['isQueryEXT'](query);
    }
  Module["_glIsQueryEXT"] = _glIsQueryEXT;

  function _glBeginQueryEXT(target, id) {
      GLctx.disjointTimerQueryExt['beginQueryEXT'](target, GL.timerQueriesEXT[id]);
    }
  Module["_glBeginQueryEXT"] = _glBeginQueryEXT;

  function _glEndQueryEXT(target) {
      GLctx.disjointTimerQueryExt['endQueryEXT'](target);
    }
  Module["_glEndQueryEXT"] = _glEndQueryEXT;

  function _glQueryCounterEXT(id, target) {
      GLctx.disjointTimerQueryExt['queryCounterEXT'](GL.timerQueriesEXT[id], target);
    }
  Module["_glQueryCounterEXT"] = _glQueryCounterEXT;

  function _glGetQueryivEXT(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)]=GLctx.disjointTimerQueryExt['getQueryEXT'](target, pname);
    }
  Module["_glGetQueryivEXT"] = _glGetQueryivEXT;

  function _glGetQueryObjectivEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      HEAP32[((params)>>2)]=ret;
    }
  Module["_glGetQueryObjectivEXT"] = _glGetQueryObjectivEXT;

  function _glGetQueryObjectuivEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      HEAP32[((params)>>2)]=ret;
    }
  Module["_glGetQueryObjectuivEXT"] = _glGetQueryObjectuivEXT;

  function _glGetQueryObjecti64vEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      writeI53ToI64(params, ret);
    }
  Module["_glGetQueryObjecti64vEXT"] = _glGetQueryObjecti64vEXT;

  function _glGetQueryObjectui64vEXT(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.timerQueriesEXT[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      writeI53ToI64(params, ret);
    }
  Module["_glGetQueryObjectui64vEXT"] = _glGetQueryObjectui64vEXT;

  function _glIsBuffer(buffer) {
      var b = GL.buffers[buffer];
      if (!b) return 0;
      return GLctx.isBuffer(b);
    }
  Module["_glIsBuffer"] = _glIsBuffer;

  function _glGenRenderbuffers(n, renderbuffers) {
      __glGenObject(n, renderbuffers, 'createRenderbuffer', GL.renderbuffers
        );
    }
  Module["_glGenRenderbuffers"] = _glGenRenderbuffers;

  function _glDeleteRenderbuffers(n, renderbuffers) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((renderbuffers)+(i*4))>>2)];
        var renderbuffer = GL.renderbuffers[id];
        if (!renderbuffer) continue; // GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
        GLctx.deleteRenderbuffer(renderbuffer);
        renderbuffer.name = 0;
        GL.renderbuffers[id] = null;
      }
    }
  Module["_glDeleteRenderbuffers"] = _glDeleteRenderbuffers;

  function _glBindRenderbuffer(target, renderbuffer) {
      GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
    }
  Module["_glBindRenderbuffer"] = _glBindRenderbuffer;

  function _glGetRenderbufferParameteriv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)]=GLctx.getRenderbufferParameter(target, pname);
    }
  Module["_glGetRenderbufferParameteriv"] = _glGetRenderbufferParameteriv;

  function _glIsRenderbuffer(renderbuffer) {
      var rb = GL.renderbuffers[renderbuffer];
      if (!rb) return 0;
      return GLctx.isRenderbuffer(rb);
    }
  Module["_glIsRenderbuffer"] = _glIsRenderbuffer;


  function _glGetUniformfv(program, location, params) {
      emscriptenWebGLGetUniform(program, location, params, 2);
    }
  Module["_glGetUniformfv"] = _glGetUniformfv;

  function _glGetUniformiv(program, location, params) {
      emscriptenWebGLGetUniform(program, location, params, 0);
    }
  Module["_glGetUniformiv"] = _glGetUniformiv;

  function _glGetUniformLocation(program, name) {
      name = UTF8ToString(name);
  
      var arrayIndex = 0;
      // If user passed an array accessor "[index]", parse the array index off the accessor.
      if (name[name.length - 1] == ']') {
        var leftBrace = name.lastIndexOf('[');
        arrayIndex = name[leftBrace+1] != ']' ? jstoi_q(name.slice(leftBrace + 1)) : 0; // "index]", parseInt will ignore the ']' at the end; but treat "foo[]" as "foo[0]"
        name = name.slice(0, leftBrace);
      }
  
      var uniformInfo = GL.programInfos[program] && GL.programInfos[program].uniforms[name]; // returns pair [ dimension_of_uniform_array, uniform_location ]
      if (uniformInfo && arrayIndex >= 0 && arrayIndex < uniformInfo[0]) { // Check if user asked for an out-of-bounds element, i.e. for 'vec4 colors[3];' user could ask for 'colors[10]' which should return -1.
        return uniformInfo[1] + arrayIndex;
      } else {
        return -1;
      }
    }
  Module["_glGetUniformLocation"] = _glGetUniformLocation;


  function _glGetVertexAttribfv(index, pname, params) {
      // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
      // otherwise the results are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
    }
  Module["_glGetVertexAttribfv"] = _glGetVertexAttribfv;

  function _glGetVertexAttribiv(index, pname, params) {
      // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
      // otherwise the results are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
    }
  Module["_glGetVertexAttribiv"] = _glGetVertexAttribiv;

  function _glGetVertexAttribPointerv(index, pname, pointer) {
      if (!pointer) {
        // GLES2 specification does not specify how to behave if pointer is a null pointer. Since calling this function does not make sense
        // if pointer == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((pointer)>>2)]=GLctx.getVertexAttribOffset(index, pname);
    }
  Module["_glGetVertexAttribPointerv"] = _glGetVertexAttribPointerv;

  function _glGetActiveUniform(program, index, bufSize, length, size, type, name) {
      program = GL.programs[program];
      var info = GLctx.getActiveUniform(program, index);
      if (!info) return; // If an error occurs, nothing will be written to length, size, type and name.
  
      var numBytesWrittenExclNull = (bufSize > 0 && name) ? stringToUTF8(info.name, name, bufSize) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
      if (size) HEAP32[((size)>>2)]=info.size;
      if (type) HEAP32[((type)>>2)]=info.type;
    }
  Module["_glGetActiveUniform"] = _glGetActiveUniform;

  function _glUniform1f(location, v0) {
      GLctx.uniform1f(GL.uniforms[location], v0);
    }
  Module["_glUniform1f"] = _glUniform1f;

  function _glUniform2f(location, v0, v1) {
      GLctx.uniform2f(GL.uniforms[location], v0, v1);
    }
  Module["_glUniform2f"] = _glUniform2f;

  function _glUniform3f(location, v0, v1, v2) {
      GLctx.uniform3f(GL.uniforms[location], v0, v1, v2);
    }
  Module["_glUniform3f"] = _glUniform3f;

  function _glUniform4f(location, v0, v1, v2, v3) {
      GLctx.uniform4f(GL.uniforms[location], v0, v1, v2, v3);
    }
  Module["_glUniform4f"] = _glUniform4f;

  function _glUniform1i(location, v0) {
      GLctx.uniform1i(GL.uniforms[location], v0);
    }
  Module["_glUniform1i"] = _glUniform1i;

  function _glUniform2i(location, v0, v1) {
      GLctx.uniform2i(GL.uniforms[location], v0, v1);
    }
  Module["_glUniform2i"] = _glUniform2i;

  function _glUniform3i(location, v0, v1, v2) {
      GLctx.uniform3i(GL.uniforms[location], v0, v1, v2);
    }
  Module["_glUniform3i"] = _glUniform3i;

  function _glUniform4i(location, v0, v1, v2, v3) {
      GLctx.uniform4i(GL.uniforms[location], v0, v1, v2, v3);
    }
  Module["_glUniform4i"] = _glUniform4i;

  function _glUniform1iv(location, count, value) {
  
  
      if (count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*4)>>2);
      }
      GLctx.uniform1iv(GL.uniforms[location], view);
    }
  Module["_glUniform1iv"] = _glUniform1iv;

  function _glUniform2iv(location, count, value) {
  
  
      if (2*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*8)>>2);
      }
      GLctx.uniform2iv(GL.uniforms[location], view);
    }
  Module["_glUniform2iv"] = _glUniform2iv;

  function _glUniform3iv(location, count, value) {
  
  
      if (3*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAP32[(((value)+(4*i+8))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*12)>>2);
      }
      GLctx.uniform3iv(GL.uniforms[location], view);
    }
  Module["_glUniform3iv"] = _glUniform3iv;

  function _glUniform4iv(location, count, value) {
  
  
      if (4*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferIntViews[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAP32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAP32[(((value)+(4*i+12))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2,(value+count*16)>>2);
      }
      GLctx.uniform4iv(GL.uniforms[location], view);
    }
  Module["_glUniform4iv"] = _glUniform4iv;

  function _glUniform1fv(location, count, value) {
  
  
      if (count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*4)>>2);
      }
      GLctx.uniform1fv(GL.uniforms[location], view);
    }
  Module["_glUniform1fv"] = _glUniform1fv;

  function _glUniform2fv(location, count, value) {
  
  
      if (2*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*8)>>2);
      }
      GLctx.uniform2fv(GL.uniforms[location], view);
    }
  Module["_glUniform2fv"] = _glUniform2fv;

  function _glUniform3fv(location, count, value) {
  
  
      if (3*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*12)>>2);
      }
      GLctx.uniform3fv(GL.uniforms[location], view);
    }
  Module["_glUniform3fv"] = _glUniform3fv;

  function _glUniform4fv(location, count, value) {
  
  
      if (4*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[4*count-1];
        // hoist the heap out of the loop for size and for pthreads+growth.
        var heap = HEAPF32;
        value >>= 2;
        for (var i = 0; i < 4 * count; i += 4) {
          var dst = value + i;
          view[i] = heap[dst];
          view[i + 1] = heap[dst + 1];
          view[i + 2] = heap[dst + 2];
          view[i + 3] = heap[dst + 3];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*16)>>2);
      }
      GLctx.uniform4fv(GL.uniforms[location], view);
    }
  Module["_glUniform4fv"] = _glUniform4fv;

  function _glUniformMatrix2fv(location, count, transpose, value) {
  
  
      if (4*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAPF32[(((value)+(4*i+12))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*16)>>2);
      }
      GLctx.uniformMatrix2fv(GL.uniforms[location], !!transpose, view);
    }
  Module["_glUniformMatrix2fv"] = _glUniformMatrix2fv;

  function _glUniformMatrix3fv(location, count, transpose, value) {
  
  
      if (9*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[9*count-1];
        for (var i = 0; i < 9*count; i += 9) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAPF32[(((value)+(4*i+12))>>2)];
          view[i+4] = HEAPF32[(((value)+(4*i+16))>>2)];
          view[i+5] = HEAPF32[(((value)+(4*i+20))>>2)];
          view[i+6] = HEAPF32[(((value)+(4*i+24))>>2)];
          view[i+7] = HEAPF32[(((value)+(4*i+28))>>2)];
          view[i+8] = HEAPF32[(((value)+(4*i+32))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*36)>>2);
      }
      GLctx.uniformMatrix3fv(GL.uniforms[location], !!transpose, view);
    }
  Module["_glUniformMatrix3fv"] = _glUniformMatrix3fv;

  function _glUniformMatrix4fv(location, count, transpose, value) {
  
  
      if (16*count <= GL.MINI_TEMP_BUFFER_SIZE) {
        // avoid allocation when uploading few enough uniforms
        var view = GL.miniTempBufferFloatViews[16*count-1];
        // hoist the heap out of the loop for size and for pthreads+growth.
        var heap = HEAPF32;
        value >>= 2;
        for (var i = 0; i < 16 * count; i += 16) {
          var dst = value + i;
          view[i] = heap[dst];
          view[i + 1] = heap[dst + 1];
          view[i + 2] = heap[dst + 2];
          view[i + 3] = heap[dst + 3];
          view[i + 4] = heap[dst + 4];
          view[i + 5] = heap[dst + 5];
          view[i + 6] = heap[dst + 6];
          view[i + 7] = heap[dst + 7];
          view[i + 8] = heap[dst + 8];
          view[i + 9] = heap[dst + 9];
          view[i + 10] = heap[dst + 10];
          view[i + 11] = heap[dst + 11];
          view[i + 12] = heap[dst + 12];
          view[i + 13] = heap[dst + 13];
          view[i + 14] = heap[dst + 14];
          view[i + 15] = heap[dst + 15];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2,(value+count*64)>>2);
      }
      GLctx.uniformMatrix4fv(GL.uniforms[location], !!transpose, view);
    }
  Module["_glUniformMatrix4fv"] = _glUniformMatrix4fv;

  function _glBindBuffer(target, buffer) {
  
      GLctx.bindBuffer(target, GL.buffers[buffer]);
    }
  Module["_glBindBuffer"] = _glBindBuffer;

  function _glVertexAttrib1fv(index, v) {
  
      GLctx.vertexAttrib1f(index, HEAPF32[v>>2]);
    }
  Module["_glVertexAttrib1fv"] = _glVertexAttrib1fv;

  function _glVertexAttrib2fv(index, v) {
  
      GLctx.vertexAttrib2f(index, HEAPF32[v>>2], HEAPF32[v+4>>2]);
    }
  Module["_glVertexAttrib2fv"] = _glVertexAttrib2fv;

  function _glVertexAttrib3fv(index, v) {
  
      GLctx.vertexAttrib3f(index, HEAPF32[v>>2], HEAPF32[v+4>>2], HEAPF32[v+8>>2]);
    }
  Module["_glVertexAttrib3fv"] = _glVertexAttrib3fv;

  function _glVertexAttrib4fv(index, v) {
  
      GLctx.vertexAttrib4f(index, HEAPF32[v>>2], HEAPF32[v+4>>2], HEAPF32[v+8>>2], HEAPF32[v+12>>2]);
    }
  Module["_glVertexAttrib4fv"] = _glVertexAttrib4fv;

  function _glGetAttribLocation(program, name) {
      return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
    }
  Module["_glGetAttribLocation"] = _glGetAttribLocation;

  function _glGetActiveAttrib(program, index, bufSize, length, size, type, name) {
      program = GL.programs[program];
      var info = GLctx.getActiveAttrib(program, index);
      if (!info) return; // If an error occurs, nothing will be written to length, size and type and name.
  
      var numBytesWrittenExclNull = (bufSize > 0 && name) ? stringToUTF8(info.name, name, bufSize) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
      if (size) HEAP32[((size)>>2)]=info.size;
      if (type) HEAP32[((type)>>2)]=info.type;
    }
  Module["_glGetActiveAttrib"] = _glGetActiveAttrib;

  function _glCreateShader(shaderType) {
      var id = GL.getNewId(GL.shaders);
      GL.shaders[id] = GLctx.createShader(shaderType);
      return id;
    }
  Module["_glCreateShader"] = _glCreateShader;

  function _glDeleteShader(id) {
      if (!id) return;
      var shader = GL.shaders[id];
      if (!shader) { // glDeleteShader actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteShader(shader);
      GL.shaders[id] = null;
    }
  Module["_glDeleteShader"] = _glDeleteShader;

  function _glGetAttachedShaders(program, maxCount, count, shaders) {
      var result = GLctx.getAttachedShaders(GL.programs[program]);
      var len = result.length;
      if (len > maxCount) {
        len = maxCount;
      }
      HEAP32[((count)>>2)]=len;
      for (var i = 0; i < len; ++i) {
        var id = GL.shaders.indexOf(result[i]);
        HEAP32[(((shaders)+(i*4))>>2)]=id;
      }
    }
  Module["_glGetAttachedShaders"] = _glGetAttachedShaders;

  function _glShaderSource(shader, count, string, length) {
      var source = GL.getSource(shader, count, string, length);
  
  
      GLctx.shaderSource(GL.shaders[shader], source);
    }
  Module["_glShaderSource"] = _glShaderSource;

  function _glGetShaderSource(shader, bufSize, length, source) {
      var result = GLctx.getShaderSource(GL.shaders[shader]);
      if (!result) return; // If an error occurs, nothing will be written to length or source.
      var numBytesWrittenExclNull = (bufSize > 0 && source) ? stringToUTF8(result, source, bufSize) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
    }
  Module["_glGetShaderSource"] = _glGetShaderSource;

  function _glCompileShader(shader) {
      GLctx.compileShader(GL.shaders[shader]);
    }
  Module["_glCompileShader"] = _glCompileShader;

  function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
      var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
    }
  Module["_glGetShaderInfoLog"] = _glGetShaderInfoLog;

  function _glGetShaderiv(shader, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
        if (log === null) log = '(unknown error)';
        HEAP32[((p)>>2)]=log.length + 1;
      } else if (pname == 0x8B88) { // GL_SHADER_SOURCE_LENGTH
        var source = GLctx.getShaderSource(GL.shaders[shader]);
        var sourceLength = (source === null || source.length == 0) ? 0 : source.length + 1;
        HEAP32[((p)>>2)]=sourceLength;
      } else {
        HEAP32[((p)>>2)]=GLctx.getShaderParameter(GL.shaders[shader], pname);
      }
    }
  Module["_glGetShaderiv"] = _glGetShaderiv;

  function _glGetProgramiv(program, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      if (program >= GL.counter) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      var ptable = GL.programInfos[program];
      if (!ptable) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        return;
      }
  
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getProgramInfoLog(GL.programs[program]);
        if (log === null) log = '(unknown error)';
        HEAP32[((p)>>2)]=log.length + 1;
      } else if (pname == 0x8B87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
        HEAP32[((p)>>2)]=ptable.maxUniformLength;
      } else if (pname == 0x8B8A /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
        if (ptable.maxAttributeLength == -1) {
          program = GL.programs[program];
          var numAttribs = GLctx.getProgramParameter(program, 0x8B89/*GL_ACTIVE_ATTRIBUTES*/);
          ptable.maxAttributeLength = 0; // Spec says if there are no active attribs, 0 must be returned.
          for (var i = 0; i < numAttribs; ++i) {
            var activeAttrib = GLctx.getActiveAttrib(program, i);
            ptable.maxAttributeLength = Math.max(ptable.maxAttributeLength, activeAttrib.name.length+1);
          }
        }
        HEAP32[((p)>>2)]=ptable.maxAttributeLength;
      } else if (pname == 0x8A35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
        if (ptable.maxUniformBlockNameLength == -1) {
          program = GL.programs[program];
          var numBlocks = GLctx.getProgramParameter(program, 0x8A36/*GL_ACTIVE_UNIFORM_BLOCKS*/);
          ptable.maxUniformBlockNameLength = 0;
          for (var i = 0; i < numBlocks; ++i) {
            var activeBlockName = GLctx.getActiveUniformBlockName(program, i);
            ptable.maxUniformBlockNameLength = Math.max(ptable.maxUniformBlockNameLength, activeBlockName.length+1);
          }
        }
        HEAP32[((p)>>2)]=ptable.maxUniformBlockNameLength;
      } else {
        HEAP32[((p)>>2)]=GLctx.getProgramParameter(GL.programs[program], pname);
      }
    }
  Module["_glGetProgramiv"] = _glGetProgramiv;

  function _glIsShader(shader) {
      var s = GL.shaders[shader];
      if (!s) return 0;
      return GLctx.isShader(s);
    }
  Module["_glIsShader"] = _glIsShader;

  function _glCreateProgram() {
      var id = GL.getNewId(GL.programs);
      var program = GLctx.createProgram();
      program.name = id;
      GL.programs[id] = program;
      return id;
    }
  Module["_glCreateProgram"] = _glCreateProgram;

  function _glDeleteProgram(id) {
      if (!id) return;
      var program = GL.programs[id];
      if (!program) { // glDeleteProgram actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteProgram(program);
      program.name = 0;
      GL.programs[id] = null;
      GL.programInfos[id] = null;
    }
  Module["_glDeleteProgram"] = _glDeleteProgram;

  function _glAttachShader(program, shader) {
      GLctx.attachShader(GL.programs[program],
                              GL.shaders[shader]);
    }
  Module["_glAttachShader"] = _glAttachShader;

  function _glDetachShader(program, shader) {
      GLctx.detachShader(GL.programs[program],
                              GL.shaders[shader]);
    }
  Module["_glDetachShader"] = _glDetachShader;

  function _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
      var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
      HEAP32[((range)>>2)]=result.rangeMin;
      HEAP32[(((range)+(4))>>2)]=result.rangeMax;
      HEAP32[((precision)>>2)]=result.precision;
    }
  Module["_glGetShaderPrecisionFormat"] = _glGetShaderPrecisionFormat;

  function _glLinkProgram(program) {
      GLctx.linkProgram(GL.programs[program]);
      GL.populateUniformTable(program);
    }
  Module["_glLinkProgram"] = _glLinkProgram;

  function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
      var log = GLctx.getProgramInfoLog(GL.programs[program]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)]=numBytesWrittenExclNull;
    }
  Module["_glGetProgramInfoLog"] = _glGetProgramInfoLog;

  function _glUseProgram(program) {
      GLctx.useProgram(GL.programs[program]);
    }
  Module["_glUseProgram"] = _glUseProgram;

  function _glValidateProgram(program) {
      GLctx.validateProgram(GL.programs[program]);
    }
  Module["_glValidateProgram"] = _glValidateProgram;

  function _glIsProgram(program) {
      program = GL.programs[program];
      if (!program) return 0;
      return GLctx.isProgram(program);
    }
  Module["_glIsProgram"] = _glIsProgram;

  function _glBindAttribLocation(program, index, name) {
      GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
    }
  Module["_glBindAttribLocation"] = _glBindAttribLocation;

  function _glBindFramebuffer(target, framebuffer) {
  
      GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
  
    }
  Module["_glBindFramebuffer"] = _glBindFramebuffer;

  function _glGenFramebuffers(n, ids) {
      __glGenObject(n, ids, 'createFramebuffer', GL.framebuffers
        );
    }
  Module["_glGenFramebuffers"] = _glGenFramebuffers;

  function _glDeleteFramebuffers(n, framebuffers) {
      for (var i = 0; i < n; ++i) {
        var id = HEAP32[(((framebuffers)+(i*4))>>2)];
        var framebuffer = GL.framebuffers[id];
        if (!framebuffer) continue; // GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
        GLctx.deleteFramebuffer(framebuffer);
        framebuffer.name = 0;
        GL.framebuffers[id] = null;
      }
    }
  Module["_glDeleteFramebuffers"] = _glDeleteFramebuffers;

  function _glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
      GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget,
                                         GL.renderbuffers[renderbuffer]);
    }
  Module["_glFramebufferRenderbuffer"] = _glFramebufferRenderbuffer;

  function _glFramebufferTexture2D(target, attachment, textarget, texture, level) {
      GLctx.framebufferTexture2D(target, attachment, textarget,
                                      GL.textures[texture], level);
    }
  Module["_glFramebufferTexture2D"] = _glFramebufferTexture2D;

  function _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
      var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
      if (result instanceof WebGLRenderbuffer ||
          result instanceof WebGLTexture) {
        result = result.name | 0;
      }
      HEAP32[((params)>>2)]=result;
    }
  Module["_glGetFramebufferAttachmentParameteriv"] = _glGetFramebufferAttachmentParameteriv;

  function _glIsFramebuffer(framebuffer) {
      var fb = GL.framebuffers[framebuffer];
      if (!fb) return 0;
      return GLctx.isFramebuffer(fb);
    }
  Module["_glIsFramebuffer"] = _glIsFramebuffer;

  function _glGenVertexArrays(n, arrays) {
      __glGenObject(n, arrays, 'createVertexArray', GL.vaos
        );
    }
  Module["_glGenVertexArrays"] = _glGenVertexArrays;

  function _glDeleteVertexArrays(n, vaos) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((vaos)+(i*4))>>2)];
        GLctx['deleteVertexArray'](GL.vaos[id]);
        GL.vaos[id] = null;
      }
    }
  Module["_glDeleteVertexArrays"] = _glDeleteVertexArrays;

  function _glBindVertexArray(vao) {
      GLctx['bindVertexArray'](GL.vaos[vao]);
    }
  Module["_glBindVertexArray"] = _glBindVertexArray;

  function _glIsVertexArray(array) {
  
      var vao = GL.vaos[array];
      if (!vao) return 0;
      return GLctx['isVertexArray'](vao);
    }
  Module["_glIsVertexArray"] = _glIsVertexArray;

  function _glVertexPointer(){ throw 'Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_glVertexPointer"] = _glVertexPointer;

  function _glMatrixMode(){ throw 'Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_glMatrixMode"] = _glMatrixMode;

  function _glBegin(){ throw 'Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_glBegin"] = _glBegin;

  function _glLoadIdentity(){ throw 'Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_glLoadIdentity"] = _glLoadIdentity;

  function _glGenVertexArraysOES(n, arrays) {
      __glGenObject(n, arrays, 'createVertexArray', GL.vaos
        );
    }
  Module["_glGenVertexArraysOES"] = _glGenVertexArraysOES;

  function _glDeleteVertexArraysOES(n, vaos) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((vaos)+(i*4))>>2)];
        GLctx['deleteVertexArray'](GL.vaos[id]);
        GL.vaos[id] = null;
      }
    }
  Module["_glDeleteVertexArraysOES"] = _glDeleteVertexArraysOES;

  function _glBindVertexArrayOES(vao) {
      GLctx['bindVertexArray'](GL.vaos[vao]);
    }
  Module["_glBindVertexArrayOES"] = _glBindVertexArrayOES;

  function _glIsVertexArrayOES(array) {
  
      var vao = GL.vaos[array];
      if (!vao) return 0;
      return GLctx['isVertexArray'](vao);
    }
  Module["_glIsVertexArrayOES"] = _glIsVertexArrayOES;

  function _gluPerspective(fov, aspect, near, far) {
      GLImmediate.matricesModified = true;
      GLImmediate.matrixVersion[GLImmediate.currentMatrix] = (GLImmediate.matrixVersion[GLImmediate.currentMatrix] + 1)|0;
      GLImmediate.matrix[GLImmediate.currentMatrix] =
        GLImmediate.matrixLib.mat4.perspective(fov, aspect, near, far,
                                                 GLImmediate.matrix[GLImmediate.currentMatrix]);
    }
  Module["_gluPerspective"] = _gluPerspective;

  function _gluLookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz) {
      GLImmediate.matricesModified = true;
      GLImmediate.matrixVersion[GLImmediate.currentMatrix] = (GLImmediate.matrixVersion[GLImmediate.currentMatrix] + 1)|0;
      GLImmediate.matrixLib.mat4.lookAt(GLImmediate.matrix[GLImmediate.currentMatrix], [ex, ey, ez],
          [cx, cy, cz], [ux, uy, uz]);
    }
  Module["_gluLookAt"] = _gluLookAt;

  function _gluProject(objX, objY, objZ, model, proj, view, winX, winY, winZ) {
      // The algorithm for this functions comes from Mesa
  
      var inVec = new Float32Array(4);
      var outVec = new Float32Array(4);
      GLImmediate.matrixLib.mat4.multiplyVec4(HEAPF64.subarray((model)>>3,(model+128)>>3),
          [objX, objY, objZ, 1.0], outVec);
      GLImmediate.matrixLib.mat4.multiplyVec4(HEAPF64.subarray((proj)>>3,(proj+128)>>3),
          outVec, inVec);
      if (inVec[3] == 0.0) {
        return 0 /* GL_FALSE */;
      }
      inVec[0] /= inVec[3];
      inVec[1] /= inVec[3];
      inVec[2] /= inVec[3];
      // Map x, y and z to range 0-1 */
      inVec[0] = inVec[0] * 0.5 + 0.5;
      inVec[1] = inVec[1] * 0.5 + 0.5;
      inVec[2] = inVec[2] * 0.5 + 0.5;
      // Map x, y to viewport
      inVec[0] = inVec[0] * HEAP32[(((view)+(8))>>2)] + HEAP32[((view)>>2)];
      inVec[1] = inVec[1] * HEAP32[(((view)+(12))>>2)] + HEAP32[(((view)+(4))>>2)];
  
      HEAPF64[((winX)>>3)]=inVec[0];
      HEAPF64[((winY)>>3)]=inVec[1];
      HEAPF64[((winZ)>>3)]=inVec[2];
  
      return 1 /* GL_TRUE */;
    }
  Module["_gluProject"] = _gluProject;

  function _gluUnProject(winX, winY, winZ, model, proj, view, objX, objY, objZ) {
      var result = GLImmediate.matrixLib.mat4.unproject([winX, winY, winZ],
          HEAPF64.subarray((model)>>3,(model+128)>>3),
          HEAPF64.subarray((proj)>>3,(proj+128)>>3),
          HEAP32.subarray((view)>>2,(view+16)>>2));
  
      if (result === null) {
        return 0 /* GL_FALSE */;
      }
  
      HEAPF64[((objX)>>3)]=result[0];
      HEAPF64[((objY)>>3)]=result[1];
      HEAPF64[((objZ)>>3)]=result[2];
  
      return 1 /* GL_TRUE */;
    }
  Module["_gluUnProject"] = _gluUnProject;

  
  function _glOrtho(
  ) {
  if (!Module['_glOrtho']) abort("external function 'glOrtho' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_glOrtho'].apply(null, arguments);
  }function _gluOrtho2D(left, right, bottom, top) {
      _glOrtho(left, right, bottom, top, -1, 1);
    }
  Module["_gluOrtho2D"] = _gluOrtho2D;

  function _glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
      GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
    }
  Module["_glVertexAttribPointer"] = _glVertexAttribPointer;

  function _glEnableVertexAttribArray(index) {
      GLctx.enableVertexAttribArray(index);
    }
  Module["_glEnableVertexAttribArray"] = _glEnableVertexAttribArray;

  function _glDisableVertexAttribArray(index) {
      GLctx.disableVertexAttribArray(index);
    }
  Module["_glDisableVertexAttribArray"] = _glDisableVertexAttribArray;

  function _glDrawArrays(mode, first, count) {
  
      GLctx.drawArrays(mode, first, count);
  
    }
  Module["_glDrawArrays"] = _glDrawArrays;

  function _glDrawElements(mode, count, type, indices) {
  
      GLctx.drawElements(mode, count, type, indices);
  
    }
  Module["_glDrawElements"] = _glDrawElements;

  function _glShaderBinary() {
      GL.recordError(0x500/*GL_INVALID_ENUM*/);
    }
  Module["_glShaderBinary"] = _glShaderBinary;

  function _glReleaseShaderCompiler() {
      // NOP (as allowed by GLES 2.0 spec)
    }
  Module["_glReleaseShaderCompiler"] = _glReleaseShaderCompiler;

  function _glGetError() {
      var error = GLctx.getError() || GL.lastError;
      GL.lastError = 0/*GL_NO_ERROR*/;
      return error;
    }
  Module["_glGetError"] = _glGetError;

  function _glVertexAttribDivisor(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_glVertexAttribDivisor"] = _glVertexAttribDivisor;

  function _glDrawArraysInstanced(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_glDrawArraysInstanced"] = _glDrawArraysInstanced;

  function _glDrawElementsInstanced(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_glDrawElementsInstanced"] = _glDrawElementsInstanced;

  function _glVertexAttribDivisorNV(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_glVertexAttribDivisorNV"] = _glVertexAttribDivisorNV;

  function _glDrawArraysInstancedNV(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_glDrawArraysInstancedNV"] = _glDrawArraysInstancedNV;

  function _glDrawElementsInstancedNV(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_glDrawElementsInstancedNV"] = _glDrawElementsInstancedNV;

  function _glVertexAttribDivisorEXT(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_glVertexAttribDivisorEXT"] = _glVertexAttribDivisorEXT;

  function _glDrawArraysInstancedEXT(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_glDrawArraysInstancedEXT"] = _glDrawArraysInstancedEXT;

  function _glDrawElementsInstancedEXT(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_glDrawElementsInstancedEXT"] = _glDrawElementsInstancedEXT;

  function _glVertexAttribDivisorARB(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_glVertexAttribDivisorARB"] = _glVertexAttribDivisorARB;

  function _glDrawArraysInstancedARB(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_glDrawArraysInstancedARB"] = _glDrawArraysInstancedARB;

  function _glDrawElementsInstancedARB(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_glDrawElementsInstancedARB"] = _glDrawElementsInstancedARB;

  function _glVertexAttribDivisorANGLE(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_glVertexAttribDivisorANGLE"] = _glVertexAttribDivisorANGLE;

  function _glDrawArraysInstancedANGLE(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_glDrawArraysInstancedANGLE"] = _glDrawArraysInstancedANGLE;

  function _glDrawElementsInstancedANGLE(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_glDrawElementsInstancedANGLE"] = _glDrawElementsInstancedANGLE;

  function _glDrawBuffers(n, bufs) {
  
      var bufArray = __tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx['drawBuffers'](bufArray);
    }
  Module["_glDrawBuffers"] = _glDrawBuffers;

  function _glDrawBuffersEXT(n, bufs) {
  
      var bufArray = __tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx['drawBuffers'](bufArray);
    }
  Module["_glDrawBuffersEXT"] = _glDrawBuffersEXT;

  function _glDrawBuffersWEBGL(n, bufs) {
  
      var bufArray = __tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx['drawBuffers'](bufArray);
    }
  Module["_glDrawBuffersWEBGL"] = _glDrawBuffersWEBGL;

  function _glColorMask(red, green, blue, alpha) {
      GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
    }
  Module["_glColorMask"] = _glColorMask;

  function _glDepthMask(flag) {
      GLctx.depthMask(!!flag);
    }
  Module["_glDepthMask"] = _glDepthMask;

  function _glSampleCoverage(value, invert) {
      GLctx.sampleCoverage(value, !!invert);
    }
  Module["_glSampleCoverage"] = _glSampleCoverage;

  function _glFinish() { GLctx['finish']() }
  Module["_glFinish"] = _glFinish;

  function _glFlush() { GLctx['flush']() }
  Module["_glFlush"] = _glFlush;

  function _glClearDepth(x0) { GLctx['clearDepth'](x0) }
  Module["_glClearDepth"] = _glClearDepth;

  function _glClearDepthf(x0) { GLctx['clearDepth'](x0) }
  Module["_glClearDepthf"] = _glClearDepthf;

  function _glDepthFunc(x0) { GLctx['depthFunc'](x0) }
  Module["_glDepthFunc"] = _glDepthFunc;

  function _glEnable(x0) { GLctx['enable'](x0) }
  Module["_glEnable"] = _glEnable;

  function _glDisable(x0) { GLctx['disable'](x0) }
  Module["_glDisable"] = _glDisable;

  function _glFrontFace(x0) { GLctx['frontFace'](x0) }
  Module["_glFrontFace"] = _glFrontFace;

  function _glCullFace(x0) { GLctx['cullFace'](x0) }
  Module["_glCullFace"] = _glCullFace;

  function _glClear(x0) { GLctx['clear'](x0) }
  Module["_glClear"] = _glClear;

  function _glLineWidth(x0) { GLctx['lineWidth'](x0) }
  Module["_glLineWidth"] = _glLineWidth;

  function _glClearStencil(x0) { GLctx['clearStencil'](x0) }
  Module["_glClearStencil"] = _glClearStencil;

  function _glStencilMask(x0) { GLctx['stencilMask'](x0) }
  Module["_glStencilMask"] = _glStencilMask;

  function _glCheckFramebufferStatus(x0) { return GLctx['checkFramebufferStatus'](x0) }
  Module["_glCheckFramebufferStatus"] = _glCheckFramebufferStatus;

  function _glGenerateMipmap(x0) { GLctx['generateMipmap'](x0) }
  Module["_glGenerateMipmap"] = _glGenerateMipmap;

  function _glActiveTexture(x0) { GLctx['activeTexture'](x0) }
  Module["_glActiveTexture"] = _glActiveTexture;

  function _glBlendEquation(x0) { GLctx['blendEquation'](x0) }
  Module["_glBlendEquation"] = _glBlendEquation;

  function _glIsEnabled(x0) { return GLctx['isEnabled'](x0) }
  Module["_glIsEnabled"] = _glIsEnabled;

  function _glBlendFunc(x0, x1) { GLctx['blendFunc'](x0, x1) }
  Module["_glBlendFunc"] = _glBlendFunc;

  function _glBlendEquationSeparate(x0, x1) { GLctx['blendEquationSeparate'](x0, x1) }
  Module["_glBlendEquationSeparate"] = _glBlendEquationSeparate;

  function _glDepthRange(x0, x1) { GLctx['depthRange'](x0, x1) }
  Module["_glDepthRange"] = _glDepthRange;

  function _glDepthRangef(x0, x1) { GLctx['depthRange'](x0, x1) }
  Module["_glDepthRangef"] = _glDepthRangef;

  function _glStencilMaskSeparate(x0, x1) { GLctx['stencilMaskSeparate'](x0, x1) }
  Module["_glStencilMaskSeparate"] = _glStencilMaskSeparate;

  function _glHint(x0, x1) { GLctx['hint'](x0, x1) }
  Module["_glHint"] = _glHint;

  function _glPolygonOffset(x0, x1) { GLctx['polygonOffset'](x0, x1) }
  Module["_glPolygonOffset"] = _glPolygonOffset;

  function _glVertexAttrib1f(x0, x1) { GLctx['vertexAttrib1f'](x0, x1) }
  Module["_glVertexAttrib1f"] = _glVertexAttrib1f;

  function _glTexParameteri(x0, x1, x2) { GLctx['texParameteri'](x0, x1, x2) }
  Module["_glTexParameteri"] = _glTexParameteri;

  function _glTexParameterf(x0, x1, x2) { GLctx['texParameterf'](x0, x1, x2) }
  Module["_glTexParameterf"] = _glTexParameterf;

  function _glVertexAttrib2f(x0, x1, x2) { GLctx['vertexAttrib2f'](x0, x1, x2) }
  Module["_glVertexAttrib2f"] = _glVertexAttrib2f;

  function _glStencilFunc(x0, x1, x2) { GLctx['stencilFunc'](x0, x1, x2) }
  Module["_glStencilFunc"] = _glStencilFunc;

  function _glStencilOp(x0, x1, x2) { GLctx['stencilOp'](x0, x1, x2) }
  Module["_glStencilOp"] = _glStencilOp;

  function _glViewport(x0, x1, x2, x3) { GLctx['viewport'](x0, x1, x2, x3) }
  Module["_glViewport"] = _glViewport;

  function _glClearColor(x0, x1, x2, x3) { GLctx['clearColor'](x0, x1, x2, x3) }
  Module["_glClearColor"] = _glClearColor;

  function _glScissor(x0, x1, x2, x3) { GLctx['scissor'](x0, x1, x2, x3) }
  Module["_glScissor"] = _glScissor;

  function _glVertexAttrib3f(x0, x1, x2, x3) { GLctx['vertexAttrib3f'](x0, x1, x2, x3) }
  Module["_glVertexAttrib3f"] = _glVertexAttrib3f;

  function _glRenderbufferStorage(x0, x1, x2, x3) { GLctx['renderbufferStorage'](x0, x1, x2, x3) }
  Module["_glRenderbufferStorage"] = _glRenderbufferStorage;

  function _glBlendFuncSeparate(x0, x1, x2, x3) { GLctx['blendFuncSeparate'](x0, x1, x2, x3) }
  Module["_glBlendFuncSeparate"] = _glBlendFuncSeparate;

  function _glBlendColor(x0, x1, x2, x3) { GLctx['blendColor'](x0, x1, x2, x3) }
  Module["_glBlendColor"] = _glBlendColor;

  function _glStencilFuncSeparate(x0, x1, x2, x3) { GLctx['stencilFuncSeparate'](x0, x1, x2, x3) }
  Module["_glStencilFuncSeparate"] = _glStencilFuncSeparate;

  function _glStencilOpSeparate(x0, x1, x2, x3) { GLctx['stencilOpSeparate'](x0, x1, x2, x3) }
  Module["_glStencilOpSeparate"] = _glStencilOpSeparate;

  function _glVertexAttrib4f(x0, x1, x2, x3, x4) { GLctx['vertexAttrib4f'](x0, x1, x2, x3, x4) }
  Module["_glVertexAttrib4f"] = _glVertexAttrib4f;

  function _glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }
  Module["_glCopyTexImage2D"] = _glCopyTexImage2D;

  function _glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexSubImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }
  Module["_glCopyTexSubImage2D"] = _glCopyTexSubImage2D;






































































































  function _emscripten_glGenVertexArrays(n, arrays) {
      __glGenObject(n, arrays, 'createVertexArray', GL.vaos
        );
    }
  Module["_emscripten_glGenVertexArrays"] = _emscripten_glGenVertexArrays;

  function _emscripten_glDeleteVertexArrays(n, vaos) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((vaos)+(i*4))>>2)];
        GLctx['deleteVertexArray'](GL.vaos[id]);
        GL.vaos[id] = null;
      }
    }
  Module["_emscripten_glDeleteVertexArrays"] = _emscripten_glDeleteVertexArrays;

  function _emscripten_glBindVertexArray(vao) {
      GLctx['bindVertexArray'](GL.vaos[vao]);
    }
  Module["_emscripten_glBindVertexArray"] = _emscripten_glBindVertexArray;

  function _emscripten_glIsVertexArray(array) {
  
      var vao = GL.vaos[array];
      if (!vao) return 0;
      return GLctx['isVertexArray'](vao);
    }
  Module["_emscripten_glIsVertexArray"] = _emscripten_glIsVertexArray;

  function _emscripten_glVertexPointer(){ throw 'Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_emscripten_glVertexPointer"] = _emscripten_glVertexPointer;

  function _emscripten_glMatrixMode(){ throw 'Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_emscripten_glMatrixMode"] = _emscripten_glMatrixMode;

  function _emscripten_glBegin(){ throw 'Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_emscripten_glBegin"] = _emscripten_glBegin;

  function _emscripten_glLoadIdentity(){ throw 'Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -s LEGACY_GL_EMULATION=1 to enable legacy GL emulation.'; }
  Module["_emscripten_glLoadIdentity"] = _emscripten_glLoadIdentity;





  function _emscripten_gluPerspective(fov, aspect, near, far) {
      GLImmediate.matricesModified = true;
      GLImmediate.matrixVersion[GLImmediate.currentMatrix] = (GLImmediate.matrixVersion[GLImmediate.currentMatrix] + 1)|0;
      GLImmediate.matrix[GLImmediate.currentMatrix] =
        GLImmediate.matrixLib.mat4.perspective(fov, aspect, near, far,
                                                 GLImmediate.matrix[GLImmediate.currentMatrix]);
    }
  Module["_emscripten_gluPerspective"] = _emscripten_gluPerspective;

  function _emscripten_gluLookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz) {
      GLImmediate.matricesModified = true;
      GLImmediate.matrixVersion[GLImmediate.currentMatrix] = (GLImmediate.matrixVersion[GLImmediate.currentMatrix] + 1)|0;
      GLImmediate.matrixLib.mat4.lookAt(GLImmediate.matrix[GLImmediate.currentMatrix], [ex, ey, ez],
          [cx, cy, cz], [ux, uy, uz]);
    }
  Module["_emscripten_gluLookAt"] = _emscripten_gluLookAt;

  function _emscripten_gluProject(objX, objY, objZ, model, proj, view, winX, winY, winZ) {
      // The algorithm for this functions comes from Mesa
  
      var inVec = new Float32Array(4);
      var outVec = new Float32Array(4);
      GLImmediate.matrixLib.mat4.multiplyVec4(HEAPF64.subarray((model)>>3,(model+128)>>3),
          [objX, objY, objZ, 1.0], outVec);
      GLImmediate.matrixLib.mat4.multiplyVec4(HEAPF64.subarray((proj)>>3,(proj+128)>>3),
          outVec, inVec);
      if (inVec[3] == 0.0) {
        return 0 /* GL_FALSE */;
      }
      inVec[0] /= inVec[3];
      inVec[1] /= inVec[3];
      inVec[2] /= inVec[3];
      // Map x, y and z to range 0-1 */
      inVec[0] = inVec[0] * 0.5 + 0.5;
      inVec[1] = inVec[1] * 0.5 + 0.5;
      inVec[2] = inVec[2] * 0.5 + 0.5;
      // Map x, y to viewport
      inVec[0] = inVec[0] * HEAP32[(((view)+(8))>>2)] + HEAP32[((view)>>2)];
      inVec[1] = inVec[1] * HEAP32[(((view)+(12))>>2)] + HEAP32[(((view)+(4))>>2)];
  
      HEAPF64[((winX)>>3)]=inVec[0];
      HEAPF64[((winY)>>3)]=inVec[1];
      HEAPF64[((winZ)>>3)]=inVec[2];
  
      return 1 /* GL_TRUE */;
    }
  Module["_emscripten_gluProject"] = _emscripten_gluProject;

  function _emscripten_gluUnProject(winX, winY, winZ, model, proj, view, objX, objY, objZ) {
      var result = GLImmediate.matrixLib.mat4.unproject([winX, winY, winZ],
          HEAPF64.subarray((model)>>3,(model+128)>>3),
          HEAPF64.subarray((proj)>>3,(proj+128)>>3),
          HEAP32.subarray((view)>>2,(view+16)>>2));
  
      if (result === null) {
        return 0 /* GL_FALSE */;
      }
  
      HEAPF64[((objX)>>3)]=result[0];
      HEAPF64[((objY)>>3)]=result[1];
      HEAPF64[((objZ)>>3)]=result[2];
  
      return 1 /* GL_TRUE */;
    }
  Module["_emscripten_gluUnProject"] = _emscripten_gluUnProject;

  function _emscripten_gluOrtho2D(left, right, bottom, top) {
      _glOrtho(left, right, bottom, top, -1, 1);
    }
  Module["_emscripten_gluOrtho2D"] = _emscripten_gluOrtho2D;









  function _emscripten_glVertexAttribDivisor(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_emscripten_glVertexAttribDivisor"] = _emscripten_glVertexAttribDivisor;

  function _emscripten_glDrawArraysInstanced(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_emscripten_glDrawArraysInstanced"] = _emscripten_glDrawArraysInstanced;

  function _emscripten_glDrawElementsInstanced(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_emscripten_glDrawElementsInstanced"] = _emscripten_glDrawElementsInstanced;

  function _emscripten_glVertexAttribDivisorNV(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_emscripten_glVertexAttribDivisorNV"] = _emscripten_glVertexAttribDivisorNV;

  function _emscripten_glDrawArraysInstancedNV(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_emscripten_glDrawArraysInstancedNV"] = _emscripten_glDrawArraysInstancedNV;

  function _emscripten_glDrawElementsInstancedNV(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_emscripten_glDrawElementsInstancedNV"] = _emscripten_glDrawElementsInstancedNV;

  function _emscripten_glVertexAttribDivisorEXT(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_emscripten_glVertexAttribDivisorEXT"] = _emscripten_glVertexAttribDivisorEXT;

  function _emscripten_glDrawArraysInstancedEXT(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_emscripten_glDrawArraysInstancedEXT"] = _emscripten_glDrawArraysInstancedEXT;

  function _emscripten_glDrawElementsInstancedEXT(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_emscripten_glDrawElementsInstancedEXT"] = _emscripten_glDrawElementsInstancedEXT;

  function _emscripten_glVertexAttribDivisorARB(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }
  Module["_emscripten_glVertexAttribDivisorARB"] = _emscripten_glVertexAttribDivisorARB;

  function _emscripten_glDrawArraysInstancedARB(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
  Module["_emscripten_glDrawArraysInstancedARB"] = _emscripten_glDrawArraysInstancedARB;

  function _emscripten_glDrawElementsInstancedARB(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
  Module["_emscripten_glDrawElementsInstancedARB"] = _emscripten_glDrawElementsInstancedARB;




  function _emscripten_glDrawBuffers(n, bufs) {
  
      var bufArray = __tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx['drawBuffers'](bufArray);
    }
  Module["_emscripten_glDrawBuffers"] = _emscripten_glDrawBuffers;

  function _emscripten_glDrawBuffersEXT(n, bufs) {
  
      var bufArray = __tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx['drawBuffers'](bufArray);
    }
  Module["_emscripten_glDrawBuffersEXT"] = _emscripten_glDrawBuffersEXT;







  function _emscripten_glClearDepth(x0) { GLctx['clearDepth'](x0) }
  Module["_emscripten_glClearDepth"] = _emscripten_glClearDepth;


















  function _emscripten_glDepthRange(x0, x1) { GLctx['depthRange'](x0, x1) }
  Module["_emscripten_glDepthRange"] = _emscripten_glDepthRange;























  var AL={QUEUE_INTERVAL:25,QUEUE_LOOKAHEAD:0.1,DEVICE_NAME:"Emscripten OpenAL",CAPTURE_DEVICE_NAME:"Emscripten OpenAL capture",ALC_EXTENSIONS:{ALC_SOFT_pause_device:true,ALC_SOFT_HRTF:true},AL_EXTENSIONS:{AL_EXT_float32:true,AL_SOFT_loop_points:true,AL_SOFT_source_length:true,AL_EXT_source_distance_model:true,AL_SOFT_source_spatialize:true},_alcErr:0,alcErr:0,deviceRefCounts:{},alcStringCache:{},paused:false,stringCache:{},contexts:{},currentCtx:null,buffers:{0:{id:0,refCount:0,audioBuf:null,frequency:0,bytesPerSample:2,channels:1,length:0}},paramArray:[],_nextId:1,newId:function() {
        return AL.freeIds.length > 0 ? AL.freeIds.pop() : AL._nextId++;
      },freeIds:[],scheduleContextAudio:function(ctx) {
        // If we are animating using the requestAnimationFrame method, then the main loop does not run when in the background.
        // To give a perfect glitch-free audio stop when switching from foreground to background, we need to avoid updating
        // audio altogether when in the background, so detect that case and kill audio buffer streaming if so.
        if (Browser.mainLoop.timingMode === 1 /* EM_TIMING_RAF */ && document['visibilityState'] != 'visible') {
          return;
        }
  
        for (var i in ctx.sources) {
          AL.scheduleSourceAudio(ctx.sources[i]);
        }
      },scheduleSourceAudio:function(src, lookahead) {
        // See comment on scheduleContextAudio above.
        if (Browser.mainLoop.timingMode === 1 /*EM_TIMING_RAF*/ && document['visibilityState'] != 'visible') {
          return;
        }
        if (src.state !== 0x1012 /* AL_PLAYING */) {
          return;
        }
  
        var currentTime = AL.updateSourceTime(src);
  
        var startTime = src.bufStartTime;
        var startOffset = src.bufOffset;
        var bufCursor = src.bufsProcessed;
  
        // Advance past any audio that is already scheduled
        for (var i = 0; i < src.audioQueue.length; i++) {
          var audioSrc = src.audioQueue[i];
          startTime = audioSrc._startTime + audioSrc._duration;
          startOffset = 0.0;
          bufCursor += audioSrc._skipCount + 1;
        }
  
        if (!lookahead) {
          lookahead = AL.QUEUE_LOOKAHEAD;
        }
        var lookaheadTime = currentTime + lookahead;
        var skipCount = 0;
        while (startTime < lookaheadTime) {
          if (bufCursor >= src.bufQueue.length) {
            if (src.looping) {
              bufCursor %= src.bufQueue.length;
            } else {
              break;
            }
          }
  
          var buf = src.bufQueue[bufCursor % src.bufQueue.length];
          // If the buffer contains no data, skip it
          if (buf.length === 0) {
            skipCount++;
            // If we've gone through the whole queue and everything is 0 length, just give up
            if (skipCount === src.bufQueue.length) {
              break;
            }
          } else {
            var audioSrc = src.context.audioCtx.createBufferSource();
            audioSrc.buffer = buf.audioBuf;
            audioSrc.playbackRate.value = src.playbackRate;
            if (buf.audioBuf._loopStart || buf.audioBuf._loopEnd) {
              audioSrc.loopStart = buf.audioBuf._loopStart;
              audioSrc.loopEnd = buf.audioBuf._loopEnd;
            }
  
            var duration = 0.0;
            // If the source is a looping static buffer, use native looping for gapless playback
            if (src.type === 0x1028 /* AL_STATIC */ && src.looping) {
              duration = Number.POSITIVE_INFINITY;
              audioSrc.loop = true;
              if (buf.audioBuf._loopStart) {
                audioSrc.loopStart = buf.audioBuf._loopStart;
              }
              if (buf.audioBuf._loopEnd) {
                audioSrc.loopEnd = buf.audioBuf._loopEnd;
              }
            } else {
              duration = (buf.audioBuf.duration - startOffset) / src.playbackRate;
            }
  
            audioSrc._startOffset = startOffset;
            audioSrc._duration = duration;
            audioSrc._skipCount = skipCount;
            skipCount = 0;
  
            audioSrc.connect(src.gain);
  
            if (typeof(audioSrc.start) !== 'undefined') {
              // Sample the current time as late as possible to mitigate drift
              startTime = Math.max(startTime, src.context.audioCtx.currentTime);
              audioSrc.start(startTime, startOffset);
            } else if (typeof(audioSrc.noteOn) !== 'undefined') {
              startTime = Math.max(startTime, src.context.audioCtx.currentTime);
              audioSrc.noteOn(startTime);
            }
            audioSrc._startTime = startTime;
            src.audioQueue.push(audioSrc);
  
            startTime += duration;
          }
  
          startOffset = 0.0;
          bufCursor++;
        }
      },updateSourceTime:function(src) {
        var currentTime = src.context.audioCtx.currentTime;
        if (src.state !== 0x1012 /* AL_PLAYING */) {
          return currentTime;
        }
  
        // if the start time is unset, determine it based on the current offset.
        // This will be the case when a source is resumed after being paused, and
        // allows us to pretend that the source actually started playing some time
        // in the past such that it would just now have reached the stored offset.
        if (!isFinite(src.bufStartTime)) {
          src.bufStartTime = currentTime - src.bufOffset / src.playbackRate;
          src.bufOffset = 0.0;
        }
  
        var nextStartTime = 0.0;
        while (src.audioQueue.length) {
          var audioSrc = src.audioQueue[0];
          src.bufsProcessed += audioSrc._skipCount;
          nextStartTime = audioSrc._startTime + audioSrc._duration; // n.b. audioSrc._duration already factors in playbackRate, so no divide by src.playbackRate on it.
  
          if (currentTime < nextStartTime) {
            break;
          }
  
          src.audioQueue.shift();
          src.bufStartTime = nextStartTime;
          src.bufOffset = 0.0;
          src.bufsProcessed++;
        }
  
        if (src.bufsProcessed >= src.bufQueue.length && !src.looping) {
          // The source has played its entire queue and is non-looping, so just mark it as stopped.
          AL.setSourceState(src, 0x1014 /* AL_STOPPED */);
        } else if (src.type === 0x1028 /* AL_STATIC */ && src.looping) {
          // If the source is a looping static buffer, determine the buffer offset based on the loop points
          var buf = src.bufQueue[0];
          if (buf.length === 0) {
            src.bufOffset = 0.0;
          } else {
            var delta = (currentTime - src.bufStartTime) * src.playbackRate;
            var loopStart = buf.audioBuf._loopStart || 0.0;
            var loopEnd = buf.audioBuf._loopEnd || buf.audioBuf.duration;
            if (loopEnd <= loopStart) {
              loopEnd = buf.audioBuf.duration;
            }
  
            if (delta < loopEnd) {
              src.bufOffset = delta;
            } else {
              src.bufOffset = loopStart + (delta - loopStart) % (loopEnd - loopStart);
            }
          }
        } else if (src.audioQueue[0]) {
          // The source is still actively playing, so we just need to calculate where we are in the current buffer
          // so it can be remembered if the source gets paused.
          src.bufOffset = (currentTime - src.audioQueue[0]._startTime) * src.playbackRate;
        } else {
          // The source hasn't finished yet, but there is no scheduled audio left for it. This can be because
          // the source has just been started/resumed, or due to an underrun caused by a long blocking operation.
          // We need to determine what state we would be in by this point in time so that when we next schedule
          // audio playback, it will be just as if no underrun occurred.
  
          if (src.type !== 0x1028 /* AL_STATIC */ && src.looping) {
            // if the source is a looping buffer queue, let's first calculate the queue duration, so we can
            // quickly fast forward past any full loops of the queue and only worry about the remainder.
            var srcDuration = AL.sourceDuration(src) / src.playbackRate;
            if (srcDuration > 0.0) {
              src.bufStartTime += Math.floor((currentTime - src.bufStartTime) / srcDuration) * srcDuration;
            }
          }
  
          // Since we've already skipped any full-queue loops if there were any, we just need to find
          // out where in the queue the remaining time puts us, which won't require stepping through the
          // entire queue more than once.
          for (var i = 0; i < src.bufQueue.length; i++) {
            if (src.bufsProcessed >= src.bufQueue.length) {
              if (src.looping) {
                src.bufsProcessed %= src.bufQueue.length;
              } else {
                AL.setSourceState(src, 0x1014 /* AL_STOPPED */);
                break;
              }
            }
  
            var buf = src.bufQueue[src.bufsProcessed];
            if (buf.length > 0) {
              nextStartTime = src.bufStartTime + buf.audioBuf.duration / src.playbackRate;
  
              if (currentTime < nextStartTime) {
                src.bufOffset = (currentTime - src.bufStartTime) * src.playbackRate;
                break;
              }
  
              src.bufStartTime = nextStartTime;
            }
  
            src.bufOffset = 0.0;
            src.bufsProcessed++;
          }
        }
  
        return currentTime;
      },cancelPendingSourceAudio:function(src) {
        AL.updateSourceTime(src);
  
        for (var i = 1; i < src.audioQueue.length; i++) {
          var audioSrc = src.audioQueue[i];
          audioSrc.stop();
        }
  
        if (src.audioQueue.length > 1) {
          src.audioQueue.length = 1;
        }
      },stopSourceAudio:function(src) {
        for (var i = 0; i < src.audioQueue.length; i++) {
          src.audioQueue[i].stop();
        }
        src.audioQueue.length = 0;
      },setSourceState:function(src, state) {
        if (state === 0x1012 /* AL_PLAYING */) {
          if (src.state === 0x1012 /* AL_PLAYING */ || src.state == 0x1014 /* AL_STOPPED */) {
            src.bufsProcessed = 0;
            src.bufOffset = 0.0;
          } else {
          }
  
          AL.stopSourceAudio(src);
  
          src.state = 0x1012 /* AL_PLAYING */;
          src.bufStartTime = Number.NEGATIVE_INFINITY;
          AL.scheduleSourceAudio(src);
        } else if (state === 0x1013 /* AL_PAUSED */) {
          if (src.state === 0x1012 /* AL_PLAYING */) {
            // Store off the current offset to restore with on resume.
            AL.updateSourceTime(src);
            AL.stopSourceAudio(src);
  
            src.state = 0x1013 /* AL_PAUSED */;
          }
        } else if (state === 0x1014 /* AL_STOPPED */) {
          if (src.state !== 0x1011 /* AL_INITIAL */) {
            src.state = 0x1014 /* AL_STOPPED */;
            src.bufsProcessed = src.bufQueue.length;
            src.bufStartTime = Number.NEGATIVE_INFINITY;
            src.bufOffset = 0.0;
            AL.stopSourceAudio(src);
          }
        } else if (state === 0x1011 /* AL_INITIAL */) {
          if (src.state !== 0x1011 /* AL_INITIAL */) {
            src.state = 0x1011 /* AL_INITIAL */;
            src.bufsProcessed = 0;
            src.bufStartTime = Number.NEGATIVE_INFINITY;
            src.bufOffset = 0.0;
            AL.stopSourceAudio(src);
          }
        }
      },initSourcePanner:function(src) {
        if (src.type === 0x1030 /* AL_UNDETERMINED */) {
          return;
        }
  
        // Find the first non-zero buffer in the queue to determine the proper format
        var templateBuf = AL.buffers[0];
        for (var i = 0; i < src.bufQueue.length; i++) {
          if (src.bufQueue[i].id !== 0) {
            templateBuf = src.bufQueue[i];
            break;
          }
        }
        // Create a panner if AL_SOURCE_SPATIALIZE_SOFT is set to true, or alternatively if it's set to auto and the source is mono
        if (src.spatialize === 1 /* AL_TRUE */ || (src.spatialize === 2 /* AL_AUTO_SOFT */ && templateBuf.channels === 1)) {
          if (src.panner) {
            return;
          }
          src.panner = src.context.audioCtx.createPanner();
  
          AL.updateSourceGlobal(src);
          AL.updateSourceSpace(src);
  
          src.panner.connect(src.context.gain);
          src.gain.disconnect();
          src.gain.connect(src.panner);
        } else {
          if (!src.panner) {
            return;
          }
  
          src.panner.disconnect();
          src.gain.disconnect();
          src.gain.connect(src.context.gain);
          src.panner = null;
        }
      },updateContextGlobal:function(ctx) {
        for (var i in ctx.sources) {
          AL.updateSourceGlobal(ctx.sources[i]);
        }
      },updateSourceGlobal:function(src) {
        var panner = src.panner;
        if (!panner) {
          return;
        }
  
        panner.refDistance = src.refDistance;
        panner.maxDistance = src.maxDistance;
        panner.rolloffFactor = src.rolloffFactor;
  
        panner.panningModel = src.context.hrtf ? 'HRTF' : 'equalpower';
  
        // Use the source's distance model if AL_SOURCE_DISTANCE_MODEL is enabled
        var distanceModel = src.context.sourceDistanceModel ? src.distanceModel : src.context.distanceModel;
        switch (distanceModel) {
        case 0 /* AL_NONE */:
          panner.distanceModel = 'inverse';
          panner.refDistance = 3.40282e38 /* FLT_MAX */;
          break;
        case 0xd001 /* AL_INVERSE_DISTANCE */:
        case 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */:
          panner.distanceModel = 'inverse';
          break;
        case 0xd003 /* AL_LINEAR_DISTANCE */:
        case 0xd004 /* AL_LINEAR_DISTANCE_CLAMPED */:
          panner.distanceModel = 'linear';
          break;
        case 0xd005 /* AL_EXPONENT_DISTANCE */:
        case 0xd006 /* AL_EXPONENT_DISTANCE_CLAMPED */:
          panner.distanceModel = 'exponential';
          break;
        }
      },updateListenerSpace:function(ctx) {
        var listener = ctx.audioCtx.listener;
        if (listener.positionX) {
          listener.positionX.value = ctx.listener.position[0];
          listener.positionY.value = ctx.listener.position[1];
          listener.positionZ.value = ctx.listener.position[2];
        } else {
          listener.setPosition(ctx.listener.position[0], ctx.listener.position[1], ctx.listener.position[2]);
        }
        if (listener.forwardX) {
          listener.forwardX.value = ctx.listener.direction[0];
          listener.forwardY.value = ctx.listener.direction[1];
          listener.forwardZ.value = ctx.listener.direction[2];
          listener.upX.value = ctx.listener.up[0];
          listener.upY.value = ctx.listener.up[1];
          listener.upZ.value = ctx.listener.up[2];
        } else {
          listener.setOrientation(
            ctx.listener.direction[0], ctx.listener.direction[1], ctx.listener.direction[2],
            ctx.listener.up[0], ctx.listener.up[1], ctx.listener.up[2]);
        }
  
        // Update sources that are relative to the listener
        for (var i in ctx.sources) {
          AL.updateSourceSpace(ctx.sources[i]);
        }
      },updateSourceSpace:function(src) {
        if (!src.panner) {
          return;
        }
        var panner = src.panner;
  
        var posX = src.position[0];
        var posY = src.position[1];
        var posZ = src.position[2];
        var dirX = src.direction[0];
        var dirY = src.direction[1];
        var dirZ = src.direction[2];
  
        var listener = src.context.listener;
        var lPosX = listener.position[0];
        var lPosY = listener.position[1];
        var lPosZ = listener.position[2];
  
        // WebAudio does spatialization in world-space coordinates, meaning both the buffer sources and
        // the listener position are in the same absolute coordinate system relative to a fixed origin.
        // By default, OpenAL works this way as well, but it also provides a "listener relative" mode, where
        // a buffer source's coordinate are interpreted not in absolute world space, but as being relative
        // to the listener object itself, so as the listener moves the source appears to move with it
        // with no update required. Since web audio does not support this mode, we must transform the source
        // coordinates from listener-relative space to absolute world space.
        //
        // We do this via affine transformation matrices applied to the source position and source direction.
        // A change-of-basis converts from listener-space displacements to world-space displacements,
        // which must be done for both the source position and direction. Lastly, the source position must be
        // added to the listener position to get the final source position, since the source position represents
        // a displacement from the listener.
        if (src.relative) {
          // Negate the listener direction since forward is -Z.
          var lBackX = -listener.direction[0];
          var lBackY = -listener.direction[1];
          var lBackZ = -listener.direction[2];
          var lUpX = listener.up[0];
          var lUpY = listener.up[1];
          var lUpZ = listener.up[2];
  
          var inverseMagnitude = function(x, y, z) {
            var length = Math.sqrt(x * x + y * y + z * z);
  
            if (length < Number.EPSILON) {
              return 0.0;
            }
  
            return 1.0 / length;
          };
  
          // Normalize the Back vector
          var invMag = inverseMagnitude(lBackX, lBackY, lBackZ);
          lBackX *= invMag;
          lBackY *= invMag;
          lBackZ *= invMag;
  
          // ...and the Up vector
          invMag = inverseMagnitude(lUpX, lUpY, lUpZ);
          lUpX *= invMag;
          lUpY *= invMag;
          lUpZ *= invMag;
  
          // Calculate the Right vector as the cross product of the Up and Back vectors
          var lRightX = (lUpY * lBackZ - lUpZ * lBackY);
          var lRightY = (lUpZ * lBackX - lUpX * lBackZ);
          var lRightZ = (lUpX * lBackY - lUpY * lBackX);
  
          // Back and Up might not be exactly perpendicular, so the cross product also needs normalization
          invMag = inverseMagnitude(lRightX, lRightY, lRightZ);
          lRightX *= invMag;
          lRightY *= invMag;
          lRightZ *= invMag;
  
          // Recompute Up from the now orthonormal Right and Back vectors so we have a fully orthonormal basis
          lUpX = (lBackY * lRightZ - lBackZ * lRightY);
          lUpY = (lBackZ * lRightX - lBackX * lRightZ);
          lUpZ = (lBackX * lRightY - lBackY * lRightX);
  
          var oldX = dirX;
          var oldY = dirY;
          var oldZ = dirZ;
  
          // Use our 3 vectors to apply a change-of-basis matrix to the source direction
          dirX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
          dirY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
          dirZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
  
          oldX = posX;
          oldY = posY;
          oldZ = posZ;
  
          // ...and to the source position
          posX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
          posY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
          posZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
  
          // The change-of-basis corrects the orientation, but the origin is still the listener.
          // Translate the source position by the listener position to finish.
          posX += lPosX;
          posY += lPosY;
          posZ += lPosZ;
        }
  
        if (panner.positionX) {
          panner.positionX.value = posX;
          panner.positionY.value = posY;
          panner.positionZ.value = posZ;
        } else {
          panner.setPosition(posX, posY, posZ);
        }
        if (panner.orientationX) {
          panner.orientationX.value = dirX;
          panner.orientationY.value = dirY;
          panner.orientationZ.value = dirZ;
        } else {
          panner.setOrientation(dirX, dirY, dirZ);
        }
  
        var oldShift = src.dopplerShift;
        var velX = src.velocity[0];
        var velY = src.velocity[1];
        var velZ = src.velocity[2];
        var lVelX = listener.velocity[0];
        var lVelY = listener.velocity[1];
        var lVelZ = listener.velocity[2];
        if (posX === lPosX && posY === lPosY && posZ === lPosZ
          || velX === lVelX && velY === lVelY && velZ === lVelZ)
        {
          src.dopplerShift = 1.0;
        } else {
          // Doppler algorithm from 1.1 spec
          var speedOfSound = src.context.speedOfSound;
          var dopplerFactor = src.context.dopplerFactor;
  
          var slX = lPosX - posX;
          var slY = lPosY - posY;
          var slZ = lPosZ - posZ;
  
          var magSl = Math.sqrt(slX * slX + slY * slY + slZ * slZ);
          var vls = (slX * lVelX + slY * lVelY + slZ * lVelZ) / magSl;
          var vss = (slX * velX + slY * velY + slZ * velZ) / magSl;
  
          vls = Math.min(vls, speedOfSound / dopplerFactor);
          vss = Math.min(vss, speedOfSound / dopplerFactor);
  
          src.dopplerShift = (speedOfSound - dopplerFactor * vls) / (speedOfSound - dopplerFactor * vss);
        }
        if (src.dopplerShift !== oldShift) {
          AL.updateSourceRate(src);
        }
      },updateSourceRate:function(src) {
        if (src.state === 0x1012 /* AL_PLAYING */) {
          // clear scheduled buffers
          AL.cancelPendingSourceAudio(src);
  
          var audioSrc = src.audioQueue[0];
          if (!audioSrc) {
            return; // It is possible that AL.scheduleContextAudio() has not yet fed the next buffer, if so, skip.
          }
  
          var duration;
          if (src.type === 0x1028 /* AL_STATIC */ && src.looping) {
            duration = Number.POSITIVE_INFINITY;
          } else {
            // audioSrc._duration is expressed after factoring in playbackRate, so when changing playback rate, need
            // to recompute/rescale the rate to the new playback speed.
            duration = (audioSrc.buffer.duration - audioSrc._startOffset) / src.playbackRate;
          }
  
          audioSrc._duration = duration;
          audioSrc.playbackRate.value = src.playbackRate;
  
          // reschedule buffers with the new playbackRate
          AL.scheduleSourceAudio(src);
        }
      },sourceDuration:function(src) {
        var length = 0.0;
        for (var i = 0; i < src.bufQueue.length; i++) {
          var audioBuf = src.bufQueue[i].audioBuf;
          length += audioBuf ? audioBuf.duration : 0.0;
        }
        return length;
      },sourceTell:function(src) {
        AL.updateSourceTime(src);
  
        var offset = 0.0;
        for (var i = 0; i < src.bufsProcessed; i++) {
          offset += src.bufQueue[i].audioBuf.duration;
        }
        offset += src.bufOffset;
  
        return offset;
      },sourceSeek:function(src, offset) {
        var playing = src.state == 0x1012 /* AL_PLAYING */;
        if (playing) {
          AL.setSourceState(src, 0x1011 /* AL_INITIAL */);
        }
  
        if (src.bufQueue[src.bufsProcessed].audioBuf !== null) {
          src.bufsProcessed = 0;
          while (offset > src.bufQueue[src.bufsProcessed].audioBuf.duration) {
            offset -= src.bufQueue[src.bufsProcessed].audiobuf.duration;
            src.bufsProcessed++;
          }
  
          src.bufOffset = offset;
        }
  
        if (playing) {
          AL.setSourceState(src, 0x1012 /* AL_PLAYING */);
        }
      },getGlobalParam:function(funcname, param) {
        if (!AL.currentCtx) {
          return null;
        }
  
        switch (param) {
        case 0xC000 /* AL_DOPPLER_FACTOR */:
          return AL.currentCtx.dopplerFactor;
        case 0xC003 /* AL_SPEED_OF_SOUND */:
          return AL.currentCtx.speedOfSound;
        case 0xD000 /* AL_DISTANCE_MODEL */:
          return AL.currentCtx.distanceModel;
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return null;
        }
      },setGlobalParam:function(funcname, param, value) {
        if (!AL.currentCtx) {
          return;
        }
  
        switch (param) {
        case 0xC000 /* AL_DOPPLER_FACTOR */:
          if (!Number.isFinite(value) || value < 0.0) { // Strictly negative values are disallowed
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          AL.currentCtx.dopplerFactor = value;
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 0xC003 /* AL_SPEED_OF_SOUND */:
          if (!Number.isFinite(value) || value <= 0.0) { // Negative or zero values are disallowed
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          AL.currentCtx.speedOfSound = value;
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 0xD000 /* AL_DISTANCE_MODEL */:
          switch (value) {
          case 0 /* AL_NONE */:
          case 0xd001 /* AL_INVERSE_DISTANCE */:
          case 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */:
          case 0xd003 /* AL_LINEAR_DISTANCE */:
          case 0xd004 /* AL_LINEAR_DISTANCE_CLAMPED */:
          case 0xd005 /* AL_EXPONENT_DISTANCE */:
          case 0xd006 /* AL_EXPONENT_DISTANCE_CLAMPED */:
            AL.currentCtx.distanceModel = value;
            AL.updateContextGlobal(AL.currentCtx);
            break;
          default:
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          break;
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return;
        }
      },getListenerParam:function(funcname, param) {
        if (!AL.currentCtx) {
          return null;
        }
  
        switch (param) {
        case 0x1004 /* AL_POSITION */:
          return AL.currentCtx.listener.position;
        case 0x1006 /* AL_VELOCITY */:
          return AL.currentCtx.listener.velocity;
        case 0x100F /* AL_ORIENTATION */:
          return AL.currentCtx.listener.direction.concat(AL.currentCtx.listener.up);
        case 0x100A /* AL_GAIN */:
          return AL.currentCtx.gain.gain.value;
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return null;
        }
      },setListenerParam:function(funcname, param, value) {
        if (!AL.currentCtx) {
          return;
        }
        if (value === null) {
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return;
        }
  
        var listener = AL.currentCtx.listener;
        switch (param) {
        case 0x1004 /* AL_POSITION */:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          listener.position[0] = value[0];
          listener.position[1] = value[1];
          listener.position[2] = value[2];
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 0x1006 /* AL_VELOCITY */:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          listener.velocity[0] = value[0];
          listener.velocity[1] = value[1];
          listener.velocity[2] = value[2];
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 0x100A /* AL_GAIN */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          AL.currentCtx.gain.gain.value = value;
          break;
        case 0x100F /* AL_ORIENTATION */:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])
            || !Number.isFinite(value[3]) || !Number.isFinite(value[4]) || !Number.isFinite(value[5])
          ) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          listener.direction[0] = value[0];
          listener.direction[1] = value[1];
          listener.direction[2] = value[2];
          listener.up[0] = value[3];
          listener.up[1] = value[4];
          listener.up[2] = value[5];
          AL.updateListenerSpace(AL.currentCtx);
          break;
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return;
        }
      },getBufferParam:function(funcname, bufferId, param) {
        if (!AL.currentCtx) {
          return;
        }
        var buf = AL.buffers[bufferId];
        if (!buf || bufferId === 0) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
  
        switch (param) {
        case 0x2001 /* AL_FREQUENCY */:
          return buf.frequency;
        case 0x2002 /* AL_BITS */:
          return buf.bytesPerSample * 8;
        case 0x2003 /* AL_CHANNELS */:
          return buf.channels;
        case 0x2004 /* AL_SIZE */:
          return buf.length * buf.bytesPerSample * buf.channels;
        case 0x2015 /* AL_LOOP_POINTS_SOFT */:
          if (buf.length === 0) {
            return [0, 0];
          } else {
            return [
              (buf.audioBuf._loopStart || 0.0) * buf.frequency,
              (buf.audioBuf._loopEnd || buf.length) * buf.frequency
            ];
          }
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return null;
        }
      },setBufferParam:function(funcname, bufferId, param, value) {
        if (!AL.currentCtx) {
          return;
        }
        var buf = AL.buffers[bufferId];
        if (!buf || bufferId === 0) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
        if (value === null) {
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return;
        }
  
        switch (param) {
        case 0x2004 /* AL_SIZE */:
          if (value !== 0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          // Per the spec, setting AL_SIZE to 0 is a legal NOP.
          break;
        case 0x2015 /* AL_LOOP_POINTS_SOFT */:
          if (value[0] < 0 || value[0] > buf.length || value[1] < 0 || value[1] > buf.Length || value[0] >= value[1]) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          if (buf.refCount > 0) {
            AL.currentCtx.err = 0xA004 /* AL_INVALID_OPERATION */;
            return;
          }
  
          if (buf.audioBuf) {
            buf.audioBuf._loopStart = value[0] / buf.frequency;
            buf.audioBuf._loopEnd = value[1] / buf.frequency;
          }
          break;
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return;
        }
      },getSourceParam:function(funcname, sourceId, param) {
        if (!AL.currentCtx) {
          return null;
        }
        var src = AL.currentCtx.sources[sourceId];
        if (!src) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return null;
        }
  
        switch (param) {
        case 0x202 /* AL_SOURCE_RELATIVE */:
          return src.relative;
        case 0x1001 /* AL_CONE_INNER_ANGLE */:
          return src.coneInnerAngle;
        case 0x1002 /* AL_CONE_OUTER_ANGLE */:
          return src.coneOuterAngle;
        case 0x1003 /* AL_PITCH */:
          return src.pitch;
        case 0x1004 /* AL_POSITION */:
          return src.position;
        case 0x1005 /* AL_DIRECTION */:
          return src.direction;
        case 0x1006 /* AL_VELOCITY */:
          return src.velocity;
        case 0x1007 /* AL_LOOPING */:
          return src.looping;
        case 0x1009 /* AL_BUFFER */:
          if (src.type === 0x1028 /* AL_STATIC */) {
            return src.bufQueue[0].id;
          } else {
            return 0;
          }
        case 0x100A /* AL_GAIN */:
          return src.gain.gain.value;
         case 0x100D /* AL_MIN_GAIN */:
          return src.minGain;
        case 0x100E /* AL_MAX_GAIN */:
          return src.maxGain;
        case 0x1010 /* AL_SOURCE_STATE */:
          return src.state;
        case 0x1015 /* AL_BUFFERS_QUEUED */:
          if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
            return 0;
          } else {
            return src.bufQueue.length;
          }
        case 0x1016 /* AL_BUFFERS_PROCESSED */:
          if ((src.bufQueue.length === 1 && src.bufQueue[0].id === 0) || src.looping) {
            return 0;
          } else {
            return src.bufsProcessed;
          }
        case 0x1020 /* AL_REFERENCE_DISTANCE */:
          return src.refDistance;
        case 0x1021 /* AL_ROLLOFF_FACTOR */:
          return src.rolloffFactor;
        case 0x1022 /* AL_CONE_OUTER_GAIN */:
          return src.coneOuterGain;
        case 0x1023 /* AL_MAX_DISTANCE */:
          return src.maxDistance;
        case 0x1024 /* AL_SEC_OFFSET */:
          return AL.sourceTell(src);
        case 0x1025 /* AL_SAMPLE_OFFSET */:
          var offset = AL.sourceTell(src);
          if (offset > 0.0) {
            offset *= src.bufQueue[0].frequency;
          }
          return offset;
        case 0x1026 /* AL_BYTE_OFFSET */:
          var offset = AL.sourceTell(src);
          if (offset > 0.0) {
            offset *= src.bufQueue[0].frequency * src.bufQueue[0].bytesPerSample;
          }
          return offset;
        case 0x1027 /* AL_SOURCE_TYPE */:
          return src.type;
        case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
          return src.spatialize;
        case 0x2009 /* AL_BYTE_LENGTH_SOFT */: 
          var length = 0;
          var bytesPerFrame = 0;
          for (var i = 0; i < src.bufQueue.length; i++) {
            length += src.bufQueue[i].length;
            if (src.bufQueue[i].id !== 0) {
              bytesPerFrame = src.bufQueue[i].bytesPerSample * src.bufQueue[i].channels;
            }
          }
          return length * bytesPerFrame;
        case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
          var length = 0;
          for (var i = 0; i < src.bufQueue.length; i++) {
            length += src.bufQueue[i].length;
          }
          return length;
        case 0x200B /* AL_SEC_LENGTH_SOFT */:
          return AL.sourceDuration(src);
        case 0xD000 /* AL_DISTANCE_MODEL */:
          return src.distanceModel;
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return null;
        }
      },setSourceParam:function(funcname, sourceId, param, value) {
        if (!AL.currentCtx) {
          return;
        }
        var src = AL.currentCtx.sources[sourceId];
        if (!src) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
        if (value === null) {
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return;
        }
  
        switch (param) {
        case 0x202 /* AL_SOURCE_RELATIVE */:
          if (value === 1 /* AL_TRUE */) {
            src.relative = true;
            AL.updateSourceSpace(src);
          } else if (value === 0 /* AL_FALSE */) {
            src.relative = false;
            AL.updateSourceSpace(src);
          } else {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          break;
        case 0x1001 /* AL_CONE_INNER_ANGLE */:
          if (!Number.isFinite(value)) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          src.coneInnerAngle = value;
          if (src.panner) {
            src.panner.coneInnerAngle = value % 360.0;
          }
          break;
        case 0x1002 /* AL_CONE_OUTER_ANGLE */:
          if (!Number.isFinite(value)) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          src.coneOuterAngle = value;
          if (src.panner) {
            src.panner.coneOuterAngle = value % 360.0;
          }
          break;
        case 0x1003 /* AL_PITCH */:
          if (!Number.isFinite(value) || value <= 0.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          if (src.pitch === value) {
            break;
          }
  
          src.pitch = value;
          AL.updateSourceRate(src);
          break;
        case 0x1004 /* AL_POSITION */:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          src.position[0] = value[0];
          src.position[1] = value[1];
          src.position[2] = value[2];
          AL.updateSourceSpace(src);
          break;
        case 0x1005 /* AL_DIRECTION */:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          src.direction[0] = value[0];
          src.direction[1] = value[1];
          src.direction[2] = value[2];
          AL.updateSourceSpace(src);
          break;
        case 0x1006 /* AL_VELOCITY */:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          src.velocity[0] = value[0];
          src.velocity[1] = value[1];
          src.velocity[2] = value[2];
          AL.updateSourceSpace(src);
          break;
        case 0x1007 /* AL_LOOPING */:
          if (value === 1 /* AL_TRUE */) {
            src.looping = true;
            AL.updateSourceTime(src);
            if (src.type === 0x1028 /* AL_STATIC */ && src.audioQueue.length > 0) {
              var audioSrc  = src.audioQueue[0];
              audioSrc.loop = true;
              audioSrc._duration = Number.POSITIVE_INFINITY;
            }
          } else if (value === 0 /* AL_FALSE */) {
            src.looping = false;
            var currentTime = AL.updateSourceTime(src);
            if (src.type === 0x1028 /* AL_STATIC */ && src.audioQueue.length > 0) {
              var audioSrc  = src.audioQueue[0];
              audioSrc.loop = false;
              audioSrc._duration = src.bufQueue[0].audioBuf.duration / src.playbackRate;
              audioSrc._startTime = currentTime - src.bufOffset / src.playbackRate;
            }
          } else {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          break;
        case 0x1009 /* AL_BUFFER */:
          if (src.state === 0x1012 /* AL_PLAYING */ || src.state === 0x1013 /* AL_PAUSED */) {
            AL.currentCtx.err = 0xA004 /* AL_INVALID_OPERATION */;
            return;
          }
  
          if (value === 0) {
            for (var i in src.bufQueue) {
              src.bufQueue[i].refCount--;
            }
            src.bufQueue.length = 1;
            src.bufQueue[0] = AL.buffers[0];
  
            src.bufsProcessed = 0;
            src.type = 0x1030 /* AL_UNDETERMINED */;
          } else {
            var buf = AL.buffers[value];
            if (!buf) {
              AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
              return;
            }
  
            for (var i in src.bufQueue) {
              src.bufQueue[i].refCount--;
            }
            src.bufQueue.length = 0;
  
            buf.refCount++;
            src.bufQueue = [buf];
            src.bufsProcessed = 0;
            src.type = 0x1028 /* AL_STATIC */;
          }
  
          AL.initSourcePanner(src);
          AL.scheduleSourceAudio(src);
          break;
        case 0x100A /* AL_GAIN */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          src.gain.gain.value = value;
          break;
        case 0x100D /* AL_MIN_GAIN */:
          if (!Number.isFinite(value) || value < 0.0 || value > Math.min(src.maxGain, 1.0)) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          src.minGain = value;
          break;
        case 0x100E /* AL_MAX_GAIN */:
          if (!Number.isFinite(value) || value < Math.max(0.0, src.minGain) || value > 1.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          src.maxGain = value;
          break;
        case 0x1020 /* AL_REFERENCE_DISTANCE */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          src.refDistance = value;
          if (src.panner) {
            src.panner.refDistance = value;
          }
          break;
        case 0x1021 /* AL_ROLLOFF_FACTOR */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          src.rolloffFactor = value;
          if (src.panner) {
            src.panner.rolloffFactor = value;
          }
          break;
        case 0x1022 /* AL_CONE_OUTER_GAIN */:
          if (!Number.isFinite(value) || value < 0.0 || value > 1.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          src.coneOuterGain = value;
          if (src.panner) {
            src.panner.coneOuterGain = value;
          }
          break;
        case 0x1023 /* AL_MAX_DISTANCE */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          src.maxDistance = value;
          if (src.panner) {
            src.panner.maxDistance = value;
          }
          break;
        case 0x1024 /* AL_SEC_OFFSET */:
          if (value < 0.0 || value > AL.sourceDuration(src)) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          AL.sourceSeek(src, value);
          break;
        case 0x1025 /* AL_SAMPLE_OFFSET */:
          var srcLen = AL.sourceDuration(src);
          if (srcLen > 0.0) {
            var frequency;
            for (var bufId in src.bufQueue) {
              if (bufId) {
                frequency = src.bufQueue[bufId].frequency;
                break;
              }
            }
            value /= frequency;
          }
          if (value < 0.0 || value > srcLen) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          AL.sourceSeek(src, value);
          break;
        case 0x1026 /* AL_BYTE_OFFSET */:
          var srcLen = AL.sourceDuration(src);
          if (srcLen > 0.0) {
            var bytesPerSec;
            for (var bufId in src.bufQueue) {
              if (bufId) {
                var buf = src.bufQueue[bufId];
                bytesPerSec = buf.frequency * buf.bytesPerSample * buf.channels;
                break;
              }
            }
            value /= bytesPerSec;
          }
          if (value < 0.0 || value > srcLen) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          AL.sourceSeek(src, value);
          break;
        case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
          if (value !== 0 /* AL_FALSE */ && value !== 1 /* AL_TRUE */ && value !== 2 /* AL_AUTO_SOFT */) {
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
  
          src.spatialize = value;
          AL.initSourcePanner(src);
          break;
        case 0x2009 /* AL_BYTE_LENGTH_SOFT */: 
        case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
        case 0x200B /* AL_SEC_LENGTH_SOFT */:
          AL.currentCtx.err = 0xA004 /* AL_INVALID_OPERATION */;
          break;
        case 0xD000 /* AL_DISTANCE_MODEL */:
          switch (value) {
          case 0 /* AL_NONE */:
          case 0xd001 /* AL_INVERSE_DISTANCE */:
          case 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */:
          case 0xd003 /* AL_LINEAR_DISTANCE */:
          case 0xd004 /* AL_LINEAR_DISTANCE_CLAMPED */:
          case 0xd005 /* AL_EXPONENT_DISTANCE */:
          case 0xd006 /* AL_EXPONENT_DISTANCE_CLAMPED */:
            src.distanceModel = value;
            if (AL.currentCtx.sourceDistanceModel) {
              AL.updateContextGlobal(AL.currentCtx);
            }
            break;
          default:
            AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
            return;
          }
          break;
        default:
          AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
          return;
        }
      },captures:{},sharedCaptureAudioCtx:null,requireValidCaptureDevice:function(deviceId, funcname) {
        if (deviceId === 0) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return null;
        }
        var c = AL.captures[deviceId];
        if (!c) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return null;
        }
        var err = c.mediaStreamError;
        if (err) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return null;
        }
        return c;
      }};
  Module["AL"] = AL;

  function _alcCaptureOpenDevice(pDeviceName, requestedSampleRate, format, bufferFrameCapacity) {
  
      var resolvedDeviceName = AL.CAPTURE_DEVICE_NAME;
  
      // NULL is a valid device name here (resolves to default);
      if (pDeviceName !== 0) {
        resolvedDeviceName = UTF8ToString(pDeviceName);
        if (resolvedDeviceName !== AL.CAPTURE_DEVICE_NAME) {
          // ALC_OUT_OF_MEMORY
          // From the programmer's guide, ALC_OUT_OF_MEMORY's meaning is
          // overloaded here, to mean:
          // 'The specified device is invalid, or can not capture audio.'
          // This may be misleading to API users, but well...
          AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
          return 0;
        }
      }
  
      // Otherwise it's probably okay (though useless) for bufferFrameCapacity to be zero.
      if (bufferFrameCapacity < 0) { // ALCsizei is signed int
        AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
        return 0;
      }
  
      navigator.getUserMedia = navigator.getUserMedia 
        || navigator.webkitGetUserMedia 
        || navigator.mozGetUserMedia 
        || navigator.msGetUserMedia;
      var has_getUserMedia = navigator.getUserMedia 
        || (navigator.mediaDevices 
        &&  navigator.mediaDevices.getUserMedia);
  
      if (!has_getUserMedia) {
        // See previously mentioned rationale for ALC_OUT_OF_MEMORY
        AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
        return 0;
      }
  
      var AudioContext = window.AudioContext || window.webkitAudioContext;
  
      if (!AL.sharedCaptureAudioCtx) {
        try {
          AL.sharedCaptureAudioCtx = new AudioContext();
        } catch(e) {
          // See previously mentioned rationale for ALC_OUT_OF_MEMORY
          AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
          return 0;
        }
      }
  
      var outputChannelCount;
  
      switch (format) {
      case 0x10010: /* AL_FORMAT_MONO_FLOAT32 */
      case 0x1101:  /* AL_FORMAT_MONO16 */
      case 0x1100:  /* AL_FORMAT_MONO8 */
        outputChannelCount = 1;
        break;
      case 0x10011: /* AL_FORMAT_STEREO_FLOAT32 */
      case 0x1103:  /* AL_FORMAT_STEREO16 */
      case 0x1102:  /* AL_FORMAT_STEREO8 */
        outputChannelCount = 2;
        break;
      default:
        AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
        return 0;
      }
  
      function newF32Array(cap) { return new Float32Array(cap);}
      function newI16Array(cap) { return new Int16Array(cap);  }
      function newU8Array(cap)  { return new Uint8Array(cap);  }
  
      var requestedSampleType;
      var newSampleArray;
  
      switch (format) {
      case 0x10010: /* AL_FORMAT_MONO_FLOAT32 */
      case 0x10011: /* AL_FORMAT_STEREO_FLOAT32 */
        requestedSampleType = 'f32';
        newSampleArray = newF32Array;
        break;
      case 0x1101:  /* AL_FORMAT_MONO16 */
      case 0x1103:  /* AL_FORMAT_STEREO16 */
        requestedSampleType = 'i16';
        newSampleArray = newI16Array;
        break;
      case 0x1100:  /* AL_FORMAT_MONO8 */
      case 0x1102:  /* AL_FORMAT_STEREO8 */
        requestedSampleType = 'u8';
        newSampleArray = newU8Array;
        break;
      }
  
      var buffers = [];
      try {
        for (var chan=0; chan < outputChannelCount; ++chan) {
          buffers[chan] = newSampleArray(bufferFrameCapacity);
        }
      } catch(e) {
        AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
        return 0;
      }
  
  
      // What we'll place into the `AL.captures` array in the end,
      // declared here for closures to access it
      var newCapture = {
        audioCtx: AL.sharedCaptureAudioCtx,
        deviceName: resolvedDeviceName,
        requestedSampleRate: requestedSampleRate,
        requestedSampleType: requestedSampleType,
        outputChannelCount: outputChannelCount,
        inputChannelCount: null, // Not known until the getUserMedia() promise resolves
        mediaStreamError: null, // Used by other functions to return early and report an error.
        mediaStreamSourceNode: null,
        // Either one, or none of the below two, is active.
        mergerNode: null,
        splitterNode: null,
        scriptProcessorNode: null,
        isCapturing: false,
        buffers: buffers,
        get bufferFrameCapacity() {
          return buffers[0].length;
        },
        capturePlayhead: 0, // current write position, in sample frames
        capturedFrameCount: 0
      };
  
      // Preparing for getUserMedia()
  
      var onError = function(mediaStreamError) {
        newCapture.mediaStreamError = mediaStreamError;
      };
      var onSuccess = function(mediaStream) {
        newCapture.mediaStreamSourceNode = newCapture.audioCtx.createMediaStreamSource(mediaStream);
  
        var inputChannelCount = 1;
        switch(newCapture.mediaStreamSourceNode.channelCountMode) {
        case 'max':
          inputChannelCount = outputChannelCount;
          break;
        case 'clamped-max':
          inputChannelCount = Math.min(outputChannelCount, newCapture.mediaStreamSourceNode.channelCount);
          break;
        case 'explicit':
          inputChannelCount = newCapture.mediaStreamSourceNode.channelCount;
          break;
        }
  
        newCapture.inputChannelCount = inputChannelCount;
  
  
        // Have to pick a size from 256, 512, 1024, 2048, 4096, 8192, 16384.
        // One can also set it to zero, which leaves the decision up to the impl.
        // An extension could allow specifying this value.
        var processorFrameCount = 512;
  
        newCapture.scriptProcessorNode = newCapture.audioCtx.createScriptProcessor(
          processorFrameCount, inputChannelCount, outputChannelCount
        );
  
        if (inputChannelCount > outputChannelCount) {
          newCapture.mergerNode = newCapture.audioCtx.createChannelMerger(inputChannelCount);
          newCapture.mediaStreamSourceNode.connect(newCapture.mergerNode);
          newCapture.mergerNode.connect(newCapture.scriptProcessorNode);
        } else if (inputChannelCount < outputChannelCount) {
          newCapture.splitterNode = newCapture.audioCtx.createChannelSplitter(outputChannelCount);
          newCapture.mediaStreamSourceNode.connect(newCapture.splitterNode);
          newCapture.splitterNode.connect(newCapture.scriptProcessorNode);
        } else {
          newCapture.mediaStreamSourceNode.connect(newCapture.scriptProcessorNode);
        }
  
        newCapture.scriptProcessorNode.connect(newCapture.audioCtx.destination);
  
        newCapture.scriptProcessorNode.onaudioprocess = function(audioProcessingEvent) {
  
          if (!newCapture.isCapturing) {
            return;
          }
  
          var c = newCapture;
          var srcBuf = audioProcessingEvent.inputBuffer;
  
          // Actually just copy srcBuf's channel data into
          // c.buffers, optimizing for each case.
          switch (format) {
          case 0x10010: /* AL_FORMAT_MONO_FLOAT32 */
            var channel0 = srcBuf.getChannelData(0);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i];
            }
            break;
          case 0x10011: /* AL_FORMAT_STEREO_FLOAT32 */
            var channel0 = srcBuf.getChannelData(0);
            var channel1 = srcBuf.getChannelData(1);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i];
              c.buffers[1][wi] = channel1[i];
            }
            break;
          case 0x1101:  /* AL_FORMAT_MONO16 */
            var channel0 = srcBuf.getChannelData(0);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i] * 32767;
            }
            break;
          case 0x1103:  /* AL_FORMAT_STEREO16 */
            var channel0 = srcBuf.getChannelData(0);
            var channel1 = srcBuf.getChannelData(1);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i] * 32767;
              c.buffers[1][wi] = channel1[i] * 32767;
            }
            break;
          case 0x1100:  /* AL_FORMAT_MONO8 */
            var channel0 = srcBuf.getChannelData(0);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = (channel0[i] + 1.0) * 127;
            }
            break;
          case 0x1102:  /* AL_FORMAT_STEREO8 */
            var channel0 = srcBuf.getChannelData(0);
            var channel1 = srcBuf.getChannelData(1);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = (channel0[i] + 1.0) * 127;
              c.buffers[1][wi] = (channel1[i] + 1.0) * 127;
            }
            break;
          }
  
          c.capturePlayhead += srcBuf.length;
          c.capturePlayhead %= c.bufferFrameCapacity;
          c.capturedFrameCount += srcBuf.length;
          c.capturedFrameCount = Math.min(c.capturedFrameCount, c.bufferFrameCapacity);
        };
      };
  
      // The latest way to call getUserMedia()
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices
             .getUserMedia({audio: true})
             .then(onSuccess)
             .catch(onError);
      } else { // The usual (now deprecated) way
        navigator.getUserMedia({audio: true}, onSuccess, onError);
      }
  
      var id = AL.newId();
      AL.captures[id] = newCapture;
      return id;
    }
  Module["_alcCaptureOpenDevice"] = _alcCaptureOpenDevice;

  function _alcCaptureCloseDevice(deviceId) {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureCloseDevice');
      if (!c) return false;
  
      delete AL.captures[deviceId];
      AL.freeIds.push(deviceId);
  
      // This clean-up might be unnecessary (paranoid) ?
  
      // May happen if user hasn't decided to grant or deny input
      if (c.mediaStreamSourceNode) c.mediaStreamSourceNode.disconnect();
      if (c.mergerNode) c.mergerNode.disconnect();
      if (c.splitterNode) c.splitterNode.disconnect();
      // May happen if user hasn't decided to grant or deny input
      if (c.scriptProcessorNode) c.scriptProcessorNode.disconnect();
  
      delete c.buffers;
  
      c.capturedFrameCount = 0;
      c.isCapturing = false;
  
      return true;
    }
  Module["_alcCaptureCloseDevice"] = _alcCaptureCloseDevice;

  function _alcCaptureStart(deviceId) {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureStart');
      if (!c) return;
  
      if (c.isCapturing) {
        // NOTE: Spec says (emphasis mine):
        //     The amount of audio samples available after **restarting** a 
        //     stopped capture device is reset to zero.
        // So redundant calls to alcCaptureStart() must have no effect.
        return;
      }
      c.isCapturing = true;
      c.capturedFrameCount = 0;
      c.capturePlayhead = 0;
    }
  Module["_alcCaptureStart"] = _alcCaptureStart;

  function _alcCaptureStop(deviceId) {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureStop');
      if (!c) return;
  
      c.isCapturing = false;
    }
  Module["_alcCaptureStop"] = _alcCaptureStop;

  function _alcCaptureSamples(deviceId, pFrames, requestedFrameCount) {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureSamples');
      if (!c) return;
  
      // ALCsizei is actually 32-bit signed int, so could be negative
      // Also, spec says :
      //   Requesting more sample frames than are currently available is 
      //   an error.
      if (requestedFrameCount < 0
      ||  requestedFrameCount > c.capturedFrameCount) 
      {
    // if OPENAL_DEBUG
        console.error('alcCaptureSamples() with invalid bufferSize');
    // endif
        AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
        return;
      }
      
      function setF32Sample(i, sample) {
        HEAPF32[(((pFrames)+(4*i))>>2)]=sample;
      }
      function setI16Sample(i, sample) {
        HEAP16[(((pFrames)+(2*i))>>1)]=sample;
      }
      function setU8Sample(i, sample) {
        HEAP8[(((pFrames)+(i))>>0)]=sample;
      }
  
      var setSample;
  
      switch(c.requestedSampleType) {
      case 'f32': setSample = setF32Sample; break;
      case 'i16': setSample = setI16Sample; break;
      case 'u8' : setSample = setU8Sample ; break;
      default: 
        return;
      }
  
      var dstfreq = c.requestedSampleRate;
      var srcfreq = c.audioCtx.sampleRate;
  
      if (srcfreq == dstfreq) {
        for (var i = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
          for (var chan = 0; chan < c.buffers.length; ++chan, ++i) {
            var src_i = (frame_i + c.capturePlayhead) % c.capturedFrameCount;
            setSample(i, c.buffers[chan][src_i]);
          }
        }
      } else {
        // Perform linear resampling.
  
        // There is room for improvement - right now we're fine with linear resampling.
        // We don't use OfflineAudioContexts for this: See the discussion at
        // https://github.com/jpernst/emscripten/issues/2#issuecomment-312729735
        // if you're curious about why.
  
        var lerp = function(from, to, progress) {
          return (1 - progress) * from + progress * to;
        };
  
        for (var i = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
  
          var t = frame_i / dstfreq; // Most exact time for the current output sample
          var src_i = (Math.floor(t*srcfreq) + c.capturePlayhead) % c.capturedFrameCount;
          var src_next_i = (src_i+1) % c.capturedFrameCount;
          var between = t*srcfreq - src_i; //(t - src_i/srcfreq) / ((src_i+1)/srcfreq - src_i/srcfreq);
  
          for (var chan = 0; chan < c.buffers.length; ++chan, ++i) {
            var cb = c.buffers[chan];
            var sample = lerp(cb[src_i], cb[src_next_i], between);
            setSample(i, sample);
          }
        }
      }
  
      // Spec doesn't say if alcCaptureSamples() must zero the number
      // of available captured sample-frames, but not only would it
      // be insane not to do, OpenAL-Soft happens to do that as well.
      c.capturedFrameCount = 0;
    }
  Module["_alcCaptureSamples"] = _alcCaptureSamples;

  function _alcOpenDevice(pDeviceName) {
      if (pDeviceName) {
        var name = UTF8ToString(pDeviceName);
        if (name !== AL.DEVICE_NAME) {
          return 0;
        }
      }
  
      if (typeof(AudioContext) !== 'undefined' || typeof(webkitAudioContext) !== 'undefined') {
        var deviceId = AL.newId();
        AL.deviceRefCounts[deviceId] = 0;
        return deviceId;
      } else {
        return 0;
      }
    }
  Module["_alcOpenDevice"] = _alcOpenDevice;

  function _alcCloseDevice(deviceId) {
      if (!(deviceId in AL.deviceRefCounts) || AL.deviceRefCounts[deviceId] > 0) {
        return 0 /* ALC_FALSE */;
      }
  
      delete AL.deviceRefCounts[deviceId];
      AL.freeIds.push(deviceId);
      return 1 /* ALC_TRUE */;
    }
  Module["_alcCloseDevice"] = _alcCloseDevice;

  function _alcCreateContext(deviceId, pAttrList) {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 0xA001; /* ALC_INVALID_DEVICE */
        return 0;
      }
  
      var options = null;
      var attrs = [];
      var hrtf = null;
      pAttrList >>= 2;
      if (pAttrList) {
        var attr = 0;
        var val = 0;
        while (true) {
          attr = HEAP32[pAttrList++];
          attrs.push(attr);
          if (attr === 0) {
            break;
          }
          val = HEAP32[pAttrList++];
          attrs.push(val);
  
          switch (attr) {
          case 0x1007 /* ALC_FREQUENCY */:
            if (!options) {
              options = {};
            }
  
            options.sampleRate = val;
            break;
          case 0x1010 /* ALC_MONO_SOURCES */: // fallthrough
          case 0x1011 /* ALC_STEREO_SOURCES */:
            // Do nothing; these hints are satisfied by default
            break
          case 0x1992 /* ALC_HRTF_SOFT */:
            switch (val) {
              case 0 /* ALC_FALSE */:
                hrtf = false;
                break;
              case 1 /* ALC_TRUE */:
                hrtf = true;
                break;
              case 2 /* ALC_DONT_CARE_SOFT */:
                break;
              default:
                AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
                return 0;
            }
            break;
          case 0x1996 /* ALC_HRTF_ID_SOFT */:
            if (val !== 0) {
              AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
              return 0;
            }
            break;
          default:
            AL.alcErr = 0xA004; /* ALC_INVALID_VALUE */
            return 0;
          }
        }
      }
  
      var AudioContext = window.AudioContext || window.webkitAudioContext;
      var ac = null;
      try {
        // Only try to pass options if there are any, for compat with browsers that don't support this
        if (options) {
          ac = new AudioContext(options);
        } else {
          ac = new AudioContext();
        }
      } catch (e) {
        if (e.name === 'NotSupportedError') {
          AL.alcErr = 0xA004; /* ALC_INVALID_VALUE */
        } else {
          AL.alcErr = 0xA001; /* ALC_INVALID_DEVICE */
        }
  
        return 0;
      }
  
      // Old Web Audio API (e.g. Safari 6.0.5) had an inconsistently named createGainNode function.
      if (typeof(ac.createGain) === 'undefined') {
        ac.createGain = ac.createGainNode;
      }
  
      var gain = ac.createGain();
      gain.connect(ac.destination);
      var ctx = {
        deviceId: deviceId,
        id: AL.newId(),
        attrs: attrs,
        audioCtx: ac,
        listener: {
      	  position: [0.0, 0.0, 0.0],
      	  velocity: [0.0, 0.0, 0.0],
      	  direction: [0.0, 0.0, 0.0],
      	  up: [0.0, 0.0, 0.0]
        },
        sources: [],
        interval: setInterval(function() { AL.scheduleContextAudio(ctx); }, AL.QUEUE_INTERVAL),
        gain: gain,
        distanceModel: 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */,
        speedOfSound: 343.3,
        dopplerFactor: 1.0,
        sourceDistanceModel: false,
        hrtf: hrtf || false,
  
        _err: 0,
        get err() {
          return this._err;
        },
        set err(val) {
          // Errors should not be overwritten by later errors until they are cleared by a query.
          if (this._err === 0 /* AL_NO_ERROR */ || val === 0 /* AL_NO_ERROR */) {
            this._err = val;
          }
        }
      };
      AL.deviceRefCounts[deviceId]++;
      AL.contexts[ctx.id] = ctx;
  
      if (hrtf !== null) {
        // Apply hrtf attrib to all contexts for this device
        for (var ctxId in AL.contexts) {
          var c = AL.contexts[ctxId];
          if (c.deviceId === deviceId) {
            c.hrtf = hrtf;
            AL.updateContextGlobal(c);
          }
        }
      }
  
      return ctx.id;
    }
  Module["_alcCreateContext"] = _alcCreateContext;

  function _alcDestroyContext(contextId) {
      var ctx = AL.contexts[contextId];
      if (AL.currentCtx === ctx) {
        AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
        return;
      }
  
      // Stop playback, etc
      if (AL.contexts[contextId].interval) {
        clearInterval(AL.contexts[contextId].interval);
      }
      AL.deviceRefCounts[ctx.deviceId]--;
      delete AL.contexts[contextId];
      AL.freeIds.push(contextId);
    }
  Module["_alcDestroyContext"] = _alcDestroyContext;

  function _alcGetError(deviceId) {
      var err = AL.alcErr;
      AL.alcErr = 0 /* ALC_NO_ERROR */;
      return err;
    }
  Module["_alcGetError"] = _alcGetError;

  function _alcGetCurrentContext() {
      if (AL.currentCtx !== null) {
        return AL.currentCtx.id;
      } else {
        return 0;
      }
    }
  Module["_alcGetCurrentContext"] = _alcGetCurrentContext;

  function _alcMakeContextCurrent(contextId) {
      if (contextId === 0) {
        AL.currentCtx = null;
        return 0;
      } else {
        AL.currentCtx = AL.contexts[contextId];
        return 1;
      }
    }
  Module["_alcMakeContextCurrent"] = _alcMakeContextCurrent;

  function _alcGetContextsDevice(contextId) {
      if (contextId in AL.contexts) {
        return AL.contexts[contextId].deviceId;
      } else {
        return 0;
      }
    }
  Module["_alcGetContextsDevice"] = _alcGetContextsDevice;

  function _alcProcessContext(contextId) {}
  Module["_alcProcessContext"] = _alcProcessContext;

  function _alcSuspendContext(contextId) {}
  Module["_alcSuspendContext"] = _alcSuspendContext;

  function _alcIsExtensionPresent(deviceId, pExtName) {
      var name = UTF8ToString(pExtName);
  
      return AL.ALC_EXTENSIONS[name] ? 1 : 0;
    }
  Module["_alcIsExtensionPresent"] = _alcIsExtensionPresent;

  
  function _emscripten_GetAlcProcAddress(
  ) {
  if (!Module['_emscripten_GetAlcProcAddress']) abort("external function 'emscripten_GetAlcProcAddress' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_emscripten_GetAlcProcAddress'].apply(null, arguments);
  }function _alcGetProcAddress(deviceId, pProcName) {
      if (!pProcName) {
        AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
        return 0; /* ALC_NONE */
      }
      return _emscripten_GetAlcProcAddress(pProcName);
    }
  Module["_alcGetProcAddress"] = _alcGetProcAddress;

  function _alcGetEnumValue(deviceId, pEnumName) {
      // Spec says :
      // Using a NULL handle is legal, but only the
      // tokens defined by the AL core are guaranteed.
      if (deviceId !== 0 && !(deviceId in AL.deviceRefCounts)) {
        // ALC_INVALID_DEVICE is not listed as a possible error state for
        // this function, sadly.
        return 0 /* ALC_NONE */;
      } else if (!pEnumName) {
        AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
        return 0; /* ALC_NONE */
      }
      name = UTF8ToString(pEnumName);
      // See alGetEnumValue(), but basically behave the same as OpenAL-Soft
      switch(name) {
      case 'ALC_NO_ERROR': return 0;
      case 'ALC_INVALID_DEVICE': return 0xA001;
      case 'ALC_INVALID_CONTEXT': return 0xA002;
      case 'ALC_INVALID_ENUM': return 0xA003;
      case 'ALC_INVALID_VALUE': return 0xA004;
      case 'ALC_OUT_OF_MEMORY': return 0xA005;
      case 'ALC_MAJOR_VERSION': return 0x1000;
      case 'ALC_MINOR_VERSION': return 0x1001;
      case 'ALC_ATTRIBUTES_SIZE': return 0x1002;
      case 'ALC_ALL_ATTRIBUTES': return 0x1003;
      case 'ALC_DEFAULT_DEVICE_SPECIFIER': return 0x1004;
      case 'ALC_DEVICE_SPECIFIER': return 0x1005;
      case 'ALC_EXTENSIONS': return 0x1006;
      case 'ALC_FREQUENCY': return 0x1007;
      case 'ALC_REFRESH': return 0x1008;
      case 'ALC_SYNC': return 0x1009;
      case 'ALC_MONO_SOURCES': return 0x1010;
      case 'ALC_STEREO_SOURCES': return 0x1011;
      case 'ALC_CAPTURE_DEVICE_SPECIFIER': return 0x310;
      case 'ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER': return 0x311;
      case 'ALC_CAPTURE_SAMPLES': return 0x312;
  
      /* Extensions */
      case 'ALC_HRTF_SOFT': return 0x1992;
      case 'ALC_HRTF_ID_SOFT': return 0x1996;
      case 'ALC_DONT_CARE_SOFT': return 0x0002;
      case 'ALC_HRTF_STATUS_SOFT': return 0x1993;
      case 'ALC_NUM_HRTF_SPECIFIERS_SOFT': return 0x1994;
      case 'ALC_HRTF_SPECIFIER_SOFT': return 0x1995;
      case 'ALC_HRTF_DISABLED_SOFT': return 0x0000;
      case 'ALC_HRTF_ENABLED_SOFT': return 0x0001;
      case 'ALC_HRTF_DENIED_SOFT': return 0x0002;
      case 'ALC_HRTF_REQUIRED_SOFT': return 0x0003;
      case 'ALC_HRTF_HEADPHONES_DETECTED_SOFT': return 0x0004;
      case 'ALC_HRTF_UNSUPPORTED_FORMAT_SOFT': return 0x0005;
  
      default:
        AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
        return 0 /* AL_NONE */;
      }
    }
  Module["_alcGetEnumValue"] = _alcGetEnumValue;

  function _alcGetString(deviceId, param) {
      if (AL.alcStringCache[param]) {
        return AL.alcStringCache[param];
      }
  
      var ret;
      switch (param) {
      case 0 /* ALC_NO_ERROR */:
        ret = 'No Error';
        break;
      case 0xA001 /* ALC_INVALID_DEVICE */:
        ret = 'Invalid Device';
        break;
      case 0xA002 /* ALC_INVALID_CONTEXT */:
        ret = 'Invalid Context';
        break;
      case 0xA003 /* ALC_INVALID_ENUM */:
        ret = 'Invalid Enum';
        break;
      case 0xA004 /* ALC_INVALID_VALUE */:
        ret = 'Invalid Value';
        break;
      case 0xA005 /* ALC_OUT_OF_MEMORY */:
        ret = 'Out of Memory';
        break;
      case 0x1004 /* ALC_DEFAULT_DEVICE_SPECIFIER */:
        if (typeof(AudioContext) !== 'undefined' ||
            typeof(webkitAudioContext) !== 'undefined') {
          ret = AL.DEVICE_NAME;
        } else {
          return 0;
        }
        break;
      case 0x1005 /* ALC_DEVICE_SPECIFIER */:
        if (typeof(AudioContext) !== 'undefined' ||
            typeof(webkitAudioContext) !== 'undefined') {
          ret = AL.DEVICE_NAME.concat('\0');
        } else {
          ret = '\0';
        }
        break;
      case 0x311 /* ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER */:
        ret = AL.CAPTURE_DEVICE_NAME;
        break;
      case 0x310 /* ALC_CAPTURE_DEVICE_SPECIFIER */:
        if (deviceId === 0) 
          ret = AL.CAPTURE_DEVICE_NAME.concat('\0');
          else {
          var c = AL.requireValidCaptureDevice(deviceId, 'alcGetString');
          if (!c) {
            return 0;
          }
          ret = c.deviceName;
        }  
        break;
      case 0x1006 /* ALC_EXTENSIONS */:
        if (!deviceId) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return 0;
        }
  
        ret = '';
        for (var ext in AL.ALC_EXTENSIONS) {
          ret = ret.concat(ext);
          ret = ret.concat(' ');
        }
        ret = ret.trim();
        break;
      default:
        AL.alcErr = 0xA003 /* ALC_INVALID_ENUM */;
        return 0;
      }
  
      ret = allocate(intArrayFromString(ret), 'i8', ALLOC_NORMAL);
      AL.alcStringCache[param] = ret;
      return ret;
    }
  Module["_alcGetString"] = _alcGetString;

  function _alcGetIntegerv(deviceId, param, size, pValues) {
      if (size === 0 || !pValues) {
        // Ignore the query, per the spec
        return;
      }
  
      switch(param) {
      case 0x1000 /* ALC_MAJOR_VERSION */:
        HEAP32[((pValues)>>2)]=1;
        break;
      case 0x1001 /* ALC_MINOR_VERSION */:
        HEAP32[((pValues)>>2)]=1;
        break;
      case 0x1002 /* ALC_ATTRIBUTES_SIZE */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)]=AL.currentCtx.attrs.length;
        break;
      case 0x1003 /* ALC_ALL_ATTRIBUTES */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        for (var i = 0; i < AL.currentCtx.attrs.length; i++) {
          HEAP32[(((pValues)+(i*4))>>2)]=AL.currentCtx.attrs[i];
        }
        break;
      case 0x1007 /* ALC_FREQUENCY */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)]=AL.currentCtx.audioCtx.sampleRate;
        break;
      case 0x1010 /* ALC_MONO_SOURCES */:
      case 0x1011 /* ALC_STEREO_SOURCES */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)]=0x7FFFFFFF;
        break;
      case 0x1992 /* ALC_HRTF_SOFT */:
      case 0x1993 /* ALC_HRTF_STATUS_SOFT */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return;
        }
  
        var hrtfStatus = 0 /* ALC_HRTF_DISABLED_SOFT */;
        for (var ctxId in AL.contexts) {
          var ctx = AL.contexts[ctxId];
          if (ctx.deviceId === deviceId) {
            hrtfStatus = ctx.hrtf ? 1 /* ALC_HRTF_ENABLED_SOFT */ : 0 /* ALC_HRTF_DISABLED_SOFT */;
          }
        }
        HEAP32[((pValues)>>2)]=hrtfStatus;
        break;
      case 0x1994 /* ALC_NUM_HRTF_SPECIFIERS_SOFT */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return;
        }
        HEAP32[((pValues)>>2)]=1;
        break;
      case 0x20003 /* ALC_MAX_AUXILIARY_SENDS */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)]=1;
      case 0x312 /* ALC_CAPTURE_SAMPLES */:
        var c = AL.requireValidCaptureDevice(deviceId, 'alcGetIntegerv');
        if (!c) {
          return;
        }
        var n = c.capturedFrameCount;
        var dstfreq = c.requestedSampleRate;
        var srcfreq = c.audioCtx.sampleRate;
        var nsamples = Math.floor(n * (dstfreq/srcfreq));
        HEAP32[((pValues)>>2)]=nsamples;
        break;
      default:
        AL.alcErr = 0xA003 /* ALC_INVALID_ENUM */;
        return;
      }
    }
  Module["_alcGetIntegerv"] = _alcGetIntegerv;

  function _emscripten_alcDevicePauseSOFT(deviceId) {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
        return;
      }
  
      if (AL.paused) {
        return;
      }
      AL.paused = true;
  
      for (ctxId in AL.contexts) {
        var ctx = AL.contexts[ctxId];
        if (ctx.deviceId !== deviceId) {
          continue;
        }
  
        ctx.audioCtx.suspend();
        clearInterval(ctx.interval);
        ctx.interval = null;
      }
    }
  Module["_emscripten_alcDevicePauseSOFT"] = _emscripten_alcDevicePauseSOFT;

  function _emscripten_alcDeviceResumeSOFT(deviceId) {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
        return;
      }
  
      if (!AL.paused) {
        return;
      }
      AL.paused = false;
  
      for (ctxId in AL.contexts) {
        var ctx = AL.contexts[ctxId];
        if (ctx.deviceId !== deviceId) {
          continue;
        }
  
        ctx.interval = setInterval(function() { AL.scheduleContextAudio(ctx); }, AL.QUEUE_INTERVAL);
        ctx.audioCtx.resume();
      }
    }
  Module["_emscripten_alcDeviceResumeSOFT"] = _emscripten_alcDeviceResumeSOFT;

  function _emscripten_alcGetStringiSOFT(deviceId, param, index) {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
        return 0;
      }
  
      if (AL.alcStringCache[param]) {
        return AL.alcStringCache[param];
      }
  
      var ret;
      switch (param) {
      case 0x1995 /* ALC_HRTF_SPECIFIER_SOFT */:
        if (index === 0) {
          ret = 'Web Audio HRTF';
        } else {
          AL.alcErr = 0xA004 /* ALC_INVALID_VALUE */;
          return 0;
        }
        break;
      default:
        if (index === 0) {
          return _alcGetString(deviceId, param);
        } else {
          AL.alcErr = 0xA003 /* ALC_INVALID_ENUM */;
          return 0;
        }
      }
  
      ret = allocate(intArrayFromString(ret), 'i8', ALLOC_NORMAL);
      AL.alcStringCache[param] = ret;
      return ret;
    }
  Module["_emscripten_alcGetStringiSOFT"] = _emscripten_alcGetStringiSOFT;

  function _emscripten_alcResetDeviceSOFT(deviceId, pAttrList) {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 0xA001 /* ALC_INVALID_DEVICE */;
        return 0 /* ALC_FALSE */;
      }
  
      var hrtf = null;
      pAttrList >>= 2;
      if (pAttrList) {
        var attr = 0;
        var val = 0;
        while (true) {
          attr = HEAP32[pAttrList++];
          if (attr === 0) {
            break;
          }
          val = HEAP32[pAttrList++];
  
          switch (attr) {
          case 0x1992 /* ALC_HRTF_SOFT */:
            if (val === 1 /* ALC_TRUE */) {
              hrtf = true;
            } else if (val === 0 /* ALC_FALSE */) {
              hrtf = false;
            }
            break;
          }
        }
      }
  
      if (hrtf !== null) {
        // Apply hrtf attrib to all contexts for this device
        for (var ctxId in AL.contexts) {
          var ctx = AL.contexts[ctxId];
          if (ctx.deviceId === deviceId) {
            ctx.hrtf = hrtf;
            AL.updateContextGlobal(ctx);
          }
        }
      }
  
      return 1 /* ALC_TRUE */;
    }
  Module["_emscripten_alcResetDeviceSOFT"] = _emscripten_alcResetDeviceSOFT;

  function _alGenBuffers(count, pBufferIds) {
      if (!AL.currentCtx) {
        return;
      }
  
      for (var i = 0; i < count; ++i) {
        var buf = {
          deviceId: AL.currentCtx.deviceId,
          id: AL.newId(),
          refCount: 0,
          audioBuf: null,
          frequency: 0,
          bytesPerSample: 2,
          channels: 1,
          length: 0,
        };
        AL.deviceRefCounts[buf.deviceId]++;
        AL.buffers[buf.id] = buf;
        HEAP32[(((pBufferIds)+(i*4))>>2)]=buf.id;
      }
    }
  Module["_alGenBuffers"] = _alGenBuffers;

  function _alDeleteBuffers(count, pBufferIds) {
      if (!AL.currentCtx) {
        return;
      }
  
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        /// Deleting the zero buffer is a legal NOP, so ignore it
        if (bufId === 0) {
          continue;
        }
  
        // Make sure the buffer index is valid.
        if (!AL.buffers[bufId]) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
  
        // Make sure the buffer is no longer in use.
        if (AL.buffers[bufId].refCount) {
          AL.currentCtx.err = 0xA004 /* AL_INVALID_OPERATION */;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        if (bufId === 0) {
          continue;
        }
  
        AL.deviceRefCounts[AL.buffers[bufId].deviceId]--;
        delete AL.buffers[bufId];
        AL.freeIds.push(bufId);
      }
    }
  Module["_alDeleteBuffers"] = _alDeleteBuffers;

  function _alGenSources(count, pSourceIds) {
      if (!AL.currentCtx) {
        return;
      }
      for (var i = 0; i < count; ++i) {
        var gain = AL.currentCtx.audioCtx.createGain();
        gain.connect(AL.currentCtx.gain);
        var src = {
          context: AL.currentCtx,
          id: AL.newId(),
          type: 0x1030 /* AL_UNDETERMINED */,
          state: 0x1011 /* AL_INITIAL */,
          bufQueue: [AL.buffers[0]],
          audioQueue: [],
          looping: false,
          pitch: 1.0,
          dopplerShift: 1.0,
          gain: gain,
          minGain: 0.0,
          maxGain: 1.0,
          panner: null,
          bufsProcessed: 0,
          bufStartTime: Number.NEGATIVE_INFINITY,
          bufOffset: 0.0,
          relative: false,
          refDistance: 1.0,
          maxDistance: 3.40282e38 /* FLT_MAX */,
          rolloffFactor: 1.0,
          position: [0.0, 0.0, 0.0],
          velocity: [0.0, 0.0, 0.0],
          direction: [0.0, 0.0, 0.0],
          coneOuterGain: 0.0,
          coneInnerAngle: 360.0,
          coneOuterAngle: 360.0,
          distanceModel: 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */,
          spatialize: 2 /* AL_AUTO_SOFT */,
  
          get playbackRate() {
            return this.pitch * this.dopplerShift;
          }
        };
        AL.currentCtx.sources[src.id] = src;
        HEAP32[(((pSourceIds)+(i*4))>>2)]=src.id;
      }
    }
  Module["_alGenSources"] = _alGenSources;

  
  function _alSourcei(sourceId, param, value) {
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */: 
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        AL.setSourceParam('alSourcei', sourceId, param, value);
        break;
      default:
        AL.setSourceParam('alSourcei', sourceId, param, null);
        break;
      }
    }
  Module["_alSourcei"] = _alSourcei;function _alDeleteSources(count, pSourceIds) {
      if (!AL.currentCtx) {
        return;
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        if (!AL.currentCtx.sources[srcId]) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        AL.setSourceState(AL.currentCtx.sources[srcId], 0x1014 /* AL_STOPPED */);
        _alSourcei(srcId, 0x1009 /* AL_BUFFER */, 0);
        delete AL.currentCtx.sources[srcId];
        AL.freeIds.push(srcId);
      }
    }
  Module["_alDeleteSources"] = _alDeleteSources;

  function _alGetError() {
      if (!AL.currentCtx) {
        return 0xA004 /* AL_INVALID_OPERATION */;
      } else {
        // Reset error on get.
        var err = AL.currentCtx.err;
        AL.currentCtx.err = 0 /* AL_NO_ERROR */;
        return err;
      }
    }
  Module["_alGetError"] = _alGetError;

  function _alIsExtensionPresent(pExtName) {
      name = UTF8ToString(pExtName);
  
      return AL.AL_EXTENSIONS[name] ? 1 : 0;
    }
  Module["_alIsExtensionPresent"] = _alIsExtensionPresent;

  
  function _emscripten_GetAlProcAddress(
  ) {
  if (!Module['_emscripten_GetAlProcAddress']) abort("external function 'emscripten_GetAlProcAddress' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_emscripten_GetAlProcAddress'].apply(null, arguments);
  }function _alGetProcAddress(pProcName) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pProcName) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return 0; /* ALC_NONE */
      }
      return _emscripten_GetAlProcAddress(pProcName);
    }
  Module["_alGetProcAddress"] = _alGetProcAddress;

  function _alGetEnumValue(pEnumName) {
      if (!AL.currentCtx) {
        return 0;
      }
  
      if (!pEnumName) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return 0 /* AL_NONE */;
      }
      name = UTF8ToString(pEnumName);
  
      switch(name) {
      // Spec doesn't clearly state that alGetEnumValue() is required to
      // support _only_ extension tokens.
      // We should probably follow OpenAL-Soft's example and support all
      // of the names we know.
      // See http://repo.or.cz/openal-soft.git/blob/HEAD:/Alc/ALc.c
      case 'AL_BITS': return 0x2002;
      case 'AL_BUFFER': return 0x1009;
      case 'AL_BUFFERS_PROCESSED': return 0x1016;
      case 'AL_BUFFERS_QUEUED': return 0x1015;
      case 'AL_BYTE_OFFSET': return 0x1026;
      case 'AL_CHANNELS': return 0x2003;
      case 'AL_CONE_INNER_ANGLE': return 0x1001;
      case 'AL_CONE_OUTER_ANGLE': return 0x1002;
      case 'AL_CONE_OUTER_GAIN': return 0x1022;
      case 'AL_DIRECTION': return 0x1005;
      case 'AL_DISTANCE_MODEL': return 0xD000;
      case 'AL_DOPPLER_FACTOR': return 0xC000;
      case 'AL_DOPPLER_VELOCITY': return 0xC001;
      case 'AL_EXPONENT_DISTANCE': return 0xD005;
      case 'AL_EXPONENT_DISTANCE_CLAMPED': return 0xD006;
      case 'AL_EXTENSIONS': return 0xB004;
      case 'AL_FORMAT_MONO16': return 0x1101;
      case 'AL_FORMAT_MONO8': return 0x1100;
      case 'AL_FORMAT_STEREO16': return 0x1103;
      case 'AL_FORMAT_STEREO8': return 0x1102;
      case 'AL_FREQUENCY': return 0x2001;
      case 'AL_GAIN': return 0x100A;
      case 'AL_INITIAL': return 0x1011;
      case 'AL_INVALID': return -1;
      case 'AL_ILLEGAL_ENUM': // fallthrough
      case 'AL_INVALID_ENUM': return 0xA002;
      case 'AL_INVALID_NAME': return 0xA001;
      case 'AL_ILLEGAL_COMMAND': // fallthrough
      case 'AL_INVALID_OPERATION': return 0xA004;
      case 'AL_INVALID_VALUE': return 0xA003;
      case 'AL_INVERSE_DISTANCE': return 0xD001;
      case 'AL_INVERSE_DISTANCE_CLAMPED': return 0xD002;
      case 'AL_LINEAR_DISTANCE': return 0xD003;
      case 'AL_LINEAR_DISTANCE_CLAMPED': return 0xD004;
      case 'AL_LOOPING': return 0x1007;
      case 'AL_MAX_DISTANCE': return 0x1023;
      case 'AL_MAX_GAIN': return 0x100E;
      case 'AL_MIN_GAIN': return 0x100D;
      case 'AL_NONE': return 0;
      case 'AL_NO_ERROR': return 0;
      case 'AL_ORIENTATION': return 0x100F;
      case 'AL_OUT_OF_MEMORY': return 0xA005;
      case 'AL_PAUSED': return 0x1013;
      case 'AL_PENDING': return 0x2011;
      case 'AL_PITCH': return 0x1003;
      case 'AL_PLAYING': return 0x1012;
      case 'AL_POSITION': return 0x1004;
      case 'AL_PROCESSED': return 0x2012;
      case 'AL_REFERENCE_DISTANCE': return 0x1020;
      case 'AL_RENDERER': return 0xB003;
      case 'AL_ROLLOFF_FACTOR': return 0x1021;
      case 'AL_SAMPLE_OFFSET': return 0x1025;
      case 'AL_SEC_OFFSET': return 0x1024;
      case 'AL_SIZE': return 0x2004;
      case 'AL_SOURCE_RELATIVE': return 0x202;
      case 'AL_SOURCE_STATE': return 0x1010;
      case 'AL_SOURCE_TYPE': return 0x1027;
      case 'AL_SPEED_OF_SOUND': return 0xC003;
      case 'AL_STATIC': return 0x1028;
      case 'AL_STOPPED': return 0x1014;
      case 'AL_STREAMING': return 0x1029;
      case 'AL_UNDETERMINED': return 0x1030;
      case 'AL_UNUSED': return 0x2010;
      case 'AL_VELOCITY': return 0x1006;
      case 'AL_VENDOR': return 0xB001;
      case 'AL_VERSION': return 0xB002;
  
      /* Extensions */
      case 'AL_AUTO_SOFT': return 0x0002;
      case 'AL_SOURCE_DISTANCE_MODEL': return 0x200;
      case 'AL_SOURCE_SPATIALIZE_SOFT': return 0x1214;
      case 'AL_LOOP_POINTS_SOFT': return 0x2015;
      case 'AL_BYTE_LENGTH_SOFT': return 0x2009;
      case 'AL_SAMPLE_LENGTH_SOFT': return 0x200A;
      case 'AL_SEC_LENGTH_SOFT': return 0x200B;
      case 'AL_FORMAT_MONO_FLOAT32': return 0x10010;
      case 'AL_FORMAT_STEREO_FLOAT32': return 0x10011;
  
      default:
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return 0;
      }
    }
  Module["_alGetEnumValue"] = _alGetEnumValue;

  function _alGetString(param) {
      if (!AL.currentCtx) {
        return 0;
      }
  
      if (AL.stringCache[param]) {
        return AL.stringCache[param];
      }
  
      var ret;
      switch (param) {
      case 0 /* AL_NO_ERROR */:
        ret = 'No Error';
        break;
      case 0xA001 /* AL_INVALID_NAME */:
        ret = 'Invalid Name';
        break;
      case 0xA002 /* AL_INVALID_ENUM */:
        ret = 'Invalid Enum';
        break;
      case 0xA003 /* AL_INVALID_VALUE */:
        ret = 'Invalid Value';
        break;
      case 0xA004 /* AL_INVALID_OPERATION */:
        ret = 'Invalid Operation';
        break;
      case 0xA005 /* AL_OUT_OF_MEMORY */:
        ret = 'Out of Memory';
        break;
      case 0xB001 /* AL_VENDOR */:
        ret = 'Emscripten';
        break;
      case 0xB002 /* AL_VERSION */:
        ret = '1.1';
        break;
      case 0xB003 /* AL_RENDERER */:
        ret = 'WebAudio';
        break;
      case 0xB004 /* AL_EXTENSIONS */:
        ret = '';
        for (var ext in AL.AL_EXTENSIONS) {
          ret = ret.concat(ext);
          ret = ret.concat(' ');
        }
        ret = ret.trim();
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return 0;
      }
  
      ret = allocate(intArrayFromString(ret), 'i8', ALLOC_NORMAL);
      AL.stringCache[param] = ret;
      return ret;
    }
  Module["_alGetString"] = _alGetString;

  function _alEnable(param) {
      if (!AL.currentCtx) {
        return;
      }
      switch (param) {
      case 'AL_SOURCE_DISTANCE_MODEL':
        AL.currentCtx.sourceDistanceModel = true;
        AL.updateContextGlobal(AL.currentCtx);
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alEnable"] = _alEnable;

  function _alDisable(param) {
      if (!AL.currentCtx) {
        return;
      }
      switch (pname) {
      case 'AL_SOURCE_DISTANCE_MODEL':
        AL.currentCtx.sourceDistanceModel = false;
        AL.updateContextGlobal(AL.currentCtx);
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alDisable"] = _alDisable;

  function _alIsEnabled(param) {
      if (!AL.currentCtx) {
        return 0;
      }
      switch (pname) {
      case 'AL_SOURCE_DISTANCE_MODEL':
        return AL.currentCtx.sourceDistanceModel ? 0 /* AL_FALSE */ : 1 /* AL_TRUE */;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return 0;
      }
    }
  Module["_alIsEnabled"] = _alIsEnabled;

  function _alGetDouble(param) {
      var val = AL.getGlobalParam('alGetDouble', param);
      if (val === null) {
        return 0.0;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        return val;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return 0.0;
      }
    }
  Module["_alGetDouble"] = _alGetDouble;

  function _alGetDoublev(param, pValues) {
      var val = AL.getGlobalParam('alGetDoublev', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        HEAPF64[((pValues)>>3)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetDoublev"] = _alGetDoublev;

  function _alGetFloat(param) {
      var val = AL.getGlobalParam('alGetFloat', param);
      if (val === null) {
        return 0.0;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        return val;
      default:
        return 0.0;
      }
    }
  Module["_alGetFloat"] = _alGetFloat;

  function _alGetFloatv(param, pValues) {
      var val = AL.getGlobalParam('alGetFloatv', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        HEAPF32[((pValues)>>2)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetFloatv"] = _alGetFloatv;

  function _alGetInteger(param) {
      var val = AL.getGlobalParam('alGetInteger', param);
      if (val === null) {
        return 0;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        return val;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return 0;
      }
    }
  Module["_alGetInteger"] = _alGetInteger;

  function _alGetIntegerv(param, pValues) {
      var val = AL.getGlobalParam('alGetIntegerv', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        HEAP32[((pValues)>>2)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetIntegerv"] = _alGetIntegerv;

  function _alGetBoolean(param) {
      var val = AL.getGlobalParam('alGetBoolean', param);
      if (val === null) {
        return 0 /* AL_FALSE */;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        return val !== 0 ? 1 /* AL_TRUE */ : 0 /* AL_FALSE */;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return 0 /* AL_FALSE */;
      }
    }
  Module["_alGetBoolean"] = _alGetBoolean;

  function _alGetBooleanv(param, pValues) {
      var val = AL.getGlobalParam('alGetBooleanv', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 0xC000 /* AL_DOPPLER_FACTOR */:
      case 0xC003 /* AL_SPEED_OF_SOUND */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        HEAP8[((pValues)>>0)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetBooleanv"] = _alGetBooleanv;

  function _alDistanceModel(model) {
      AL.setGlobalParam('alDistanceModel', 0xD000 /* AL_DISTANCE_MODEL */, model);
    }
  Module["_alDistanceModel"] = _alDistanceModel;

  function _alSpeedOfSound(value) {
      AL.setGlobalParam('alSpeedOfSound', 0xC003 /* AL_SPEED_OF_SOUND */, value);
    }
  Module["_alSpeedOfSound"] = _alSpeedOfSound;

  function _alDopplerFactor(value) {
      AL.setGlobalParam('alDopplerFactor', 0xC000 /* AL_DOPPLER_FACTOR */, value);
    }
  Module["_alDopplerFactor"] = _alDopplerFactor;

  function _alDopplerVelocity(value) {
      warnOnce('alDopplerVelocity() is deprecated, and only kept for compatibility with OpenAL 1.0. Use alSpeedOfSound() instead.');
      if (!AL.currentCtx) {
        return;
      }
      if (value <= 0) { // Negative or zero values are disallowed
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
    }
  Module["_alDopplerVelocity"] = _alDopplerVelocity;

  function _alGetListenerf(param, pValue) {
      var val = AL.getListenerParam('alGetListenerf', param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x100A /* AL_GAIN */:
        HEAPF32[((pValue)>>2)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetListenerf"] = _alGetListenerf;

  function _alGetListener3f(param, pValue0, pValue1, pValue2) {
      var val = AL.getListenerParam('alGetListener3f', param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAPF32[((pValue0)>>2)]=val[0];
        HEAPF32[((pValue1)>>2)]=val[1];
        HEAPF32[((pValue2)>>2)]=val[2];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetListener3f"] = _alGetListener3f;

  function _alGetListenerfv(param, pValues) {
      var val = AL.getListenerParam('alGetListenerfv', param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAPF32[((pValues)>>2)]=val[0];
        HEAPF32[(((pValues)+(4))>>2)]=val[1];
        HEAPF32[(((pValues)+(8))>>2)]=val[2];
        break;
      case 0x100F /* AL_ORIENTATION */:
        HEAPF32[((pValues)>>2)]=val[0];
        HEAPF32[(((pValues)+(4))>>2)]=val[1];
        HEAPF32[(((pValues)+(8))>>2)]=val[2];
        HEAPF32[(((pValues)+(12))>>2)]=val[3];
        HEAPF32[(((pValues)+(16))>>2)]=val[4];
        HEAPF32[(((pValues)+(20))>>2)]=val[5];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetListenerfv"] = _alGetListenerfv;

  function _alGetListeneri(param, pValue) {
      var val = AL.getListenerParam('alGetListeneri', param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
    }
  Module["_alGetListeneri"] = _alGetListeneri;

  function _alGetListener3i(param, pValue0, pValue1, pValue2) {
      var val = AL.getListenerParam('alGetListener3i', param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAP32[((pValue0)>>2)]=val[0];
        HEAP32[((pValue1)>>2)]=val[1];
        HEAP32[((pValue2)>>2)]=val[2];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetListener3i"] = _alGetListener3i;

  function _alGetListeneriv(param, pValues) {
      var val = AL.getListenerParam('alGetListeneriv', param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAP32[((pValues)>>2)]=val[0];
        HEAP32[(((pValues)+(4))>>2)]=val[1];
        HEAP32[(((pValues)+(8))>>2)]=val[2];
        break;
      case 0x100F /* AL_ORIENTATION */:
        HEAP32[((pValues)>>2)]=val[0];
        HEAP32[(((pValues)+(4))>>2)]=val[1];
        HEAP32[(((pValues)+(8))>>2)]=val[2];
        HEAP32[(((pValues)+(12))>>2)]=val[3];
        HEAP32[(((pValues)+(16))>>2)]=val[4];
        HEAP32[(((pValues)+(20))>>2)]=val[5];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetListeneriv"] = _alGetListeneriv;

  function _alListenerf(param, value) {
      switch (param) {
      case 0x100A /* AL_GAIN */:
        AL.setListenerParam('alListenerf', param, value);
        break;
      default:
        AL.setListenerParam('alListenerf', param, null);
        break;
      }
    }
  Module["_alListenerf"] = _alListenerf;

  function _alListener3f(param, value0, value1, value2) {
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setListenerParam('alListener3f', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListener3f', param, null);
        break;
      }
    }
  Module["_alListener3f"] = _alListener3f;

  function _alListenerfv(param, pValues) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = HEAPF32[((pValues)>>2)];
        AL.paramArray[1] = HEAPF32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAPF32[(((pValues)+(8))>>2)];
        AL.setListenerParam('alListenerfv', param, AL.paramArray);
        break;
      case 0x100F /* AL_ORIENTATION */:
        AL.paramArray[0] = HEAPF32[((pValues)>>2)];
        AL.paramArray[1] = HEAPF32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAPF32[(((pValues)+(8))>>2)];
        AL.paramArray[3] = HEAPF32[(((pValues)+(12))>>2)];
        AL.paramArray[4] = HEAPF32[(((pValues)+(16))>>2)];
        AL.paramArray[5] = HEAPF32[(((pValues)+(20))>>2)];
        AL.setListenerParam('alListenerfv', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListenerfv', param, null);
        break;
      }
    }
  Module["_alListenerfv"] = _alListenerfv;

  function _alListeneri(param, value) {
      AL.setListenerParam('alListeneri', param, null);
    }
  Module["_alListeneri"] = _alListeneri;

  function _alListener3i(param, value0, value1, value2) {
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setListenerParam('alListener3i', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListener3i', param, null);
        break;
      }
    }
  Module["_alListener3i"] = _alListener3i;

  function _alListeneriv(param, pValues) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAP32[(((pValues)+(8))>>2)];
        AL.setListenerParam('alListeneriv', param, AL.paramArray);
        break;
      case 0x100F /* AL_ORIENTATION */:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAP32[(((pValues)+(8))>>2)];
        AL.paramArray[3] = HEAP32[(((pValues)+(12))>>2)];
        AL.paramArray[4] = HEAP32[(((pValues)+(16))>>2)];
        AL.paramArray[5] = HEAP32[(((pValues)+(20))>>2)];
        AL.setListenerParam('alListeneriv', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListeneriv', param, null);
        break;
      }
    }
  Module["_alListeneriv"] = _alListeneriv;

  function _alIsBuffer(bufferId) {
      if (!AL.currentCtx) {
        return false;
      }
      if (bufferId > AL.buffers.length) {
        return false;
      }
  
      if (!AL.buffers[bufferId]) {
        return false;
      } else {
        return true;
      }
    }
  Module["_alIsBuffer"] = _alIsBuffer;

  function _alBufferData(bufferId, format, pData, size, freq) {
      if (!AL.currentCtx) {
        return;
      }
      var buf = AL.buffers[bufferId];
      if (!buf) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
      if (freq <= 0) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      var audioBuf = null;
      try {
        switch (format) {
        case 0x1100 /* AL_FORMAT_MONO8 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size, freq);
            var channel0 = audioBuf.getChannelData(0);
            for (var i = 0; i < size; ++i) {
              channel0[i] = HEAPU8[pData++] * 0.0078125 /* 1/128 */ - 1.0;
            }
          }
          buf.bytesPerSample = 1;
          buf.channels = 1;
          buf.length = size;
          break;
        case 0x1101 /* AL_FORMAT_MONO16 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 1, freq);
            var channel0 = audioBuf.getChannelData(0);
            pData >>= 1;
            for (var i = 0; i < size >> 1; ++i) {
              channel0[i] = HEAP16[pData++] * 0.000030517578125 /* 1/32768 */;
            }
          }
          buf.bytesPerSample = 2;
          buf.channels = 1;
          buf.length = size >> 1;
          break;
        case 0x1102 /* AL_FORMAT_STEREO8 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 1, freq);
            var channel0 = audioBuf.getChannelData(0);
            var channel1 = audioBuf.getChannelData(1);
            for (var i = 0; i < size >> 1; ++i) {
              channel0[i] = HEAPU8[pData++] * 0.0078125 /* 1/128 */ - 1.0;
              channel1[i] = HEAPU8[pData++] * 0.0078125 /* 1/128 */ - 1.0;
            }
          }
          buf.bytesPerSample = 1;
          buf.channels = 2;
          buf.length = size >> 1;
          break;
        case 0x1103 /* AL_FORMAT_STEREO16 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 2, freq);
            var channel0 = audioBuf.getChannelData(0);
            var channel1 = audioBuf.getChannelData(1);
            pData >>= 1;
            for (var i = 0; i < size >> 2; ++i) {
              channel0[i] = HEAP16[pData++] * 0.000030517578125 /* 1/32768 */;
              channel1[i] = HEAP16[pData++] * 0.000030517578125 /* 1/32768 */;
            }
          }
          buf.bytesPerSample = 2;
          buf.channels = 2;
          buf.length = size >> 2;
          break;
        case 0x10010 /* AL_FORMAT_MONO_FLOAT32 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 2, freq);
            var channel0 = audioBuf.getChannelData(0);
            pData >>= 2;
            for (var i = 0; i < size >> 2; ++i) {
              channel0[i] = HEAPF32[pData++];
            }
          }
          buf.bytesPerSample = 4;
          buf.channels = 1;
          buf.length = size >> 2;
          break;
        case 0x10011 /* AL_FORMAT_STEREO_FLOAT32 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 3, freq);
            var channel0 = audioBuf.getChannelData(0);
            var channel1 = audioBuf.getChannelData(1);
            pData >>= 2;
            for (var i = 0; i < size >> 3; ++i) {
              channel0[i] = HEAPF32[pData++];
              channel1[i] = HEAPF32[pData++];
            }
          }
          buf.bytesPerSample = 4;
          buf.channels = 2;
          buf.length = size >> 3;
          break;
        default:
          AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
          return;
        }
        buf.frequency = freq;
        buf.audioBuf = audioBuf;
      } catch (e) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
    }
  Module["_alBufferData"] = _alBufferData;

  function _alGetBufferf(bufferId, param, pValue) {
      var val = AL.getBufferParam('alGetBufferf', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
    }
  Module["_alGetBufferf"] = _alGetBufferf;

  function _alGetBuffer3f(bufferId, param, pValue0, pValue1, pValue2) {
      var val = AL.getBufferParam('alGetBuffer3f', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
    }
  Module["_alGetBuffer3f"] = _alGetBuffer3f;

  function _alGetBufferfv(bufferId, param, pValues) {
      var val = AL.getBufferParam('alGetBufferfv', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
    }
  Module["_alGetBufferfv"] = _alGetBufferfv;

  function _alGetBufferi(bufferId, param, pValue) {
      var val = AL.getBufferParam('alGetBufferi', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x2001 /* AL_FREQUENCY */:
      case 0x2002 /* AL_BITS */:
      case 0x2003 /* AL_CHANNELS */:
      case 0x2004 /* AL_SIZE */:
        HEAP32[((pValue)>>2)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetBufferi"] = _alGetBufferi;

  function _alGetBuffer3i(bufferId, param, pValue0, pValue1, pValue2) {
      var val = AL.getBufferParam('alGetBuffer3i', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
    }
  Module["_alGetBuffer3i"] = _alGetBuffer3i;

  function _alGetBufferiv(bufferId, param, pValues) {
      var val = AL.getBufferParam('alGetBufferiv', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x2001 /* AL_FREQUENCY */:
      case 0x2002 /* AL_BITS */:
      case 0x2003 /* AL_CHANNELS */:
      case 0x2004 /* AL_SIZE */:
        HEAP32[((pValues)>>2)]=val;
        break;
      case 0x2015 /* AL_LOOP_POINTS_SOFT */:
        HEAP32[((pValues)>>2)]=val[0];
        HEAP32[(((pValues)+(4))>>2)]=val[1];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetBufferiv"] = _alGetBufferiv;

  function _alBufferf(bufferId, param, value) {
      AL.setBufferParam('alBufferf', bufferId, param, null);
    }
  Module["_alBufferf"] = _alBufferf;

  function _alBuffer3f(bufferId, param, value0, value1, value2) {
      AL.setBufferParam('alBuffer3f', bufferId, param, null);
    }
  Module["_alBuffer3f"] = _alBuffer3f;

  function _alBufferfv(bufferId, param, pValues) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      AL.setBufferParam('alBufferfv', bufferId, param, null);
    }
  Module["_alBufferfv"] = _alBufferfv;

  function _alBufferi(bufferId, param, value) {
      AL.setBufferParam('alBufferi', bufferId, param, null);
    }
  Module["_alBufferi"] = _alBufferi;

  function _alBuffer3i(bufferId, param, value0, value1, value2) {
      AL.setBufferParam('alBuffer3i', bufferId, param, null);
    }
  Module["_alBuffer3i"] = _alBuffer3i;

  function _alBufferiv(bufferId, param, pValues) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x2015 /* AL_LOOP_POINTS_SOFT */:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.setBufferParam('alBufferiv', bufferId, param, AL.paramArray);
        break;
      default:
        AL.setBufferParam('alBufferiv', bufferId, param, null);
        break;
      }
    }
  Module["_alBufferiv"] = _alBufferiv;

  function _alIsSource(sourceId) {
      if (!AL.currentCtx) {
        return false;
      }
  
      if (!AL.currentCtx.sources[sourceId]) {
        return false;
      } else {
        return true;
      }
    }
  Module["_alIsSource"] = _alIsSource;

  function _alSourceQueueBuffers(sourceId, count, pBufferIds) {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
        return;
      }
      if (src.type === 0x1028 /* AL_STATIC */) {
        AL.currentCtx.err = 0xA004 /* AL_INVALID_OPERATION */;
        return;
      }
  
      if (count === 0) {
        return;
      }
  
      // Find the first non-zero buffer in the queue to determine the proper format
      var templateBuf = AL.buffers[0];
      for (var i = 0; i < src.bufQueue.length; i++) {
        if (src.bufQueue[i].id !== 0) {
          templateBuf = src.bufQueue[i];
          break;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        var buf = AL.buffers[bufId];
        if (!buf) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
  
        // Check that the added buffer has the correct format. If the template is the zero buffer, any format is valid.
        if (templateBuf.id !== 0 && (
          buf.frequency !== templateBuf.frequency
          || buf.bytesPerSample !== templateBuf.bytesPerSample
          || buf.channels !== templateBuf.channels)
        ) {
          AL.currentCtx.err = 0xA004 /* AL_INVALID_OPERATION */;
        }
      }
  
      // If the only buffer in the queue is the zero buffer, clear the queue before we add anything.
      if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
        src.bufQueue.length = 0;
      }
  
      src.type = 0x1029 /* AL_STREAMING */;
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        var buf = AL.buffers[bufId];
        buf.refCount++;
        src.bufQueue.push(buf);
      }
  
      // if the source is looping, cancel the schedule so we can reschedule the loop order
      if (src.looping) {
        AL.cancelPendingSourceAudio(src);
      }
  
      AL.initSourcePanner(src);
      AL.scheduleSourceAudio(src);
    }
  Module["_alSourceQueueBuffers"] = _alSourceQueueBuffers;

  function _alSourceUnqueueBuffers(sourceId, count, pBufferIds) {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
        return;
      }
      if (count > (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 ? 0 : src.bufsProcessed)) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      if (count === 0) {
        return;
      }
  
      for (var i = 0; i < count; i++) {
        var buf = src.bufQueue.shift();
        buf.refCount--;
        // Write the buffers index out to the return list.
        HEAP32[(((pBufferIds)+(i*4))>>2)]=buf.id;
        src.bufsProcessed--;
      }
  
      /// If the queue is empty, put the zero buffer back in
      if (src.bufQueue.length === 0) {
        src.bufQueue.push(AL.buffers[0]);
      }
  
      AL.initSourcePanner(src);
      AL.scheduleSourceAudio(src);
    }
  Module["_alSourceUnqueueBuffers"] = _alSourceUnqueueBuffers;

  function _alSourcePlay(sourceId) {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
        return;
      }
      AL.setSourceState(src, 0x1012 /* AL_PLAYING */);
    }
  Module["_alSourcePlay"] = _alSourcePlay;

  function _alSourcePlayv(count, pSourceIds) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        AL.setSourceState(HEAP32[(((pSourceIds)+(i*4))>>2)], 0x1012 /* AL_PLAYING */);
      }
    }
  Module["_alSourcePlayv"] = _alSourcePlayv;

  function _alSourceStop(sourceId) {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
        return;
      }
      AL.setSourceState(src, 0x1014 /* AL_STOPPED */);
    }
  Module["_alSourceStop"] = _alSourceStop;

  function _alSourceStopv(count, pSourceIds) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        AL.setSourceState(HEAP32[(((pSourceIds)+(i*4))>>2)], 0x1014 /* AL_STOPPED */);
      }
    }
  Module["_alSourceStopv"] = _alSourceStopv;

  function _alSourceRewind(sourceId) {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
        return;
      }
      // Stop the source first to clear the source queue
      AL.setSourceState(src, 0x1014 /* AL_STOPPED */);
      // Now set the state of AL_INITIAL according to the specification
      AL.setSourceState(src, 0x1011 /* AL_INITIAL */);
    }
  Module["_alSourceRewind"] = _alSourceRewind;

  function _alSourceRewindv(count, pSourceIds) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        AL.setSourceState(HEAP32[(((pSourceIds)+(i*4))>>2)], 0x1011 /* AL_INITIAL */);
      }
    }
  Module["_alSourceRewindv"] = _alSourceRewindv;

  function _alSourcePause(sourceId) {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
        return;
      }
      AL.setSourceState(src, 0x1013 /* AL_PAUSED */);
    }
  Module["_alSourcePause"] = _alSourcePause;

  function _alSourcePausev(count, pSourceIds) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 0xA001 /* AL_INVALID_NAME */;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        AL.setSourceState(HEAP32[(((pSourceIds)+(i*4))>>2)], 0x1013 /* AL_PAUSED */);
      }
    }
  Module["_alSourcePausev"] = _alSourcePausev;

  function _alGetSourcef(sourceId, param, pValue) {
      var val = AL.getSourceParam('alGetSourcef', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 0x100A /* AL_GAIN */:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        HEAPF32[((pValue)>>2)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetSourcef"] = _alGetSourcef;

  function _alGetSource3f(sourceId, param, pValue0, pValue1, pValue2) {
      var val = AL.getSourceParam('alGetSource3f', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAPF32[((pValue0)>>2)]=val[0];
        HEAPF32[((pValue1)>>2)]=val[1];
        HEAPF32[((pValue2)>>2)]=val[2];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetSource3f"] = _alGetSource3f;

  function _alGetSourcefv(sourceId, param, pValues) {
      var val = AL.getSourceParam('alGetSourcefv', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 0x100A /* AL_GAIN */:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        HEAPF32[((pValues)>>2)]=val[0];
        break;
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAPF32[((pValues)>>2)]=val[0];
        HEAPF32[(((pValues)+(4))>>2)]=val[1];
        HEAPF32[(((pValues)+(8))>>2)]=val[2];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetSourcefv"] = _alGetSourcefv;

  function _alGetSourcei(sourceId, param, pValue) {
      var val = AL.getSourceParam('alGetSourcei', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1010 /* AL_SOURCE_STATE */:
      case 0x1015 /* AL_BUFFERS_QUEUED */:
      case 0x1016 /* AL_BUFFERS_PROCESSED */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1027 /* AL_SOURCE_TYPE */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */: 
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        HEAP32[((pValue)>>2)]=val;
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetSourcei"] = _alGetSourcei;

  function _alGetSource3i(source, param, pValue0, pValue1, pValue2) {
      var val = AL.getSourceParam('alGetSource3i', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAP32[((pValue0)>>2)]=val[0];
        HEAP32[((pValue1)>>2)]=val[1];
        HEAP32[((pValue2)>>2)]=val[2];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetSource3i"] = _alGetSource3i;

  function _alGetSourceiv(sourceId, param, pValues) {
      var val = AL.getSourceParam('alGetSourceiv', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1010 /* AL_SOURCE_STATE */:
      case 0x1015 /* AL_BUFFERS_QUEUED */:
      case 0x1016 /* AL_BUFFERS_PROCESSED */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1027 /* AL_SOURCE_TYPE */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */: 
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        HEAP32[((pValues)>>2)]=val;
        break;
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        HEAP32[((pValues)>>2)]=val[0];
        HEAP32[(((pValues)+(4))>>2)]=val[1];
        HEAP32[(((pValues)+(8))>>2)]=val[2];
        break;
      default:
        AL.currentCtx.err = 0xA002 /* AL_INVALID_ENUM */;
        return;
      }
    }
  Module["_alGetSourceiv"] = _alGetSourceiv;

  function _alSourcef(sourceId, param, value) {
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 0x100A /* AL_GAIN */:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        AL.setSourceParam('alSourcef', sourceId, param, value);
        break;
      default:
        AL.setSourceParam('alSourcef', sourceId, param, null);
        break;
      }
    }
  Module["_alSourcef"] = _alSourcef;

  function _alSource3f(sourceId, param, value0, value1, value2) {
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setSourceParam('alSource3f', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSource3f', sourceId, param, null);
        break;
      }
    }
  Module["_alSource3f"] = _alSource3f;

  function _alSourcefv(sourceId, param, pValues) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 0x100A /* AL_GAIN */:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        var val = HEAPF32[((pValues)>>2)];
        AL.setSourceParam('alSourcefv', sourceId, param, val);
        break;
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = HEAPF32[((pValues)>>2)];
        AL.paramArray[1] = HEAPF32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAPF32[(((pValues)+(8))>>2)];
        AL.setSourceParam('alSourcefv', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSourcefv', sourceId, param, null);
        break;
      }
    }
  Module["_alSourcefv"] = _alSourcefv;


  function _alSource3i(sourceId, param, value0, value1, value2) {
      switch (param) {
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setSourceParam('alSource3i', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSource3i', sourceId, param, null);
        break;
      }
    }
  Module["_alSource3i"] = _alSource3i;

  function _alSourceiv(source, param, pValues) {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 0xA003 /* AL_INVALID_VALUE */;
        return;
      }
  
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */: 
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 0xD000 /* AL_DISTANCE_MODEL */:
        var val = HEAP32[((pValues)>>2)];
        AL.setSourceParam('alSourceiv', sourceId, param, val);
        break;
      case 0x1004 /* AL_POSITION */:
      case 0x1005 /* AL_DIRECTION */:
      case 0x1006 /* AL_VELOCITY */:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAP32[(((pValues)+(8))>>2)];
        AL.setSourceParam('alSourceiv', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSourceiv', sourceId, param, null);
        break;
      }
    }
  Module["_alSourceiv"] = _alSourceiv;

  
  
  /** @suppress{missingProperties} */
  function SDL_ttfContext() { return SDL.ttfContext}
  Module["SDL_ttfContext"] = SDL_ttfContext;
  
  /** @suppress{missingProperties} */
  function SDL_audio() { return SDL.audio}
  Module["SDL_audio"] = SDL_audio;var SDL={defaults:{width:320,height:200,copyOnLock:true,discardOnLock:false,opaqueFrontBuffer:true},version:null,surfaces:{},canvasPool:[],events:[],fonts:[null],audios:[null],rwops:[null],music:{audio:null,volume:1},mixerFrequency:22050,mixerFormat:32784,mixerNumChannels:2,mixerChunkSize:1024,channelMinimumNumber:0,GL:false,glAttributes:{0:3,1:3,2:2,3:0,4:0,5:1,6:16,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0,15:1,16:0,17:0,18:0},keyboardState:null,keyboardMap:{},canRequestFullscreen:false,isRequestingFullscreen:false,textInput:false,startTime:null,initFlags:0,buttonState:0,modState:0,DOMButtons:[0,0,0],DOMEventToSDLEvent:{},TOUCH_DEFAULT_ID:0,eventHandler:null,eventHandlerContext:null,eventHandlerTemp:0,keyCodes:{16:1249,17:1248,18:1250,20:1081,33:1099,34:1102,35:1101,36:1098,37:1104,38:1106,39:1103,40:1105,44:316,45:1097,46:127,91:1251,93:1125,96:1122,97:1113,98:1114,99:1115,100:1116,101:1117,102:1118,103:1119,104:1120,105:1121,106:1109,107:1111,109:1110,110:1123,111:1108,112:1082,113:1083,114:1084,115:1085,116:1086,117:1087,118:1088,119:1089,120:1090,121:1091,122:1092,123:1093,124:1128,125:1129,126:1130,127:1131,128:1132,129:1133,130:1134,131:1135,132:1136,133:1137,134:1138,135:1139,144:1107,160:94,161:33,162:34,163:35,164:36,165:37,166:38,167:95,168:40,169:41,170:42,171:43,172:124,173:45,174:123,175:125,176:126,181:127,182:129,183:128,188:44,190:46,191:47,192:96,219:91,220:92,221:93,222:39,224:1251},scanCodes:{8:42,9:43,13:40,27:41,32:44,35:204,39:53,44:54,46:55,47:56,48:39,49:30,50:31,51:32,52:33,53:34,54:35,55:36,56:37,57:38,58:203,59:51,61:46,91:47,92:49,93:48,96:52,97:4,98:5,99:6,100:7,101:8,102:9,103:10,104:11,105:12,106:13,107:14,108:15,109:16,110:17,111:18,112:19,113:20,114:21,115:22,116:23,117:24,118:25,119:26,120:27,121:28,122:29,127:76,305:224,308:226,316:70},loadRect:function(rect) {
        return {
          x: HEAP32[((rect + 0)>>2)],
          y: HEAP32[((rect + 4)>>2)],
          w: HEAP32[((rect + 8)>>2)],
          h: HEAP32[((rect + 12)>>2)]
        };
      },updateRect:function(rect, r) {
        HEAP32[((rect)>>2)]=r.x;
        HEAP32[(((rect)+(4))>>2)]=r.y;
        HEAP32[(((rect)+(8))>>2)]=r.w;
        HEAP32[(((rect)+(12))>>2)]=r.h;
      },intersectionOfRects:function(first, second) {
        var leftX = Math.max(first.x, second.x);
        var leftY = Math.max(first.y, second.y);
        var rightX = Math.min(first.x + first.w, second.x + second.w);
        var rightY = Math.min(first.y + first.h, second.y + second.h);
  
        return {
          x: leftX,
          y: leftY,
          w: Math.max(leftX, rightX) - leftX,
          h: Math.max(leftY, rightY) - leftY
        }
      },checkPixelFormat:function(fmt) {
        // Canvas screens are always RGBA.
        var format = HEAP32[((fmt)>>2)];
        if (format != -2042224636) {
          warnOnce('Unsupported pixel format!');
        }
      },loadColorToCSSRGB:function(color) {
        var rgba = HEAP32[((color)>>2)];
        return 'rgb(' + (rgba&255) + ',' + ((rgba >> 8)&255) + ',' + ((rgba >> 16)&255) + ')';
      },loadColorToCSSRGBA:function(color) {
        var rgba = HEAP32[((color)>>2)];
        return 'rgba(' + (rgba&255) + ',' + ((rgba >> 8)&255) + ',' + ((rgba >> 16)&255) + ',' + (((rgba >> 24)&255)/255) + ')';
      },translateColorToCSSRGBA:function(rgba) {
        return 'rgba(' + (rgba&0xff) + ',' + (rgba>>8 & 0xff) + ',' + (rgba>>16 & 0xff) + ',' + (rgba>>>24)/0xff + ')';
      },translateRGBAToCSSRGBA:function(r, g, b, a) {
        return 'rgba(' + (r&0xff) + ',' + (g&0xff) + ',' + (b&0xff) + ',' + (a&0xff)/255 + ')';
      },translateRGBAToColor:function(r, g, b, a) {
        return r | g << 8 | b << 16 | a << 24;
      },makeSurface:function(width, height, flags, usePageCanvas, source, rmask, gmask, bmask, amask) {
        flags = flags || 0;
        var is_SDL_HWSURFACE = flags & 0x00000001;
        var is_SDL_HWPALETTE = flags & 0x00200000;
        var is_SDL_OPENGL = flags & 0x04000000;
  
        var surf = _malloc(60);
        var pixelFormat = _malloc(44);
        //surface with SDL_HWPALETTE flag is 8bpp surface (1 byte)
        var bpp = is_SDL_HWPALETTE ? 1 : 4;
        var buffer = 0;
  
        // preemptively initialize this for software surfaces,
        // otherwise it will be lazily initialized inside of SDL_LockSurface
        if (!is_SDL_HWSURFACE && !is_SDL_OPENGL) {
          buffer = _malloc(width * height * 4);
        }
  
        HEAP32[((surf)>>2)]=flags;
        HEAP32[(((surf)+(4))>>2)]=pixelFormat;
        HEAP32[(((surf)+(8))>>2)]=width;
        HEAP32[(((surf)+(12))>>2)]=height;
        HEAP32[(((surf)+(16))>>2)]=width * bpp;  // assuming RGBA or indexed for now,
                                                                                          // since that is what ImageData gives us in browsers
        HEAP32[(((surf)+(20))>>2)]=buffer;
  
        HEAP32[(((surf)+(36))>>2)]=0;
        HEAP32[(((surf)+(40))>>2)]=0;
        HEAP32[(((surf)+(44))>>2)]=Module["canvas"].width;
        HEAP32[(((surf)+(48))>>2)]=Module["canvas"].height;
  
        HEAP32[(((surf)+(56))>>2)]=1;
  
        HEAP32[((pixelFormat)>>2)]=-2042224636;
        HEAP32[(((pixelFormat)+(4))>>2)]=0;// TODO
        HEAP8[(((pixelFormat)+(8))>>0)]=bpp * 8;
        HEAP8[(((pixelFormat)+(9))>>0)]=bpp;
  
        HEAP32[(((pixelFormat)+(12))>>2)]=rmask || 0x000000ff;
        HEAP32[(((pixelFormat)+(16))>>2)]=gmask || 0x0000ff00;
        HEAP32[(((pixelFormat)+(20))>>2)]=bmask || 0x00ff0000;
        HEAP32[(((pixelFormat)+(24))>>2)]=amask || 0xff000000;
  
        // Decide if we want to use WebGL or not
        SDL.GL = SDL.GL || is_SDL_OPENGL;
        var canvas;
        if (!usePageCanvas) {
          if (SDL.canvasPool.length > 0) {
            canvas = SDL.canvasPool.pop();
          } else {
            canvas = document.createElement('canvas');
          }
          canvas.width = width;
          canvas.height = height;
        } else {
          canvas = Module['canvas'];
        }
  
        var webGLContextAttributes = {
          antialias: ((SDL.glAttributes[13 /*SDL_GL_MULTISAMPLEBUFFERS*/] != 0) && (SDL.glAttributes[14 /*SDL_GL_MULTISAMPLESAMPLES*/] > 1)),
          depth: (SDL.glAttributes[6 /*SDL_GL_DEPTH_SIZE*/] > 0),
          stencil: (SDL.glAttributes[7 /*SDL_GL_STENCIL_SIZE*/] > 0),
          alpha: (SDL.glAttributes[3 /*SDL_GL_ALPHA_SIZE*/] > 0)
        };
  
        var ctx = Browser.createContext(canvas, is_SDL_OPENGL, usePageCanvas, webGLContextAttributes);
  
        SDL.surfaces[surf] = {
          width: width,
          height: height,
          canvas: canvas,
          ctx: ctx,
          surf: surf,
          buffer: buffer,
          pixelFormat: pixelFormat,
          alpha: 255,
          flags: flags,
          locked: 0,
          usePageCanvas: usePageCanvas,
          source: source,
  
          isFlagSet: function(flag) {
            return flags & flag;
          }
        };
  
        return surf;
      },copyIndexedColorData:function(surfData, rX, rY, rW, rH) {
        // HWPALETTE works with palette
        // setted by SDL_SetColors
        if (!surfData.colors) {
          return;
        }
  
        var fullWidth  = Module['canvas'].width;
        var fullHeight = Module['canvas'].height;
  
        var startX  = rX || 0;
        var startY  = rY || 0;
        var endX    = (rW || (fullWidth - startX)) + startX;
        var endY    = (rH || (fullHeight - startY)) + startY;
  
        var buffer  = surfData.buffer;
  
        if (!surfData.image.data32) {
          surfData.image.data32 = new Uint32Array(surfData.image.data.buffer);
        }
        var data32   = surfData.image.data32;
  
        var colors32 = surfData.colors32;
  
        for (var y = startY; y < endY; ++y) {
          var base = y * fullWidth;
          for (var x = startX; x < endX; ++x) {
            data32[base + x] = colors32[HEAPU8[((buffer + base + x)>>0)]];
          }
        }
      },freeSurface:function(surf) {
        var refcountPointer = surf + 56;
        var refcount = HEAP32[((refcountPointer)>>2)];
        if (refcount > 1) {
          HEAP32[((refcountPointer)>>2)]=refcount - 1;
          return;
        }
  
        var info = SDL.surfaces[surf];
        if (!info.usePageCanvas && info.canvas) SDL.canvasPool.push(info.canvas);
        if (info.buffer) _free(info.buffer);
        _free(info.pixelFormat);
        _free(surf);
        SDL.surfaces[surf] = null;
  
        if (surf === SDL.screen) {
          SDL.screen = null;
        }
      },blitSurface:function(src, srcrect, dst, dstrect, scale) {
        var srcData = SDL.surfaces[src];
        var dstData = SDL.surfaces[dst];
        var sr, dr;
        if (srcrect) {
          sr = SDL.loadRect(srcrect);
        } else {
          sr = { x: 0, y: 0, w: srcData.width, h: srcData.height };
        }
        if (dstrect) {
          dr = SDL.loadRect(dstrect);
        } else {
          dr = { x: 0, y: 0, w: srcData.width, h: srcData.height };
        }
        if (dstData.clipRect) {
          var widthScale = (!scale || sr.w === 0) ? 1 : sr.w / dr.w;
          var heightScale = (!scale || sr.h === 0) ? 1 : sr.h / dr.h;
  
          dr = SDL.intersectionOfRects(dstData.clipRect, dr);
  
          sr.w = dr.w * widthScale;
          sr.h = dr.h * heightScale;
  
          if (dstrect) {
            SDL.updateRect(dstrect, dr);
          }
        }
        var blitw, blith;
        if (scale) {
          blitw = dr.w; blith = dr.h;
        } else {
          blitw = sr.w; blith = sr.h;
        }
        if (sr.w === 0 || sr.h === 0 || blitw === 0 || blith === 0) {
          return 0;
        }
        var oldAlpha = dstData.ctx.globalAlpha;
        dstData.ctx.globalAlpha = srcData.alpha/255;
        dstData.ctx.drawImage(srcData.canvas, sr.x, sr.y, sr.w, sr.h, dr.x, dr.y, blitw, blith);
        dstData.ctx.globalAlpha = oldAlpha;
        if (dst != SDL.screen) {
          // XXX As in IMG_Load, for compatibility we write out |pixels|
          warnOnce('WARNING: copying canvas data to memory for compatibility');
          _SDL_LockSurface(dst);
          dstData.locked--; // The surface is not actually locked in this hack
        }
        return 0;
      },downFingers:{},savedKeydown:null,receiveEvent:function(event) {
        function unpressAllPressedKeys() {
          // Un-press all pressed keys: TODO
          for (var code in SDL.keyboardMap) {
            SDL.events.push({
              type: 'keyup',
              keyCode: SDL.keyboardMap[code]
            });
          }
        };
        switch(event.type) {
          case 'touchstart': case 'touchmove': {
            event.preventDefault();
  
            var touches = [];
  
            // Clear out any touchstart events that we've already processed
            if (event.type === 'touchstart') {
              for (var i = 0; i < event.touches.length; i++) {
                var touch = event.touches[i];
                if (SDL.downFingers[touch.identifier] != true) {
                  SDL.downFingers[touch.identifier] = true;
                  touches.push(touch);
                }
              }
            } else {
              touches = event.touches;
            }
  
            var firstTouch = touches[0];
            if (firstTouch) {
              if (event.type == 'touchstart') {
                SDL.DOMButtons[0] = 1;
              }
              var mouseEventType;
              switch(event.type) {
                case 'touchstart': mouseEventType = 'mousedown'; break;
                case 'touchmove': mouseEventType = 'mousemove'; break;
              }
              var mouseEvent = {
                type: mouseEventType,
                button: 0,
                pageX: firstTouch.clientX,
                pageY: firstTouch.clientY
              };
              SDL.events.push(mouseEvent);
            }
  
            for (var i = 0; i < touches.length; i++) {
              var touch = touches[i];
              SDL.events.push({
                type: event.type,
                touch: touch
              });
            };
            break;
          }
          case 'touchend': {
            event.preventDefault();
  
            // Remove the entry in the SDL.downFingers hash
            // because the finger is no longer down.
            for(var i = 0; i < event.changedTouches.length; i++) {
              var touch = event.changedTouches[i];
              if (SDL.downFingers[touch.identifier] === true) {
                delete SDL.downFingers[touch.identifier];
              }
            }
  
            var mouseEvent = {
              type: 'mouseup',
              button: 0,
              pageX: event.changedTouches[0].clientX,
              pageY: event.changedTouches[0].clientY
            };
            SDL.DOMButtons[0] = 0;
            SDL.events.push(mouseEvent);
  
            for (var i = 0; i < event.changedTouches.length; i++) {
              var touch = event.changedTouches[i];
              SDL.events.push({
                type: 'touchend',
                touch: touch
              });
            };
            break;
          }
          case 'DOMMouseScroll': case 'mousewheel': case 'wheel':
            var delta = -Browser.getMouseWheelDelta(event); // Flip the wheel direction to translate from browser wheel direction (+:down) to SDL direction (+:up)
            delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1)); // Quantize to integer so that minimum scroll is at least +/- 1.
  
            // Simulate old-style SDL events representing mouse wheel input as buttons
            var button = delta > 0 ? 3 /*SDL_BUTTON_WHEELUP-1*/ : 4 /*SDL_BUTTON_WHEELDOWN-1*/; // Subtract one since JS->C marshalling is defined to add one back.
            SDL.events.push({ type: 'mousedown', button: button, pageX: event.pageX, pageY: event.pageY });
            SDL.events.push({ type: 'mouseup', button: button, pageX: event.pageX, pageY: event.pageY });
  
            // Pass a delta motion event.
            SDL.events.push({ type: 'wheel', deltaX: 0, deltaY: delta });
            event.preventDefault(); // If we don't prevent this, then 'wheel' event will be sent again by the browser as 'DOMMouseScroll' and we will receive this same event the second time.
            break;
          case 'mousemove':
            if (SDL.DOMButtons[0] === 1) {
              SDL.events.push({
                type: 'touchmove',
                touch: {
                  identifier: 0,
                  deviceID: -1,
                  pageX: event.pageX,
                  pageY: event.pageY
                }
              });
            }
            if (Browser.pointerLock) {
              // workaround for firefox bug 750111
              if ('mozMovementX' in event) {
                event['movementX'] = event['mozMovementX'];
                event['movementY'] = event['mozMovementY'];
              }
              // workaround for Firefox bug 782777
              if (event['movementX'] == 0 && event['movementY'] == 0) {
                // ignore a mousemove event if it doesn't contain any movement info
                // (without pointer lock, we infer movement from pageX/pageY, so this check is unnecessary)
                event.preventDefault();
                return;
              }
            }
            // fall through
          case 'keydown': case 'keyup': case 'keypress': case 'mousedown': case 'mouseup':
            // If we preventDefault on keydown events, the subsequent keypress events
            // won't fire. However, it's fine (and in some cases necessary) to
            // preventDefault for keys that don't generate a character. Otherwise,
            // preventDefault is the right thing to do in general.
            if (event.type !== 'keydown' || (!SDL_unicode() && !SDL.textInput) || (event.keyCode === 8 /* backspace */ || event.keyCode === 9 /* tab */)) {
              event.preventDefault();
            }
  
            if (event.type == 'mousedown') {
              SDL.DOMButtons[event.button] = 1;
              SDL.events.push({
                type: 'touchstart',
                touch: {
                  identifier: 0,
                  deviceID: -1,
                  pageX: event.pageX,
                  pageY: event.pageY
                }
              });
            } else if (event.type == 'mouseup') {
              // ignore extra ups, can happen if we leave the canvas while pressing down, then return,
              // since we add a mouseup in that case
              if (!SDL.DOMButtons[event.button]) {
                return;
              }
  
              SDL.events.push({
                type: 'touchend',
                touch: {
                  identifier: 0,
                  deviceID: -1,
                  pageX: event.pageX,
                  pageY: event.pageY
                }
              });
              SDL.DOMButtons[event.button] = 0;
            }
  
            // We can only request fullscreen as the result of user input.
            // Due to this limitation, we toggle a boolean on keydown which
            // SDL_WM_ToggleFullScreen will check and subsequently set another
            // flag indicating for us to request fullscreen on the following
            // keyup. This isn't perfect, but it enables SDL_WM_ToggleFullScreen
            // to work as the result of a keypress (which is an extremely
            // common use case).
            if (event.type === 'keydown' || event.type === 'mousedown') {
              SDL.canRequestFullscreen = true;
            } else if (event.type === 'keyup' || event.type === 'mouseup') {
              if (SDL.isRequestingFullscreen) {
                Module['requestFullscreen'](/*lockPointer=*/true, /*resizeCanvas=*/true);
                SDL.isRequestingFullscreen = false;
              }
              SDL.canRequestFullscreen = false;
            }
  
            // SDL expects a unicode character to be passed to its keydown events.
            // Unfortunately, the browser APIs only provide a charCode property on
            // keypress events, so we must backfill in keydown events with their
            // subsequent keypress event's charCode.
            if (event.type === 'keypress' && SDL.savedKeydown) {
              // charCode is read-only
              SDL.savedKeydown.keypressCharCode = event.charCode;
              SDL.savedKeydown = null;
            } else if (event.type === 'keydown') {
              SDL.savedKeydown = event;
            }
  
            // Don't push keypress events unless SDL_StartTextInput has been called.
            if (event.type !== 'keypress' || SDL.textInput) {
              SDL.events.push(event);
            }
            break;
          case 'mouseout':
            // Un-press all pressed mouse buttons, because we might miss the release outside of the canvas
            for (var i = 0; i < 3; i++) {
              if (SDL.DOMButtons[i]) {
                SDL.events.push({
                  type: 'mouseup',
                  button: i,
                  pageX: event.pageX,
                  pageY: event.pageY
                });
                SDL.DOMButtons[i] = 0;
              }
            }
            event.preventDefault();
            break;
          case 'focus':
            SDL.events.push(event);
            event.preventDefault();
            break;
          case 'blur':
            SDL.events.push(event);
            unpressAllPressedKeys();
            event.preventDefault();
            break;
          case 'visibilitychange':
            SDL.events.push({
              type: 'visibilitychange',
              visible: !document.hidden
            });
            unpressAllPressedKeys();
            event.preventDefault();
            break;
          case 'unload':
            if (Browser.mainLoop.runner) {
              SDL.events.push(event);
              // Force-run a main event loop, since otherwise this event will never be caught!
              Browser.mainLoop.runner();
            }
            return;
          case 'resize':
            SDL.events.push(event);
            // manually triggered resize event doesn't have a preventDefault member
            if (event.preventDefault) {
              event.preventDefault();
            }
            break;
        }
        if (SDL.events.length >= 10000) {
          err('SDL event queue full, dropping events');
          SDL.events = SDL.events.slice(0, 10000);
        }
        // If we have a handler installed, this will push the events to the app
        // instead of the app polling for them.
        SDL.flushEventsToHandler();
        return;
      },lookupKeyCodeForEvent:function(event) {
          var code = event.keyCode;
          if (code >= 65 && code <= 90) {
            code += 32; // make lowercase for SDL
          } else {
            code = SDL.keyCodes[event.keyCode] || event.keyCode;
            // If this is one of the modifier keys (224 | 1<<10 - 227 | 1<<10), and the event specifies that it is
            // a right key, add 4 to get the right key SDL key code.
            if (event.location === 2 /*KeyboardEvent.DOM_KEY_LOCATION_RIGHT*/ && code >= (224 | 1<<10) && code <= (227 | 1<<10)) {
              code += 4;
            }
          }
          return code;
      },handleEvent:function(event) {
        if (event.handled) return;
        event.handled = true;
  
        switch (event.type) {
          case 'touchstart': case 'touchend': case 'touchmove': {
            Browser.calculateMouseEvent(event);
            break;
          }
          case 'keydown': case 'keyup': {
            var down = event.type === 'keydown';
            var code = SDL.lookupKeyCodeForEvent(event);
            // Assigning a boolean to HEAP8, that's alright but Closure would like to warn about it:
            /** @suppress{checkTypes} */
            HEAP8[(((SDL.keyboardState)+(code))>>0)]=down;
            // TODO: lmeta, rmeta, numlock, capslock, KMOD_MODE, KMOD_RESERVED
            SDL.modState = (HEAP8[(((SDL.keyboardState)+(1248))>>0)] ? 0x0040 : 0) | // KMOD_LCTRL
              (HEAP8[(((SDL.keyboardState)+(1249))>>0)] ? 0x0001 : 0) | // KMOD_LSHIFT
              (HEAP8[(((SDL.keyboardState)+(1250))>>0)] ? 0x0100 : 0) | // KMOD_LALT
              (HEAP8[(((SDL.keyboardState)+(1252))>>0)] ? 0x0080 : 0) | // KMOD_RCTRL
              (HEAP8[(((SDL.keyboardState)+(1253))>>0)] ? 0x0002 : 0) | // KMOD_RSHIFT
              (HEAP8[(((SDL.keyboardState)+(1254))>>0)] ? 0x0200 : 0); //  KMOD_RALT
            if (down) {
              SDL.keyboardMap[code] = event.keyCode; // save the DOM input, which we can use to unpress it during blur
            } else {
              delete SDL.keyboardMap[code];
            }
  
            break;
          }
          case 'mousedown': case 'mouseup':
            if (event.type == 'mousedown') {
              // SDL_BUTTON(x) is defined as (1 << ((x)-1)).  SDL buttons are 1-3,
              // and DOM buttons are 0-2, so this means that the below formula is
              // correct.
              SDL.buttonState |= 1 << event.button;
            } else if (event.type == 'mouseup') {
              SDL.buttonState &= ~(1 << event.button);
            }
            // fall through
          case 'mousemove': {
            Browser.calculateMouseEvent(event);
            break;
          }
        }
      },flushEventsToHandler:function() {
        if (!SDL.eventHandler) return;
  
        while (SDL.pollEvent(SDL.eventHandlerTemp)) {
          Module['dynCall_iii'](SDL.eventHandler, SDL.eventHandlerContext, SDL.eventHandlerTemp);
        }
      },pollEvent:function(ptr) {
        if (SDL.initFlags & 0x200 && SDL.joystickEventState) {
          // If SDL_INIT_JOYSTICK was supplied AND the joystick system is configured
          // to automatically query for events, query for joystick events.
          SDL.queryJoysticks();
        }
        if (ptr) {
          while (SDL.events.length > 0) {
            if (SDL.makeCEvent(SDL.events.shift(), ptr) !== false) return 1;
          }
          return 0;
        } else {
          // XXX: somewhat risky in that we do not check if the event is real or not (makeCEvent returns false) if no pointer supplied
          return SDL.events.length > 0;
        }
      },makeCEvent:function(event, ptr) {
        if (typeof event === 'number') {
          // This is a pointer to a copy of a native C event that was SDL_PushEvent'ed
          _memcpy(ptr, event, 28);
          _free(event); // the copy is no longer needed
          return;
        }
  
        SDL.handleEvent(event);
  
        switch (event.type) {
          case 'keydown': case 'keyup': {
            var down = event.type === 'keydown';
            //out('Received key event: ' + event.keyCode);
            var key = SDL.lookupKeyCodeForEvent(event);
            var scan;
            if (key >= 1024) {
              scan = key - 1024;
            } else {
              scan = SDL.scanCodes[key] || key;
            }
  
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP8[(((ptr)+(8))>>0)]=down ? 1 : 0;
            HEAP8[(((ptr)+(9))>>0)]=0; // TODO
            HEAP32[(((ptr)+(12))>>2)]=scan;
            HEAP32[(((ptr)+(16))>>2)]=key;
            HEAP16[(((ptr)+(20))>>1)]=SDL.modState;
            // some non-character keys (e.g. backspace and tab) won't have keypressCharCode set, fill in with the keyCode.
            HEAP32[(((ptr)+(24))>>2)]=event.keypressCharCode || key;
  
            break;
          }
          case 'keypress': {
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            // Not filling in windowID for now
            var cStr = intArrayFromString(String.fromCharCode(event.charCode));
            for (var i = 0; i < cStr.length; ++i) {
              HEAP8[(((ptr)+(8 + i))>>0)]=cStr[i];
            }
            break;
          }
          case 'mousedown': case 'mouseup': case 'mousemove': {
            if (event.type != 'mousemove') {
              var down = event.type === 'mousedown';
              HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
              HEAP32[(((ptr)+(4))>>2)]=0;
              HEAP32[(((ptr)+(8))>>2)]=0;
              HEAP32[(((ptr)+(12))>>2)]=0;
              HEAP8[(((ptr)+(16))>>0)]=event.button+1; // DOM buttons are 0-2, SDL 1-3
              HEAP8[(((ptr)+(17))>>0)]=down ? 1 : 0;
              HEAP32[(((ptr)+(20))>>2)]=Browser.mouseX;
              HEAP32[(((ptr)+(24))>>2)]=Browser.mouseY;
            } else {
              HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
              HEAP32[(((ptr)+(4))>>2)]=0;
              HEAP32[(((ptr)+(8))>>2)]=0;
              HEAP32[(((ptr)+(12))>>2)]=0;
              HEAP32[(((ptr)+(16))>>2)]=SDL.buttonState;
              HEAP32[(((ptr)+(20))>>2)]=Browser.mouseX;
              HEAP32[(((ptr)+(24))>>2)]=Browser.mouseY;
              HEAP32[(((ptr)+(28))>>2)]=Browser.mouseMovementX;
              HEAP32[(((ptr)+(32))>>2)]=Browser.mouseMovementY;
            }
            break;
          }
          case 'wheel': {
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(16))>>2)]=event.deltaX;
            HEAP32[(((ptr)+(20))>>2)]=event.deltaY;
            break;
          }
          case 'touchstart': case 'touchend': case 'touchmove': {
            var touch = event.touch;
            if (!Browser.touches[touch.identifier]) break;
            var w = Module['canvas'].width;
            var h = Module['canvas'].height;
            var x = Browser.touches[touch.identifier].x / w;
            var y = Browser.touches[touch.identifier].y / h;
            var lx = Browser.lastTouches[touch.identifier].x / w;
            var ly = Browser.lastTouches[touch.identifier].y / h;
            var dx = x - lx;
            var dy = y - ly;
            if (touch['deviceID'] === undefined) touch.deviceID = SDL.TOUCH_DEFAULT_ID;
            if (dx === 0 && dy === 0 && event.type === 'touchmove') return false; // don't send these if nothing happened
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)]=_SDL_GetTicks();
            (tempI64 = [touch.deviceID>>>0,(tempDouble=touch.deviceID,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((ptr)+(8))>>2)]=tempI64[0],HEAP32[(((ptr)+(12))>>2)]=tempI64[1]);
            (tempI64 = [touch.identifier>>>0,(tempDouble=touch.identifier,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((ptr)+(16))>>2)]=tempI64[0],HEAP32[(((ptr)+(20))>>2)]=tempI64[1]);
            HEAPF32[(((ptr)+(24))>>2)]=x;
            HEAPF32[(((ptr)+(28))>>2)]=y;
            HEAPF32[(((ptr)+(32))>>2)]=dx;
            HEAPF32[(((ptr)+(36))>>2)]=dy;
            if (touch.force !== undefined) {
              HEAPF32[(((ptr)+(40))>>2)]=touch.force;
            } else { // No pressure data, send a digital 0/1 pressure.
              HEAPF32[(((ptr)+(40))>>2)]=event.type == "touchend" ? 0 : 1;
            }
            break;
          }
          case 'unload': {
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            break;
          }
          case 'resize': {
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)]=event.w;
            HEAP32[(((ptr)+(8))>>2)]=event.h;
            break;
          }
          case 'joystick_button_up': case 'joystick_button_down': {
            var state = event.type === 'joystick_button_up' ? 0 : 1;
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP8[(((ptr)+(4))>>0)]=event.index;
            HEAP8[(((ptr)+(5))>>0)]=event.button;
            HEAP8[(((ptr)+(6))>>0)]=state;
            break;
          }
          case 'joystick_axis_motion': {
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP8[(((ptr)+(4))>>0)]=event.index;
            HEAP8[(((ptr)+(5))>>0)]=event.axis;
            HEAP32[(((ptr)+(8))>>2)]=SDL.joystickAxisValueConversion(event.value);
            break;
          }
          case 'focus': {
            var SDL_WINDOWEVENT_FOCUS_GAINED = 12 /* SDL_WINDOWEVENT_FOCUS_GAINED */;
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)]=0;
            HEAP8[(((ptr)+(8))>>0)]=SDL_WINDOWEVENT_FOCUS_GAINED;
            break;
          }
          case 'blur': {
            var SDL_WINDOWEVENT_FOCUS_LOST = 13 /* SDL_WINDOWEVENT_FOCUS_LOST */;
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)]=0;
            HEAP8[(((ptr)+(8))>>0)]=SDL_WINDOWEVENT_FOCUS_LOST;
            break;
          }
          case 'visibilitychange': {
            var SDL_WINDOWEVENT_SHOWN  = 1 /* SDL_WINDOWEVENT_SHOWN */;
            var SDL_WINDOWEVENT_HIDDEN = 2 /* SDL_WINDOWEVENT_HIDDEN */;
            var visibilityEventID = event.visible ? SDL_WINDOWEVENT_SHOWN : SDL_WINDOWEVENT_HIDDEN;
            HEAP32[((ptr)>>2)]=SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)]=0;
            HEAP8[(((ptr)+(8))>>0)]=visibilityEventID;
            break;
          }
          default: throw 'Unhandled SDL event: ' + event.type;
        }
      },makeFontString:function(height, fontName) {
        if (fontName.charAt(0) != "'" && fontName.charAt(0) != '"') {
          // https://developer.mozilla.org/ru/docs/Web/CSS/font-family
          // Font family names containing whitespace should be quoted.
          // BTW, quote all font names is easier than searching spaces
          fontName = '"' + fontName + '"';
        }
        return height + 'px ' + fontName + ', serif';
      },estimateTextWidth:function(fontData, text) {
        var h = fontData.size;
        var fontString = SDL.makeFontString(h, fontData.name);
        var tempCtx = SDL_ttfContext();
        assert(tempCtx, 'TTF_Init must have been called');
        tempCtx.font = fontString;
        var ret = tempCtx.measureText(text).width | 0;
        return ret;
      },allocateChannels:function(num) { // called from Mix_AllocateChannels and init
        if (SDL.numChannels && SDL.numChannels >= num && num != 0) return;
        SDL.numChannels = num;
        SDL.channels = [];
        for (var i = 0; i < num; i++) {
          SDL.channels[i] = {
            audio: null,
            volume: 1.0
          };
        }
      },setGetVolume:function(info, volume) {
        if (!info) return 0;
        var ret = info.volume * 128; // MIX_MAX_VOLUME
        if (volume != -1) {
          info.volume = Math.min(Math.max(volume, 0), 128) / 128;
          if (info.audio) {
            try {
              info.audio.volume = info.volume; // For <audio> element
              if (info.audio.webAudioGainNode) info.audio.webAudioGainNode['gain']['value'] = info.volume; // For WebAudio playback
            } catch(e) {
              err('setGetVolume failed to set audio volume: ' + e);
            }
          }
        }
        return ret;
      },setPannerPosition:function(info, x, y, z) {
        if (!info) return;
        if (info.audio) {
          if (info.audio.webAudioPannerNode) {
            info.audio.webAudioPannerNode['setPosition'](x, y, z);
          }
        }
      },playWebAudio:function(audio) {
        if (!audio) return;
        if (audio.webAudioNode) return; // This instance is already playing, don't start again.
        if (!SDL.webAudioAvailable()) return;
        try {
          var webAudio = audio.resource.webAudio;
          audio.paused = false;
          if (!webAudio.decodedBuffer) {
            if (webAudio.onDecodeComplete === undefined) abort("Cannot play back audio object that was not loaded");
            webAudio.onDecodeComplete.push(function() { if (!audio.paused) SDL.playWebAudio(audio); });
            return;
          }
          audio.webAudioNode = SDL.audioContext['createBufferSource']();
          audio.webAudioNode['buffer'] = webAudio.decodedBuffer;
          audio.webAudioNode['loop'] = audio.loop;
          audio.webAudioNode['onended'] = function() { audio['onended'](); } // For <media> element compatibility, route the onended signal to the instance.
  
          audio.webAudioPannerNode = SDL.audioContext['createPanner']();
          // avoid Chrome bug
          // If posz = 0, the sound will come from only the right.
          // By posz = -0.5 (slightly ahead), the sound will come from right and left correctly.
          audio.webAudioPannerNode["setPosition"](0, 0, -.5);
          audio.webAudioPannerNode['panningModel'] = 'equalpower';
  
          // Add an intermediate gain node to control volume.
          audio.webAudioGainNode = SDL.audioContext['createGain']();
          audio.webAudioGainNode['gain']['value'] = audio.volume;
  
          audio.webAudioNode['connect'](audio.webAudioPannerNode);
          audio.webAudioPannerNode['connect'](audio.webAudioGainNode);
          audio.webAudioGainNode['connect'](SDL.audioContext['destination']);
  
          audio.webAudioNode['start'](0, audio.currentPosition);
          audio.startTime = SDL.audioContext['currentTime'] - audio.currentPosition;
        } catch(e) {
          err('playWebAudio failed: ' + e);
        }
      },pauseWebAudio:function(audio) {
        if (!audio) return;
        if (audio.webAudioNode) {
          try {
            // Remember where we left off, so that if/when we resume, we can restart the playback at a proper place.
            audio.currentPosition = (SDL.audioContext['currentTime'] - audio.startTime) % audio.resource.webAudio.decodedBuffer.duration;
            // Important: When we reach here, the audio playback is stopped by the user. But when calling .stop() below, the Web Audio
            // graph will send the onended signal, but we don't want to process that, since pausing should not clear/destroy the audio
            // channel.
            audio.webAudioNode['onended'] = undefined;
            audio.webAudioNode.stop(0); // 0 is a default parameter, but WebKit is confused by it #3861
            audio.webAudioNode = undefined;
          } catch(e) {
            err('pauseWebAudio failed: ' + e);
          }
        }
        audio.paused = true;
      },openAudioContext:function() {
        // Initialize Web Audio API if we haven't done so yet. Note: Only initialize Web Audio context ever once on the web page,
        // since initializing multiple times fails on Chrome saying 'audio resources have been exhausted'.
        if (!SDL.audioContext) {
          if (typeof(AudioContext) !== 'undefined') SDL.audioContext = new AudioContext();
          else if (typeof(webkitAudioContext) !== 'undefined') SDL.audioContext = new webkitAudioContext();
        }
      },webAudioAvailable:function() { return !!SDL.audioContext; },fillWebAudioBufferFromHeap:function(heapPtr, sizeSamplesPerChannel, dstAudioBuffer) {
        // The input audio data is interleaved across the channels, i.e. [L, R, L, R, L, R, ...] and is either 8-bit, 16-bit or float as
        // supported by the SDL API. The output audio wave data for Web Audio API must be in planar buffers of [-1,1]-normalized Float32 data,
        // so perform a buffer conversion for the data.
        var audio = SDL_audio();
        var numChannels = audio.channels;
        for(var c = 0; c < numChannels; ++c) {
          var channelData = dstAudioBuffer['getChannelData'](c);
          if (channelData.length != sizeSamplesPerChannel) {
            throw 'Web Audio output buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + sizeSamplesPerChannel + ' samples!';
          }
          if (audio.format == 0x8010 /*AUDIO_S16LSB*/) {
            for(var j = 0; j < sizeSamplesPerChannel; ++j) {
              channelData[j] = (HEAP16[(((heapPtr)+((j*numChannels + c)*2))>>1)]) / 0x8000;
            }
          } else if (audio.format == 0x0008 /*AUDIO_U8*/) {
            for(var j = 0; j < sizeSamplesPerChannel; ++j) {
              var v = (HEAP8[(((heapPtr)+(j*numChannels + c))>>0)]);
              channelData[j] = ((v >= 0) ? v-128 : v+128) /128;
            }
          } else if (audio.format == 0x8120 /*AUDIO_F32*/) {
            for(var j = 0; j < sizeSamplesPerChannel; ++j) {
              channelData[j] = (HEAPF32[(((heapPtr)+((j*numChannels + c)*4))>>2)]);
            }
          } else {
            throw 'Invalid SDL audio format ' + audio.format + '!';
          }
        }
      },debugSurface:function(surfData) {
        console.log('dumping surface ' + [surfData.surf, surfData.source, surfData.width, surfData.height]);
        var image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
        var data = image.data;
        var num = Math.min(surfData.width, surfData.height);
        for (var i = 0; i < num; i++) {
          console.log('   diagonal ' + i + ':' + [data[i*surfData.width*4 + i*4 + 0], data[i*surfData.width*4 + i*4 + 1], data[i*surfData.width*4 + i*4 + 2], data[i*surfData.width*4 + i*4 + 3]]);
        }
      },joystickEventState:1,lastJoystickState:{},joystickNamePool:{},recordJoystickState:function(joystick, state) {
        // Standardize button state.
        var buttons = new Array(state.buttons.length);
        for (var i = 0; i < state.buttons.length; i++) {
          buttons[i] = SDL.getJoystickButtonState(state.buttons[i]);
        }
  
        SDL.lastJoystickState[joystick] = {
          buttons: buttons,
          axes: state.axes.slice(0),
          timestamp: state.timestamp,
          index: state.index,
          id: state.id
        };
      },getJoystickButtonState:function(button) {
        if (typeof button === 'object') {
          // Current gamepad API editor's draft (Firefox Nightly)
          // https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html#idl-def-GamepadButton
          return button['pressed'];
        } else {
          // Current gamepad API working draft (Firefox / Chrome Stable)
          // http://www.w3.org/TR/2012/WD-gamepad-20120529/#gamepad-interface
          return button > 0;
        }
      },queryJoysticks:function() {
        for (var joystick in SDL.lastJoystickState) {
          var state = SDL.getGamepad(joystick - 1);
          var prevState = SDL.lastJoystickState[joystick];
          // If joystick was removed, state returns null.
          if (typeof state === 'undefined') return;
          if (state === null) return;
          // Check only if the timestamp has differed.
          // NOTE: Timestamp is not available in Firefox.
          // NOTE: Timestamp is currently not properly set for the GearVR controller
          //       on Samsung Internet: it is always zero.
          if (typeof state.timestamp !== 'number' || state.timestamp !== prevState.timestamp || !state.timestamp) {
            var i;
            for (i = 0; i < state.buttons.length; i++) {
              var buttonState = SDL.getJoystickButtonState(state.buttons[i]);
              // NOTE: The previous state already has a boolean representation of
              //       its button, so no need to standardize its button state here.
              if (buttonState !== prevState.buttons[i]) {
                // Insert button-press event.
                SDL.events.push({
                  type: buttonState ? 'joystick_button_down' : 'joystick_button_up',
                  joystick: joystick,
                  index: joystick - 1,
                  button: i
                });
              }
            }
            for (i = 0; i < state.axes.length; i++) {
              if (state.axes[i] !== prevState.axes[i]) {
                // Insert axes-change event.
                SDL.events.push({
                  type: 'joystick_axis_motion',
                  joystick: joystick,
                  index: joystick - 1,
                  axis: i,
                  value: state.axes[i]
                });
              }
            }
  
            SDL.recordJoystickState(joystick, state);
          }
        }
      },joystickAxisValueConversion:function(value) {
        // Make sure value is properly clamped
        value = Math.min(1, Math.max(value, -1));
        // Ensures that 0 is 0, 1 is 32767, and -1 is 32768.
        return Math.ceil(((value+1) * 32767.5) - 32768);
      },getGamepads:function() {
        var fcn = navigator.getGamepads || navigator.webkitGamepads || navigator.mozGamepads || navigator.gamepads || navigator.webkitGetGamepads;
        if (fcn !== undefined) {
          // The function must be applied on the navigator object.
          return fcn.apply(navigator);
        } else {
          return [];
        }
      },getGamepad:function(deviceIndex) {
        var gamepads = SDL.getGamepads();
        if (gamepads.length > deviceIndex && deviceIndex >= 0) {
          return gamepads[deviceIndex];
        }
        return null;
      }};
  Module["SDL"] = SDL;/** @suppress{missingProperties} */
  function SDL_unicode() { return SDL.unicode}
  Module["SDL_unicode"] = SDL_unicode;




  function _SDL_Linked_Version() {
      if (SDL.version === null) {
        SDL.version = _malloc(3);
        HEAP8[((SDL.version + 0)>>0)]=1;
        HEAP8[((SDL.version + 1)>>0)]=3;
        HEAP8[((SDL.version + 2)>>0)]=0;
      }
      return SDL.version;
    }
  Module["_SDL_Linked_Version"] = _SDL_Linked_Version;



  function _SDL_GetVideoInfo() {
      // %struct.SDL_VideoInfo = type { i32, i32, %struct.SDL_PixelFormat*, i32, i32 } - 5 fields of quantum size
      var ret = _malloc(5 * 4);
      HEAP32[((ret+0)>>2)]=0; // TODO
      HEAP32[((ret+4)>>2)]=0; // TODO
      HEAP32[((ret+8)>>2)]=0;
      HEAP32[((ret+12)>>2)]=Module["canvas"].width;
      HEAP32[((ret+16)>>2)]=Module["canvas"].height;
      return ret;
    }
  Module["_SDL_GetVideoInfo"] = _SDL_GetVideoInfo;

  function _SDL_ListModes(format, flags) {
      return -1; // -1 == all modes are ok. TODO
    }
  Module["_SDL_ListModes"] = _SDL_ListModes;

  function _SDL_VideoModeOK(width, height, depth, flags) {
      // SDL_VideoModeOK returns 0 if the requested mode is not supported under any bit depth, or returns the
      // bits-per-pixel of the closest available mode with the given width, height and requested surface flags
      return depth; // all modes are ok.
    }
  Module["_SDL_VideoModeOK"] = _SDL_VideoModeOK;

  
  function _SDL_VideoDriverName(buf, max_size) {
      if (SDL.startTime === null) {
        return 0; //return NULL
      }
      //driverName - emscripten_sdl_driver
      var driverName = [101, 109, 115, 99, 114, 105, 112, 116, 101,
        110, 95, 115, 100, 108, 95, 100, 114, 105, 118, 101, 114];
  
      var index = 0;
      var size  = driverName.length;
  
      if (max_size <= size) {
        size = max_size - 1; //-1 cause null-terminator
      }
  
      while (index < size) {
          var value = driverName[index];
          HEAP8[(((buf)+(index))>>0)]=value;
          index++;
      }
  
      HEAP8[(((buf)+(index))>>0)]=0;
      return buf;
    }
  Module["_SDL_VideoDriverName"] = _SDL_VideoDriverName;function _SDL_AudioDriverName(buf, max_size) {
      return _SDL_VideoDriverName(buf, max_size);
    }
  Module["_SDL_AudioDriverName"] = _SDL_AudioDriverName;


  function _SDL_SetVideoMode(width, height, depth, flags) {
      ['touchstart', 'touchend', 'touchmove', 'mousedown', 'mouseup', 'mousemove', 'DOMMouseScroll', 'mousewheel', 'wheel', 'mouseout'].forEach(function(event) {
        Module['canvas'].addEventListener(event, SDL.receiveEvent, true);
      });
  
      var canvas = Module['canvas'];
  
      // (0,0) means 'use fullscreen' in native; in Emscripten, use the current canvas size.
      if (width == 0 && height == 0) {
        width = canvas.width;
        height = canvas.height;
      }
  
      if (!SDL.addedResizeListener) {
        SDL.addedResizeListener = true;
        Browser.resizeListeners.push(function(w, h) {
          if (!SDL.settingVideoMode) {
            SDL.receiveEvent({
              type: 'resize',
              w: w,
              h: h
            });
          }
        });
      }
  
      SDL.settingVideoMode = true; // SetVideoMode itself should not trigger resize events
      Browser.setCanvasSize(width, height);
      SDL.settingVideoMode = false;
  
      // Free the old surface first if there is one
      if (SDL.screen) {
        SDL.freeSurface(SDL.screen);
        assert(!SDL.screen);
      }
  
      if (SDL.GL) flags = flags | 0x04000000; // SDL_OPENGL - if we are using GL, then later calls to SetVideoMode may not mention GL, but we do need it. Once in GL mode, we never leave it.
  
      SDL.screen = SDL.makeSurface(width, height, flags, true, 'screen');
  
      return SDL.screen;
    }
  Module["_SDL_SetVideoMode"] = _SDL_SetVideoMode;

  function _SDL_GetVideoSurface() {
      return SDL.screen;
    }
  Module["_SDL_GetVideoSurface"] = _SDL_GetVideoSurface;







  function _SDL_Flip(surf) {
      // We actually do this in Unlock, since the screen surface has as its canvas
      // backing the page canvas element
    }
  Module["_SDL_Flip"] = _SDL_Flip;

  function _SDL_UpdateRect(surf, x, y, w, h) {
      // We actually do the whole screen in Unlock...
    }
  Module["_SDL_UpdateRect"] = _SDL_UpdateRect;

  function _SDL_UpdateRects(surf, numrects, rects) {
      // We actually do the whole screen in Unlock...
    }
  Module["_SDL_UpdateRects"] = _SDL_UpdateRects;


  function _SDL_WM_SetCaption(title, icon) {
      if (title && typeof setWindowTitle !== 'undefined') {
        setWindowTitle(UTF8ToString(title));
      }
      icon = icon && UTF8ToString(icon);
    }
  Module["_SDL_WM_SetCaption"] = _SDL_WM_SetCaption;

  function _SDL_EnableKeyRepeat(delay, interval) {
      // TODO
    }
  Module["_SDL_EnableKeyRepeat"] = _SDL_EnableKeyRepeat;


  function _SDL_GetKeyState() {
      return _SDL_GetKeyboardState();
    }
  Module["_SDL_GetKeyState"] = _SDL_GetKeyState;




  function _SDL_WarpMouse(x, y) {
      return; // TODO: implement this in a non-buggy way. Need to keep relative mouse movements correct after calling this
      /*
      var rect = Module["canvas"].getBoundingClientRect();
      SDL.events.push({
        type: 'mousemove',
        pageX: x + (window.scrollX + rect.left),
        pageY: y + (window.scrollY + rect.top)
      });
      */
    }
  Module["_SDL_WarpMouse"] = _SDL_WarpMouse;









  function _SDL_DisplayFormatAlpha(surf) {
      return _SDL_ConvertSurface(surf);
    }
  Module["_SDL_DisplayFormatAlpha"] = _SDL_DisplayFormatAlpha;









  function _SDL_BlitSurface(src, srcrect, dst, dstrect) {
      return SDL.blitSurface(src, srcrect, dst, dstrect, false);
    }
  Module["_SDL_BlitSurface"] = _SDL_BlitSurface;

  function _SDL_BlitScaled(src, srcrect, dst, dstrect) {
      return SDL.blitSurface(src, srcrect, dst, dstrect, true);
    }
  Module["_SDL_BlitScaled"] = _SDL_BlitScaled;

  function _zoomSurface(src, x, y, smooth) {
      var srcData = SDL.surfaces[src];
      var w = srcData.width * x;
      var h = srcData.height * y;
      var ret = SDL.makeSurface(Math.abs(w), Math.abs(h), srcData.flags, false, 'zoomSurface');
      var dstData = SDL.surfaces[ret];
      if (x >= 0 && y >= 0) dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
      else {
        dstData.ctx.save();
        dstData.ctx.scale(x < 0 ? -1 : 1, y < 0 ? -1 : 1);
        dstData.ctx.drawImage(srcData.canvas, w < 0 ? w : 0, h < 0 ? h : 0, Math.abs(w), Math.abs(h));
        // XXX I think this should work according to the spec, but currently
        // fails on FF: dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
        dstData.ctx.restore();
      }
      return ret;
    }
  Module["_zoomSurface"] = _zoomSurface;

  function _rotozoomSurface(src, angle, zoom, smooth) {
      if (angle % 360 === 0) {
        return _zoomSurface(src, zoom, zoom, smooth);
      }
      var srcData = SDL.surfaces[src];
      var w = srcData.width * zoom;
      var h = srcData.height * zoom;
      var diagonal = Math.ceil(Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)));
      var ret = SDL.makeSurface(diagonal, diagonal, srcData.flags, false, 'rotozoomSurface');
      var dstData = SDL.surfaces[ret];
      dstData.ctx.translate(diagonal / 2, diagonal / 2);
      dstData.ctx.rotate(-angle * Math.PI / 180);
      dstData.ctx.drawImage(srcData.canvas, -w / 2, -h / 2, w, h);
      return ret;
    }
  Module["_rotozoomSurface"] = _rotozoomSurface;

  function _SDL_SetAlpha(surf, flag, alpha) {
      var surfData = SDL.surfaces[surf];
      surfData.alpha = alpha;
  
      if (!(flag & 0x00010000)) { // !SDL_SRCALPHA
        surfData.alpha = 255;
      }
    }
  Module["_SDL_SetAlpha"] = _SDL_SetAlpha;







  function _emscripten_SDL_SetEventHandler(handler, userdata) {
      SDL.eventHandler = handler;
      SDL.eventHandlerContext = userdata;
  
      // All SDLEvents take the same amount of memory
      if (!SDL.eventHandlerTemp) SDL.eventHandlerTemp = _malloc(28);
    }
  Module["_emscripten_SDL_SetEventHandler"] = _emscripten_SDL_SetEventHandler;

  function _SDL_SetColors(surf, colors, firstColor, nColors) {
      var surfData = SDL.surfaces[surf];
  
      // we should create colors array
      // only once cause client code
      // often wants to change portion
      // of palette not all palette.
      if (!surfData.colors) {
        var buffer = new ArrayBuffer(256 * 4); // RGBA, A is unused, but faster this way
        surfData.colors = new Uint8Array(buffer);
        surfData.colors32 = new Uint32Array(buffer);
      }
  
      for (var i = 0; i < nColors; ++i) {
        var index = (firstColor + i) * 4;
        surfData.colors[index] = HEAPU8[(((colors)+(i*4))>>0)];
        surfData.colors[index + 1] = HEAPU8[(((colors)+(i*4 + 1))>>0)];
        surfData.colors[index + 2] = HEAPU8[(((colors)+(i*4 + 2))>>0)];
        surfData.colors[index + 3] = 255; // opaque
      }
  
      return 1;
    }
  Module["_SDL_SetColors"] = _SDL_SetColors;

  function _SDL_SetPalette(surf, flags, colors, firstColor, nColors) {
      return _SDL_SetColors(surf, colors, firstColor, nColors);
    }
  Module["_SDL_SetPalette"] = _SDL_SetPalette;





  function _SDL_GetAppState() {
      var state = 0;
  
      if (Browser.pointerLock) {
        state |= 0x01;  // SDL_APPMOUSEFOCUS
      }
      if (document.hasFocus()) {
        state |= 0x02;  // SDL_APPINPUTFOCUS
      }
      state |= 0x04;  // SDL_APPACTIVE
  
      return state;
    }
  Module["_SDL_GetAppState"] = _SDL_GetAppState;

  function _SDL_WM_GrabInput() {}
  Module["_SDL_WM_GrabInput"] = _SDL_WM_GrabInput;

  function _SDL_WM_ToggleFullScreen(surf) {
      if (Browser.exitFullscreen()) {
        return 1;
      } else {
        if (!SDL.canRequestFullscreen) {
          return 0;
        }
        SDL.isRequestingFullscreen = true;
        return 1;
      }
    }
  Module["_SDL_WM_ToggleFullScreen"] = _SDL_WM_ToggleFullScreen;

  function _IMG_Init(flags) {
      return flags; // We support JPG, PNG, TIF because browsers do
    }
  Module["_IMG_Init"] = _IMG_Init;

  function _IMG_Load_RW(rwopsID, freeSrc) {
      try {
        // stb_image integration support
        var cleanup = function() {
          if (rwops && freeSrc) _SDL_FreeRW(rwopsID);
        }
        var addCleanup = function(func) {
          var old = cleanup;
          cleanup = function added_cleanup() {
            old();
            func();
          }
        }
        var callStbImage = function(func, params) {
          var x = Module['_malloc'](4);
          var y = Module['_malloc'](4);
          var comp = Module['_malloc'](4);
          addCleanup(function() {
            Module['_free'](x);
            Module['_free'](y);
            Module['_free'](comp);
            if (data) Module['_stbi_image_free'](data);
          });
          var data = Module['_' + func].apply(null, params.concat([x, y, comp, 0]));
          if (!data) return null;
          return {
            rawData: true,
            data: data,
            width: HEAP32[((x)>>2)],
            height: HEAP32[((y)>>2)],
            size: HEAP32[((x)>>2)] * HEAP32[((y)>>2)] * HEAP32[((comp)>>2)],
            bpp: HEAP32[((comp)>>2)]
          };
        }
  
        var rwops = SDL.rwops[rwopsID];
        if (rwops === undefined) {
          return 0;
        }
  
        var raw;
        var filename = rwops.filename;
        if (filename === undefined) {
          warnOnce('Only file names that have been preloaded are supported for IMG_Load_RW. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins');
          return 0;
        }
  
        if (!raw) {
          filename = PATH_FS.resolve(filename);
          raw = Module["preloadedImages"][filename];
          if (!raw) {
            if (raw === null) err('Trying to reuse preloaded image, but freePreloadedMediaOnUse is set!');
            warnOnce('Cannot find preloaded image ' + filename);
            warnOnce('Cannot find preloaded image ' + filename + '. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins');
            return 0;
          } else if (Module['freePreloadedMediaOnUse']) {
            Module["preloadedImages"][filename] = null;
          }
        }
  
        var surf = SDL.makeSurface(raw.width, raw.height, 0, false, 'load:' + filename);
        var surfData = SDL.surfaces[surf];
        surfData.ctx.globalCompositeOperation = "copy";
        if (!raw.rawData) {
          surfData.ctx.drawImage(raw, 0, 0, raw.width, raw.height, 0, 0, raw.width, raw.height);
        } else {
          var imageData = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
          if (raw.bpp == 4) {
            // rgba
            imageData.data.set(HEAPU8.subarray((raw.data),(raw.data+raw.size)));
          } else if (raw.bpp == 3) {
            // rgb
            var pixels = raw.size/3;
            var data = imageData.data;
            var sourcePtr = raw.data;
            var destPtr = 0;
            for (var i = 0; i < pixels; i++) {
              data[destPtr++] = HEAPU8[((sourcePtr++)>>0)];
              data[destPtr++] = HEAPU8[((sourcePtr++)>>0)];
              data[destPtr++] = HEAPU8[((sourcePtr++)>>0)];
              data[destPtr++] = 255;
            }
          } else if (raw.bpp == 2) {
            // grayscale + alpha
            var pixels = raw.size;
            var data = imageData.data;
            var sourcePtr = raw.data;
            var destPtr = 0;
            for (var i = 0; i < pixels; i++) {
              var gray = HEAPU8[((sourcePtr++)>>0)];
              var alpha = HEAPU8[((sourcePtr++)>>0)];
              data[destPtr++] = gray;
              data[destPtr++] = gray;
              data[destPtr++] = gray;
              data[destPtr++] = alpha;
            }
          } else if (raw.bpp == 1) {
            // grayscale
            var pixels = raw.size;
            var data = imageData.data;
            var sourcePtr = raw.data;
            var destPtr = 0;
            for (var i = 0; i < pixels; i++) {
              var value = HEAPU8[((sourcePtr++)>>0)];
              data[destPtr++] = value;
              data[destPtr++] = value;
              data[destPtr++] = value;
              data[destPtr++] = 255;
            }
          } else {
            err('cannot handle bpp ' + raw.bpp);
            return 0;
          }
          surfData.ctx.putImageData(imageData, 0, 0);
        }
        surfData.ctx.globalCompositeOperation = "source-over";
        // XXX SDL does not specify that loaded images must have available pixel data, in fact
        //     there are cases where you just want to blit them, so you just need the hardware
        //     accelerated version. However, code everywhere seems to assume that the pixels
        //     are in fact available, so we retrieve it here. This does add overhead though.
        _SDL_LockSurface(surf);
        surfData.locked--; // The surface is not actually locked in this hack
        if (SDL.GL) {
          // After getting the pixel data, we can free the canvas and context if we do not need to do 2D canvas blitting
          surfData.canvas = surfData.ctx = null;
        }
        return surf;
      } finally {
        cleanup();
      }
    }
  Module["_IMG_Load_RW"] = _IMG_Load_RW;

  
  function _IMG_Load(filename){
      var rwops = _SDL_RWFromFile(filename);
      var result = _IMG_Load_RW(rwops, 1);
      return result;
    }
  Module["_IMG_Load"] = _IMG_Load;function _SDL_LoadBMP(a0
  ) {
  return _IMG_Load(a0);
  }
  Module["_SDL_LoadBMP"] = _SDL_LoadBMP;



  function _IMG_Quit() {
      out('IMG_Quit called (and ignored)');
    }
  Module["_IMG_Quit"] = _IMG_Quit;









  function _SDL_mutexP() { return 0 }
  Module["_SDL_mutexP"] = _SDL_mutexP;

  function _SDL_mutexV() { return 0 }
  Module["_SDL_mutexV"] = _SDL_mutexV;








  function _Mix_Init(flags) {
      if (!flags) return 0;
      return 8; /* MIX_INIT_OGG */
    }
  Module["_Mix_Init"] = _Mix_Init;

  function _Mix_Quit(){}
  Module["_Mix_Quit"] = _Mix_Quit;

  function _Mix_OpenAudio(frequency, format, channels, chunksize) {
      SDL.openAudioContext();
      SDL.allocateChannels(32);
      // Just record the values for a later call to Mix_QuickLoad_RAW
      SDL.mixerFrequency = frequency;
      SDL.mixerFormat = format;
      SDL.mixerNumChannels = channels;
      SDL.mixerChunkSize = chunksize;
      return 0;
    }
  Module["_Mix_OpenAudio"] = _Mix_OpenAudio;

  function _Mix_CloseAudio(
  ) {
  _SDL_CloseAudio();
  }
  Module["_Mix_CloseAudio"] = _Mix_CloseAudio;

  function _Mix_AllocateChannels(num) {
      SDL.allocateChannels(num);
      return num;
    }
  Module["_Mix_AllocateChannels"] = _Mix_AllocateChannels;

  function _Mix_ChannelFinished(func) {
      SDL.channelFinished = func;
    }
  Module["_Mix_ChannelFinished"] = _Mix_ChannelFinished;

  function _Mix_Volume(channel, volume) {
      if (channel == -1) {
        for (var i = 0; i < SDL.numChannels-1; i++) {
          _Mix_Volume(i, volume);
        }
        return _Mix_Volume(SDL.numChannels-1, volume);
      }
      return SDL.setGetVolume(SDL.channels[channel], volume);
    }
  Module["_Mix_Volume"] = _Mix_Volume;

  function _Mix_SetPanning(channel, left, right) {
      // SDL API uses [0-255], while PannerNode has an (x, y, z) position.
  
      // Normalizing.
      left /= 255;
      right /= 255;
  
      // Set the z coordinate a little forward, otherwise there won't be any
      // smooth transition between left and right.
      SDL.setPannerPosition(SDL.channels[channel], right - left, 0, 0.1);
      return 1;
    }
  Module["_Mix_SetPanning"] = _Mix_SetPanning;

  /** @param {number|boolean=} freesrc */
  function _Mix_LoadWAV_RW(rwopsID, freesrc) {
      var rwops = SDL.rwops[rwopsID];
  
  
      if (rwops === undefined)
        return 0;
  
      var filename = '';
      var audio;
      var webAudio;
      var bytes;
  
      if (rwops.filename !== undefined) {
        filename = PATH_FS.resolve(rwops.filename);
        var raw = Module["preloadedAudios"][filename];
        if (!raw) {
          if (raw === null) err('Trying to reuse preloaded audio, but freePreloadedMediaOnUse is set!');
          if (!Module.noAudioDecoding) warnOnce('Cannot find preloaded audio ' + filename);
  
          // see if we can read the file-contents from the in-memory FS
          try {
            bytes = FS.readFile(filename);
          } catch (e) {
            err('Couldn\'t find file for: ' + filename);
            return 0;
          }
        }
        if (Module['freePreloadedMediaOnUse']) {
          Module["preloadedAudios"][filename] = null;
        }
        audio = raw;
      }
      else if (rwops.bytes !== undefined) {
        // For Web Audio context buffer decoding, we must make a clone of the audio data, but for <media> element,
        // a view to existing data is sufficient.
        if (SDL.webAudioAvailable()) bytes = HEAPU8.buffer.slice(rwops.bytes, rwops.bytes + rwops.count);
        else bytes = HEAPU8.subarray(rwops.bytes, rwops.bytes + rwops.count);
      }
      else {
        return 0;
      }
  
      var arrayBuffer = bytes ? bytes.buffer || bytes : bytes;
  
      // To allow user code to work around browser bugs with audio playback on <audio> elements an Web Audio, enable
      // the user code to hook in a callback to decide on a file basis whether each file should use Web Audio or <audio> for decoding and playback.
      // In particular, see https://bugzilla.mozilla.org/show_bug.cgi?id=654787 and ?id=1012801 for tradeoffs.
      var canPlayWithWebAudio = Module['SDL_canPlayWithWebAudio'] === undefined || Module['SDL_canPlayWithWebAudio'](filename, arrayBuffer);
  
      if (bytes !== undefined && SDL.webAudioAvailable() && canPlayWithWebAudio) {
        audio = undefined;
        webAudio = {};
        // The audio decoding process is asynchronous, which gives trouble if user code plays the audio data back immediately
        // after loading. Therefore prepare an array of callback handlers to run when this audio decoding is complete, which
        // will then start the playback (with some delay).
        webAudio.onDecodeComplete = []; // While this member array exists, decoding hasn't finished yet.
        var onDecodeComplete = function(data) {
          webAudio.decodedBuffer = data;
          // Call all handlers that were waiting for this decode to finish, and clear the handler list.
          webAudio.onDecodeComplete.forEach(function(e) { e(); });
          webAudio.onDecodeComplete = undefined; // Don't allow more callback handlers since audio has finished decoding.
        };
        SDL.audioContext['decodeAudioData'](arrayBuffer, onDecodeComplete);
      } else if (audio === undefined && bytes) {
        // Here, we didn't find a preloaded audio but we either were passed a filepath for
        // which we loaded bytes, or we were passed some bytes
        var blob = new Blob([bytes], {type: rwops.mimetype});
        var url = URL.createObjectURL(blob);
        audio = new Audio();
        audio.src = url;
        audio.mozAudioChannelType = 'content'; // bugzilla 910340
      }
  
      var id = SDL.audios.length;
      // Keep the loaded audio in the audio arrays, ready for playback
      SDL.audios.push({
        source: filename,
        audio: audio, // Points to the <audio> element, if loaded
        webAudio: webAudio // Points to a Web Audio -specific resource object, if loaded
      });
      return id;
    }
  Module["_Mix_LoadWAV_RW"] = _Mix_LoadWAV_RW;

  function _Mix_LoadWAV(filename) {
      var rwops = _SDL_RWFromFile(filename);
      var result = _Mix_LoadWAV_RW(rwops);
      _SDL_FreeRW(rwops);
      return result;
    }
  Module["_Mix_LoadWAV"] = _Mix_LoadWAV;

  function _Mix_QuickLoad_RAW(mem, len) {
      var audio;
      var webAudio;
  
      var numSamples = len >> 1; // len is the length in bytes, and the array contains 16-bit PCM values
      var buffer = new Float32Array(numSamples);
      for (var i = 0; i < numSamples; ++i) {
        buffer[i] = (HEAP16[(((mem)+(i*2))>>1)]) / 0x8000; // hardcoded 16-bit audio, signed (TODO: reSign if not ta2?)
      }
  
      if (SDL.webAudioAvailable()) {
        webAudio = {};
        webAudio.decodedBuffer = buffer;
      } else {
        audio = new Audio();
        audio.mozAudioChannelType = 'content'; // bugzilla 910340
        // Record the number of channels and frequency for later usage
        audio.numChannels = SDL.mixerNumChannels;
        audio.frequency = SDL.mixerFrequency;
        // FIXME: doesn't make sense to keep the audio element in the buffer
      }
  
      var id = SDL.audios.length;
      SDL.audios.push({
        source: '',
        audio: audio,
        webAudio: webAudio,
        buffer: buffer
      });
      return id;
    }
  Module["_Mix_QuickLoad_RAW"] = _Mix_QuickLoad_RAW;

  function _Mix_FreeChunk(id) {
      SDL.audios[id] = null;
    }
  Module["_Mix_FreeChunk"] = _Mix_FreeChunk;

  function _Mix_ReserveChannels(num) {
      SDL.channelMinimumNumber = num;
    }
  Module["_Mix_ReserveChannels"] = _Mix_ReserveChannels;

  function _Mix_PlayChannel(channel, id, loops) {
      // TODO: handle fixed amount of N loops. Currently loops either 0 or infinite times.
  
      // Get the audio element associated with the ID
      var info = SDL.audios[id];
      if (!info) return -1;
      if (!info.audio && !info.webAudio) return -1;
  
      // If the user asks us to allocate a channel automatically, get the first
      // free one.
      if (channel == -1) {
        for (var i = SDL.channelMinimumNumber; i < SDL.numChannels; i++) {
          if (!SDL.channels[i].audio) {
            channel = i;
            break;
          }
        }
        if (channel == -1) {
          err('All ' + SDL.numChannels + ' channels in use!');
          return -1;
        }
      }
      var channelInfo = SDL.channels[channel];
      var audio;
      if (info.webAudio) {
        // Create an instance of the WebAudio object.
        audio = {};
        audio.resource = info; // This new object is an instance that refers to this existing resource.
        audio.paused = false;
        audio.currentPosition = 0;
        // Make our instance look similar to the instance of a <media> to make api simple.
        audio.play = function() { SDL.playWebAudio(this); }
        audio.pause = function() { SDL.pauseWebAudio(this); }
      } else {
        // We clone the audio node to utilize the preloaded audio buffer, since
        // the browser has already preloaded the audio file.
        audio = info.audio.cloneNode(true);
        audio.numChannels = info.audio.numChannels;
        audio.frequency = info.audio.frequency;
      }
      audio['onended'] = function SDL_audio_onended() { // TODO: cache these
        if (channelInfo.audio == this) { channelInfo.audio.paused = true; channelInfo.audio = null; }
        if (SDL.channelFinished) getFuncWrapper(SDL.channelFinished, 'vi')(channel);
      }
      channelInfo.audio = audio;
      // TODO: handle N loops. Behavior matches Mix_PlayMusic
      audio.loop = loops != 0;
      audio.volume = channelInfo.volume;
      audio.play();
      return channel;
    }
  Module["_Mix_PlayChannel"] = _Mix_PlayChannel;

  function _Mix_PlayChannelTimed(a0,a1,a2
  ) {
  return _Mix_PlayChannel(a0,a1,a2);
  }
  Module["_Mix_PlayChannelTimed"] = _Mix_PlayChannelTimed;

  function _Mix_FadingChannel(channel) {
      return 0; // MIX_NO_FADING, TODO
    }
  Module["_Mix_FadingChannel"] = _Mix_FadingChannel;

  function _Mix_HaltChannel(channel) {
      function halt(channel) {
        var info = SDL.channels[channel];
        if (info.audio) {
          info.audio.pause();
          info.audio = null;
        }
        if (SDL.channelFinished) {
          getFuncWrapper(SDL.channelFinished, 'vi')(channel);
        }
      }
      if (channel != -1) {
        halt(channel);
      } else {
        for (var i = 0; i < SDL.channels.length; ++i) halt(i);
      }
      return 0;
    }
  Module["_Mix_HaltChannel"] = _Mix_HaltChannel;

  
  function _Mix_HaltMusic() {
      var audio = SDL.music.audio;
      if (audio) {
        audio.src = audio.src; // rewind <media> element
        audio.currentPosition = 0; // rewind Web Audio graph playback.
        audio.pause();
      }
      SDL.music.audio = null;
      if (SDL.hookMusicFinished) {
        dynCall_v(SDL.hookMusicFinished);
      }
      return 0;
    }
  Module["_Mix_HaltMusic"] = _Mix_HaltMusic;function _Mix_HookMusicFinished(func) {
      SDL.hookMusicFinished = func;
      if (SDL.music.audio) { // ensure the callback will be called, if a music is already playing
        SDL.music.audio['onended'] = _Mix_HaltMusic;
      }
    }
  Module["_Mix_HookMusicFinished"] = _Mix_HookMusicFinished;

  function _Mix_VolumeMusic(volume) {
      return SDL.setGetVolume(SDL.music, volume);
    }
  Module["_Mix_VolumeMusic"] = _Mix_VolumeMusic;

  /** @param {number|boolean=} a1 */
  function _Mix_LoadMUS_RW(a0,a1
  ) {
  return _Mix_LoadWAV_RW(a0,a1);
  }
  Module["_Mix_LoadMUS_RW"] = _Mix_LoadMUS_RW;

  function _Mix_LoadMUS(filename) {
      var rwops = _SDL_RWFromFile(filename);
      var result = _Mix_LoadMUS_RW(rwops);
      _SDL_FreeRW(rwops);
      return result;
    }
  Module["_Mix_LoadMUS"] = _Mix_LoadMUS;

  function _Mix_FreeMusic(a0
  ) {
  return _Mix_FreeChunk(a0);
  }
  Module["_Mix_FreeMusic"] = _Mix_FreeMusic;

  function _Mix_PlayMusic(id, loops) {
      // Pause old music if it exists.
      if (SDL.music.audio) {
        if (!SDL.music.audio.paused) err('Music is already playing. ' + SDL.music.source);
        SDL.music.audio.pause();
      }
      var info = SDL.audios[id];
      var audio;
      if (info.webAudio) { // Play via Web Audio API
        // Create an instance of the WebAudio object.
        audio = {};
        audio.resource = info; // This new webAudio object is an instance that refers to this existing resource.
        audio.paused = false;
        audio.currentPosition = 0;
        audio.play = function() { SDL.playWebAudio(this); }
        audio.pause = function() { SDL.pauseWebAudio(this); }
      } else if (info.audio) { // Play via the <audio> element
        audio = info.audio;
      }
      audio['onended'] = function() { if (SDL.music.audio == this) _Mix_HaltMusic(); } // will send callback
      audio.loop = loops != 0; // TODO: handle N loops for finite N
      audio.volume = SDL.music.volume;
      SDL.music.audio = audio;
      audio.play();
      return 0;
    }
  Module["_Mix_PlayMusic"] = _Mix_PlayMusic;

  function _Mix_PauseMusic() {
      var audio = SDL.music.audio;
      if (audio) audio.pause();
    }
  Module["_Mix_PauseMusic"] = _Mix_PauseMusic;

  function _Mix_ResumeMusic() {
      var audio = SDL.music.audio;
      if (audio) audio.play();
    }
  Module["_Mix_ResumeMusic"] = _Mix_ResumeMusic;


  function _Mix_FadeInMusicPos(a0,a1
  ) {
  return _Mix_PlayMusic(a0,a1);
  }
  Module["_Mix_FadeInMusicPos"] = _Mix_FadeInMusicPos;

  function _Mix_FadeOutMusic(
  ) {
  return _Mix_HaltMusic();
  }
  Module["_Mix_FadeOutMusic"] = _Mix_FadeOutMusic;

  function _Mix_PlayingMusic() {
      return (SDL.music.audio && !SDL.music.audio.paused) ? 1 : 0;
    }
  Module["_Mix_PlayingMusic"] = _Mix_PlayingMusic;

  function _Mix_Playing(channel) {
      if (channel === -1) {
        var count = 0;
        for (var i = 0; i < SDL.channels.length; i++) {
          count += _Mix_Playing(i);
        }
        return count;
      }
      var info = SDL.channels[channel];
      if (info && info.audio && !info.audio.paused) {
        return 1;
      }
      return 0;
    }
  Module["_Mix_Playing"] = _Mix_Playing;

  function _Mix_Pause(channel) {
      if (channel === -1) {
        for (var i = 0; i<SDL.channels.length;i++) {
          _Mix_Pause(i);
        }
        return;
      }
      var info = SDL.channels[channel];
      if (info && info.audio) {
        info.audio.pause();
      } else {
        //err('Mix_Pause: no sound found for channel: ' + channel);
      }
    }
  Module["_Mix_Pause"] = _Mix_Pause;

  function _Mix_Paused(channel) {
      if (channel === -1) {
        var pausedCount = 0;
        for (var i = 0; i<SDL.channels.length;i++) {
          pausedCount += _Mix_Paused(i);
        }
        return pausedCount;
      }
      var info = SDL.channels[channel];
      if (info && info.audio && info.audio.paused) {
        return 1;
      }
      return 0;
    }
  Module["_Mix_Paused"] = _Mix_Paused;

  function _Mix_PausedMusic() {
      return (SDL.music.audio && SDL.music.audio.paused) ? 1 : 0;
    }
  Module["_Mix_PausedMusic"] = _Mix_PausedMusic;

  function _Mix_Resume(channel) {
      if (channel === -1) {
        for (var i = 0; i<SDL.channels.length;i++) {
          _Mix_Resume(i);
        }
        return;
      }
      var info = SDL.channels[channel];
      if (info && info.audio) info.audio.play();
    }
  Module["_Mix_Resume"] = _Mix_Resume;

  function _TTF_Init() {
      // OffscreenCanvas 2D is faster than Canvas for text operations, so we use
      // it if it's available.
      try {
        var offscreenCanvas = new OffscreenCanvas(0, 0);
        SDL.ttfContext = offscreenCanvas.getContext('2d');
      } catch (ex) {
        var canvas = document.createElement('canvas');
        SDL.ttfContext = canvas.getContext('2d');
      }
  
      return 0;
    }
  Module["_TTF_Init"] = _TTF_Init;

  function _TTF_OpenFont(filename, size) {
      filename = PATH.normalize(UTF8ToString(filename));
      var id = SDL.fonts.length;
      SDL.fonts.push({
        name: filename, // but we don't actually do anything with it..
        size: size
      });
      return id;
    }
  Module["_TTF_OpenFont"] = _TTF_OpenFont;

  function _TTF_CloseFont(font) {
      SDL.fonts[font] = null;
    }
  Module["_TTF_CloseFont"] = _TTF_CloseFont;

  function _TTF_RenderText_Solid(font, text, color) {
      // XXX the font and color are ignored
      text = UTF8ToString(text) || ' '; // if given an empty string, still return a valid surface
      var fontData = SDL.fonts[font];
      var w = SDL.estimateTextWidth(fontData, text);
      var h = fontData.size;
      color = SDL.loadColorToCSSRGB(color); // XXX alpha breaks fonts?
      var fontString = SDL.makeFontString(h, fontData.name);
      var surf = SDL.makeSurface(w, h, 0, false, 'text:' + text); // bogus numbers..
      var surfData = SDL.surfaces[surf];
      surfData.ctx.save();
      surfData.ctx.fillStyle = color;
      surfData.ctx.font = fontString;
      // use bottom alignment, because it works
      // same in all browsers, more info here:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=737852
      surfData.ctx.textBaseline = 'bottom';
      surfData.ctx.fillText(text, 0, h|0);
      surfData.ctx.restore();
      return surf;
    }
  Module["_TTF_RenderText_Solid"] = _TTF_RenderText_Solid;

  function _TTF_RenderText_Blended(a0,a1,a2
  ) {
  return _TTF_RenderText_Solid(a0,a1,a2);
  }
  Module["_TTF_RenderText_Blended"] = _TTF_RenderText_Blended;

  function _TTF_RenderText_Shaded(a0,a1,a2
  ) {
  return _TTF_RenderText_Solid(a0,a1,a2);
  }
  Module["_TTF_RenderText_Shaded"] = _TTF_RenderText_Shaded;

  function _TTF_RenderUTF8_Solid(a0,a1,a2
  ) {
  return _TTF_RenderText_Solid(a0,a1,a2);
  }
  Module["_TTF_RenderUTF8_Solid"] = _TTF_RenderUTF8_Solid;

  
  function _TTF_SizeText(font, text, w, h) {
      var fontData = SDL.fonts[font];
      if (w) {
        HEAP32[((w)>>2)]=SDL.estimateTextWidth(fontData, UTF8ToString(text));
      }
      if (h) {
        HEAP32[((h)>>2)]=fontData.size;
      }
      return 0;
    }
  Module["_TTF_SizeText"] = _TTF_SizeText;function _TTF_SizeUTF8(a0,a1,a2,a3
  ) {
  return _TTF_SizeText(a0,a1,a2,a3);
  }
  Module["_TTF_SizeUTF8"] = _TTF_SizeUTF8;


  function _TTF_GlyphMetrics(font, ch, minx, maxx, miny, maxy, advance) {
      var fontData = SDL.fonts[font];
      var width = SDL.estimateTextWidth(fontData,  String.fromCharCode(ch));
  
      if (advance) {
        HEAP32[((advance)>>2)]=width;
      }
      if (minx) {
        HEAP32[((minx)>>2)]=0;
      }
      if (maxx) {
        HEAP32[((maxx)>>2)]=width;
      }
      if (miny) {
        HEAP32[((miny)>>2)]=0;
      }
      if (maxy) {
        HEAP32[((maxy)>>2)]=fontData.size;
      }
    }
  Module["_TTF_GlyphMetrics"] = _TTF_GlyphMetrics;

  function _TTF_FontAscent(font) {
      var fontData = SDL.fonts[font];
      return (fontData.size*0.98)|0; // XXX
    }
  Module["_TTF_FontAscent"] = _TTF_FontAscent;

  function _TTF_FontDescent(font) {
      var fontData = SDL.fonts[font];
      return (fontData.size*0.02)|0; // XXX
    }
  Module["_TTF_FontDescent"] = _TTF_FontDescent;

  function _TTF_FontHeight(font) {
      var fontData = SDL.fonts[font];
      return fontData.size;
    }
  Module["_TTF_FontHeight"] = _TTF_FontHeight;

  function _TTF_FontLineSkip(a0
  ) {
  return _TTF_FontHeight(a0);
  }
  Module["_TTF_FontLineSkip"] = _TTF_FontLineSkip;

  function _TTF_Quit() {
      out('TTF_Quit called (and ignored)');
    }
  Module["_TTF_Quit"] = _TTF_Quit;

  var SDL_gfx={drawRectangle:function(surf, x1, y1, x2, y2, action, cssColor) {
        x1 = x1 << 16 >> 16;
        y1 = y1 << 16 >> 16;
        x2 = x2 << 16 >> 16;
        y2 = y2 << 16 >> 16;
        var surfData = SDL.surfaces[surf];
        assert(!surfData.locked); // but we could unlock and re-lock if we must..
        // TODO: if ctx does not change, leave as is, and also do not re-set xStyle etc.
        var x = x1 < x2 ? x1 : x2;
        var y = y1 < y2 ? y1 : y2;
        var w = Math.abs(x2 - x1);
        var h = Math.abs(y2 - y1);
        surfData.ctx.save();
        surfData.ctx[action + 'Style'] = cssColor;
        surfData.ctx[action + 'Rect'](x, y, w, h);
        surfData.ctx.restore();
      },drawLine:function(surf, x1, y1, x2, y2, cssColor) {
        x1 = x1 << 16 >> 16;
        y1 = y1 << 16 >> 16;
        x2 = x2 << 16 >> 16;
        y2 = y2 << 16 >> 16;
        var surfData = SDL.surfaces[surf];
        assert(!surfData.locked); // but we could unlock and re-lock if we must..
        surfData.ctx.save();
        surfData.ctx.strokeStyle = cssColor;
        surfData.ctx.beginPath();
        surfData.ctx.moveTo(x1, y1);
        surfData.ctx.lineTo(x2, y2);
        surfData.ctx.stroke();
        surfData.ctx.restore();
      },drawEllipse:function(surf, x, y, rx, ry, action, cssColor) {
        x = x << 16 >> 16;
        y = y << 16 >> 16;
        rx = rx << 16 >> 16;
        ry = ry << 16 >> 16;
        var surfData = SDL.surfaces[surf];
        assert(!surfData.locked); // but we could unlock and re-lock if we must..
  
        surfData.ctx.save();
        surfData.ctx.beginPath();
        surfData.ctx.translate(x, y);
        surfData.ctx.scale(rx, ry);
        surfData.ctx.arc(0, 0, 1, 0, 2 * Math.PI);
        surfData.ctx.restore();
  
        surfData.ctx.save();
        surfData.ctx[action + 'Style'] = cssColor;
        surfData.ctx[action]();
        surfData.ctx.restore();
      },translateColorToCSSRGBA:function(rgba) {
        return 'rgba(' + (rgba>>>24) + ',' + (rgba>>16 & 0xff) + ',' + (rgba>>8 & 0xff) + ',' + (rgba&0xff) + ')';
      }};
  Module["SDL_gfx"] = SDL_gfx;

  function _boxColor(surf, x1, y1, x2, y2, color) {
      return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'fill', SDL_gfx.translateColorToCSSRGBA(color));
    }
  Module["_boxColor"] = _boxColor;

  function _boxRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
      return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'fill', SDL.translateRGBAToCSSRGBA(r, g, b, a));
    }
  Module["_boxRGBA"] = _boxRGBA;

  function _rectangleColor(surf, x1, y1, x2, y2, color) {
      return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'stroke', SDL_gfx.translateColorToCSSRGBA(color));
    }
  Module["_rectangleColor"] = _rectangleColor;

  function _rectangleRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
      return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'stroke', SDL.translateRGBAToCSSRGBA(r, g, b, a));
    }
  Module["_rectangleRGBA"] = _rectangleRGBA;

  function _ellipseColor(surf, x, y, rx, ry, color) {
      return SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'stroke', SDL_gfx.translateColorToCSSRGBA(color));
    }
  Module["_ellipseColor"] = _ellipseColor;

  function _ellipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
      return SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'stroke', SDL.translateRGBAToCSSRGBA(r, g, b, a));
    }
  Module["_ellipseRGBA"] = _ellipseRGBA;

  function _filledEllipseColor(surf, x, y, rx, ry, color) {
      return SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'fill', SDL_gfx.translateColorToCSSRGBA(color));
    }
  Module["_filledEllipseColor"] = _filledEllipseColor;

  function _filledEllipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
      return SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'fill', SDL.translateRGBAToCSSRGBA(r, g, b, a));
    }
  Module["_filledEllipseRGBA"] = _filledEllipseRGBA;

  function _lineColor(surf, x1, y1, x2, y2, color) {
      return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL_gfx.translateColorToCSSRGBA(color));
    }
  Module["_lineColor"] = _lineColor;

  function _lineRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
      return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL.translateRGBAToCSSRGBA(r, g, b, a));
    }
  Module["_lineRGBA"] = _lineRGBA;

  function _pixelRGBA(surf, x1, y1, r, g, b, a) {
      // This cannot be fast, to render many pixels this way!
      _boxRGBA(surf, x1, y1, x1, y1, r, g, b, a);
    }
  Module["_pixelRGBA"] = _pixelRGBA;




  function _SDL_GL_SwapBuffers() {
      if (Browser.doSwapBuffers) Browser.doSwapBuffers(); // in workers, this is used to send out a buffered frame
    }
  Module["_SDL_GL_SwapBuffers"] = _SDL_GL_SwapBuffers;
















  function _SDL_putenv(a0
  ) {
  return _putenv(a0);
  }
  Module["_SDL_putenv"] = _SDL_putenv;

  function _SDL_SetGamma(r, g, b) {
      return -1;
    }
  Module["_SDL_SetGamma"] = _SDL_SetGamma;

  function _SDL_SetGammaRamp(redTable, greenTable, blueTable) {
      return -1;
    }
  Module["_SDL_SetGammaRamp"] = _SDL_SetGammaRamp;




  function _SDL_JoystickOpened(deviceIndex) {
      return SDL.lastJoystickState.hasOwnProperty(deviceIndex+1) ? 1 : 0;
    }
  Module["_SDL_JoystickOpened"] = _SDL_JoystickOpened;

  function _SDL_JoystickIndex(joystick) {
      // joystick pointers are simply the deviceIndex+1.
      return joystick - 1;
    }
  Module["_SDL_JoystickIndex"] = _SDL_JoystickIndex;




















  function _SDL_EnableUNICODE(on) {
      var ret = SDL.unicode || 0;
      SDL.unicode = on;
      return ret;
    }
  Module["_SDL_EnableUNICODE"] = _SDL_EnableUNICODE;










  function _SDL_WM_IconifyWindow() { throw 'SDL_WM_IconifyWindow TODO' }
  Module["_SDL_WM_IconifyWindow"] = _SDL_WM_IconifyWindow;

  function _Mix_SetPostMix() { warnOnce('Mix_SetPostMix: TODO') }
  Module["_Mix_SetPostMix"] = _Mix_SetPostMix;

  function _Mix_VolumeChunk(chunk, volume) { throw 'Mix_VolumeChunk: TODO' }
  Module["_Mix_VolumeChunk"] = _Mix_VolumeChunk;

  function _Mix_SetPosition(channel, angle, distance) { throw 'Mix_SetPosition: TODO' }
  Module["_Mix_SetPosition"] = _Mix_SetPosition;

  function _Mix_QuerySpec() { throw 'Mix_QuerySpec: TODO' }
  Module["_Mix_QuerySpec"] = _Mix_QuerySpec;

  function _Mix_FadeInChannelTimed() { throw 'Mix_FadeInChannelTimed' }
  Module["_Mix_FadeInChannelTimed"] = _Mix_FadeInChannelTimed;

  function _Mix_FadeOutChannel() { throw 'Mix_FadeOutChannel' }
  Module["_Mix_FadeOutChannel"] = _Mix_FadeOutChannel;

  function _Mix_Linked_Version() { throw 'Mix_Linked_Version: TODO' }
  Module["_Mix_Linked_Version"] = _Mix_Linked_Version;


  function _SDL_WM_SetIcon() { /* This function would set the application window icon surface, which doesn't apply for web canvases, so a no-op. */ }
  Module["_SDL_WM_SetIcon"] = _SDL_WM_SetIcon;



  function _SDL_HasMMXExt() { return 0; }
  Module["_SDL_HasMMXExt"] = _SDL_HasMMXExt;


  function _SDL_Has3DNowExt() { return 0; }
  Module["_SDL_Has3DNowExt"] = _SDL_Has3DNowExt;




  
  function _glutPostRedisplay() {
      if (GLUT.displayFunc && !GLUT.requestedAnimationFrame) {
        GLUT.requestedAnimationFrame = true;
        Browser.requestAnimationFrame(function() {
          GLUT.requestedAnimationFrame = false;
          Browser.mainLoop.runIter(function() {
            dynCall_v(GLUT.displayFunc);
          });
        });
      }
    }
  Module["_glutPostRedisplay"] = _glutPostRedisplay;var GLUT={initTime:null,idleFunc:null,displayFunc:null,keyboardFunc:null,keyboardUpFunc:null,specialFunc:null,specialUpFunc:null,reshapeFunc:null,motionFunc:null,passiveMotionFunc:null,mouseFunc:null,buttons:0,modifiers:0,initWindowWidth:256,initWindowHeight:256,initDisplayMode:18,windowX:0,windowY:0,windowWidth:0,windowHeight:0,requestedAnimationFrame:false,saveModifiers:function(event) {
        GLUT.modifiers = 0;
        if (event['shiftKey'])
          GLUT.modifiers += 1; /* GLUT_ACTIVE_SHIFT */
        if (event['ctrlKey'])
          GLUT.modifiers += 2; /* GLUT_ACTIVE_CTRL */
        if (event['altKey'])
          GLUT.modifiers += 4; /* GLUT_ACTIVE_ALT */
      },onMousemove:function(event) {
        /* Send motion event only if the motion changed, prevents
         * spamming our app with uncessary callback call. It does happen in
         * Chrome on Windows.
         */
        var lastX = Browser.mouseX;
        var lastY = Browser.mouseY;
        Browser.calculateMouseEvent(event);
        var newX = Browser.mouseX;
        var newY = Browser.mouseY;
        if (newX == lastX && newY == lastY) return;
  
        if (GLUT.buttons == 0 && event.target == Module["canvas"] && GLUT.passiveMotionFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          dynCall_vii(GLUT.passiveMotionFunc, lastX, lastY);
        } else if (GLUT.buttons != 0 && GLUT.motionFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          dynCall_vii(GLUT.motionFunc, lastX, lastY);
        }
      },getSpecialKey:function(keycode) {
          var key = null;
          switch (keycode) {
            case 8:  key = 120 /* backspace */; break;
            case 46: key = 111 /* delete */; break;
  
            case 0x70 /*DOM_VK_F1*/: key = 1 /* GLUT_KEY_F1 */; break;
            case 0x71 /*DOM_VK_F2*/: key = 2 /* GLUT_KEY_F2 */; break;
            case 0x72 /*DOM_VK_F3*/: key = 3 /* GLUT_KEY_F3 */; break;
            case 0x73 /*DOM_VK_F4*/: key = 4 /* GLUT_KEY_F4 */; break;
            case 0x74 /*DOM_VK_F5*/: key = 5 /* GLUT_KEY_F5 */; break;
            case 0x75 /*DOM_VK_F6*/: key = 6 /* GLUT_KEY_F6 */; break;
            case 0x76 /*DOM_VK_F7*/: key = 7 /* GLUT_KEY_F7 */; break;
            case 0x77 /*DOM_VK_F8*/: key = 8 /* GLUT_KEY_F8 */; break;
            case 0x78 /*DOM_VK_F9*/: key = 9 /* GLUT_KEY_F9 */; break;
            case 0x79 /*DOM_VK_F10*/: key = 10 /* GLUT_KEY_F10 */; break;
            case 0x7a /*DOM_VK_F11*/: key = 11 /* GLUT_KEY_F11 */; break;
            case 0x7b /*DOM_VK_F12*/: key = 12 /* GLUT_KEY_F12 */; break;
            case 0x25 /*DOM_VK_LEFT*/: key = 100 /* GLUT_KEY_LEFT */; break;
            case 0x26 /*DOM_VK_UP*/: key = 101 /* GLUT_KEY_UP */; break;
            case 0x27 /*DOM_VK_RIGHT*/: key = 102 /* GLUT_KEY_RIGHT */; break;
            case 0x28 /*DOM_VK_DOWN*/: key = 103 /* GLUT_KEY_DOWN */; break;
            case 0x21 /*DOM_VK_PAGE_UP*/: key = 104 /* GLUT_KEY_PAGE_UP */; break;
            case 0x22 /*DOM_VK_PAGE_DOWN*/: key = 105 /* GLUT_KEY_PAGE_DOWN */; break;
            case 0x24 /*DOM_VK_HOME*/: key = 106 /* GLUT_KEY_HOME */; break;
            case 0x23 /*DOM_VK_END*/: key = 107 /* GLUT_KEY_END */; break;
            case 0x2d /*DOM_VK_INSERT*/: key = 108 /* GLUT_KEY_INSERT */; break;
  
            case 16   /*DOM_VK_SHIFT*/:
            case 0x05 /*DOM_VK_LEFT_SHIFT*/:
              key = 112 /* GLUT_KEY_SHIFT_L */;
              break;
            case 0x06 /*DOM_VK_RIGHT_SHIFT*/:
              key = 113 /* GLUT_KEY_SHIFT_R */;
              break;
  
            case 17   /*DOM_VK_CONTROL*/:
            case 0x03 /*DOM_VK_LEFT_CONTROL*/:
              key = 114 /* GLUT_KEY_CONTROL_L */;
              break;
            case 0x04 /*DOM_VK_RIGHT_CONTROL*/:
              key = 115 /* GLUT_KEY_CONTROL_R */;
              break;
  
            case 18   /*DOM_VK_ALT*/:
            case 0x02 /*DOM_VK_LEFT_ALT*/:
              key = 116 /* GLUT_KEY_ALT_L */;
              break;
            case 0x01 /*DOM_VK_RIGHT_ALT*/:
              key = 117 /* GLUT_KEY_ALT_R */;
              break;
          };
          return key;
      },getASCIIKey:function(event) {
        if (event['ctrlKey'] || event['altKey'] || event['metaKey']) return null;
  
        var keycode = event['keyCode'];
  
        /* The exact list is soooo hard to find in a canonical place! */
  
        if (48 <= keycode && keycode <= 57)
          return keycode; // numeric  TODO handle shift?
        if (65 <= keycode && keycode <= 90)
          return event['shiftKey'] ? keycode : keycode + 32;
        if (96 <= keycode && keycode <= 105)
          return keycode - 48; // numpad numbers
        if (106 <= keycode && keycode <= 111)
          return keycode - 106 + 42; // *,+-./  TODO handle shift?
  
        switch (keycode) {
          case 9:  // tab key
          case 13: // return key
          case 27: // escape
          case 32: // space
          case 61: // equal
            return keycode;
        }
  
        var s = event['shiftKey'];
        switch (keycode) {
          case 186: return s ? 58 : 59; // colon / semi-colon
          case 187: return s ? 43 : 61; // add / equal (these two may be wrong)
          case 188: return s ? 60 : 44; // less-than / comma
          case 189: return s ? 95 : 45; // dash
          case 190: return s ? 62 : 46; // greater-than / period
          case 191: return s ? 63 : 47; // forward slash
          case 219: return s ? 123 : 91; // open bracket
          case 220: return s ? 124 : 47; // back slash
          case 221: return s ? 125 : 93; // close braket
          case 222: return s ? 34 : 39; // single quote
        }
  
        return null;
      },onKeydown:function(event) {
        if (GLUT.specialFunc || GLUT.keyboardFunc) {
          var key = GLUT.getSpecialKey(event['keyCode']);
          if (key !== null) {
            if( GLUT.specialFunc ) {
              event.preventDefault();
              GLUT.saveModifiers(event);
              dynCall_viii(GLUT.specialFunc, key, Browser.mouseX, Browser.mouseY);
            }
          }
          else
          {
            key = GLUT.getASCIIKey(event);
            if( key !== null && GLUT.keyboardFunc ) {
              event.preventDefault();
              GLUT.saveModifiers(event);
              dynCall_viii(GLUT.keyboardFunc, key, Browser.mouseX, Browser.mouseY);
            }
          }
        }
      },onKeyup:function(event) {
        if (GLUT.specialUpFunc || GLUT.keyboardUpFunc) {
          var key = GLUT.getSpecialKey(event['keyCode']);
          if (key !== null) {
            if(GLUT.specialUpFunc) {
              event.preventDefault ();
              GLUT.saveModifiers(event);
              dynCall_viii(GLUT.specialUpFunc, key, Browser.mouseX, Browser.mouseY);
            }
          }
          else
          {
            key = GLUT.getASCIIKey(event);
            if( key !== null && GLUT.keyboardUpFunc ) {
              event.preventDefault ();
              GLUT.saveModifiers(event);
              dynCall_viii(GLUT.keyboardUpFunc, key, Browser.mouseX, Browser.mouseY);
            }
          }
        }
      },touchHandler:function(event) {
        if (event.target != Module['canvas']) {
          return;
        }
  
        var touches = event.changedTouches,
            main = touches[0],
            type = "";
  
        switch(event.type) {
          case "touchstart": type = "mousedown"; break;
          case "touchmove": type = "mousemove"; break;
          case "touchend": type = "mouseup"; break;
          default: return;
        }
  
        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(type, true, true, window, 1,
                                      main.screenX, main.screenY,
                                      main.clientX, main.clientY, false,
                                      false, false, false, 0/*main*/, null);
  
        main.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
      },onMouseButtonDown:function(event) {
        Browser.calculateMouseEvent(event);
  
        GLUT.buttons |= (1 << event['button']);
  
        if (event.target == Module["canvas"] && GLUT.mouseFunc) {
          try {
            event.target.setCapture();
          } catch (e) {}
          event.preventDefault();
          GLUT.saveModifiers(event);
          dynCall_viiii(GLUT.mouseFunc, event['button'], 0/*GLUT_DOWN*/, Browser.mouseX, Browser.mouseY);
        }
      },onMouseButtonUp:function(event) {
        Browser.calculateMouseEvent(event);
  
        GLUT.buttons &= ~(1 << event['button']);
  
        if (GLUT.mouseFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          dynCall_viiii(GLUT.mouseFunc, event['button'], 1/*GLUT_UP*/, Browser.mouseX, Browser.mouseY);
        }
      },onMouseWheel:function(event) {
        Browser.calculateMouseEvent(event);
  
        // cross-browser wheel delta
        var e = window.event || event; // old IE support
        // Note the minus sign that flips browser wheel direction (positive direction scrolls page down) to native wheel direction (positive direction is mouse wheel up)
        var delta = -Browser.getMouseWheelDelta(event);
        delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1)); // Quantize to integer so that minimum scroll is at least +/- 1.
  
        var button = 3; // wheel up
        if (delta < 0) {
          button = 4; // wheel down
        }
  
        if (GLUT.mouseFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          dynCall_viiii(GLUT.mouseFunc, button, 0/*GLUT_DOWN*/, Browser.mouseX, Browser.mouseY);
        }
      },onFullscreenEventChange:function(event) {
        var width;
        var height;
        if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
          width = screen["width"];
          height = screen["height"];
        } else {
          width = GLUT.windowWidth;
          height = GLUT.windowHeight;
          // TODO set position
          document.removeEventListener('fullscreenchange', GLUT.onFullscreenEventChange, true);
          document.removeEventListener('mozfullscreenchange', GLUT.onFullscreenEventChange, true);
          document.removeEventListener('webkitfullscreenchange', GLUT.onFullscreenEventChange, true);
        }
        Browser.setCanvasSize(width, height, true); // N.B. GLUT.reshapeFunc is also registered as a canvas resize callback.
                                                    // Just call it once here.
        /* Can't call _glutReshapeWindow as that requests cancelling fullscreen. */
        if (GLUT.reshapeFunc) {
          // console.log("GLUT.reshapeFunc (from FS): " + width + ", " + height);
          dynCall_vii(GLUT.reshapeFunc, width, height);
        }
        _glutPostRedisplay();
      }};
  Module["GLUT"] = GLUT;

  function _glutGetModifiers() { return GLUT.modifiers; }
  Module["_glutGetModifiers"] = _glutGetModifiers;

  function _glutInit(argcp, argv) {
      // Ignore arguments
      GLUT.initTime = Date.now();
  
      var isTouchDevice = 'ontouchstart' in document.documentElement;
      if (isTouchDevice) {
        // onMouseButtonDown, onMouseButtonUp and onMousemove handlers
        // depend on Browser.mouseX / Browser.mouseY fields. Those fields
        // don't get updated by touch events. So register a touchHandler
        // function that translates the touch events to mouse events.
  
        // GLUT doesn't support touch, mouse only, so from touch events we
        // are only looking at single finger touches to emulate left click,
        // so we can use workaround and convert all touch events in mouse
        // events. See touchHandler.
        window.addEventListener("touchmove", GLUT.touchHandler, true);
        window.addEventListener("touchstart", GLUT.touchHandler, true);
        window.addEventListener("touchend", GLUT.touchHandler, true);
      }
  
      window.addEventListener("keydown", GLUT.onKeydown, true);
      window.addEventListener("keyup", GLUT.onKeyup, true);
      window.addEventListener("mousemove", GLUT.onMousemove, true);
      window.addEventListener("mousedown", GLUT.onMouseButtonDown, true);
      window.addEventListener("mouseup", GLUT.onMouseButtonUp, true);
      // IE9, Chrome, Safari, Opera
      window.addEventListener("mousewheel", GLUT.onMouseWheel, true);
      // Firefox
      window.addEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
  
      Browser.resizeListeners.push(function(width, height) {
        if (GLUT.reshapeFunc) {
          dynCall_vii(GLUT.reshapeFunc, width, height);
        }
      });
  
      __ATEXIT__.push(function() {
        if (isTouchDevice) {
          window.removeEventListener("touchmove", GLUT.touchHandler, true);
          window.removeEventListener("touchstart", GLUT.touchHandler, true);
          window.removeEventListener("touchend", GLUT.touchHandler, true);
        }
  
        window.removeEventListener("keydown", GLUT.onKeydown, true);
        window.removeEventListener("keyup", GLUT.onKeyup, true);
        window.removeEventListener("mousemove", GLUT.onMousemove, true);
        window.removeEventListener("mousedown", GLUT.onMouseButtonDown, true);
        window.removeEventListener("mouseup", GLUT.onMouseButtonUp, true);
        // IE9, Chrome, Safari, Opera
        window.removeEventListener("mousewheel", GLUT.onMouseWheel, true);
        // Firefox
        window.removeEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
  
        Module["canvas"].width = Module["canvas"].height = 1;
      });
    }
  Module["_glutInit"] = _glutInit;

  function _glutInitWindowSize(width, height) {
      Browser.setCanvasSize( GLUT.initWindowWidth = width,
                             GLUT.initWindowHeight = height );
    }
  Module["_glutInitWindowSize"] = _glutInitWindowSize;

  function _glutInitWindowPosition(x, y) {
      // Ignore for now
    }
  Module["_glutInitWindowPosition"] = _glutInitWindowPosition;

  function _glutGet(type) {
      switch (type) {
        case 100: /* GLUT_WINDOW_X */
          return 0; /* TODO */
        case 101: /* GLUT_WINDOW_Y */
          return 0; /* TODO */
        case 102: /* GLUT_WINDOW_WIDTH */
          return Module['canvas'].width;
        case 103: /* GLUT_WINDOW_HEIGHT */
          return Module['canvas'].height;
        case 200: /* GLUT_SCREEN_WIDTH */
          return Module['canvas'].width;
        case 201: /* GLUT_SCREEN_HEIGHT */
          return Module['canvas'].height;
        case 500: /* GLUT_INIT_WINDOW_X */
          return 0; /* TODO */
        case 501: /* GLUT_INIT_WINDOW_Y */
          return 0; /* TODO */
        case 502: /* GLUT_INIT_WINDOW_WIDTH */
          return GLUT.initWindowWidth;
        case 503: /* GLUT_INIT_WINDOW_HEIGHT */
          return GLUT.initWindowHeight;
        case 700: /* GLUT_ELAPSED_TIME */
          var now = Date.now();
          return now - GLUT.initTime;
        case 0x0069: /* GLUT_WINDOW_STENCIL_SIZE */
          return Module.ctx.getContextAttributes().stencil ? 8 : 0;
        case 0x006A: /* GLUT_WINDOW_DEPTH_SIZE */
          return Module.ctx.getContextAttributes().depth ? 8 : 0;
        case 0x006E: /* GLUT_WINDOW_ALPHA_SIZE */
          return Module.ctx.getContextAttributes().alpha ? 8 : 0;
        case 0x0078: /* GLUT_WINDOW_NUM_SAMPLES */
          return Module.ctx.getContextAttributes().antialias ? 1 : 0;
  
        default:
          throw "glutGet(" + type + ") not implemented yet";
      }
    }
  Module["_glutGet"] = _glutGet;

  function _glutIdleFunc(func) {
      function callback() {
        if (GLUT.idleFunc) {
          dynCall_v(GLUT.idleFunc);
          Browser.safeSetTimeout(callback, 4); // HTML spec specifies a 4ms minimum delay on the main thread; workers might get more, but we standardize here
        }
      }
      if (!GLUT.idleFunc) {
        Browser.safeSetTimeout(callback, 0);
      }
      GLUT.idleFunc = func;
    }
  Module["_glutIdleFunc"] = _glutIdleFunc;

  function _glutTimerFunc(msec, func, value) {
      Browser.safeSetTimeout(function() { dynCall_vi(func, value); }, msec);
    }
  Module["_glutTimerFunc"] = _glutTimerFunc;

  function _glutDisplayFunc(func) {
      GLUT.displayFunc = func;
    }
  Module["_glutDisplayFunc"] = _glutDisplayFunc;

  function _glutKeyboardFunc(func) {
      GLUT.keyboardFunc = func;
    }
  Module["_glutKeyboardFunc"] = _glutKeyboardFunc;

  function _glutKeyboardUpFunc(func) {
      GLUT.keyboardUpFunc = func;
    }
  Module["_glutKeyboardUpFunc"] = _glutKeyboardUpFunc;

  function _glutSpecialFunc(func) {
      GLUT.specialFunc = func;
    }
  Module["_glutSpecialFunc"] = _glutSpecialFunc;

  function _glutSpecialUpFunc(func) {
      GLUT.specialUpFunc = func;
    }
  Module["_glutSpecialUpFunc"] = _glutSpecialUpFunc;

  function _glutReshapeFunc(func) {
      GLUT.reshapeFunc = func;
    }
  Module["_glutReshapeFunc"] = _glutReshapeFunc;

  function _glutMotionFunc(func) {
      GLUT.motionFunc = func;
    }
  Module["_glutMotionFunc"] = _glutMotionFunc;

  function _glutPassiveMotionFunc(func) {
      GLUT.passiveMotionFunc = func;
    }
  Module["_glutPassiveMotionFunc"] = _glutPassiveMotionFunc;

  function _glutMouseFunc(func) {
      GLUT.mouseFunc = func;
    }
  Module["_glutMouseFunc"] = _glutMouseFunc;

  function _glutSetCursor(cursor) {
      var cursorStyle = 'auto';
      switch(cursor) {
        case 0x0000: /* GLUT_CURSOR_RIGHT_ARROW */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0001: /* GLUT_CURSOR_LEFT_ARROW */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0002: /* GLUT_CURSOR_INFO */
          cursorStyle = 'pointer';
          break;
        case 0x0003: /* GLUT_CURSOR_DESTROY */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0004: /* GLUT_CURSOR_HELP */
          cursorStyle = 'help';
          break;
        case 0x0005: /* GLUT_CURSOR_CYCLE */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0006: /* GLUT_CURSOR_SPRAY */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0007: /* GLUT_CURSOR_WAIT */
          cursorStyle = 'wait';
          break;
        case 0x0008: /* GLUT_CURSOR_TEXT */
          cursorStyle = 'text';
          break;
        case 0x0009: /* GLUT_CURSOR_CROSSHAIR */
        case 0x0066: /* GLUT_CURSOR_FULL_CROSSHAIR */
          cursorStyle = 'crosshair';
          break;
        case 0x000A: /* GLUT_CURSOR_UP_DOWN */
          cursorStyle = 'ns-resize';
          break;
        case 0x000B: /* GLUT_CURSOR_LEFT_RIGHT */
          cursorStyle = 'ew-resize';
          break;
        case 0x000C: /* GLUT_CURSOR_TOP_SIDE */
          cursorStyle = 'n-resize';
          break;
        case 0x000D: /* GLUT_CURSOR_BOTTOM_SIDE */
          cursorStyle = 's-resize';
          break;
        case 0x000E: /* GLUT_CURSOR_LEFT_SIDE */
          cursorStyle = 'w-resize';
          break;
        case 0x000F: /* GLUT_CURSOR_RIGHT_SIDE */
          cursorStyle = 'e-resize';
          break;
        case 0x0010: /* GLUT_CURSOR_TOP_LEFT_CORNER */
          cursorStyle = 'nw-resize';
          break;
        case 0x0011: /* GLUT_CURSOR_TOP_RIGHT_CORNER */
          cursorStyle = 'ne-resize';
          break;
        case 0x0012: /* GLUT_CURSOR_BOTTOM_RIGHT_CORNER */
          cursorStyle = 'se-resize';
          break;
        case 0x0013: /* GLUT_CURSOR_BOTTOM_LEFT_CORNER */
          cursorStyle = 'sw-resize';
          break;
        case 0x0064: /* GLUT_CURSOR_INHERIT */
          break;
        case 0x0065: /* GLUT_CURSOR_NONE */
          cursorStyle = 'none';
          break;
        default:
          throw "glutSetCursor: Unknown cursor type: " + cursor;
      }
      Module['canvas'].style.cursor = cursorStyle;
    }
  Module["_glutSetCursor"] = _glutSetCursor;

  function _glutCreateWindow(name) {
      var contextAttributes = {
        antialias: ((GLUT.initDisplayMode & 0x0080 /*GLUT_MULTISAMPLE*/) != 0),
        depth: ((GLUT.initDisplayMode & 0x0010 /*GLUT_DEPTH*/) != 0),
        stencil: ((GLUT.initDisplayMode & 0x0020 /*GLUT_STENCIL*/) != 0),
        alpha: ((GLUT.initDisplayMode & 0x0008 /*GLUT_ALPHA*/) != 0)
      };
      Module.ctx = Browser.createContext(Module['canvas'], true, true, contextAttributes);
      return Module.ctx ? 1 /* a new GLUT window ID for the created context */ : 0 /* failure */;
    }
  Module["_glutCreateWindow"] = _glutCreateWindow;

  function _glutDestroyWindow(name) {
      Module.ctx = Browser.destroyContext(Module['canvas'], true, true);
      return 1;
    }
  Module["_glutDestroyWindow"] = _glutDestroyWindow;

  function _glutReshapeWindow(width, height) {
      Browser.exitFullscreen();
      Browser.setCanvasSize(width, height, true); // N.B. GLUT.reshapeFunc is also registered as a canvas resize callback.
                                                  // Just call it once here.
      if (GLUT.reshapeFunc) {
        dynCall_vii(GLUT.reshapeFunc, width, height);
      }
      _glutPostRedisplay();
    }
  Module["_glutReshapeWindow"] = _glutReshapeWindow;

  function _glutPositionWindow(x, y) {
      Browser.exitFullscreen();
      /* TODO */
      _glutPostRedisplay();
    }
  Module["_glutPositionWindow"] = _glutPositionWindow;

  function _glutFullScreen() {
      GLUT.windowX = 0; // TODO
      GLUT.windowY = 0; // TODO
      GLUT.windowWidth  = Module['canvas'].width;
      GLUT.windowHeight = Module['canvas'].height;
      document.addEventListener('fullscreenchange', GLUT.onFullscreenEventChange, true);
      document.addEventListener('mozfullscreenchange', GLUT.onFullscreenEventChange, true);
      document.addEventListener('webkitfullscreenchange', GLUT.onFullscreenEventChange, true);
      Browser.requestFullscreen(/*lockPointer=*/false, /*resizeCanvas=*/false);
    }
  Module["_glutFullScreen"] = _glutFullScreen;

  function _glutInitDisplayMode(mode) {
      GLUT.initDisplayMode = mode;
    }
  Module["_glutInitDisplayMode"] = _glutInitDisplayMode;

  function _glutSwapBuffers() {}
  Module["_glutSwapBuffers"] = _glutSwapBuffers;


  function _glutMainLoop() {
      _glutReshapeWindow(Module['canvas'].width, Module['canvas'].height);
      _glutPostRedisplay();
      throw 'unwind';
    }
  Module["_glutMainLoop"] = _glutMainLoop;

  function _XOpenDisplay() {
      return 1; // We support 1 display, the canvas
    }
  Module["_XOpenDisplay"] = _XOpenDisplay;

  function _XCreateWindow(display, parent, x, y, width, height, border_width, depth, class_, visual, valuemask, attributes) {
      // All we can do is set the width and height
      Browser.setCanvasSize(width, height);
      return 2;
    }
  Module["_XCreateWindow"] = _XCreateWindow;

  function _XChangeWindowAttributes(){}
  Module["_XChangeWindowAttributes"] = _XChangeWindowAttributes;

  function _XSetWMHints(){}
  Module["_XSetWMHints"] = _XSetWMHints;

  function _XMapWindow(){}
  Module["_XMapWindow"] = _XMapWindow;

  function _XStoreName(){}
  Module["_XStoreName"] = _XStoreName;

  function _XInternAtom(display, name_, hmm) { return 0 }
  Module["_XInternAtom"] = _XInternAtom;

  function _XSendEvent(){}
  Module["_XSendEvent"] = _XSendEvent;

  function _XPending(display) { return 0 }
  Module["_XPending"] = _XPending;





  function _eglGetConfigs(display, configs, config_size, numConfigs) {
      return EGL.chooseConfig(display, 0, configs, config_size, numConfigs);
    }
  Module["_eglGetConfigs"] = _eglGetConfigs;







  function _eglQuerySurface(display, surface, attribute, value) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (surface != 62006 /* Magic ID for Emscripten 'default surface' */) {
        EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
        return 0;
      }
      if (!value) {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0;
      }
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      switch(attribute) {
      case 0x3028: // EGL_CONFIG_ID
        HEAP32[((value)>>2)]=62002;
          return 1;
      case 0x3058: // EGL_LARGEST_PBUFFER
        // Odd EGL API: If surface is not a pbuffer surface, 'value' should not be written to. It's not specified as an error, so true should(?) be returned.
        // Existing Android implementation seems to do so at least.
        return 1;
      case 0x3057: // EGL_WIDTH
        HEAP32[((value)>>2)]=Module["canvas"].width;
        return 1;
      case 0x3056: // EGL_HEIGHT
        HEAP32[((value)>>2)]=Module["canvas"].height;
        return 1;
      case 0x3090: // EGL_HORIZONTAL_RESOLUTION
        HEAP32[((value)>>2)]=-1;
        return 1;
      case 0x3091: // EGL_VERTICAL_RESOLUTION
        HEAP32[((value)>>2)]=-1;
        return 1;
      case 0x3092: // EGL_PIXEL_ASPECT_RATIO
        HEAP32[((value)>>2)]=-1;
        return 1;
      case 0x3086: // EGL_RENDER_BUFFER
        // The main surface is bound to the visible canvas window - it's always backbuffered.
        // Alternative to EGL_BACK_BUFFER would be EGL_SINGLE_BUFFER.
        HEAP32[((value)>>2)]=0x3084;
        return 1;
      case 0x3099: // EGL_MULTISAMPLE_RESOLVE
        HEAP32[((value)>>2)]=0x309A;
        return 1;
      case 0x3093: // EGL_SWAP_BEHAVIOR
        // The two possibilities are EGL_BUFFER_PRESERVED and EGL_BUFFER_DESTROYED. Slightly unsure which is the
        // case for browser environment, but advertise the 'weaker' behavior to be sure.
        HEAP32[((value)>>2)]=0x3095;
        return 1;
      case 0x3080: // EGL_TEXTURE_FORMAT
      case 0x3081: // EGL_TEXTURE_TARGET
      case 0x3082: // EGL_MIPMAP_TEXTURE
      case 0x3083: // EGL_MIPMAP_LEVEL
        // This is a window surface, not a pbuffer surface. Spec:
        // "Querying EGL_TEXTURE_FORMAT, EGL_TEXTURE_TARGET, EGL_MIPMAP_TEXTURE, or EGL_MIPMAP_LEVEL for a non-pbuffer surface is not an error, but value is not modified."
        // So pass-through.
        return 1;
      default:
        EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
        return 0;
      }
    }
  Module["_eglQuerySurface"] = _eglQuerySurface;

  function _eglQueryContext(display, context, attribute, value) {
      if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
      if (context != 62004 /* Magic ID for Emscripten EGLContext */) {
        EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
        return 0;
      }
      if (!value) {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0;
      }
  
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      switch(attribute) {
        case 0x3028: // EGL_CONFIG_ID
          HEAP32[((value)>>2)]=62002;
          return 1;
        case 0x3097: // EGL_CONTEXT_CLIENT_TYPE
          HEAP32[((value)>>2)]=0x30A0;
          return 1;
        case 0x3098: // EGL_CONTEXT_CLIENT_VERSION
          HEAP32[((value)>>2)]=EGL.contextAttributes.majorVersion + 1;
          return 1;
        case 0x3086: // EGL_RENDER_BUFFER
          // The context is bound to the visible canvas window - it's always backbuffered.
          // Alternative to EGL_BACK_BUFFER would be EGL_SINGLE_BUFFER.
          HEAP32[((value)>>2)]=0x3084;
          return 1;
        default:
          EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
          return 0;
      }
    }
  Module["_eglQueryContext"] = _eglQueryContext;




  function _eglQueryAPI() {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 0x30A0; // EGL_OPENGL_ES_API
    }
  Module["_eglQueryAPI"] = _eglQueryAPI;






  function _eglGetCurrentContext() {
      return EGL.currentContext;
    }
  Module["_eglGetCurrentContext"] = _eglGetCurrentContext;

  function _eglGetCurrentSurface(readdraw) {
      if (readdraw == 0x305A /* EGL_READ */) {
        return EGL.currentReadSurface;
      } else if (readdraw == 0x3059 /* EGL_DRAW */) {
        return EGL.currentDrawSurface;
      } else {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0 /* EGL_NO_SURFACE */;
      }
    }
  Module["_eglGetCurrentSurface"] = _eglGetCurrentSurface;

  function _eglGetCurrentDisplay() {
      return EGL.currentContext ? 62000 /* Magic ID for Emscripten 'default display' */ : 0;
    }
  Module["_eglGetCurrentDisplay"] = _eglGetCurrentDisplay;



  function _eglReleaseThread() {
      // Equivalent to eglMakeCurrent with EGL_NO_CONTEXT and EGL_NO_SURFACE.
      EGL.currentContext = 0;
      EGL.currentReadSurface = 0;
      EGL.currentDrawSurface = 0;
      // EGL spec v1.4 p.55:
      // "calling eglGetError immediately following a successful call to eglReleaseThread should not be done.
      //  Such a call will return EGL_SUCCESS - but will also result in reallocating per-thread state."
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1 /* EGL_TRUE */;
    }
  Module["_eglReleaseThread"] = _eglReleaseThread;

  
  var GLFW={WindowFromId:function(id) {
        if (id <= 0 || !GLFW.windows) return null;
        return GLFW.windows[id - 1];
      },joystickFunc:null,errorFunc:null,monitorFunc:null,active:null,windows:null,monitors:null,monitorString:null,versionString:null,initialTime:null,extensions:null,hints:null,defaultHints:{131073:0,131074:0,131075:1,131076:1,131077:1,135169:8,135170:8,135171:8,135172:8,135173:24,135174:8,135175:0,135176:0,135177:0,135178:0,135179:0,135180:0,135181:0,135182:0,135183:0,139265:196609,139266:1,139267:0,139268:0,139269:0,139270:0,139271:0,139272:0},DOMToGLFWKeyCode:function(keycode) {
        switch (keycode) {
          // these keycodes are only defined for GLFW3, assume they are the same for GLFW2
          case 0x20:return 32; // DOM_VK_SPACE -> GLFW_KEY_SPACE
          case 0xDE:return 39; // DOM_VK_QUOTE -> GLFW_KEY_APOSTROPHE
          case 0xBC:return 44; // DOM_VK_COMMA -> GLFW_KEY_COMMA
          case 0xAD:return 45; // DOM_VK_HYPHEN_MINUS -> GLFW_KEY_MINUS
          case 0xBD:return 45; // DOM_VK_MINUS -> GLFW_KEY_MINUS
          case 0xBE:return 46; // DOM_VK_PERIOD -> GLFW_KEY_PERIOD
          case 0xBF:return 47; // DOM_VK_SLASH -> GLFW_KEY_SLASH
          case 0x30:return 48; // DOM_VK_0 -> GLFW_KEY_0
          case 0x31:return 49; // DOM_VK_1 -> GLFW_KEY_1
          case 0x32:return 50; // DOM_VK_2 -> GLFW_KEY_2
          case 0x33:return 51; // DOM_VK_3 -> GLFW_KEY_3
          case 0x34:return 52; // DOM_VK_4 -> GLFW_KEY_4
          case 0x35:return 53; // DOM_VK_5 -> GLFW_KEY_5
          case 0x36:return 54; // DOM_VK_6 -> GLFW_KEY_6
          case 0x37:return 55; // DOM_VK_7 -> GLFW_KEY_7
          case 0x38:return 56; // DOM_VK_8 -> GLFW_KEY_8
          case 0x39:return 57; // DOM_VK_9 -> GLFW_KEY_9
          case 0x3B:return 59; // DOM_VK_SEMICOLON -> GLFW_KEY_SEMICOLON
          case 0x3D:return 61; // DOM_VK_EQUALS -> GLFW_KEY_EQUAL
          case 0xBB:return 61; // DOM_VK_EQUALS -> GLFW_KEY_EQUAL
          case 0x41:return 65; // DOM_VK_A -> GLFW_KEY_A
          case 0x42:return 66; // DOM_VK_B -> GLFW_KEY_B
          case 0x43:return 67; // DOM_VK_C -> GLFW_KEY_C
          case 0x44:return 68; // DOM_VK_D -> GLFW_KEY_D
          case 0x45:return 69; // DOM_VK_E -> GLFW_KEY_E
          case 0x46:return 70; // DOM_VK_F -> GLFW_KEY_F
          case 0x47:return 71; // DOM_VK_G -> GLFW_KEY_G
          case 0x48:return 72; // DOM_VK_H -> GLFW_KEY_H
          case 0x49:return 73; // DOM_VK_I -> GLFW_KEY_I
          case 0x4A:return 74; // DOM_VK_J -> GLFW_KEY_J
          case 0x4B:return 75; // DOM_VK_K -> GLFW_KEY_K
          case 0x4C:return 76; // DOM_VK_L -> GLFW_KEY_L
          case 0x4D:return 77; // DOM_VK_M -> GLFW_KEY_M
          case 0x4E:return 78; // DOM_VK_N -> GLFW_KEY_N
          case 0x4F:return 79; // DOM_VK_O -> GLFW_KEY_O
          case 0x50:return 80; // DOM_VK_P -> GLFW_KEY_P
          case 0x51:return 81; // DOM_VK_Q -> GLFW_KEY_Q
          case 0x52:return 82; // DOM_VK_R -> GLFW_KEY_R
          case 0x53:return 83; // DOM_VK_S -> GLFW_KEY_S
          case 0x54:return 84; // DOM_VK_T -> GLFW_KEY_T
          case 0x55:return 85; // DOM_VK_U -> GLFW_KEY_U
          case 0x56:return 86; // DOM_VK_V -> GLFW_KEY_V
          case 0x57:return 87; // DOM_VK_W -> GLFW_KEY_W
          case 0x58:return 88; // DOM_VK_X -> GLFW_KEY_X
          case 0x59:return 89; // DOM_VK_Y -> GLFW_KEY_Y
          case 0x5a:return 90; // DOM_VK_Z -> GLFW_KEY_Z
          case 0xDB:return 91; // DOM_VK_OPEN_BRACKET -> GLFW_KEY_LEFT_BRACKET
          case 0xDC:return 92; // DOM_VK_BACKSLASH -> GLFW_KEY_BACKSLASH
          case 0xDD:return 93; // DOM_VK_CLOSE_BRACKET -> GLFW_KEY_RIGHT_BRACKET
          case 0xC0:return 94; // DOM_VK_BACK_QUOTE -> GLFW_KEY_GRAVE_ACCENT
  
          //#define GLFW_KEY_SPECIAL      256
          case 0x1B:return (256+1); // DOM_VK_ESCAPE -> GLFW_KEY_ESC
          case 0x70:return (256+2); // DOM_VK_F1 -> GLFW_KEY_F1
          case 0x71:return (256+3); // DOM_VK_F2 -> GLFW_KEY_F2
          case 0x72:return (256+4); // DOM_VK_F3 -> GLFW_KEY_F3
          case 0x73:return (256+5); // DOM_VK_F4 -> GLFW_KEY_F4
          case 0x74:return (256+6); // DOM_VK_F5 -> GLFW_KEY_F5
          case 0x75:return (256+7); // DOM_VK_F6 -> GLFW_KEY_F6
          case 0x76:return (256+8); // DOM_VK_F7 -> GLFW_KEY_F7
          case 0x77:return (256+9); // DOM_VK_F8 -> GLFW_KEY_F8
          case 0x78:return (256+10); // DOM_VK_F9 -> GLFW_KEY_F9
          case 0x79:return (256+11); // DOM_VK_F10 -> GLFW_KEY_F10
          case 0x7A:return (256+12); // DOM_VK_F11 -> GLFW_KEY_F11
          case 0x7B:return (256+13); // DOM_VK_F12 -> GLFW_KEY_F12
          case 0x7C:return (256+14); // DOM_VK_F13 -> GLFW_KEY_F13
          case 0x7D:return (256+15); // DOM_VK_F14 -> GLFW_KEY_F14
          case 0x7E:return (256+16); // DOM_VK_F15 -> GLFW_KEY_F15
          case 0x7F:return (256+17); // DOM_VK_F16 -> GLFW_KEY_F16
          case 0x80:return (256+18); // DOM_VK_F17 -> GLFW_KEY_F17
          case 0x81:return (256+19); // DOM_VK_F18 -> GLFW_KEY_F18
          case 0x82:return (256+20); // DOM_VK_F19 -> GLFW_KEY_F19
          case 0x83:return (256+21); // DOM_VK_F20 -> GLFW_KEY_F20
          case 0x84:return (256+22); // DOM_VK_F21 -> GLFW_KEY_F21
          case 0x85:return (256+23); // DOM_VK_F22 -> GLFW_KEY_F22
          case 0x86:return (256+24); // DOM_VK_F23 -> GLFW_KEY_F23
          case 0x87:return (256+25); // DOM_VK_F24 -> GLFW_KEY_F24
          case 0x88:return (256+26); // 0x88 (not used?) -> GLFW_KEY_F25
          case 0x27:return (256+30); // DOM_VK_RIGHT -> GLFW_KEY_RIGHT
          case 0x25:return (256+29); // DOM_VK_LEFT -> GLFW_KEY_LEFT
          case 0x28:return (256+28); // DOM_VK_DOWN -> GLFW_KEY_DOWN
          case 0x26:return (256+27); // DOM_VK_UP -> GLFW_KEY_UP
          case 0x10:return (256+31); // DOM_VK_SHIFT -> GLFW_KEY_LSHIFT
          // #define GLFW_KEY_RSHIFT       (GLFW_KEY_SPECIAL+32)
          case 0x11:return (256+33); // DOM_VK_CONTROL -> GLFW_KEY_LCTRL
          // #define GLFW_KEY_RCTRL        (GLFW_KEY_SPECIAL+34)
          case 0x12:return (256+35); // DOM_VK_ALT -> GLFW_KEY_LALT
          // #define GLFW_KEY_RALT         (GLFW_KEY_SPECIAL+36)
          case 0x09:return (256+37); // DOM_VK_TAB -> GLFW_KEY_TAB
          case 0x0D:return (256+38); // DOM_VK_RETURN -> GLFW_KEY_ENTER
          case 0x08:return (256+39); // DOM_VK_BACK -> GLFW_KEY_BACKSPACE
          case 0x2D:return (256+40); // DOM_VK_INSERT -> GLFW_KEY_INSERT
          case 0x2E:return (256+41); // DOM_VK_DELETE -> GLFW_KEY_DEL
          case 0x21:return (256+42); // DOM_VK_PAGE_UP -> GLFW_KEY_PAGEUP
          case 0x22:return (256+43); // DOM_VK_PAGE_DOWN -> GLFW_KEY_PAGEDOWN
          case 0x24:return (256+44); // DOM_VK_HOME -> GLFW_KEY_HOME
          case 0x23:return (256+45); // DOM_VK_END -> GLFW_KEY_END
          case 0x60:return (256+46); // DOM_VK_NUMPAD0 -> GLFW_KEY_KP_0
          case 0x61:return (256+47); // DOM_VK_NUMPAD1 -> GLFW_KEY_KP_1
          case 0x62:return (256+48); // DOM_VK_NUMPAD2 -> GLFW_KEY_KP_2
          case 0x63:return (256+49); // DOM_VK_NUMPAD3 -> GLFW_KEY_KP_3
          case 0x64:return (256+50); // DOM_VK_NUMPAD4 -> GLFW_KEY_KP_4
          case 0x65:return (256+51); // DOM_VK_NUMPAD5 -> GLFW_KEY_KP_5
          case 0x66:return (256+52); // DOM_VK_NUMPAD6 -> GLFW_KEY_KP_6
          case 0x67:return (256+53); // DOM_VK_NUMPAD7 -> GLFW_KEY_KP_7
          case 0x68:return (256+54); // DOM_VK_NUMPAD8 -> GLFW_KEY_KP_8
          case 0x69:return (256+55); // DOM_VK_NUMPAD9 -> GLFW_KEY_KP_9
          case 0x6F:return (256+56); // DOM_VK_DIVIDE -> GLFW_KEY_KP_DIVIDE
          case 0x6A:return (256+57); // DOM_VK_MULTIPLY -> GLFW_KEY_KP_MULTIPLY
          case 0x6D:return (256+58); // DOM_VK_SUBTRACT -> GLFW_KEY_KP_SUBTRACT
          case 0x6B:return (256+59); // DOM_VK_ADD -> GLFW_KEY_KP_ADD
          case 0x6E:return (256+60); // DOM_VK_DECIMAL -> GLFW_KEY_KP_DECIMAL
          // #define GLFW_KEY_KP_EQUAL     (GLFW_KEY_SPECIAL+61)
          // #define GLFW_KEY_KP_ENTER     (GLFW_KEY_SPECIAL+62)
          case 0x90:return (256+63); // DOM_VK_NUM_LOCK -> GLFW_KEY_KP_NUM_LOCK
          case 0x14:return (256+64); // DOM_VK_CAPS_LOCK -> GLFW_KEY_CAPS_LOCK
          case 0x91:return (256+65); // DOM_VK_SCROLL_LOCK -> GLFW_KEY_SCROLL_LOCK
          case 0x13:return (256+66); // DOM_VK_PAUSE -> GLFW_KEY_PAUSE
          case 0x5B:return (256+67); // DOM_VK_WIN -> GLFW_KEY_LSUPER
          // #define GLFW_KEY_RSUPER       (GLFW_KEY_SPECIAL+68)
          case 0x5D:return (256+69); // DOM_VK_CONTEXT_MENU -> GLFW_KEY_MENU
  
          default:return -1; // GLFW_KEY_UNKNOWN
        };
      },getModBits:function(win) {
        var mod = 0;
        if (win.keys[340]) mod |= 0x0001; // GLFW_MOD_SHIFT
        if (win.keys[341]) mod |= 0x0002; // GLFW_MOD_CONTROL
        if (win.keys[342]) mod |= 0x0004; // GLFW_MOD_ALT
        if (win.keys[343]) mod |= 0x0008; // GLFW_MOD_SUPER
        return mod;
      },onKeyPress:function(event) {
        if (!GLFW.active || !GLFW.active.charFunc) return;
        if (event.ctrlKey || event.metaKey) return;
  
        // correct unicode charCode is only available with onKeyPress event
        var charCode = event.charCode;
        if (charCode == 0 || (charCode >= 0x00 && charCode <= 0x1F)) return;
  
        dynCall_vii(GLFW.active.charFunc, charCode, 1);
  
      },onKeyChanged:function(keyCode, status) {
        if (!GLFW.active) return;
  
        var key = GLFW.DOMToGLFWKeyCode(keyCode);
        if (key == -1) return;
  
        GLFW.active.keys[key] = status;
        GLFW.active.domKeys[keyCode] = status;
        if (!GLFW.active.keyFunc) return;
  
        dynCall_vii(GLFW.active.keyFunc, key, status);
  
      },onGamepadConnected:function(event) {
        GLFW.refreshJoysticks();
      },onGamepadDisconnected:function(event) {
        GLFW.refreshJoysticks();
      },onKeydown:function(event) {
        GLFW.onKeyChanged(event.keyCode, 1); // GLFW_PRESS or GLFW_REPEAT
  
        // This logic comes directly from the sdl implementation. We cannot
        // call preventDefault on all keydown events otherwise onKeyPress will
        // not get called
        if (event.keyCode === 8 /* backspace */ || event.keyCode === 9 /* tab */) {
          event.preventDefault();
        }
      },onKeyup:function(event) {
        GLFW.onKeyChanged(event.keyCode, 0); // GLFW_RELEASE
      },onBlur:function(event) {
        if (!GLFW.active) return;
  
        for (var i = 0; i < GLFW.active.domKeys.length; ++i) {
          if (GLFW.active.domKeys[i]) {
            GLFW.onKeyChanged(i, 0); // GLFW_RELEASE
          }
        }
      },onMousemove:function(event) {
        if (!GLFW.active) return;
  
        Browser.calculateMouseEvent(event);
  
        if (event.target != Module["canvas"] || !GLFW.active.cursorPosFunc) return;
  
        dynCall_vii(GLFW.active.cursorPosFunc, Browser.mouseX, Browser.mouseY);
  
      },DOMToGLFWMouseButton:function(event) {
        // DOM and glfw have different button codes.
        // See http://www.w3schools.com/jsref/event_button.asp.
        var eventButton = event['button'];
        if (eventButton > 0) {
          if (eventButton == 1) {
            eventButton = 2;
          } else {
            eventButton = 1;
          }
        }
        return eventButton;
      },onMouseenter:function(event) {
        if (!GLFW.active) return;
  
        if (event.target != Module["canvas"] || !GLFW.active.cursorEnterFunc) return;
  
      },onMouseleave:function(event) {
        if (!GLFW.active) return;
  
        if (event.target != Module["canvas"] || !GLFW.active.cursorEnterFunc) return;
  
      },onMouseButtonChanged:function(event, status) {
        if (!GLFW.active) return;
  
        Browser.calculateMouseEvent(event);
  
        if (event.target != Module["canvas"]) return;
  
        var eventButton = GLFW.DOMToGLFWMouseButton(event);
  
        if (status == 1) { // GLFW_PRESS
          GLFW.active.buttons |= (1 << eventButton);
          try {
            event.target.setCapture();
          } catch (e) {}
        } else {  // GLFW_RELEASE
          GLFW.active.buttons &= ~(1 << eventButton);
        }
  
        if (!GLFW.active.mouseButtonFunc) return;
  
        dynCall_vii(GLFW.active.mouseButtonFunc, eventButton, status);
  
      },onMouseButtonDown:function(event) {
        if (!GLFW.active) return;
        GLFW.onMouseButtonChanged(event, 1); // GLFW_PRESS
      },onMouseButtonUp:function(event) {
        if (!GLFW.active) return;
        GLFW.onMouseButtonChanged(event, 0); // GLFW_RELEASE
      },onMouseWheel:function(event) {
        // Note the minus sign that flips browser wheel direction (positive direction scrolls page down) to native wheel direction (positive direction is mouse wheel up)
        var delta = -Browser.getMouseWheelDelta(event);
        delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1)); // Quantize to integer so that minimum scroll is at least +/- 1.
        GLFW.wheelPos += delta;
  
        if (!GLFW.active || !GLFW.active.scrollFunc || event.target != Module['canvas']) return;
  
        dynCall_vi(GLFW.active.scrollFunc, GLFW.wheelPos);
  
  
        event.preventDefault();
      },onCanvasResize:function(width, height) {
        if (!GLFW.active) return;
  
        var resizeNeeded = true;
  
        // If the client is requesting fullscreen mode
        if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
          GLFW.active.storedX = GLFW.active.x;
          GLFW.active.storedY = GLFW.active.y;
          GLFW.active.storedWidth = GLFW.active.width;
          GLFW.active.storedHeight = GLFW.active.height;
          GLFW.active.x = GLFW.active.y = 0;
          GLFW.active.width = screen.width;
          GLFW.active.height = screen.height;
          GLFW.active.fullscreen = true;
  
        // If the client is reverting from fullscreen mode
        } else if (GLFW.active.fullscreen == true) {
          GLFW.active.x = GLFW.active.storedX;
          GLFW.active.y = GLFW.active.storedY;
          GLFW.active.width = GLFW.active.storedWidth;
          GLFW.active.height = GLFW.active.storedHeight;
          GLFW.active.fullscreen = false;
  
        // If the width/height values do not match current active window sizes
        } else if (GLFW.active.width != width || GLFW.active.height != height) {
            GLFW.active.width = width;
            GLFW.active.height = height;
        } else {
          resizeNeeded = false;
        }
  
        // If any of the above conditions were true, we need to resize the canvas
        if (resizeNeeded) {
          // resets the canvas size to counter the aspect preservation of Browser.updateCanvasDimensions
          Browser.setCanvasSize(GLFW.active.width, GLFW.active.height, true);
          // TODO: Client dimensions (clientWidth/clientHeight) vs pixel dimensions (width/height) of
          // the canvas should drive window and framebuffer size respectfully.
          GLFW.onWindowSizeChanged();
          GLFW.onFramebufferSizeChanged();
        }
      },onWindowSizeChanged:function() {
        if (!GLFW.active) return;
  
        if (!GLFW.active.windowSizeFunc) return;
  
        dynCall_vii(GLFW.active.windowSizeFunc, GLFW.active.width, GLFW.active.height);
  
      },onFramebufferSizeChanged:function() {
        if (!GLFW.active) return;
  
        if (!GLFW.active.framebufferSizeFunc) return;
  
      },getTime:function() {
        return _emscripten_get_now() / 1000;
      },setWindowTitle:function(winid, title) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
        win.title = UTF8ToString(title);
        if (GLFW.active.id == win.id) {
          document.title = win.title;
        }
      },setJoystickCallback:function(cbfun) {
        GLFW.joystickFunc = cbfun;
        GLFW.refreshJoysticks();
      },joys:{},lastGamepadState:null,lastGamepadStateFrame:null,refreshJoysticks:function() {
        // Produce a new Gamepad API sample if we are ticking a new game frame, or if not using emscripten_set_main_loop() at all to drive animation.
        if (Browser.mainLoop.currentFrameNumber !== GLFW.lastGamepadStateFrame || !Browser.mainLoop.currentFrameNumber) {
          GLFW.lastGamepadState = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : null);
          GLFW.lastGamepadStateFrame = Browser.mainLoop.currentFrameNumber;
  
          for (var joy = 0; joy < GLFW.lastGamepadState.length; ++joy) {
            var gamepad = GLFW.lastGamepadState[joy];
  
            if (gamepad) {
              if (!GLFW.joys[joy]) {
                console.log('glfw joystick connected:',joy);
                GLFW.joys[joy] = {
                  id: allocate(intArrayFromString(gamepad.id), 'i8', ALLOC_NORMAL),
                  buttonsCount: gamepad.buttons.length,
                  axesCount: gamepad.axes.length,
                  buttons: allocate(new Array(gamepad.buttons.length), 'i8', ALLOC_NORMAL),
                  axes: allocate(new Array(gamepad.axes.length*4), 'float', ALLOC_NORMAL)
                };
  
                if (GLFW.joystickFunc) {
                  dynCall_vii(GLFW.joystickFunc, joy, 0x00040001); // GLFW_CONNECTED
                }
              }
  
              var data = GLFW.joys[joy];
  
              for (var i = 0; i < gamepad.buttons.length;  ++i) {
                setValue(data.buttons + i, gamepad.buttons[i].pressed, 'i8');
              }
  
              for (var i = 0; i < gamepad.axes.length; ++i) {
                setValue(data.axes + i*4, gamepad.axes[i], 'float');
              }
            } else {
              if (GLFW.joys[joy]) {
                console.log('glfw joystick disconnected',joy);
  
                if (GLFW.joystickFunc) {
                  dynCall_vii(GLFW.joystickFunc, joy, 0x00040002); // GLFW_DISCONNECTED
                }
  
                _free(GLFW.joys[joy].id);
                _free(GLFW.joys[joy].buttons);
                _free(GLFW.joys[joy].axes);
  
                delete GLFW.joys[joy];
              }
            }
          }
        }
      },setKeyCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.keyFunc;
        win.keyFunc = cbfun;
        return prevcbfun;
      },setCharCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.charFunc;
        win.charFunc = cbfun;
        return prevcbfun;
      },setMouseButtonCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.mouseButtonFunc;
        win.mouseButtonFunc = cbfun;
        return prevcbfun;
      },setCursorPosCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.cursorPosFunc;
        win.cursorPosFunc = cbfun;
        return prevcbfun;
      },setScrollCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.scrollFunc;
        win.scrollFunc = cbfun;
        return prevcbfun;
      },setDropCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.dropFunc;
        win.dropFunc = cbfun;
        return prevcbfun;
      },onDrop:function(event) {
        if (!GLFW.active || !GLFW.active.dropFunc) return;
        if (!event.dataTransfer || !event.dataTransfer.files || event.dataTransfer.files.length == 0) return;
  
        event.preventDefault();
  
        var filenames = allocate(new Array(event.dataTransfer.files.length*4), 'i8*', ALLOC_NORMAL);
        var filenamesArray = [];
        var count = event.dataTransfer.files.length;
  
        // Read and save the files to emscripten's FS
        var written = 0;
        var drop_dir = '.glfw_dropped_files';
        FS.createPath('/', drop_dir);
  
        function save(file) {
          var path = '/' + drop_dir + '/' + file.name.replace(/\//g, '_');
          var reader = new FileReader();
          reader.onloadend = function(e) {
            if (reader.readyState != 2) { // not DONE
              ++written;
              console.log('failed to read dropped file: '+file.name+': '+reader.error);
              return;
            }
  
            var data = e.target.result;
            FS.writeFile(path, new Uint8Array(data));
            if (++written === count) {
              dynCall_viii(GLFW.active.dropFunc, GLFW.active.id, count, filenames);
  
              for (var i = 0; i < filenamesArray.length; ++i) {
                _free(filenamesArray[i]);
              }
              _free(filenames);
            }
          };
          reader.readAsArrayBuffer(file);
  
          var filename = allocate(intArrayFromString(path), 'i8', ALLOC_NORMAL);
          filenamesArray.push(filename);
          setValue(filenames + i*4, filename, 'i8*');
        }
  
        for (var i = 0; i < count; ++i) {
          save(event.dataTransfer.files[i]);
        }
  
        return false;
      },onDragover:function(event) {
        if (!GLFW.active || !GLFW.active.dropFunc) return;
  
        event.preventDefault();
        return false;
      },setWindowSizeCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.windowSizeFunc;
        win.windowSizeFunc = cbfun;
  
        // As documented in GLFW2 API (http://www.glfw.org/GLFWReference27.pdf#page=22), when size
        // callback function is set, it will be called with the current window size before this
        // function returns.
        // GLFW3 on the over hand doesn't have this behavior (https://github.com/glfw/glfw/issues/62).
        if (!win.windowSizeFunc) return null;
        dynCall_vii(win.windowSizeFunc, win.width, win.height);
  
        return prevcbfun;
      },setWindowCloseCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.windowCloseFunc;
        win.windowCloseFunc = cbfun;
        return prevcbfun;
      },setWindowRefreshCallback:function(winid, cbfun) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.windowRefreshFunc;
        win.windowRefreshFunc = cbfun;
        return prevcbfun;
      },onClickRequestPointerLock:function(e) {
        if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
          Module['canvas'].requestPointerLock();
          e.preventDefault();
        }
      },setInputMode:function(winid, mode, value) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
        switch(mode) {
          case 0x00033001: { // GLFW_CURSOR
            switch(value) {
              case 0x00034001: { // GLFW_CURSOR_NORMAL
                win.inputModes[mode] = value;
                Module['canvas'].removeEventListener('click', GLFW.onClickRequestPointerLock, true);
                Module['canvas'].exitPointerLock();
                break;
              }
              case 0x00034002: { // GLFW_CURSOR_HIDDEN
                console.log("glfwSetInputMode called with GLFW_CURSOR_HIDDEN value not implemented.");
                break;
              }
              case 0x00034003: { // GLFW_CURSOR_DISABLED
                win.inputModes[mode] = value;
                Module['canvas'].addEventListener('click', GLFW.onClickRequestPointerLock, true);
                Module['canvas'].requestPointerLock();
                break;
              }
              default: {
                console.log("glfwSetInputMode called with unknown value parameter value: " + value + ".");
                break;
              }
            }
            break;
          }
          case 0x00033002: { // GLFW_STICKY_KEYS
            console.log("glfwSetInputMode called with GLFW_STICKY_KEYS mode not implemented.");
            break;
          }
          case 0x00033003: { // GLFW_STICKY_MOUSE_BUTTONS
            console.log("glfwSetInputMode called with GLFW_STICKY_MOUSE_BUTTONS mode not implemented.");
            break;
          }
          default: {
            console.log("glfwSetInputMode called with unknown mode parameter value: " + mode + ".");
            break;
          }
        }
      },getKey:function(winid, key) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return 0;
        return win.keys[key];
      },getMouseButton:function(winid, button) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return 0;
        return (win.buttons & (1 << button)) > 0;
      },getCursorPos:function(winid, x, y) {
        setValue(x, Browser.mouseX, 'double');
        setValue(y, Browser.mouseY, 'double');
      },getMousePos:function(winid, x, y) {
        setValue(x, Browser.mouseX, 'i32');
        setValue(y, Browser.mouseY, 'i32');
      },setCursorPos:function(winid, x, y) {
      },getWindowPos:function(winid, x, y) {
        var wx = 0;
        var wy = 0;
  
        var win = GLFW.WindowFromId(winid);
        if (win) {
          wx = win.x;
          wy = win.y;
        }
  
        setValue(x, wx, 'i32');
        setValue(y, wy, 'i32');
      },setWindowPos:function(winid, x, y) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
        win.x = x;
        win.y = y;
      },getWindowSize:function(winid, width, height) {
        var ww = 0;
        var wh = 0;
  
        var win = GLFW.WindowFromId(winid);
        if (win) {
          ww = win.width;
          wh = win.height;
        }
  
        setValue(width, ww, 'i32');
        setValue(height, wh, 'i32');
      },setWindowSize:function(winid, width, height) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
        if (GLFW.active.id == win.id) {
          if (width == screen.width && height == screen.height) {
            Browser.requestFullscreen();
          } else {
            Browser.exitFullscreen();
            Browser.setCanvasSize(width, height);
            win.width = width;
            win.height = height;
          }
        }
  
        if (!win.windowSizeFunc) return;
  
        dynCall_vii(win.windowSizeFunc, width, height);
  
      },createWindow:function(width, height, title, monitor, share) {
        var i, id;
        for (i = 0; i < GLFW.windows.length && GLFW.windows[i] !== null; i++) {
          // no-op
        }
        if (i > 0) throw "glfwCreateWindow only supports one window at time currently";
  
        // id for window
        id = i + 1;
  
        // not valid
        if (width <= 0 || height <= 0) return 0;
  
        if (monitor) {
          Browser.requestFullscreen();
        } else {
          Browser.setCanvasSize(width, height);
        }
  
        // Create context when there are no existing alive windows
        for (i = 0; i < GLFW.windows.length && GLFW.windows[i] == null; i++) {
          // no-op
        }
        if (i == GLFW.windows.length) {
          var contextAttributes = {
            antialias: (GLFW.hints[0x0002100D] > 1), // GLFW_SAMPLES
            depth: (GLFW.hints[0x00021005] > 0),     // GLFW_DEPTH_BITS
            stencil: (GLFW.hints[0x00021006] > 0),   // GLFW_STENCIL_BITS
            alpha: (GLFW.hints[0x00021004] > 0)      // GLFW_ALPHA_BITS
          }
          Module.ctx = Browser.createContext(Module['canvas'], true, true, contextAttributes);
        }
  
        // If context creation failed, do not return a valid window
        if (!Module.ctx) return 0;
  
        // Get non alive id
        var win = new GLFW_Window(id, width, height, title, monitor, share);
  
        // Set window to array
        if (id - 1 == GLFW.windows.length) {
          GLFW.windows.push(win);
        } else {
          GLFW.windows[id - 1] = win;
        }
  
        GLFW.active = win;
        return win.id;
      },destroyWindow:function(winid) {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
  
        GLFW.windows[win.id - 1] = null;
        if (GLFW.active.id == win.id)
          GLFW.active = null;
  
        // Destroy context when no alive windows
        for (var i = 0; i < GLFW.windows.length; i++)
          if (GLFW.windows[i] !== null) return;
  
        Module.ctx = Browser.destroyContext(Module['canvas'], true, true);
      },swapBuffers:function(winid) {
      },GLFW2ParamToGLFW3Param:function(param) {
        var table = {
          0x00030001:0, // GLFW_MOUSE_CURSOR
          0x00030002:0, // GLFW_STICKY_KEYS
          0x00030003:0, // GLFW_STICKY_MOUSE_BUTTONS
          0x00030004:0, // GLFW_SYSTEM_KEYS
          0x00030005:0, // GLFW_KEY_REPEAT
          0x00030006:0, // GLFW_AUTO_POLL_EVENTS
          0x00020001:0, // GLFW_OPENED
          0x00020002:0, // GLFW_ACTIVE
          0x00020003:0, // GLFW_ICONIFIED
          0x00020004:0, // GLFW_ACCELERATED
          0x00020005:0x00021001, // GLFW_RED_BITS
          0x00020006:0x00021002, // GLFW_GREEN_BITS
          0x00020007:0x00021003, // GLFW_BLUE_BITS
          0x00020008:0x00021004, // GLFW_ALPHA_BITS
          0x00020009:0x00021005, // GLFW_DEPTH_BITS
          0x0002000A:0x00021006, // GLFW_STENCIL_BITS
          0x0002000B:0x0002100F, // GLFW_REFRESH_RATE
          0x0002000C:0x00021007, // GLFW_ACCUM_RED_BITS
          0x0002000D:0x00021008, // GLFW_ACCUM_GREEN_BITS
          0x0002000E:0x00021009, // GLFW_ACCUM_BLUE_BITS
          0x0002000F:0x0002100A, // GLFW_ACCUM_ALPHA_BITS
          0x00020010:0x0002100B, // GLFW_AUX_BUFFERS
          0x00020011:0x0002100C, // GLFW_STEREO
          0x00020012:0, // GLFW_WINDOW_NO_RESIZE
          0x00020013:0x0002100D, // GLFW_FSAA_SAMPLES
          0x00020014:0x00022002, // GLFW_OPENGL_VERSION_MAJOR
          0x00020015:0x00022003, // GLFW_OPENGL_VERSION_MINOR
          0x00020016:0x00022006, // GLFW_OPENGL_FORWARD_COMPAT
          0x00020017:0x00022007, // GLFW_OPENGL_DEBUG_CONTEXT
          0x00020018:0x00022008, // GLFW_OPENGL_PROFILE
        };
        return table[param];
      }};
  Module["GLFW"] = GLFW;/** @constructor */
  function GLFW_Window(id, width, height, title, monitor, share) {
        this.id = id;
        this.x = 0;
        this.y = 0;
        this.fullscreen = false; // Used to determine if app in fullscreen mode
        this.storedX = 0; // Used to store X before fullscreen
        this.storedY = 0; // Used to store Y before fullscreen
        this.width = width;
        this.height = height;
        this.storedWidth = width; // Used to store width before fullscreen
        this.storedHeight = height; // Used to store height before fullscreen
        this.title = title;
        this.monitor = monitor;
        this.share = share;
        this.attributes = GLFW.hints;
        this.inputModes = {
          0x00033001:0x00034001, // GLFW_CURSOR (GLFW_CURSOR_NORMAL)
          0x00033002:0, // GLFW_STICKY_KEYS
          0x00033003:0, // GLFW_STICKY_MOUSE_BUTTONS
        };
        this.buttons = 0;
        this.keys = new Array();
        this.domKeys = new Array();
        this.shouldClose = 0;
        this.title = null;
        this.windowPosFunc = null; // GLFWwindowposfun
        this.windowSizeFunc = null; // GLFWwindowsizefun
        this.windowCloseFunc = null; // GLFWwindowclosefun
        this.windowRefreshFunc = null; // GLFWwindowrefreshfun
        this.windowFocusFunc = null; // GLFWwindowfocusfun
        this.windowIconifyFunc = null; // GLFWwindowiconifyfun
        this.framebufferSizeFunc = null; // GLFWframebuffersizefun
        this.mouseButtonFunc = null; // GLFWmousebuttonfun
        this.cursorPosFunc = null; // GLFWcursorposfun
        this.cursorEnterFunc = null; // GLFWcursorenterfun
        this.scrollFunc = null; // GLFWscrollfun
        this.dropFunc = null; // GLFWdropfun
        this.keyFunc = null; // GLFWkeyfun
        this.charFunc = null; // GLFWcharfun
        this.userptr = null;
      }
  Module["GLFW_Window"] = GLFW_Window;


  function _glfwInit() {
      if (GLFW.windows) return 1; // GL_TRUE
  
      GLFW.initialTime = GLFW.getTime();
      GLFW.hints = GLFW.defaultHints;
      GLFW.windows = new Array()
      GLFW.active = null;
  
      window.addEventListener("gamepadconnected", GLFW.onGamepadConnected, true);
      window.addEventListener("gamepaddisconnected", GLFW.onGamepadDisconnected, true);
      window.addEventListener("keydown", GLFW.onKeydown, true);
      window.addEventListener("keypress", GLFW.onKeyPress, true);
      window.addEventListener("keyup", GLFW.onKeyup, true);
      window.addEventListener("blur", GLFW.onBlur, true);
      Module["canvas"].addEventListener("touchmove", GLFW.onMousemove, true);
      Module["canvas"].addEventListener("touchstart", GLFW.onMouseButtonDown, true);
      Module["canvas"].addEventListener("touchcancel", GLFW.onMouseButtonUp, true);
      Module["canvas"].addEventListener("touchend", GLFW.onMouseButtonUp, true);
      Module["canvas"].addEventListener("mousemove", GLFW.onMousemove, true);
      Module["canvas"].addEventListener("mousedown", GLFW.onMouseButtonDown, true);
      Module["canvas"].addEventListener("mouseup", GLFW.onMouseButtonUp, true);
      Module["canvas"].addEventListener('wheel', GLFW.onMouseWheel, true);
      Module["canvas"].addEventListener('mousewheel', GLFW.onMouseWheel, true);
      Module["canvas"].addEventListener('mouseenter', GLFW.onMouseenter, true);
      Module["canvas"].addEventListener('mouseleave', GLFW.onMouseleave, true);
      Module["canvas"].addEventListener('drop', GLFW.onDrop, true);
      Module["canvas"].addEventListener('dragover', GLFW.onDragover, true);
  
      Browser.resizeListeners.push(function(width, height) {
         GLFW.onCanvasResize(width, height);
      });
      return 1; // GL_TRUE
    }
  Module["_glfwInit"] = _glfwInit;

  function _glfwTerminate() {
      window.removeEventListener("gamepadconnected", GLFW.onGamepadConnected, true);
      window.removeEventListener("gamepaddisconnected", GLFW.onGamepadDisconnected, true);
      window.removeEventListener("keydown", GLFW.onKeydown, true);
      window.removeEventListener("keypress", GLFW.onKeyPress, true);
      window.removeEventListener("keyup", GLFW.onKeyup, true);
      window.removeEventListener("blur", GLFW.onBlur, true);
      Module["canvas"].removeEventListener("touchmove", GLFW.onMousemove, true);
      Module["canvas"].removeEventListener("touchstart", GLFW.onMouseButtonDown, true);
      Module["canvas"].removeEventListener("touchcancel", GLFW.onMouseButtonUp, true);
      Module["canvas"].removeEventListener("touchend", GLFW.onMouseButtonUp, true);
      Module["canvas"].removeEventListener("mousemove", GLFW.onMousemove, true);
      Module["canvas"].removeEventListener("mousedown", GLFW.onMouseButtonDown, true);
      Module["canvas"].removeEventListener("mouseup", GLFW.onMouseButtonUp, true);
      Module["canvas"].removeEventListener('wheel', GLFW.onMouseWheel, true);
      Module["canvas"].removeEventListener('mousewheel', GLFW.onMouseWheel, true);
      Module["canvas"].removeEventListener('mouseenter', GLFW.onMouseenter, true);
      Module["canvas"].removeEventListener('mouseleave', GLFW.onMouseleave, true);
      Module["canvas"].removeEventListener('drop', GLFW.onDrop, true);
      Module["canvas"].removeEventListener('dragover', GLFW.onDragover, true);
  
  
      Module["canvas"].width = Module["canvas"].height = 1;
      GLFW.windows = null;
      GLFW.active = null;
    }
  Module["_glfwTerminate"] = _glfwTerminate;

  function _glfwGetVersion(major, minor, rev) {
      setValue(major, 2, 'i32');
      setValue(minor, 7, 'i32');
      setValue(rev, 7, 'i32');
  
    }
  Module["_glfwGetVersion"] = _glfwGetVersion;

  function _glfwPollEvents() {}
  Module["_glfwPollEvents"] = _glfwPollEvents;

  function _glfwWaitEvents() {}
  Module["_glfwWaitEvents"] = _glfwWaitEvents;

  function _glfwGetTime() {
      return GLFW.getTime() - GLFW.initialTime;
    }
  Module["_glfwGetTime"] = _glfwGetTime;

  function _glfwSetTime(time) {
      GLFW.initialTime = GLFW.getTime() - time;
    }
  Module["_glfwSetTime"] = _glfwSetTime;

  function _glfwExtensionSupported(extension) {
      if (!GLFW.extensions) {
        GLFW.extensions = UTF8ToString(_glGetString(0x1F03)).split(' ');
      }
  
      if (GLFW.extensions.indexOf(extension) != -1) return 1;
  
      // extensions from GLEmulations do not come unprefixed
      // so, try with prefix
      return (GLFW.extensions.indexOf("GL_" + extension) != -1);
    }
  Module["_glfwExtensionSupported"] = _glfwExtensionSupported;

  function _glfwGetProcAddress(procname) {
      return _emscripten_GetProcAddress(procname);
    }
  Module["_glfwGetProcAddress"] = _glfwGetProcAddress;

  function _glfwSwapInterval(interval) {
      interval = Math.abs(interval); // GLFW uses negative values to enable GLX_EXT_swap_control_tear, which we don't have, so just treat negative and positive the same.
      if (interval == 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 0);
      else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, interval);
    }
  Module["_glfwSwapInterval"] = _glfwSwapInterval;

  function _glfwOpenWindow(width, height, redbits, greenbits, bluebits, alphabits, depthbits, stencilbits, mode) {
      GLFW.hints[0x00021001] = redbits;     // GLFW_RED_BITS
      GLFW.hints[0x00021002] = greenbits;   // GLFW_GREEN_BITS
      GLFW.hints[0x00021003] = bluebits;    // GLFW_BLUE_BITS
      GLFW.hints[0x00021004] = alphabits;   // GLFW_ALPHA_BITS
      GLFW.hints[0x00021005] = depthbits;   // GLFW_DEPTH_BITS
      GLFW.hints[0x00021006] = stencilbits; // GLFW_STENCIL_BITS
      GLFW.createWindow(width, height, "GLFW2 Window", 0, 0);
      return 1; // GL_TRUE
    }
  Module["_glfwOpenWindow"] = _glfwOpenWindow;

  function _glfwCloseWindow() {
      GLFW.destroyWindow(GLFW.active.id);
    }
  Module["_glfwCloseWindow"] = _glfwCloseWindow;

  function _glfwOpenWindowHint(target, hint) {
      target = GLFW.GLFW2ParamToGLFW3Param(target);
      GLFW.hints[target] = hint;
    }
  Module["_glfwOpenWindowHint"] = _glfwOpenWindowHint;

  function _glfwGetWindowSize(width, height) {
      GLFW.getWindowSize(GLFW.active.id, width, height);
    }
  Module["_glfwGetWindowSize"] = _glfwGetWindowSize;

  function _glfwSetWindowSize(width, height) {
      GLFW.setWindowSize(GLFW.active.id, width, height);
    }
  Module["_glfwSetWindowSize"] = _glfwSetWindowSize;

  function _glfwGetWindowPos(x, y) {
      GLFW.getWindowPos(GLFW.active.id, x, y);
    }
  Module["_glfwGetWindowPos"] = _glfwGetWindowPos;

  function _glfwSetWindowPos(x, y) {
      GLFW.setWindowPos(GLFW.active.id, x, y);
    }
  Module["_glfwSetWindowPos"] = _glfwSetWindowPos;

  function _glfwSetWindowTitle(title) {
      GLFW.setWindowTitle(GLFW.active.id, title);
    }
  Module["_glfwSetWindowTitle"] = _glfwSetWindowTitle;

  function _glfwIconifyWindow() {
      warnOnce('glfwIconifyWindow is not implemented');
    }
  Module["_glfwIconifyWindow"] = _glfwIconifyWindow;

  function _glfwRestoreWindow() {
      warnOnce('glfwRestoreWindow is not implemented');
    }
  Module["_glfwRestoreWindow"] = _glfwRestoreWindow;

  function _glfwSwapBuffers() {
      GLFW.swapBuffers(GLFW.active.id);
    }
  Module["_glfwSwapBuffers"] = _glfwSwapBuffers;

  function _glfwGetWindowParam(param) {
      param = GLFW.GLFW2ParamToGLFW3Param(param);
      return GLFW.hints[param];
    }
  Module["_glfwGetWindowParam"] = _glfwGetWindowParam;

  function _glfwSetWindowSizeCallback(cbfun) {
      GLFW.setWindowSizeCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetWindowSizeCallback"] = _glfwSetWindowSizeCallback;

  function _glfwSetWindowCloseCallback(cbfun) {
      GLFW.setWindowCloseCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetWindowCloseCallback"] = _glfwSetWindowCloseCallback;

  function _glfwSetWindowRefreshCallback(cbfun) {
      GLFW.setWindowRefreshCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetWindowRefreshCallback"] = _glfwSetWindowRefreshCallback;

  function _glfwGetKey(key) {
      return GLFW.getKey(GLFW.active.id, key);
    }
  Module["_glfwGetKey"] = _glfwGetKey;

  function _glfwGetMouseButton(button) {
      return GLFW.getMouseButton(GLFW.active.id, button);
    }
  Module["_glfwGetMouseButton"] = _glfwGetMouseButton;

  function _glfwGetMousePos(x, y) {
      GLFW.getMousePos(GLFW.active.id, x, y);
    }
  Module["_glfwGetMousePos"] = _glfwGetMousePos;

  function _glfwSetMousePos(x, y) {
      GLFW.setCursorPos(GLFW.active.id, x, y);
    }
  Module["_glfwSetMousePos"] = _glfwSetMousePos;

  function _glfwGetMouseWheel() {
      return 0;
    }
  Module["_glfwGetMouseWheel"] = _glfwGetMouseWheel;

  function _glfwSetMouseWheel(pos) {
    }
  Module["_glfwSetMouseWheel"] = _glfwSetMouseWheel;

  function _glfwSetKeyCallback(cbfun) {
      GLFW.setKeyCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetKeyCallback"] = _glfwSetKeyCallback;

  function _glfwSetCharCallback(cbfun) {
      GLFW.setCharCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetCharCallback"] = _glfwSetCharCallback;

  function _glfwSetMouseButtonCallback(cbfun) {
      GLFW.setMouseButtonCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetMouseButtonCallback"] = _glfwSetMouseButtonCallback;

  function _glfwSetMousePosCallback(cbfun) {
      GLFW.setCursorPosCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetMousePosCallback"] = _glfwSetMousePosCallback;

  function _glfwSetMouseWheelCallback(cbfun) {
      GLFW.setScrollCallback(GLFW.active.id, cbfun);
    }
  Module["_glfwSetMouseWheelCallback"] = _glfwSetMouseWheelCallback;

  function _glfwGetDesktopMode(mode) {
      throw "glfwGetDesktopMode is not implemented.";
    }
  Module["_glfwGetDesktopMode"] = _glfwGetDesktopMode;

  function _glfwSleep(time) {
      _sleep(time);
    }
  Module["_glfwSleep"] = _glfwSleep;

  function _glfwEnable(target) {
      target = GLFW.GLFW2ParamToGLFW3Param(target);
      GLFW.hints[target] = false;
    }
  Module["_glfwEnable"] = _glfwEnable;

  function _glfwDisable(target) {
      target = GLFW.GLFW2ParamToGLFW3Param(target);
      GLFW.hints[target] = true;
    }
  Module["_glfwDisable"] = _glfwDisable;

  function _glfwGetGLVersion(major, minor, rev) {
      setValue(major, 0, 'i32');
      setValue(minor, 0, 'i32');
      setValue(rev, 1, 'i32');
    }
  Module["_glfwGetGLVersion"] = _glfwGetGLVersion;

  function _glfwCreateThread(fun, arg) {
      var str = 'v';
      for (var i in arg) {
        str += 'i';
      }
      dynCall(str, fun, arg);
      // One single thread
      return 0;
    }
  Module["_glfwCreateThread"] = _glfwCreateThread;

  function _glfwDestroyThread(ID) {}
  Module["_glfwDestroyThread"] = _glfwDestroyThread;

  function _glfwWaitThread(ID, waitmode) {}
  Module["_glfwWaitThread"] = _glfwWaitThread;

  function _glfwGetThreadID() {
      // One single thread
      return 0;
    }
  Module["_glfwGetThreadID"] = _glfwGetThreadID;

  function _glfwCreateMutex() { throw "glfwCreateMutex is not implemented."; }
  Module["_glfwCreateMutex"] = _glfwCreateMutex;

  function _glfwDestroyMutex(mutex) { throw "glfwDestroyMutex is not implemented."; }
  Module["_glfwDestroyMutex"] = _glfwDestroyMutex;

  function _glfwLockMutex(mutex) { throw "glfwLockMutex is not implemented."; }
  Module["_glfwLockMutex"] = _glfwLockMutex;

  function _glfwUnlockMutex(mutex) { throw "glfwUnlockMutex is not implemented."; }
  Module["_glfwUnlockMutex"] = _glfwUnlockMutex;

  function _glfwCreateCond() { throw "glfwCreateCond is not implemented."; }
  Module["_glfwCreateCond"] = _glfwCreateCond;

  function _glfwDestroyCond(cond) { throw "glfwDestroyCond is not implemented."; }
  Module["_glfwDestroyCond"] = _glfwDestroyCond;

  function _glfwWaitCond(cond, mutex, timeout) { throw "glfwWaitCond is not implemented."; }
  Module["_glfwWaitCond"] = _glfwWaitCond;

  function _glfwSignalCond(cond) { throw "glfwSignalCond is not implemented."; }
  Module["_glfwSignalCond"] = _glfwSignalCond;

  function _glfwBroadcastCond(cond) { throw "glfwBroadcastCond is not implemented."; }
  Module["_glfwBroadcastCond"] = _glfwBroadcastCond;

  function _glfwGetNumberOfProcessors() {
      // Threads are disabled anyway…
      return 1;
    }
  Module["_glfwGetNumberOfProcessors"] = _glfwGetNumberOfProcessors;

  function _glfwReadImage(name, img, flags) { throw "glfwReadImage is not implemented."; }
  Module["_glfwReadImage"] = _glfwReadImage;

  function _glfwReadMemoryImage(data, size, img, flags) { throw "glfwReadMemoryImage is not implemented."; }
  Module["_glfwReadMemoryImage"] = _glfwReadMemoryImage;

  function _glfwFreeImage(img) { throw "glfwFreeImage is not implemented."; }
  Module["_glfwFreeImage"] = _glfwFreeImage;

  function _glfwLoadTexture2D(name, flags) { throw "glfwLoadTexture2D is not implemented."; }
  Module["_glfwLoadTexture2D"] = _glfwLoadTexture2D;

  function _glfwLoadMemoryTexture2D(data, size, flags) { throw "glfwLoadMemoryTexture2D is not implemented."; }
  Module["_glfwLoadMemoryTexture2D"] = _glfwLoadMemoryTexture2D;

  function _glfwLoadTextureImage2D(img, flags) { throw "glfwLoadTextureImage2D is not implemented."; }
  Module["_glfwLoadTextureImage2D"] = _glfwLoadTextureImage2D;

  function _uuid_clear(uu) {
      // void uuid_clear(uuid_t uu);
      _memset(uu, 0, 16);
    }
  Module["_uuid_clear"] = _uuid_clear;

  function _uuid_compare(uu1, uu2) {
      // int uuid_compare(const uuid_t uu1, const uuid_t uu2);
      return _memcmp(uu1, uu2, 16);
    }
  Module["_uuid_compare"] = _uuid_compare;

  function _uuid_copy(dst, src) {
      // void uuid_copy(uuid_t dst, const uuid_t src);
      _memcpy(dst, src, 16);
    }
  Module["_uuid_copy"] = _uuid_copy;

  function _uuid_generate(out) {
      // void uuid_generate(uuid_t out);
      var uuid = null;
  
      if (ENVIRONMENT_IS_NODE) {
      } else if (ENVIRONMENT_IS_WEB &&
                 typeof(window.crypto) !== 'undefined' &&
                 typeof(window.crypto.getRandomValues) !== 'undefined') {
        // If crypto.getRandomValues is available try to use it.
        uuid = new Uint8Array(16);
        window.crypto.getRandomValues(uuid);
      }
  
      // Fall back to Math.random if a higher quality random number generator is not available.
      if (!uuid) {
        uuid = new Array(16);
        var d = new Date().getTime();
        for (var i = 0; i < 16; i++) {
          var r = ((d + Math.random() * 256) % 256)|0;
          d = (d / 256)|0;
          uuid[i] = r;
        }
      }
  
      uuid[6] = (uuid[6] & 0x0F) | 0x40;
      uuid[8] = (uuid[8] & 0x7F) | 0x80;
      writeArrayToMemory(uuid, out);
    }
  Module["_uuid_generate"] = _uuid_generate;

  function _uuid_is_null(uu) {
      // int uuid_is_null(const uuid_t uu);
      for (var i = 0; i < 4; i++, uu = (uu+4)|0) {
        var val = HEAP32[((uu)>>2)];
        if (val) {
          return 0;
        }
      }
      return 1;
    }
  Module["_uuid_is_null"] = _uuid_is_null;

  function _uuid_parse(inp, uu) {
      // int uuid_parse(const char *in, uuid_t uu);
      inp = UTF8ToString(inp);
      if (inp.length === 36) {
        var i = 0;
        var uuid = new Array(16);
        inp.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {
          if (i < 16) {
            uuid[i++] = parseInt(byte, 16);
          }
        });
  
        if (i < 16) {
          return -1;
        } else {
          writeArrayToMemory(uuid, uu);
          return 0;
        }
      } else {
        return -1;
      }
    }
  Module["_uuid_parse"] = _uuid_parse;

  /** @param {number|boolean=} upper */
  function _uuid_unparse(uu, out, upper) {
      // void uuid_unparse(const uuid_t uu, char *out);
      var i = 0;
      var uuid = 'xxxx-xx-xx-xx-xxxxxx'.replace(/[x]/g, function(c) {
        var r = upper ? (HEAPU8[(((uu)+(i))>>0)]).toString(16).toUpperCase() :
                        (HEAPU8[(((uu)+(i))>>0)]).toString(16);
        r = (r.length === 1) ? '0' + r : r; // Zero pad single digit hex values
        i++;
        return r;
      });
      stringToUTF8(uuid, out, 37); // Always fixed 36 bytes of ASCII characters and a trailing \0.
    }
  Module["_uuid_unparse"] = _uuid_unparse;

  function _uuid_unparse_lower(uu, out) {
      // void uuid_unparse_lower(const uuid_t uu, char *out);
      _uuid_unparse(uu, out);
    }
  Module["_uuid_unparse_lower"] = _uuid_unparse_lower;

  function _uuid_unparse_upper(uu, out) {
      // void uuid_unparse_upper(const uuid_t uu, char *out);
      _uuid_unparse(uu, out, true);
    }
  Module["_uuid_unparse_upper"] = _uuid_unparse_upper;

  function _uuid_type(uu) {
      // int uuid_type(const uuid_t uu);
      return 4;
    }
  Module["_uuid_type"] = _uuid_type;

  function _uuid_variant(uu) {
      // int uuid_variant(const uuid_t uu);
      return 1;
    }
  Module["_uuid_variant"] = _uuid_variant;

  var GLEW={isLinaroFork:1,extensions:null,error:{0:null,1:null,2:null,3:null,4:null,5:null,6:null,7:null,8:null},version:{1:null,2:null,3:null,4:null},errorStringConstantFromCode:function(error) {
        if (GLEW.isLinaroFork) {
          switch (error) {
            case 4:return "OpenGL ES lib expected, found OpenGL lib"; // GLEW_ERROR_NOT_GLES_VERSION
            case 5:return "OpenGL lib expected, found OpenGL ES lib"; // GLEW_ERROR_GLES_VERSION
            case 6:return "Missing EGL version"; // GLEW_ERROR_NO_EGL_VERSION
            case 7:return "EGL 1.1 and up are supported"; // GLEW_ERROR_EGL_VERSION_10_ONLY
            default:break;
          }
        }
  
        switch (error) {
          case 0:return "No error"; // GLEW_OK || GLEW_NO_ERROR
          case 1:return "Missing GL version"; // GLEW_ERROR_NO_GL_VERSION
          case 2:return "GL 1.1 and up are supported"; // GLEW_ERROR_GL_VERSION_10_ONLY
          case 3:return "GLX 1.2 and up are supported"; // GLEW_ERROR_GLX_VERSION_11_ONLY
          default:return null;
        }
      },errorString:function(error) {
        if (!GLEW.error[error]) {
          var string = GLEW.errorStringConstantFromCode(error);
          if (!string) {
            string = "Unknown error";
            error = 8; // prevent array from growing more than this
          }
          GLEW.error[error] = allocate(intArrayFromString(string), 'i8', ALLOC_NORMAL);
        }
        return GLEW.error[error];
      },versionStringConstantFromCode:function(name) {
        switch (name) {
          case 1:return "1.10.0"; // GLEW_VERSION
          case 2:return "1"; // GLEW_VERSION_MAJOR
          case 3:return "10"; // GLEW_VERSION_MINOR
          case 4:return "0"; // GLEW_VERSION_MICRO
          default:return null;
        }
      },versionString:function(name) {
        if (!GLEW.version[name]) {
          var string = GLEW.versionStringConstantFromCode(name);
          if (!string)
            return 0;
          GLEW.version[name] = allocate(intArrayFromString(string), 'i8', ALLOC_NORMAL);
        }
        return GLEW.version[name];
      },extensionIsSupported:function(name) {
        if (!GLEW.extensions) {
          GLEW.extensions = UTF8ToString(_glGetString(0x1F03)).split(' ');
        }
  
        if (GLEW.extensions.indexOf(name) != -1)
          return 1;
  
        // extensions from GLEmulations do not come unprefixed
        // so, try with prefix
        return (GLEW.extensions.indexOf("GL_" + name) != -1);
      }};
  Module["GLEW"] = GLEW;

  function _glewInit() { return 0; }
  Module["_glewInit"] = _glewInit;

  function _glewIsSupported(name) {
      var exts = UTF8ToString(name).split(' ');
      for (var i = 0; i < exts.length; ++i) {
        if (!GLEW.extensionIsSupported(exts[i]))
          return 0;
      }
      return 1;
    }
  Module["_glewIsSupported"] = _glewIsSupported;

  function _glewGetExtension(name) {
      return GLEW.extensionIsSupported(UTF8ToString(name));
    }
  Module["_glewGetExtension"] = _glewGetExtension;

  function _glewGetErrorString(error) {
      return GLEW.errorString(error);
    }
  Module["_glewGetErrorString"] = _glewGetErrorString;

  function _glewGetString(name) {
      return GLEW.versionString(name);
    }
  Module["_glewGetString"] = _glewGetString;

  var IDBStore={indexedDB:function() {
      if (typeof indexedDB !== 'undefined') return indexedDB;
      var ret = null;
      if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      assert(ret, 'IDBStore used, but indexedDB not supported');
      return ret;
    },DB_VERSION:22,DB_STORE_NAME:"FILE_DATA",dbs:{},blobs:[0],getDB:function(name, callback) {
      // check the cache first
      var db = IDBStore.dbs[name];
      if (db) {
        return callback(null, db);
      }
      var req;
      try {
        req = IDBStore.indexedDB().open(name, IDBStore.DB_VERSION);
      } catch (e) {
        return callback(e);
      }
      req.onupgradeneeded = function(e) {
        var db = e.target.result;
        var transaction = e.target.transaction;
        var fileStore;
        if (db.objectStoreNames.contains(IDBStore.DB_STORE_NAME)) {
          fileStore = transaction.objectStore(IDBStore.DB_STORE_NAME);
        } else {
          fileStore = db.createObjectStore(IDBStore.DB_STORE_NAME);
        }
      };
      req.onsuccess = function() {
        db = req.result;
        // add to the cache
        IDBStore.dbs[name] = db;
        callback(null, db);
      };
      req.onerror = /** @this{IDBOpenDBRequest} */ function(e) {
        callback(this.error);
        e.preventDefault();
      };
    },getStore:function(dbName, type, callback) {
      IDBStore.getDB(dbName, function(error, db) {
        if (error) return callback(error);
        var transaction = db.transaction([IDBStore.DB_STORE_NAME], type);
        transaction.onerror = function(e) {
          callback(this.error || 'unknown error');
          e.preventDefault();
        };
        var store = transaction.objectStore(IDBStore.DB_STORE_NAME);
        callback(null, store);
      });
    },getFile:function(dbName, id, callback) {
      IDBStore.getStore(dbName, 'readonly', function(err, store) {
        if (err) return callback(err);
        var req = store.get(id);
        req.onsuccess = function(event) {
          var result = event.target.result;
          if (!result) {
            return callback('file ' + id + ' not found');
          } else {
            return callback(null, result);
          }
        };
        req.onerror = function(error) {
          callback(error);
        };
      });
    },setFile:function(dbName, id, data, callback) {
      IDBStore.getStore(dbName, 'readwrite', function(err, store) {
        if (err) return callback(err);
        var req = store.put(data, id);
        req.onsuccess = function(event) {
          callback();
        };
        req.onerror = function(error) {
          callback(error);
        };
      });
    },deleteFile:function(dbName, id, callback) {
      IDBStore.getStore(dbName, 'readwrite', function(err, store) {
        if (err) return callback(err);
        var req = store.delete(id);
        req.onsuccess = function(event) {
          callback();
        };
        req.onerror = function(error) {
          callback(error);
        };
      });
    },existsFile:function(dbName, id, callback) {
      IDBStore.getStore(dbName, 'readonly', function(err, store) {
        if (err) return callback(err);
        var req = store.count(id);
        req.onsuccess = function(event) {
          callback(null, event.target.result > 0);
        };
        req.onerror = function(error) {
          callback(error);
        };
      });
    }};
  Module["IDBStore"] = IDBStore;

  function _emscripten_idb_async_load(db, id, arg, onload, onerror) {
      IDBStore.getFile(UTF8ToString(db), UTF8ToString(id), function(error, byteArray) {
        if (error) {
          if (onerror) dynCall_vi(onerror, arg);
          return;
        }
        var buffer = _malloc(byteArray.length);
        HEAPU8.set(byteArray, buffer);
        dynCall_viii(onload, arg, buffer, byteArray.length);
        _free(buffer);
      });
    }
  Module["_emscripten_idb_async_load"] = _emscripten_idb_async_load;

  function _emscripten_idb_async_store(db, id, ptr, num, arg, onstore, onerror) {
      // note that we copy the data here, as these are async operatins - changes to HEAPU8 meanwhile should not affect us!
      IDBStore.setFile(UTF8ToString(db), UTF8ToString(id), new Uint8Array(HEAPU8.subarray(ptr, ptr+num)), function(error) {
        if (error) {
          if (onerror) dynCall_vi(onerror, arg);
          return;
        }
        if (onstore) dynCall_vi(onstore, arg);
      });
    }
  Module["_emscripten_idb_async_store"] = _emscripten_idb_async_store;

  function _emscripten_idb_async_delete(db, id, arg, ondelete, onerror) {
      IDBStore.deleteFile(UTF8ToString(db), UTF8ToString(id), function(error) {
        if (error) {
          if (onerror) dynCall_vi(onerror, arg);
          return;
        }
        if (ondelete) dynCall_vi(ondelete, arg);
      });
    }
  Module["_emscripten_idb_async_delete"] = _emscripten_idb_async_delete;

  function _emscripten_idb_async_exists(db, id, arg, oncheck, onerror) {
      IDBStore.existsFile(UTF8ToString(db), UTF8ToString(id), function(error, exists) {
        if (error) {
          if (onerror) dynCall_vi(onerror, arg);
          return;
        }
        if (oncheck) dynCall_vii(oncheck, arg, exists);
      });
    }
  Module["_emscripten_idb_async_exists"] = _emscripten_idb_async_exists;

  function _emscripten_idb_load() {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_load, etc.';
    }
  Module["_emscripten_idb_load"] = _emscripten_idb_load;

  function _emscripten_idb_store() {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_store, etc.';
    }
  Module["_emscripten_idb_store"] = _emscripten_idb_store;

  function _emscripten_idb_delete() {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_delete, etc.';
    }
  Module["_emscripten_idb_delete"] = _emscripten_idb_delete;

  function _emscripten_idb_exists() {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_exists, etc.';
    }
  Module["_emscripten_idb_exists"] = _emscripten_idb_exists;

  function runAndAbortIfError(func) {
      try {
        return func();
      } catch (e) {
        abort(e);
      }
    }
  Module["runAndAbortIfError"] = runAndAbortIfError;


  function _emscripten_coroutine_create() {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_coroutine_create';
    }
  Module["_emscripten_coroutine_create"] = _emscripten_coroutine_create;

  function _emscripten_coroutine_next() {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_coroutine_next';
    }
  Module["_emscripten_coroutine_next"] = _emscripten_coroutine_next;

  function _emscripten_yield() {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_yield';
    }
  Module["_emscripten_yield"] = _emscripten_yield;

  function _emscripten_wget(url, file) {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_wget';
    }
  Module["_emscripten_wget"] = _emscripten_wget;

  function _emscripten_wget_data(url, file) {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_wget_data';
    }
  Module["_emscripten_wget_data"] = _emscripten_wget_data;

  function _emscripten_scan_registers(url, file) {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_scan_registers';
    }
  Module["_emscripten_scan_registers"] = _emscripten_scan_registers;

  function _emscripten_fiber_init() {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_init';
    }
  Module["_emscripten_fiber_init"] = _emscripten_fiber_init;

  function _emscripten_fiber_init_from_current_context() {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_init_from_current_context';
    }
  Module["_emscripten_fiber_init_from_current_context"] = _emscripten_fiber_init_from_current_context;

  function _emscripten_fiber_swap() {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_swap';
    }
  Module["_emscripten_fiber_swap"] = _emscripten_fiber_swap;







  function __emscripten_fetch_delete_cached_data(
  ) {
  if (!Module['__emscripten_fetch_delete_cached_data']) abort("external function '_emscripten_fetch_delete_cached_data' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['__emscripten_fetch_delete_cached_data'].apply(null, arguments);
  }

  function __emscripten_fetch_load_cached_data(
  ) {
  if (!Module['__emscripten_fetch_load_cached_data']) abort("external function '_emscripten_fetch_load_cached_data' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['__emscripten_fetch_load_cached_data'].apply(null, arguments);
  }

  function __emscripten_fetch_cache_data(
  ) {
  if (!Module['__emscripten_fetch_cache_data']) abort("external function '_emscripten_fetch_cache_data' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['__emscripten_fetch_cache_data'].apply(null, arguments);
  }

  function __emscripten_fetch_xhr(
  ) {
  if (!Module['__emscripten_fetch_xhr']) abort("external function '_emscripten_fetch_xhr' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['__emscripten_fetch_xhr'].apply(null, arguments);
  }



  function _pthread_mutexattr_init() {}
  Module["_pthread_mutexattr_init"] = _pthread_mutexattr_init;

  function _pthread_mutexattr_setschedparam() {}
  Module["_pthread_mutexattr_setschedparam"] = _pthread_mutexattr_setschedparam;

  function _pthread_mutexattr_setprotocol() {}
  Module["_pthread_mutexattr_setprotocol"] = _pthread_mutexattr_setprotocol;

  function _pthread_mutexattr_settype() {}
  Module["_pthread_mutexattr_settype"] = _pthread_mutexattr_settype;

  function _pthread_mutexattr_destroy() {}
  Module["_pthread_mutexattr_destroy"] = _pthread_mutexattr_destroy;

  function _pthread_mutexattr_setpshared(attr, pshared) {
      // XXX implement if/when getpshared is required
      return 0;
    }
  Module["_pthread_mutexattr_setpshared"] = _pthread_mutexattr_setpshared;

  function _pthread_cond_init() { return 0; }
  Module["_pthread_cond_init"] = _pthread_cond_init;

  function _pthread_cond_destroy() { return 0; }
  Module["_pthread_cond_destroy"] = _pthread_cond_destroy;

  function _pthread_cond_timedwait() { return 0; }
  Module["_pthread_cond_timedwait"] = _pthread_cond_timedwait;

  function _pthread_condattr_init() { return 0; }
  Module["_pthread_condattr_init"] = _pthread_condattr_init;

  function _pthread_condattr_destroy() { return 0; }
  Module["_pthread_condattr_destroy"] = _pthread_condattr_destroy;

  function _pthread_condattr_setclock() { return 0; }
  Module["_pthread_condattr_setclock"] = _pthread_condattr_setclock;

  function _pthread_condattr_setpshared() { return 0; }
  Module["_pthread_condattr_setpshared"] = _pthread_condattr_setpshared;

  function _pthread_condattr_getclock() { return 0; }
  Module["_pthread_condattr_getclock"] = _pthread_condattr_getclock;

  function _pthread_condattr_getpshared() { return 0; }
  Module["_pthread_condattr_getpshared"] = _pthread_condattr_getpshared;

  function _pthread_attr_init(attr) {
      /* int pthread_attr_init(pthread_attr_t *attr); */
      //FIXME: should allocate a pthread_attr_t
      return 0;
    }
  Module["_pthread_attr_init"] = _pthread_attr_init;

  function _pthread_getattr_np(thread, attr) {
      /* int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr); */
      //FIXME: should fill in attributes of the given thread in pthread_attr_t
      return 0;
    }
  Module["_pthread_getattr_np"] = _pthread_getattr_np;

  function _pthread_attr_destroy(attr) {
      /* int pthread_attr_destroy(pthread_attr_t *attr); */
      //FIXME: should destroy the pthread_attr_t struct
      return 0;
    }
  Module["_pthread_attr_destroy"] = _pthread_attr_destroy;

  function _pthread_attr_getstack(attr, stackaddr, stacksize) {
      /* int pthread_attr_getstack(const pthread_attr_t *restrict attr,
         void **restrict stackaddr, size_t *restrict stacksize); */
      /*FIXME: assumes that there is only one thread, and that attr is the
        current thread*/
      HEAP32[((stackaddr)>>2)]=STACK_BASE;
      HEAP32[((stacksize)>>2)]=TOTAL_STACK;
      return 0;
    }
  Module["_pthread_attr_getstack"] = _pthread_attr_getstack;

  function _pthread_attr_getdetachstate(attr, detachstate) {
      /* int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); */
      return 0;
    }
  Module["_pthread_attr_getdetachstate"] = _pthread_attr_getdetachstate;


  function _pthread_setcanceltype() { return 0; }
  Module["_pthread_setcanceltype"] = _pthread_setcanceltype;



  function __pthread_cleanup_push(a0,a1
  ) {
  return _pthread_cleanup_push(a0,a1);
  }
  Module["__pthread_cleanup_push"] = __pthread_cleanup_push;

  function __pthread_cleanup_pop(
  ) {
  _pthread_cleanup_pop();
  }
  Module["__pthread_cleanup_pop"] = __pthread_cleanup_pop;


  function _pthread_rwlock_init() { return 0; }
  Module["_pthread_rwlock_init"] = _pthread_rwlock_init;

  function _pthread_rwlock_destroy() { return 0; }
  Module["_pthread_rwlock_destroy"] = _pthread_rwlock_destroy;

  function _pthread_rwlock_rdlock() { return 0; }
  Module["_pthread_rwlock_rdlock"] = _pthread_rwlock_rdlock;

  function _pthread_rwlock_tryrdlock() { return 0; }
  Module["_pthread_rwlock_tryrdlock"] = _pthread_rwlock_tryrdlock;

  function _pthread_rwlock_timedrdlock() { return 0; }
  Module["_pthread_rwlock_timedrdlock"] = _pthread_rwlock_timedrdlock;

  function _pthread_rwlock_wrlock() { return 0; }
  Module["_pthread_rwlock_wrlock"] = _pthread_rwlock_wrlock;

  function _pthread_rwlock_trywrlock() { return 0; }
  Module["_pthread_rwlock_trywrlock"] = _pthread_rwlock_trywrlock;

  function _pthread_rwlock_timedwrlock() { return 0; }
  Module["_pthread_rwlock_timedwrlock"] = _pthread_rwlock_timedwrlock;

  function _pthread_rwlock_unlock() { return 0; }
  Module["_pthread_rwlock_unlock"] = _pthread_rwlock_unlock;

  function _pthread_rwlockattr_init() { return 0; }
  Module["_pthread_rwlockattr_init"] = _pthread_rwlockattr_init;

  function _pthread_rwlockattr_destroy() { return 0; }
  Module["_pthread_rwlockattr_destroy"] = _pthread_rwlockattr_destroy;

  function _pthread_rwlockattr_setpshared() { return 0; }
  Module["_pthread_rwlockattr_setpshared"] = _pthread_rwlockattr_setpshared;

  function _pthread_rwlockattr_getpshared() { return 0; }
  Module["_pthread_rwlockattr_getpshared"] = _pthread_rwlockattr_getpshared;

  function _pthread_spin_init() { return 0; }
  Module["_pthread_spin_init"] = _pthread_spin_init;

  function _pthread_spin_destroy() { return 0; }
  Module["_pthread_spin_destroy"] = _pthread_spin_destroy;

  function _pthread_spin_lock() { return 0; }
  Module["_pthread_spin_lock"] = _pthread_spin_lock;

  function _pthread_spin_trylock() { return 0; }
  Module["_pthread_spin_trylock"] = _pthread_spin_trylock;

  function _pthread_spin_unlock() { return 0; }
  Module["_pthread_spin_unlock"] = _pthread_spin_unlock;

  function _pthread_attr_setdetachstate() {}
  Module["_pthread_attr_setdetachstate"] = _pthread_attr_setdetachstate;

  function _pthread_attr_setschedparam() {}
  Module["_pthread_attr_setschedparam"] = _pthread_attr_setschedparam;

  function _pthread_attr_setstacksize() {}
  Module["_pthread_attr_setstacksize"] = _pthread_attr_setstacksize;

  function _pthread_create() {
      return 6;
    }
  Module["_pthread_create"] = _pthread_create;

  function _pthread_cancel() {}
  Module["_pthread_cancel"] = _pthread_cancel;

  function _pthread_exit(status) {
      _exit(status);
    }
  Module["_pthread_exit"] = _pthread_exit;

  function _pthread_equal(x, y) { return x == y }
  Module["_pthread_equal"] = _pthread_equal;

  function _pthread_join() {}
  Module["_pthread_join"] = _pthread_join;

  function _pthread_detach() {}
  Module["_pthread_detach"] = _pthread_detach;

  function _sem_init() {}
  Module["_sem_init"] = _sem_init;

  function _sem_post() {}
  Module["_sem_post"] = _sem_post;

  function _sem_wait() {}
  Module["_sem_wait"] = _sem_wait;

  function _sem_trywait() {}
  Module["_sem_trywait"] = _sem_trywait;

  function _sem_destroy() {}
  Module["_sem_destroy"] = _sem_destroy;

  function _emscripten_main_browser_thread_id() { return _pthread_self(); }
  Module["_emscripten_main_browser_thread_id"] = _emscripten_main_browser_thread_id;



  function _llvm_memory_barrier(){}
  Module["_llvm_memory_barrier"] = _llvm_memory_barrier;

  function _llvm_atomic_load_add_i32_p0i32(ptr, delta) {
      var ret = HEAP32[((ptr)>>2)];
      HEAP32[((ptr)>>2)]=ret+delta;
      return ret;
    }
  Module["_llvm_atomic_load_add_i32_p0i32"] = _llvm_atomic_load_add_i32_p0i32;

  function ___atomic_is_lock_free(size, ptr) {
      return size <= 4 && (size & (size-1)) == 0 && (ptr&(size-1)) == 0;
    }
  Module["___atomic_is_lock_free"] = ___atomic_is_lock_free;










  function _emscripten_atomic_add_u32(a0,a1
  ) {
  return _llvm_atomic_load_add_i32_p0i32(a0,a1);
  }
  Module["_emscripten_atomic_add_u32"] = _emscripten_atomic_add_u32;

  function _emscripten_atomic_load_u64(a0,a1
  ) {
  return ___atomic_load_8(a0,a1);
  }
  Module["_emscripten_atomic_load_u64"] = _emscripten_atomic_load_u64;

  function _emscripten_atomic_store_u64(a0,a1,a2,a3
  ) {
  return ___atomic_store_8(a0,a1,a2,a3);
  }
  Module["_emscripten_atomic_store_u64"] = _emscripten_atomic_store_u64;

  function _emscripten_atomic_cas_u64(a0,a1,a2,a3,a4,a5,a6
  ) {
  return ___atomic_compare_exchange_8(a0,a1,a2,a3,a4,a5,a6);
  }
  Module["_emscripten_atomic_cas_u64"] = _emscripten_atomic_cas_u64;

  function _emscripten_atomic_exchange_u64(a0,a1,a2,a3
  ) {
  return ___atomic_exchange_8(a0,a1,a2,a3);
  }
  Module["_emscripten_atomic_exchange_u64"] = _emscripten_atomic_exchange_u64;

  function __emscripten_atomic_fetch_and_add_u64(a0,a1,a2,a3
  ) {
  return ___atomic_fetch_add_8(a0,a1,a2,a3);
  }
  Module["__emscripten_atomic_fetch_and_add_u64"] = __emscripten_atomic_fetch_and_add_u64;

  function __emscripten_atomic_fetch_and_sub_u64(a0,a1,a2,a3
  ) {
  return ___atomic_fetch_sub_8(a0,a1,a2,a3);
  }
  Module["__emscripten_atomic_fetch_and_sub_u64"] = __emscripten_atomic_fetch_and_sub_u64;

  function __emscripten_atomic_fetch_and_and_u64(a0,a1,a2,a3
  ) {
  return ___atomic_fetch_and_8(a0,a1,a2,a3);
  }
  Module["__emscripten_atomic_fetch_and_and_u64"] = __emscripten_atomic_fetch_and_and_u64;

  function __emscripten_atomic_fetch_and_or_u64(a0,a1,a2,a3
  ) {
  return ___atomic_fetch_or_8(a0,a1,a2,a3);
  }
  Module["__emscripten_atomic_fetch_and_or_u64"] = __emscripten_atomic_fetch_and_or_u64;

  function __emscripten_atomic_fetch_and_xor_u64(a0,a1,a2,a3
  ) {
  return ___atomic_fetch_xor_8(a0,a1,a2,a3);
  }
  Module["__emscripten_atomic_fetch_and_xor_u64"] = __emscripten_atomic_fetch_and_xor_u64;


Module["requestFullscreen"] = function Module_requestFullscreen(lockPointer, resizeCanvas) { Browser.requestFullscreen(lockPointer, resizeCanvas) };
  Module["requestFullScreen"] = function Module_requestFullScreen() { Browser.requestFullScreen() };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
  Module["createContext"] = function Module_createContext(canvas, useWebGL, setInModule, webGLContextAttributes) { return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes) };
var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;Module["FS_unlink"] = FS.unlink;;
var GLctx; GL.init();
for (var i = 0; i < 32; i++) __tempFixedLengthArray.push(new Array(i));;
Fetch.staticInit();;
var __setImmediate_id_counter = 0;
  var __setImmediate_queue = [];
  var __setImmediate_message_id = "_si";
  function __setImmediate_cb(e) {
  if (e.data === __setImmediate_message_id) {
  e.stopPropagation();
  __setImmediate_queue.shift()();
  ++__setImmediate_id_counter;
  }
  }
  if (typeof setImmediate === "undefined" && typeof addEventListener === "function") {
  addEventListener("message", __setImmediate_cb, true);
  setImmediate = function(func) {
  postMessage(__setImmediate_message_id, "*");
  return __setImmediate_id_counter + __setImmediate_queue.push(func) - 1;
  }
  clearImmediate = /**@type{function(number=)}*/(function(id) {
  var index = id - __setImmediate_id_counter;
  if (index >= 0 && index < __setImmediate_queue.length) __setImmediate_queue[index] = function(){};
  })
  };
var ASSERTIONS = true;

/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// ASM_LIBRARY EXTERN PRIMITIVES: Math_floor,Math_ceil,Math_clz32,Math_imul,Math_min,Math_max

var gb = GLOBAL_BASE, fb = 0;
var asmGlobalArg = {};
var asmLibraryArg = { "SDL_uclibc_exp": _SDL_uclibc_exp, "SDL_uclibc_fmod": _SDL_uclibc_fmod, "SDL_uclibc_log10": _SDL_uclibc_log10, "__clock_gettime": ___clock_gettime, "__handle_stack_overflow": ___handle_stack_overflow, "__map_file": ___map_file, "__memory_base": 1024, "__stack_pointer": STACK_BASE, "__sys__newselect": ___sys__newselect, "__sys_access": ___sys_access, "__sys_acct": ___sys_acct, "__sys_chdir": ___sys_chdir, "__sys_chmod": ___sys_chmod, "__sys_chown32": ___sys_chown32, "__sys_dup": ___sys_dup, "__sys_dup2": ___sys_dup2, "__sys_dup3": ___sys_dup3, "__sys_fadvise64_64": ___sys_fadvise64_64, "__sys_fallocate": ___sys_fallocate, "__sys_fchdir": ___sys_fchdir, "__sys_fchmod": ___sys_fchmod, "__sys_fchmodat": ___sys_fchmodat, "__sys_fchown32": ___sys_fchown32, "__sys_fchownat": ___sys_fchownat, "__sys_fcntl64": ___sys_fcntl64, "__sys_fdatasync": ___sys_fdatasync, "__sys_fstat64": ___sys_fstat64, "__sys_fstatat64": ___sys_fstatat64, "__sys_fstatfs64": ___sys_fstatfs64, "__sys_ftruncate64": ___sys_ftruncate64, "__sys_getcwd": ___sys_getcwd, "__sys_getdents64": ___sys_getdents64, "__sys_getegid32": ___sys_getegid32, "__sys_geteuid32": ___sys_geteuid32, "__sys_getgid32": ___sys_getgid32, "__sys_getgroups32": ___sys_getgroups32, "__sys_getpgid": ___sys_getpgid, "__sys_getpid": ___sys_getpid, "__sys_getppid": ___sys_getppid, "__sys_getpriority": ___sys_getpriority, "__sys_getresgid32": ___sys_getresgid32, "__sys_getresuid32": ___sys_getresuid32, "__sys_getrusage": ___sys_getrusage, "__sys_getsid": ___sys_getsid, "__sys_getuid32": ___sys_getuid32, "__sys_ioctl": ___sys_ioctl, "__sys_lchown32": ___sys_lchown32, "__sys_link": ___sys_link, "__sys_linkat": ___sys_linkat, "__sys_lstat64": ___sys_lstat64, "__sys_madvise1": ___sys_madvise1, "__sys_mincore": ___sys_mincore, "__sys_mkdir": ___sys_mkdir, "__sys_mkdirat": ___sys_mkdirat, "__sys_mknod": ___sys_mknod, "__sys_mknodat": ___sys_mknodat, "__sys_mlock": ___sys_mlock, "__sys_mlockall": ___sys_mlockall, "__sys_mmap2": ___sys_mmap2, "__sys_mprotect": ___sys_mprotect, "__sys_mremap": ___sys_mremap, "__sys_msync": ___sys_msync, "__sys_munlock": ___sys_munlock, "__sys_munlockall": ___sys_munlockall, "__sys_munmap": ___sys_munmap, "__sys_nice": ___sys_nice, "__sys_open": ___sys_open, "__sys_openat": ___sys_openat, "__sys_pause": ___sys_pause, "__sys_pipe": ___sys_pipe, "__sys_pipe2": ___sys_pipe2, "__sys_poll": ___sys_poll, "__sys_pread64": ___sys_pread64, "__sys_preadv": ___sys_preadv, "__sys_prlimit64": ___sys_prlimit64, "__sys_pselect6": ___sys_pselect6, "__sys_pwrite64": ___sys_pwrite64, "__sys_pwritev": ___sys_pwritev, "__sys_read": ___sys_read, "__sys_readlink": ___sys_readlink, "__sys_readlinkat": ___sys_readlinkat, "__sys_recvmmsg": ___sys_recvmmsg, "__sys_rename": ___sys_rename, "__sys_renameat": ___sys_renameat, "__sys_rmdir": ___sys_rmdir, "__sys_sendmmsg": ___sys_sendmmsg, "__sys_setdomainname": ___sys_setdomainname, "__sys_setpgid": ___sys_setpgid, "__sys_setpriority": ___sys_setpriority, "__sys_setrlimit": ___sys_setrlimit, "__sys_setsid": ___sys_setsid, "__sys_socketcall": ___sys_socketcall, "__sys_stat64": ___sys_stat64, "__sys_statfs64": ___sys_statfs64, "__sys_symlink": ___sys_symlink, "__sys_symlinkat": ___sys_symlinkat, "__sys_sync": ___sys_sync, "__sys_truncate64": ___sys_truncate64, "__sys_ugetrlimit": ___sys_ugetrlimit, "__sys_umask": ___sys_umask, "__sys_uname": ___sys_uname, "__sys_unlink": ___sys_unlink, "__sys_unlinkat": ___sys_unlinkat, "__sys_utimensat": ___sys_utimensat, "__sys_wait4": ___sys_wait4, "__table_base": 1, "__wait": ___wait, "_emscripten_fetch_free": __emscripten_fetch_free, "_emscripten_fetch_get_response_headers": __emscripten_fetch_get_response_headers, "_emscripten_fetch_get_response_headers_length": __emscripten_fetch_get_response_headers_length, "_emscripten_get_fetch_work_queue": __emscripten_get_fetch_work_queue, "_exit": __exit, "abort": _abort, "clock": _clock, "clock_gettime": _clock_gettime, "dlclose": _dlclose, "dlerror": _dlerror, "dlopen": _dlopen, "dlsym": _dlsym, "eglBindAPI": _eglBindAPI, "eglChooseConfig": _eglChooseConfig, "eglCreateContext": _eglCreateContext, "eglCreateWindowSurface": _eglCreateWindowSurface, "eglDestroyContext": _eglDestroyContext, "eglDestroySurface": _eglDestroySurface, "eglGetConfigAttrib": _eglGetConfigAttrib, "eglGetDisplay": _eglGetDisplay, "eglGetError": _eglGetError, "eglGetProcAddress": _eglGetProcAddress, "eglInitialize": _eglInitialize, "eglMakeCurrent": _eglMakeCurrent, "eglQueryString": _eglQueryString, "eglSwapBuffers": _eglSwapBuffers, "eglSwapInterval": _eglSwapInterval, "eglTerminate": _eglTerminate, "eglWaitGL": _eglWaitGL, "eglWaitNative": _eglWaitNative, "emscripten_asm_const_iii": _emscripten_asm_const_iii, "emscripten_cancel_main_loop": _emscripten_cancel_main_loop, "emscripten_exit_fullscreen": _emscripten_exit_fullscreen, "emscripten_exit_pointerlock": _emscripten_exit_pointerlock, "emscripten_force_exit": _emscripten_force_exit, "emscripten_get_battery_status": _emscripten_get_battery_status, "emscripten_get_device_pixel_ratio": _emscripten_get_device_pixel_ratio, "emscripten_get_element_css_size": _emscripten_get_element_css_size, "emscripten_get_gamepad_status": _emscripten_get_gamepad_status, "emscripten_get_num_gamepads": _emscripten_get_num_gamepads, "emscripten_get_sbrk_ptr": _emscripten_get_sbrk_ptr, "emscripten_glActiveTexture": _emscripten_glActiveTexture, "emscripten_glAttachShader": _emscripten_glAttachShader, "emscripten_glBeginQueryEXT": _emscripten_glBeginQueryEXT, "emscripten_glBindAttribLocation": _emscripten_glBindAttribLocation, "emscripten_glBindBuffer": _emscripten_glBindBuffer, "emscripten_glBindFramebuffer": _emscripten_glBindFramebuffer, "emscripten_glBindRenderbuffer": _emscripten_glBindRenderbuffer, "emscripten_glBindTexture": _emscripten_glBindTexture, "emscripten_glBindVertexArrayOES": _emscripten_glBindVertexArrayOES, "emscripten_glBlendColor": _emscripten_glBlendColor, "emscripten_glBlendEquation": _emscripten_glBlendEquation, "emscripten_glBlendEquationSeparate": _emscripten_glBlendEquationSeparate, "emscripten_glBlendFunc": _emscripten_glBlendFunc, "emscripten_glBlendFuncSeparate": _emscripten_glBlendFuncSeparate, "emscripten_glBufferData": _emscripten_glBufferData, "emscripten_glBufferSubData": _emscripten_glBufferSubData, "emscripten_glCheckFramebufferStatus": _emscripten_glCheckFramebufferStatus, "emscripten_glClear": _emscripten_glClear, "emscripten_glClearColor": _emscripten_glClearColor, "emscripten_glClearDepthf": _emscripten_glClearDepthf, "emscripten_glClearStencil": _emscripten_glClearStencil, "emscripten_glColorMask": _emscripten_glColorMask, "emscripten_glCompileShader": _emscripten_glCompileShader, "emscripten_glCompressedTexImage2D": _emscripten_glCompressedTexImage2D, "emscripten_glCompressedTexSubImage2D": _emscripten_glCompressedTexSubImage2D, "emscripten_glCopyTexImage2D": _emscripten_glCopyTexImage2D, "emscripten_glCopyTexSubImage2D": _emscripten_glCopyTexSubImage2D, "emscripten_glCreateProgram": _emscripten_glCreateProgram, "emscripten_glCreateShader": _emscripten_glCreateShader, "emscripten_glCullFace": _emscripten_glCullFace, "emscripten_glDeleteBuffers": _emscripten_glDeleteBuffers, "emscripten_glDeleteFramebuffers": _emscripten_glDeleteFramebuffers, "emscripten_glDeleteProgram": _emscripten_glDeleteProgram, "emscripten_glDeleteQueriesEXT": _emscripten_glDeleteQueriesEXT, "emscripten_glDeleteRenderbuffers": _emscripten_glDeleteRenderbuffers, "emscripten_glDeleteShader": _emscripten_glDeleteShader, "emscripten_glDeleteTextures": _emscripten_glDeleteTextures, "emscripten_glDeleteVertexArraysOES": _emscripten_glDeleteVertexArraysOES, "emscripten_glDepthFunc": _emscripten_glDepthFunc, "emscripten_glDepthMask": _emscripten_glDepthMask, "emscripten_glDepthRangef": _emscripten_glDepthRangef, "emscripten_glDetachShader": _emscripten_glDetachShader, "emscripten_glDisable": _emscripten_glDisable, "emscripten_glDisableVertexAttribArray": _emscripten_glDisableVertexAttribArray, "emscripten_glDrawArrays": _emscripten_glDrawArrays, "emscripten_glDrawArraysInstancedANGLE": _emscripten_glDrawArraysInstancedANGLE, "emscripten_glDrawBuffersWEBGL": _emscripten_glDrawBuffersWEBGL, "emscripten_glDrawElements": _emscripten_glDrawElements, "emscripten_glDrawElementsInstancedANGLE": _emscripten_glDrawElementsInstancedANGLE, "emscripten_glEnable": _emscripten_glEnable, "emscripten_glEnableVertexAttribArray": _emscripten_glEnableVertexAttribArray, "emscripten_glEndQueryEXT": _emscripten_glEndQueryEXT, "emscripten_glFinish": _emscripten_glFinish, "emscripten_glFlush": _emscripten_glFlush, "emscripten_glFramebufferRenderbuffer": _emscripten_glFramebufferRenderbuffer, "emscripten_glFramebufferTexture2D": _emscripten_glFramebufferTexture2D, "emscripten_glFrontFace": _emscripten_glFrontFace, "emscripten_glGenBuffers": _emscripten_glGenBuffers, "emscripten_glGenFramebuffers": _emscripten_glGenFramebuffers, "emscripten_glGenQueriesEXT": _emscripten_glGenQueriesEXT, "emscripten_glGenRenderbuffers": _emscripten_glGenRenderbuffers, "emscripten_glGenTextures": _emscripten_glGenTextures, "emscripten_glGenVertexArraysOES": _emscripten_glGenVertexArraysOES, "emscripten_glGenerateMipmap": _emscripten_glGenerateMipmap, "emscripten_glGetActiveAttrib": _emscripten_glGetActiveAttrib, "emscripten_glGetActiveUniform": _emscripten_glGetActiveUniform, "emscripten_glGetAttachedShaders": _emscripten_glGetAttachedShaders, "emscripten_glGetAttribLocation": _emscripten_glGetAttribLocation, "emscripten_glGetBooleanv": _emscripten_glGetBooleanv, "emscripten_glGetBufferParameteriv": _emscripten_glGetBufferParameteriv, "emscripten_glGetError": _emscripten_glGetError, "emscripten_glGetFloatv": _emscripten_glGetFloatv, "emscripten_glGetFramebufferAttachmentParameteriv": _emscripten_glGetFramebufferAttachmentParameteriv, "emscripten_glGetIntegerv": _emscripten_glGetIntegerv, "emscripten_glGetProgramInfoLog": _emscripten_glGetProgramInfoLog, "emscripten_glGetProgramiv": _emscripten_glGetProgramiv, "emscripten_glGetQueryObjecti64vEXT": _emscripten_glGetQueryObjecti64vEXT, "emscripten_glGetQueryObjectivEXT": _emscripten_glGetQueryObjectivEXT, "emscripten_glGetQueryObjectui64vEXT": _emscripten_glGetQueryObjectui64vEXT, "emscripten_glGetQueryObjectuivEXT": _emscripten_glGetQueryObjectuivEXT, "emscripten_glGetQueryivEXT": _emscripten_glGetQueryivEXT, "emscripten_glGetRenderbufferParameteriv": _emscripten_glGetRenderbufferParameteriv, "emscripten_glGetShaderInfoLog": _emscripten_glGetShaderInfoLog, "emscripten_glGetShaderPrecisionFormat": _emscripten_glGetShaderPrecisionFormat, "emscripten_glGetShaderSource": _emscripten_glGetShaderSource, "emscripten_glGetShaderiv": _emscripten_glGetShaderiv, "emscripten_glGetString": _emscripten_glGetString, "emscripten_glGetTexParameterfv": _emscripten_glGetTexParameterfv, "emscripten_glGetTexParameteriv": _emscripten_glGetTexParameteriv, "emscripten_glGetUniformLocation": _emscripten_glGetUniformLocation, "emscripten_glGetUniformfv": _emscripten_glGetUniformfv, "emscripten_glGetUniformiv": _emscripten_glGetUniformiv, "emscripten_glGetVertexAttribPointerv": _emscripten_glGetVertexAttribPointerv, "emscripten_glGetVertexAttribfv": _emscripten_glGetVertexAttribfv, "emscripten_glGetVertexAttribiv": _emscripten_glGetVertexAttribiv, "emscripten_glHint": _emscripten_glHint, "emscripten_glIsBuffer": _emscripten_glIsBuffer, "emscripten_glIsEnabled": _emscripten_glIsEnabled, "emscripten_glIsFramebuffer": _emscripten_glIsFramebuffer, "emscripten_glIsProgram": _emscripten_glIsProgram, "emscripten_glIsQueryEXT": _emscripten_glIsQueryEXT, "emscripten_glIsRenderbuffer": _emscripten_glIsRenderbuffer, "emscripten_glIsShader": _emscripten_glIsShader, "emscripten_glIsTexture": _emscripten_glIsTexture, "emscripten_glIsVertexArrayOES": _emscripten_glIsVertexArrayOES, "emscripten_glLineWidth": _emscripten_glLineWidth, "emscripten_glLinkProgram": _emscripten_glLinkProgram, "emscripten_glPixelStorei": _emscripten_glPixelStorei, "emscripten_glPolygonOffset": _emscripten_glPolygonOffset, "emscripten_glQueryCounterEXT": _emscripten_glQueryCounterEXT, "emscripten_glReadPixels": _emscripten_glReadPixels, "emscripten_glReleaseShaderCompiler": _emscripten_glReleaseShaderCompiler, "emscripten_glRenderbufferStorage": _emscripten_glRenderbufferStorage, "emscripten_glSampleCoverage": _emscripten_glSampleCoverage, "emscripten_glScissor": _emscripten_glScissor, "emscripten_glShaderBinary": _emscripten_glShaderBinary, "emscripten_glShaderSource": _emscripten_glShaderSource, "emscripten_glStencilFunc": _emscripten_glStencilFunc, "emscripten_glStencilFuncSeparate": _emscripten_glStencilFuncSeparate, "emscripten_glStencilMask": _emscripten_glStencilMask, "emscripten_glStencilMaskSeparate": _emscripten_glStencilMaskSeparate, "emscripten_glStencilOp": _emscripten_glStencilOp, "emscripten_glStencilOpSeparate": _emscripten_glStencilOpSeparate, "emscripten_glTexImage2D": _emscripten_glTexImage2D, "emscripten_glTexParameterf": _emscripten_glTexParameterf, "emscripten_glTexParameterfv": _emscripten_glTexParameterfv, "emscripten_glTexParameteri": _emscripten_glTexParameteri, "emscripten_glTexParameteriv": _emscripten_glTexParameteriv, "emscripten_glTexSubImage2D": _emscripten_glTexSubImage2D, "emscripten_glUniform1f": _emscripten_glUniform1f, "emscripten_glUniform1fv": _emscripten_glUniform1fv, "emscripten_glUniform1i": _emscripten_glUniform1i, "emscripten_glUniform1iv": _emscripten_glUniform1iv, "emscripten_glUniform2f": _emscripten_glUniform2f, "emscripten_glUniform2fv": _emscripten_glUniform2fv, "emscripten_glUniform2i": _emscripten_glUniform2i, "emscripten_glUniform2iv": _emscripten_glUniform2iv, "emscripten_glUniform3f": _emscripten_glUniform3f, "emscripten_glUniform3fv": _emscripten_glUniform3fv, "emscripten_glUniform3i": _emscripten_glUniform3i, "emscripten_glUniform3iv": _emscripten_glUniform3iv, "emscripten_glUniform4f": _emscripten_glUniform4f, "emscripten_glUniform4fv": _emscripten_glUniform4fv, "emscripten_glUniform4i": _emscripten_glUniform4i, "emscripten_glUniform4iv": _emscripten_glUniform4iv, "emscripten_glUniformMatrix2fv": _emscripten_glUniformMatrix2fv, "emscripten_glUniformMatrix3fv": _emscripten_glUniformMatrix3fv, "emscripten_glUniformMatrix4fv": _emscripten_glUniformMatrix4fv, "emscripten_glUseProgram": _emscripten_glUseProgram, "emscripten_glValidateProgram": _emscripten_glValidateProgram, "emscripten_glVertexAttrib1f": _emscripten_glVertexAttrib1f, "emscripten_glVertexAttrib1fv": _emscripten_glVertexAttrib1fv, "emscripten_glVertexAttrib2f": _emscripten_glVertexAttrib2f, "emscripten_glVertexAttrib2fv": _emscripten_glVertexAttrib2fv, "emscripten_glVertexAttrib3f": _emscripten_glVertexAttrib3f, "emscripten_glVertexAttrib3fv": _emscripten_glVertexAttrib3fv, "emscripten_glVertexAttrib4f": _emscripten_glVertexAttrib4f, "emscripten_glVertexAttrib4fv": _emscripten_glVertexAttrib4fv, "emscripten_glVertexAttribDivisorANGLE": _emscripten_glVertexAttribDivisorANGLE, "emscripten_glVertexAttribPointer": _emscripten_glVertexAttribPointer, "emscripten_glViewport": _emscripten_glViewport, "emscripten_has_asyncify": _emscripten_has_asyncify, "emscripten_is_main_browser_thread": _emscripten_is_main_browser_thread, "emscripten_longjmp": _emscripten_longjmp, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_request_fullscreen_strategy": _emscripten_request_fullscreen_strategy, "emscripten_request_pointerlock": _emscripten_request_pointerlock, "emscripten_resize_heap": _emscripten_resize_heap, "emscripten_run_script": _emscripten_run_script, "emscripten_sample_gamepad_data": _emscripten_sample_gamepad_data, "emscripten_set_beforeunload_callback_on_thread": _emscripten_set_beforeunload_callback_on_thread, "emscripten_set_blur_callback_on_thread": _emscripten_set_blur_callback_on_thread, "emscripten_set_canvas_element_size": _emscripten_set_canvas_element_size, "emscripten_set_element_css_size": _emscripten_set_element_css_size, "emscripten_set_focus_callback_on_thread": _emscripten_set_focus_callback_on_thread, "emscripten_set_fullscreenchange_callback_on_thread": _emscripten_set_fullscreenchange_callback_on_thread, "emscripten_set_gamepadconnected_callback_on_thread": _emscripten_set_gamepadconnected_callback_on_thread, "emscripten_set_gamepaddisconnected_callback_on_thread": _emscripten_set_gamepaddisconnected_callback_on_thread, "emscripten_set_keydown_callback_on_thread": _emscripten_set_keydown_callback_on_thread, "emscripten_set_keypress_callback_on_thread": _emscripten_set_keypress_callback_on_thread, "emscripten_set_keyup_callback_on_thread": _emscripten_set_keyup_callback_on_thread, "emscripten_set_main_loop": _emscripten_set_main_loop, "emscripten_set_mousedown_callback_on_thread": _emscripten_set_mousedown_callback_on_thread, "emscripten_set_mouseenter_callback_on_thread": _emscripten_set_mouseenter_callback_on_thread, "emscripten_set_mouseleave_callback_on_thread": _emscripten_set_mouseleave_callback_on_thread, "emscripten_set_mousemove_callback_on_thread": _emscripten_set_mousemove_callback_on_thread, "emscripten_set_mouseup_callback_on_thread": _emscripten_set_mouseup_callback_on_thread, "emscripten_set_pointerlockchange_callback_on_thread": _emscripten_set_pointerlockchange_callback_on_thread, "emscripten_set_resize_callback_on_thread": _emscripten_set_resize_callback_on_thread, "emscripten_set_touchcancel_callback_on_thread": _emscripten_set_touchcancel_callback_on_thread, "emscripten_set_touchend_callback_on_thread": _emscripten_set_touchend_callback_on_thread, "emscripten_set_touchmove_callback_on_thread": _emscripten_set_touchmove_callback_on_thread, "emscripten_set_touchstart_callback_on_thread": _emscripten_set_touchstart_callback_on_thread, "emscripten_set_visibilitychange_callback_on_thread": _emscripten_set_visibilitychange_callback_on_thread, "emscripten_set_wheel_callback_on_thread": _emscripten_set_wheel_callback_on_thread, "emscripten_sleep": _emscripten_sleep, "emscripten_start_fetch": _emscripten_start_fetch, "environ_get": _environ_get, "environ_sizes_get": _environ_sizes_get, "exit": _exit, "fd_close": _fd_close, "fd_fdstat_get": _fd_fdstat_get, "fd_read": _fd_read, "fd_seek": _fd_seek, "fd_sync": _fd_sync, "fd_write": _fd_write, "fork": _fork, "fp$eglBindAPI$ii": _fp$eglBindAPI$ii, "fp$eglChooseConfig$iiiiii": _fp$eglChooseConfig$iiiiii, "fp$eglCreateContext$iiiii": _fp$eglCreateContext$iiiii, "fp$eglCreateWindowSurface$iiiii": _fp$eglCreateWindowSurface$iiiii, "fp$eglDestroyContext$iii": _fp$eglDestroyContext$iii, "fp$eglDestroySurface$iii": _fp$eglDestroySurface$iii, "fp$eglGetConfigAttrib$iiiii": _fp$eglGetConfigAttrib$iiiii, "fp$eglGetDisplay$ii": _fp$eglGetDisplay$ii, "fp$eglGetError$i": _fp$eglGetError$i, "fp$eglGetProcAddress$ii": _fp$eglGetProcAddress$ii, "fp$eglInitialize$iiii": _fp$eglInitialize$iiii, "fp$eglMakeCurrent$iiiii": _fp$eglMakeCurrent$iiiii, "fp$eglQueryString$iii": _fp$eglQueryString$iii, "fp$eglSwapBuffers$iii": _fp$eglSwapBuffers$iii, "fp$eglSwapInterval$iii": _fp$eglSwapInterval$iii, "fp$eglTerminate$ii": _fp$eglTerminate$ii, "fp$eglWaitGL$i": _fp$eglWaitGL$i, "fp$eglWaitNative$ii": _fp$eglWaitNative$ii, "fp$emscripten_glActiveTexture$vi": _fp$emscripten_glActiveTexture$vi, "fp$emscripten_glAttachShader$vii": _fp$emscripten_glAttachShader$vii, "fp$emscripten_glBeginQueryEXT$vii": _fp$emscripten_glBeginQueryEXT$vii, "fp$emscripten_glBindAttribLocation$viii": _fp$emscripten_glBindAttribLocation$viii, "fp$emscripten_glBindBuffer$vii": _fp$emscripten_glBindBuffer$vii, "fp$emscripten_glBindFramebuffer$vii": _fp$emscripten_glBindFramebuffer$vii, "fp$emscripten_glBindRenderbuffer$vii": _fp$emscripten_glBindRenderbuffer$vii, "fp$emscripten_glBindTexture$vii": _fp$emscripten_glBindTexture$vii, "fp$emscripten_glBindVertexArrayOES$vi": _fp$emscripten_glBindVertexArrayOES$vi, "fp$emscripten_glBlendColor$vffff": _fp$emscripten_glBlendColor$vffff, "fp$emscripten_glBlendEquation$vi": _fp$emscripten_glBlendEquation$vi, "fp$emscripten_glBlendEquationSeparate$vii": _fp$emscripten_glBlendEquationSeparate$vii, "fp$emscripten_glBlendFunc$vii": _fp$emscripten_glBlendFunc$vii, "fp$emscripten_glBlendFuncSeparate$viiii": _fp$emscripten_glBlendFuncSeparate$viiii, "fp$emscripten_glBufferData$viiii": _fp$emscripten_glBufferData$viiii, "fp$emscripten_glBufferSubData$viiii": _fp$emscripten_glBufferSubData$viiii, "fp$emscripten_glCheckFramebufferStatus$ii": _fp$emscripten_glCheckFramebufferStatus$ii, "fp$emscripten_glClear$vi": _fp$emscripten_glClear$vi, "fp$emscripten_glClearColor$vffff": _fp$emscripten_glClearColor$vffff, "fp$emscripten_glClearDepthf$vf": _fp$emscripten_glClearDepthf$vf, "fp$emscripten_glClearStencil$vi": _fp$emscripten_glClearStencil$vi, "fp$emscripten_glColorMask$viiii": _fp$emscripten_glColorMask$viiii, "fp$emscripten_glCompileShader$vi": _fp$emscripten_glCompileShader$vi, "fp$emscripten_glCompressedTexImage2D$viiiiiiii": _fp$emscripten_glCompressedTexImage2D$viiiiiiii, "fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii": _fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii, "fp$emscripten_glCopyTexImage2D$viiiiiiii": _fp$emscripten_glCopyTexImage2D$viiiiiiii, "fp$emscripten_glCopyTexSubImage2D$viiiiiiii": _fp$emscripten_glCopyTexSubImage2D$viiiiiiii, "fp$emscripten_glCreateProgram$i": _fp$emscripten_glCreateProgram$i, "fp$emscripten_glCreateShader$ii": _fp$emscripten_glCreateShader$ii, "fp$emscripten_glCullFace$vi": _fp$emscripten_glCullFace$vi, "fp$emscripten_glDeleteBuffers$vii": _fp$emscripten_glDeleteBuffers$vii, "fp$emscripten_glDeleteFramebuffers$vii": _fp$emscripten_glDeleteFramebuffers$vii, "fp$emscripten_glDeleteProgram$vi": _fp$emscripten_glDeleteProgram$vi, "fp$emscripten_glDeleteQueriesEXT$vii": _fp$emscripten_glDeleteQueriesEXT$vii, "fp$emscripten_glDeleteRenderbuffers$vii": _fp$emscripten_glDeleteRenderbuffers$vii, "fp$emscripten_glDeleteShader$vi": _fp$emscripten_glDeleteShader$vi, "fp$emscripten_glDeleteTextures$vii": _fp$emscripten_glDeleteTextures$vii, "fp$emscripten_glDeleteVertexArraysOES$vii": _fp$emscripten_glDeleteVertexArraysOES$vii, "fp$emscripten_glDepthFunc$vi": _fp$emscripten_glDepthFunc$vi, "fp$emscripten_glDepthMask$vi": _fp$emscripten_glDepthMask$vi, "fp$emscripten_glDepthRangef$vff": _fp$emscripten_glDepthRangef$vff, "fp$emscripten_glDetachShader$vii": _fp$emscripten_glDetachShader$vii, "fp$emscripten_glDisable$vi": _fp$emscripten_glDisable$vi, "fp$emscripten_glDisableVertexAttribArray$vi": _fp$emscripten_glDisableVertexAttribArray$vi, "fp$emscripten_glDrawArrays$viii": _fp$emscripten_glDrawArrays$viii, "fp$emscripten_glDrawArraysInstancedANGLE$viiii": _fp$emscripten_glDrawArraysInstancedANGLE$viiii, "fp$emscripten_glDrawBuffersWEBGL$vii": _fp$emscripten_glDrawBuffersWEBGL$vii, "fp$emscripten_glDrawElements$viiii": _fp$emscripten_glDrawElements$viiii, "fp$emscripten_glDrawElementsInstancedANGLE$viiiii": _fp$emscripten_glDrawElementsInstancedANGLE$viiiii, "fp$emscripten_glEnable$vi": _fp$emscripten_glEnable$vi, "fp$emscripten_glEnableVertexAttribArray$vi": _fp$emscripten_glEnableVertexAttribArray$vi, "fp$emscripten_glEndQueryEXT$vi": _fp$emscripten_glEndQueryEXT$vi, "fp$emscripten_glFinish$v": _fp$emscripten_glFinish$v, "fp$emscripten_glFlush$v": _fp$emscripten_glFlush$v, "fp$emscripten_glFramebufferRenderbuffer$viiii": _fp$emscripten_glFramebufferRenderbuffer$viiii, "fp$emscripten_glFramebufferTexture2D$viiiii": _fp$emscripten_glFramebufferTexture2D$viiiii, "fp$emscripten_glFrontFace$vi": _fp$emscripten_glFrontFace$vi, "fp$emscripten_glGenBuffers$vii": _fp$emscripten_glGenBuffers$vii, "fp$emscripten_glGenFramebuffers$vii": _fp$emscripten_glGenFramebuffers$vii, "fp$emscripten_glGenQueriesEXT$vii": _fp$emscripten_glGenQueriesEXT$vii, "fp$emscripten_glGenRenderbuffers$vii": _fp$emscripten_glGenRenderbuffers$vii, "fp$emscripten_glGenTextures$vii": _fp$emscripten_glGenTextures$vii, "fp$emscripten_glGenVertexArraysOES$vii": _fp$emscripten_glGenVertexArraysOES$vii, "fp$emscripten_glGenerateMipmap$vi": _fp$emscripten_glGenerateMipmap$vi, "fp$emscripten_glGetActiveAttrib$viiiiiii": _fp$emscripten_glGetActiveAttrib$viiiiiii, "fp$emscripten_glGetActiveUniform$viiiiiii": _fp$emscripten_glGetActiveUniform$viiiiiii, "fp$emscripten_glGetAttachedShaders$viiii": _fp$emscripten_glGetAttachedShaders$viiii, "fp$emscripten_glGetAttribLocation$iii": _fp$emscripten_glGetAttribLocation$iii, "fp$emscripten_glGetBooleanv$vii": _fp$emscripten_glGetBooleanv$vii, "fp$emscripten_glGetBufferParameteriv$viii": _fp$emscripten_glGetBufferParameteriv$viii, "fp$emscripten_glGetError$i": _fp$emscripten_glGetError$i, "fp$emscripten_glGetFloatv$vii": _fp$emscripten_glGetFloatv$vii, "fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii": _fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii, "fp$emscripten_glGetIntegerv$vii": _fp$emscripten_glGetIntegerv$vii, "fp$emscripten_glGetProgramInfoLog$viiii": _fp$emscripten_glGetProgramInfoLog$viiii, "fp$emscripten_glGetProgramiv$viii": _fp$emscripten_glGetProgramiv$viii, "fp$emscripten_glGetQueryObjecti64vEXT$viii": _fp$emscripten_glGetQueryObjecti64vEXT$viii, "fp$emscripten_glGetQueryObjectivEXT$viii": _fp$emscripten_glGetQueryObjectivEXT$viii, "fp$emscripten_glGetQueryObjectui64vEXT$viii": _fp$emscripten_glGetQueryObjectui64vEXT$viii, "fp$emscripten_glGetQueryObjectuivEXT$viii": _fp$emscripten_glGetQueryObjectuivEXT$viii, "fp$emscripten_glGetQueryivEXT$viii": _fp$emscripten_glGetQueryivEXT$viii, "fp$emscripten_glGetRenderbufferParameteriv$viii": _fp$emscripten_glGetRenderbufferParameteriv$viii, "fp$emscripten_glGetShaderInfoLog$viiii": _fp$emscripten_glGetShaderInfoLog$viiii, "fp$emscripten_glGetShaderPrecisionFormat$viiii": _fp$emscripten_glGetShaderPrecisionFormat$viiii, "fp$emscripten_glGetShaderSource$viiii": _fp$emscripten_glGetShaderSource$viiii, "fp$emscripten_glGetShaderiv$viii": _fp$emscripten_glGetShaderiv$viii, "fp$emscripten_glGetString$ii": _fp$emscripten_glGetString$ii, "fp$emscripten_glGetTexParameterfv$viii": _fp$emscripten_glGetTexParameterfv$viii, "fp$emscripten_glGetTexParameteriv$viii": _fp$emscripten_glGetTexParameteriv$viii, "fp$emscripten_glGetUniformLocation$iii": _fp$emscripten_glGetUniformLocation$iii, "fp$emscripten_glGetUniformfv$viii": _fp$emscripten_glGetUniformfv$viii, "fp$emscripten_glGetUniformiv$viii": _fp$emscripten_glGetUniformiv$viii, "fp$emscripten_glGetVertexAttribPointerv$viii": _fp$emscripten_glGetVertexAttribPointerv$viii, "fp$emscripten_glGetVertexAttribfv$viii": _fp$emscripten_glGetVertexAttribfv$viii, "fp$emscripten_glGetVertexAttribiv$viii": _fp$emscripten_glGetVertexAttribiv$viii, "fp$emscripten_glHint$vii": _fp$emscripten_glHint$vii, "fp$emscripten_glIsBuffer$ii": _fp$emscripten_glIsBuffer$ii, "fp$emscripten_glIsEnabled$ii": _fp$emscripten_glIsEnabled$ii, "fp$emscripten_glIsFramebuffer$ii": _fp$emscripten_glIsFramebuffer$ii, "fp$emscripten_glIsProgram$ii": _fp$emscripten_glIsProgram$ii, "fp$emscripten_glIsQueryEXT$ii": _fp$emscripten_glIsQueryEXT$ii, "fp$emscripten_glIsRenderbuffer$ii": _fp$emscripten_glIsRenderbuffer$ii, "fp$emscripten_glIsShader$ii": _fp$emscripten_glIsShader$ii, "fp$emscripten_glIsTexture$ii": _fp$emscripten_glIsTexture$ii, "fp$emscripten_glIsVertexArrayOES$ii": _fp$emscripten_glIsVertexArrayOES$ii, "fp$emscripten_glLineWidth$vf": _fp$emscripten_glLineWidth$vf, "fp$emscripten_glLinkProgram$vi": _fp$emscripten_glLinkProgram$vi, "fp$emscripten_glPixelStorei$vii": _fp$emscripten_glPixelStorei$vii, "fp$emscripten_glPolygonOffset$vff": _fp$emscripten_glPolygonOffset$vff, "fp$emscripten_glQueryCounterEXT$vii": _fp$emscripten_glQueryCounterEXT$vii, "fp$emscripten_glReadPixels$viiiiiii": _fp$emscripten_glReadPixels$viiiiiii, "fp$emscripten_glReleaseShaderCompiler$v": _fp$emscripten_glReleaseShaderCompiler$v, "fp$emscripten_glRenderbufferStorage$viiii": _fp$emscripten_glRenderbufferStorage$viiii, "fp$emscripten_glSampleCoverage$vfi": _fp$emscripten_glSampleCoverage$vfi, "fp$emscripten_glScissor$viiii": _fp$emscripten_glScissor$viiii, "fp$emscripten_glShaderBinary$viiiii": _fp$emscripten_glShaderBinary$viiiii, "fp$emscripten_glShaderSource$viiii": _fp$emscripten_glShaderSource$viiii, "fp$emscripten_glStencilFunc$viii": _fp$emscripten_glStencilFunc$viii, "fp$emscripten_glStencilFuncSeparate$viiii": _fp$emscripten_glStencilFuncSeparate$viiii, "fp$emscripten_glStencilMask$vi": _fp$emscripten_glStencilMask$vi, "fp$emscripten_glStencilMaskSeparate$vii": _fp$emscripten_glStencilMaskSeparate$vii, "fp$emscripten_glStencilOp$viii": _fp$emscripten_glStencilOp$viii, "fp$emscripten_glStencilOpSeparate$viiii": _fp$emscripten_glStencilOpSeparate$viiii, "fp$emscripten_glTexImage2D$viiiiiiiii": _fp$emscripten_glTexImage2D$viiiiiiiii, "fp$emscripten_glTexParameterf$viif": _fp$emscripten_glTexParameterf$viif, "fp$emscripten_glTexParameterfv$viii": _fp$emscripten_glTexParameterfv$viii, "fp$emscripten_glTexParameteri$viii": _fp$emscripten_glTexParameteri$viii, "fp$emscripten_glTexParameteriv$viii": _fp$emscripten_glTexParameteriv$viii, "fp$emscripten_glTexSubImage2D$viiiiiiiii": _fp$emscripten_glTexSubImage2D$viiiiiiiii, "fp$emscripten_glUniform1f$vif": _fp$emscripten_glUniform1f$vif, "fp$emscripten_glUniform1fv$viii": _fp$emscripten_glUniform1fv$viii, "fp$emscripten_glUniform1i$vii": _fp$emscripten_glUniform1i$vii, "fp$emscripten_glUniform1iv$viii": _fp$emscripten_glUniform1iv$viii, "fp$emscripten_glUniform2f$viff": _fp$emscripten_glUniform2f$viff, "fp$emscripten_glUniform2fv$viii": _fp$emscripten_glUniform2fv$viii, "fp$emscripten_glUniform2i$viii": _fp$emscripten_glUniform2i$viii, "fp$emscripten_glUniform2iv$viii": _fp$emscripten_glUniform2iv$viii, "fp$emscripten_glUniform3f$vifff": _fp$emscripten_glUniform3f$vifff, "fp$emscripten_glUniform3fv$viii": _fp$emscripten_glUniform3fv$viii, "fp$emscripten_glUniform3i$viiii": _fp$emscripten_glUniform3i$viiii, "fp$emscripten_glUniform3iv$viii": _fp$emscripten_glUniform3iv$viii, "fp$emscripten_glUniform4f$viffff": _fp$emscripten_glUniform4f$viffff, "fp$emscripten_glUniform4fv$viii": _fp$emscripten_glUniform4fv$viii, "fp$emscripten_glUniform4i$viiiii": _fp$emscripten_glUniform4i$viiiii, "fp$emscripten_glUniform4iv$viii": _fp$emscripten_glUniform4iv$viii, "fp$emscripten_glUniformMatrix2fv$viiii": _fp$emscripten_glUniformMatrix2fv$viiii, "fp$emscripten_glUniformMatrix3fv$viiii": _fp$emscripten_glUniformMatrix3fv$viiii, "fp$emscripten_glUniformMatrix4fv$viiii": _fp$emscripten_glUniformMatrix4fv$viiii, "fp$emscripten_glUseProgram$vi": _fp$emscripten_glUseProgram$vi, "fp$emscripten_glValidateProgram$vi": _fp$emscripten_glValidateProgram$vi, "fp$emscripten_glVertexAttrib1f$vif": _fp$emscripten_glVertexAttrib1f$vif, "fp$emscripten_glVertexAttrib1fv$vii": _fp$emscripten_glVertexAttrib1fv$vii, "fp$emscripten_glVertexAttrib2f$viff": _fp$emscripten_glVertexAttrib2f$viff, "fp$emscripten_glVertexAttrib2fv$vii": _fp$emscripten_glVertexAttrib2fv$vii, "fp$emscripten_glVertexAttrib3f$vifff": _fp$emscripten_glVertexAttrib3f$vifff, "fp$emscripten_glVertexAttrib3fv$vii": _fp$emscripten_glVertexAttrib3fv$vii, "fp$emscripten_glVertexAttrib4f$viffff": _fp$emscripten_glVertexAttrib4f$viffff, "fp$emscripten_glVertexAttrib4fv$vii": _fp$emscripten_glVertexAttrib4fv$vii, "fp$emscripten_glVertexAttribDivisorANGLE$vii": _fp$emscripten_glVertexAttribDivisorANGLE$vii, "fp$emscripten_glVertexAttribPointer$viiiiii": _fp$emscripten_glVertexAttribPointer$viiiiii, "fp$emscripten_glViewport$viiii": _fp$emscripten_glViewport$viiii, "fp$nlr_pop$v": _fp$nlr_pop$v, "fp$nlr_push_tail$ii": _fp$nlr_push_tail$ii, "getTempRet0": getTempRet0, "getnameinfo": _getnameinfo, "gettimeofday": _gettimeofday, "gmtime_r": _gmtime_r, "inet_addr": _inet_addr, "invoke_X": invoke_X, "invoke_ii": invoke_ii, "invoke_iiii": invoke_iiii, "invoke_iiiii": invoke_iiiii, "invoke_v": invoke_v, "invoke_vii": invoke_vii, "invoke_viii": invoke_viii, "localtime": _localtime, "memory": wasmMemory, "nanosleep": _nanosleep, "nlr_pop": _nlr_pop, "nlr_push_tail": _nlr_push_tail, "ogg_page_bos": _ogg_page_bos, "ogg_page_continued": _ogg_page_continued, "ogg_page_eos": _ogg_page_eos, "ogg_page_granulepos": _ogg_page_granulepos, "ogg_page_serialno": _ogg_page_serialno, "ogg_stream_clear": _ogg_stream_clear, "ogg_stream_init": _ogg_stream_init, "ogg_stream_packetout": _ogg_stream_packetout, "ogg_stream_packetpeek": _ogg_stream_packetpeek, "ogg_stream_pagein": _ogg_stream_pagein, "ogg_stream_reset": _ogg_stream_reset, "ogg_stream_reset_serialno": _ogg_stream_reset_serialno, "ogg_sync_buffer": _ogg_sync_buffer, "ogg_sync_clear": _ogg_sync_clear, "ogg_sync_init": _ogg_sync_init, "ogg_sync_pageseek": _ogg_sync_pageseek, "ogg_sync_reset": _ogg_sync_reset, "ogg_sync_wrote": _ogg_sync_wrote, "oggpack_adv": _oggpack_adv, "oggpack_bytes": _oggpack_bytes, "oggpack_get_buffer": _oggpack_get_buffer, "oggpack_look": _oggpack_look, "oggpack_read": _oggpack_read, "oggpack_readinit": _oggpack_readinit, "oggpack_reset": _oggpack_reset, "oggpack_write": _oggpack_write, "oggpack_writeclear": _oggpack_writeclear, "oggpack_writeinit": _oggpack_writeinit, "oggpack_writetrunc": _oggpack_writetrunc, "pthread_cleanup_pop": _pthread_cleanup_pop, "pthread_cleanup_push": _pthread_cleanup_push, "pthread_setcancelstate": _pthread_setcancelstate, "pthread_sigmask": _pthread_sigmask, "round": _round, "roundf": _roundf, "saveSetjmp": _saveSetjmp, "setTempRet0": setTempRet0, "setitimer": _setitimer, "sigaction": _sigaction, "sigfillset": _sigfillset, "signal": _signal, "strftime": _strftime, "system": _system, "table": wasmTable, "testSetjmp": _testSetjmp, "time": _time, "waitpid": _waitpid };
var asm = createWasm();
Module["asm"] = asm;
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasm_call_ctors"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wasm_apply_relocs = Module["___wasm_apply_relocs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasm_apply_relocs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bsd_strlen = Module["_bsd_strlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bsd_strlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bsd_strcmp = Module["_bsd_strcmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bsd_strcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endswith = Module["_endswith"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endswith"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wasm_file_open = Module["_wasm_file_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wasm_file_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fprintf = Module["_fprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlen = Module["_strlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _snprintf = Module["_snprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["snprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fopen = Module["_fopen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fileno = Module["_fileno"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fileno"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wasm_find_module = Module["_wasm_find_module"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wasm_find_module"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _access = Module["_access"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["access"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stat = Module["_stat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copy_argv = Module["_copy_argv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copy_argv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcpy = Module["_strcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _show_os_loop = Module["_show_os_loop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["show_os_loop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _shm_ptr = Module["_shm_ptr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["shm_ptr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _shm_get_ptr = Module["_shm_get_ptr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["shm_get_ptr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wPy_NewInterpreter = Module["_wPy_NewInterpreter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wPy_NewInterpreter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_event_repl_init = Module["_pyexec_event_repl_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_event_repl_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wPy_Initialize = Module["_wPy_Initialize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wPy_Initialize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_init = Module["_gc_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_pystack_init = Module["_mp_pystack_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_pystack_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_init = Module["_mp_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_list_init = Module["_mp_obj_list_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_list_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_list_append = Module["_mp_obj_list_append"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_list_append"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_collect = Module["_gc_collect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_collect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_collect_start = Module["_gc_collect_start"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_collect_start"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_collect_root = Module["_gc_collect_root"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_collect_root"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_collect_end = Module["_gc_collect_end"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_collect_end"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _do_str = Module["_do_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["do_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_lexer_new_from_str_len = Module["_mp_lexer_new_from_str_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_lexer_new_from_str_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse = Module["_mp_parse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_compile = Module["_mp_compile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_compile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_function_0 = Module["_mp_call_function_0"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_function_0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raise_o = Module["_mp_raise_o"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raise_o"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_delay_us = Module["_mp_hal_delay_us"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_delay_us"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_delay_ms = Module["_mp_hal_delay_ms"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_delay_ms"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_ticks_ms = Module["_mp_hal_ticks_ms"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_ticks_ms"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_ticks_us = Module["_mp_hal_ticks_us"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_ticks_us"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_stdin_rx_chr = Module["_mp_hal_stdin_rx_chr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_stdin_rx_chr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetc = Module["_fgetc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _v2a = Module["_v2a"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["v2a"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hex_hi = Module["_hex_hi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hex_hi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hex_lo = Module["_hex_lo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hex_lo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _out_push = Module["_out_push"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["out_push"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbb_append = Module["_rbb_append"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbb_append"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_stdout_tx_strn = Module["_mp_hal_stdout_tx_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_stdout_tx_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _PyArg_ParseTuple = Module["_PyArg_ParseTuple"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["PyArg_ParseTuple"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfprintf = Module["_vfprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _prompt = Module["_prompt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["prompt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputs = Module["_fputs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgets = Module["_fgets"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgets"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memcpy = Module["_memcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _PyRun_IO_CODE = Module["_PyRun_IO_CODE"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["PyRun_IO_CODE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _PyRun_SimpleString = Module["_PyRun_SimpleString"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["PyRun_SimpleString"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _repl_run = Module["_repl_run"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["repl_run"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_new_interpreter = Module["_mp_new_interpreter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_new_interpreter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen1 = Module["_gen1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _printf = Module["_printf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["printf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen2 = Module["_gen2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _crash = Module["_crash"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["crash"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_free = Module["_ctx_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_abort = Module["_ctx_abort"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _zigzag = Module["_zigzag"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["zigzag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_get_next = Module["_ctx_get_next"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_get_next"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_switch = Module["_ctx_switch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_switch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_branch = Module["_ctx_branch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_branch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_call = Module["_ctx_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_sub = Module["_ctx_sub"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_sub"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_come_from = Module["_ctx_come_from"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_come_from"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctx_return = Module["_ctx_return"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctx_return"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Py_Init = Module["_Py_Init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Py_Init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_embed = Module["_SDL_embed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_embed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stderr_print_strn2 = Module["_stderr_print_strn2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stderr_print_strn2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uncaught_exception_handler = Module["_uncaught_exception_handler"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uncaught_exception_handler"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_is_subclass_fast = Module["_mp_obj_is_subclass_fast"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_is_subclass_fast"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_print_exception = Module["_mp_obj_print_exception"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_print_exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dump_args2 = Module["_dump_args2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dump_args2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _main_loop_or_step = Module["_main_loop_or_step"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["main_loop_or_step"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _puts = Module["_puts"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["puts"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_friendly_repl_process_char = Module["_pyexec_friendly_repl_process_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_friendly_repl_process_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _handle_uncaught_exception = Module["_handle_uncaught_exception"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["handle_uncaught_exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_store_global = Module["_mp_store_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_store_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_type = Module["_mp_obj_get_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_bc_call = Module["_fun_bc_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_bc_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_type_str = Module["_mp_obj_get_type_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_type_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_exception_msg_varg = Module["_mp_obj_new_exception_msg_varg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_exception_msg_varg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_handle_pending = Module["_mp_handle_pending"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_handle_pending"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_decode_uint_value = Module["_mp_decode_uint_value"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_decode_uint_value"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_decode_uint_skip = Module["_mp_decode_uint_skip"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_decode_uint_skip"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_pystack_alloc = Module["_mp_pystack_alloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_pystack_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_setup_code_state = Module["_mp_setup_code_state"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_setup_code_state"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_execute_bytecode = Module["_mp_execute_bytecode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_execute_bytecode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_make_raise_obj = Module["_mp_make_raise_obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_make_raise_obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_str = Module["_qstr_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_exception_msg = Module["_mp_obj_new_exception_msg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_exception_msg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_cell_get = Module["_mp_obj_cell_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_cell_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_name = Module["_mp_load_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_global = Module["_mp_load_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_attr = Module["_mp_load_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_store_attr = Module["_mp_store_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_store_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_method = Module["_mp_load_method"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_method"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_super_method = Module["_mp_load_super_method"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_super_method"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_build_class = Module["_mp_load_build_class"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_build_class"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_subscr = Module["_mp_obj_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_cell_set = Module["_mp_obj_cell_set"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_cell_set"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_store_name = Module["_mp_store_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_store_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_delete_name = Module["_mp_delete_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_delete_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_delete_global = Module["_mp_delete_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_delete_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_is_true = Module["_mp_obj_is_true"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_is_true"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_tuple = Module["_mp_obj_new_tuple"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_tuple"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_list = Module["_mp_obj_new_list"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_list"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_dict = Module["_mp_obj_new_dict"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_dict"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_dict_store = Module["_mp_obj_dict_store"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_dict_store"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_method_n_kw = Module["_mp_call_method_n_kw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_method_n_kw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_getiter = Module["_mp_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_set_store = Module["_mp_obj_set_store"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_set_store"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_unpack_sequence = Module["_mp_unpack_sequence"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_unpack_sequence"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_unpack_ex = Module["_mp_unpack_ex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_unpack_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_make_function_from_raw_code = Module["_mp_make_function_from_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_make_function_from_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_make_closure_from_raw_code = Module["_mp_make_closure_from_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_make_closure_from_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_fun_get_name = Module["_mp_obj_fun_get_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_fun_get_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_method_n_kw_var = Module["_mp_call_method_n_kw_var"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_method_n_kw_var"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_resume = Module["_mp_resume"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_resume"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_match = Module["_mp_obj_exception_match"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_match"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_get_value = Module["_mp_obj_exception_get_value"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_get_value"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_map_lookup = Module["_mp_map_lookup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_map_lookup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin___import__ = Module["_mp_builtin___import__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin___import__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcmp = Module["_strcmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_import_from = Module["_mp_import_from"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_import_from"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_import_all = Module["_mp_import_all"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_import_all"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_set = Module["_mp_obj_new_set"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_set"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_slice = Module["_mp_obj_new_slice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_slice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_instance_iternext = Module["_gen_instance_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_instance_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_method_maybe = Module["_mp_load_method_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_method_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_prepare_args_n_kw_var = Module["_mp_call_prepare_args_n_kw_var"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_prepare_args_n_kw_var"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_unary_op = Module["_mp_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_op = Module["_mp_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_add_traceback = Module["_mp_obj_exception_add_traceback"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_add_traceback"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_repl_repl_restart = Module["_pyexec_repl_repl_restart"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_repl_repl_restart"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbb_is_empty = Module["_rbb_is_empty"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbb_is_empty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbb_pop = Module["_rbb_pop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbb_pop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _main = Module["_main"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["main"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_GetProcAddress = Module["_emscripten_GetProcAddress"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_GetProcAddress"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_malloc = Module["_m_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_malloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_alloc = Module["_gc_alloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_malloc_fail = Module["_m_malloc_fail"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_malloc_fail"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_malloc_maybe = Module["_m_malloc_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_malloc_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_malloc0 = Module["_m_malloc0"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_malloc0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_realloc = Module["_m_realloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_realloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_realloc = Module["_gc_realloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_realloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_realloc_maybe = Module["_m_realloc_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_realloc_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_free = Module["_m_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_free = Module["_gc_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_get_total_bytes_allocated = Module["_m_get_total_bytes_allocated"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_get_total_bytes_allocated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_get_current_bytes_allocated = Module["_m_get_current_bytes_allocated"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_get_current_bytes_allocated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _m_get_peak_bytes_allocated = Module["_m_get_peak_bytes_allocated"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["m_get_peak_bytes_allocated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memset = Module["_memset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_lock = Module["_gc_lock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_lock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_unlock = Module["_gc_unlock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_unlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_is_locked = Module["_gc_is_locked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_is_locked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_mark_subtree = Module["_gc_mark_subtree"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_mark_subtree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_deal_with_stack_overflow = Module["_gc_deal_with_stack_overflow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_deal_with_stack_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_sweep = Module["_gc_sweep"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_sweep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_sweep_all = Module["_gc_sweep_all"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_sweep_all"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_info = Module["_gc_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_nbytes = Module["_gc_nbytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_nbytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_dump_info = Module["_gc_dump_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_dump_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_printf = Module["_mp_printf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_printf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_dump_alloc_table = Module["_gc_dump_alloc_table"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_dump_alloc_table"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_print_str = Module["_mp_print_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_print_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fiprintf = Module["_fiprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fiprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_exception_arg1 = Module["_mp_obj_new_exception_arg1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_exception_arg1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_compute_hash = Module["_qstr_compute_hash"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_compute_hash"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_init = Module["_qstr_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _find_qstr = Module["_find_qstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["find_qstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_add = Module["_qstr_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_find_strn = Module["_qstr_find_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_find_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memcmp = Module["_memcmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_from_str = Module["_qstr_from_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_from_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_from_strn = Module["_qstr_from_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_from_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raise_msg_o = Module["_mp_raise_msg_o"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raise_msg_o"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_hash = Module["_qstr_hash"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_hash"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_len = Module["_qstr_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_data = Module["_qstr_data"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_data"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_pool_info = Module["_qstr_pool_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_pool_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_dump_data = Module["_qstr_dump_data"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_dump_data"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_init = Module["_vstr_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_init_len = Module["_vstr_init_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_init_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_init_fixed_buf = Module["_vstr_init_fixed_buf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_init_fixed_buf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_init_print = Module["_vstr_init_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_init_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _void_add_strn = Module["_void_add_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["void_add_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_ensure_extra = Module["_vstr_ensure_extra"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_ensure_extra"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memmove = Module["_memmove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memmove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_clear = Module["_vstr_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_new = Module["_vstr_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_free = Module["_vstr_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_extend = Module["_vstr_extend"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_extend"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_hint_size = Module["_vstr_hint_size"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_hint_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_add_len = Module["_vstr_add_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_add_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_null_terminated_str = Module["_vstr_null_terminated_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_null_terminated_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_add_byte = Module["_vstr_add_byte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_add_byte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_add_char = Module["_vstr_add_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_add_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_add_str = Module["_vstr_add_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_add_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_add_strn = Module["_vstr_add_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_add_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_ins_blank_bytes = Module["_vstr_ins_blank_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_ins_blank_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_ins_byte = Module["_vstr_ins_byte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_ins_byte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_ins_char = Module["_vstr_ins_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_ins_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_cut_head_bytes = Module["_vstr_cut_head_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_cut_head_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_cut_out_bytes = Module["_vstr_cut_out_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_cut_out_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_cut_tail_bytes = Module["_vstr_cut_tail_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_cut_tail_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_printf = Module["_vstr_printf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_printf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vstr_vprintf = Module["_vstr_vprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vstr_vprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_vprintf = Module["_mp_vprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_vprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _plat_print_strn = Module["_plat_print_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["plat_print_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_stdout_tx_strn_cooked = Module["_mp_hal_stdout_tx_strn_cooked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_stdout_tx_strn_cooked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_print_strn = Module["_mp_print_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_print_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_print_int = Module["_mp_print_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_print_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_print_mp_int = Module["_mp_print_mp_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_print_mp_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_int = Module["_mp_obj_get_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_sign = Module["_mp_obj_int_sign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_sign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_formatted = Module["_mp_obj_int_formatted"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_formatted"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_print_float = Module["_mp_print_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_print_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_format_float = Module["_mp_format_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_format_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utf8_get_char = Module["_utf8_get_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utf8_get_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utf8_next_char = Module["_utf8_next_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utf8_next_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utf8_ptr_to_index = Module["_utf8_ptr_to_index"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utf8_ptr_to_index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utf8_charlen = Module["_utf8_charlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utf8_charlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_isspace = Module["_unichar_isspace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_isspace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_isalpha = Module["_unichar_isalpha"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_isalpha"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_isdigit = Module["_unichar_isdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_isdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_isxdigit = Module["_unichar_isxdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_isxdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_isident = Module["_unichar_isident"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_isident"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_isalnum = Module["_unichar_isalnum"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_isalnum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_isupper = Module["_unichar_isupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_isupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_islower = Module["_unichar_islower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_islower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_tolower = Module["_unichar_tolower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_tolower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_toupper = Module["_unichar_toupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_toupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unichar_xdigit_value = Module["_unichar_xdigit_value"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unichar_xdigit_value"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utf8_check = Module["_utf8_check"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utf8_check"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_remove_trailing_zeros = Module["_mpn_remove_trailing_zeros"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_remove_trailing_zeros"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_cmp = Module["_mpn_cmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_cmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_shl = Module["_mpn_shl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_shl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_shr = Module["_mpn_shr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_shr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_add = Module["_mpn_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_sub = Module["_mpn_sub"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_sub"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_and_neg = Module["_mpn_and_neg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_and_neg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_or_neg = Module["_mpn_or_neg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_or_neg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_xor_neg = Module["_mpn_xor_neg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_xor_neg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_mul_dig_add_dig = Module["_mpn_mul_dig_add_dig"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_mul_dig_add_dig"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_mul = Module["_mpn_mul"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_mul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpn_div = Module["_mpn_div"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpn_div"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_init_zero = Module["_mpz_init_zero"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_init_zero"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_init_from_int = Module["_mpz_init_from_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_init_from_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_set_from_int = Module["_mpz_set_from_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_set_from_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_need_dig = Module["_mpz_need_dig"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_need_dig"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_init_fixed_from_int = Module["_mpz_init_fixed_from_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_init_fixed_from_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_deinit = Module["_mpz_deinit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_deinit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_free = Module["_mpz_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_clone = Module["_mpz_clone"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_clone"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_set = Module["_mpz_set"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_set"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_set_from_ll = Module["_mpz_set_from_ll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_set_from_ll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_set_from_float = Module["_mpz_set_from_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_set_from_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_set_from_str = Module["_mpz_set_from_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_set_from_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_set_from_bytes = Module["_mpz_set_from_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_set_from_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_cmp = Module["_mpz_cmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_cmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_abs_inpl = Module["_mpz_abs_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_abs_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_neg_inpl = Module["_mpz_neg_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_neg_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_not_inpl = Module["_mpz_not_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_not_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_shl_inpl = Module["_mpz_shl_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_shl_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_shr_inpl = Module["_mpz_shr_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_shr_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_add_inpl = Module["_mpz_add_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_add_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_sub_inpl = Module["_mpz_sub_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_sub_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_and_inpl = Module["_mpz_and_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_and_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_or_inpl = Module["_mpz_or_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_or_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_xor_inpl = Module["_mpz_xor_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_xor_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_mul_inpl = Module["_mpz_mul_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_mul_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_pow_inpl = Module["_mpz_pow_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_pow_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_pow3_inpl = Module["_mpz_pow3_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_pow3_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_divmod_inpl = Module["_mpz_divmod_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_divmod_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_hash = Module["_mpz_hash"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_hash"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_as_int_checked = Module["_mpz_as_int_checked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_as_int_checked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_as_uint_checked = Module["_mpz_as_uint_checked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_as_uint_checked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_as_bytes = Module["_mpz_as_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_as_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_as_float = Module["_mpz_as_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_as_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mpz_as_str_inpl = Module["_mpz_as_str_inpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mpz_as_str_inpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_reader_mem_readbyte = Module["_mp_reader_mem_readbyte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_reader_mem_readbyte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_reader_mem_close = Module["_mp_reader_mem_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_reader_mem_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_reader_new_mem = Module["_mp_reader_new_mem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_reader_new_mem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_end = Module["_is_end"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_end"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_physical_newline = Module["_is_physical_newline"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_physical_newline"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char = Module["_is_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char_or = Module["_is_char_or"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char_or"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char_or3 = Module["_is_char_or3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char_or3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char_or4 = Module["_is_char_or4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char_or4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char_following = Module["_is_char_following"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char_following"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char_following_or = Module["_is_char_following_or"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char_following_or"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char_following_following_or = Module["_is_char_following_following_or"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char_following_following_or"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_char_and = Module["_is_char_and"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_char_and"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_whitespace = Module["_is_whitespace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_whitespace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_letter = Module["_is_letter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_letter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_digit = Module["_is_digit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_digit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_following_digit = Module["_is_following_digit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_following_digit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_following_base_char = Module["_is_following_base_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_following_base_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_following_odigit = Module["_is_following_odigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_following_odigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_string_or_bytes = Module["_is_string_or_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_string_or_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_head_of_identifier = Module["_is_head_of_identifier"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_head_of_identifier"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_tail_of_identifier = Module["_is_tail_of_identifier"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_tail_of_identifier"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _swap_char_banks = Module["_swap_char_banks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["swap_char_banks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _next_char = Module["_next_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["next_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _indent_push = Module["_indent_push"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["indent_push"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _indent_top = Module["_indent_top"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["indent_top"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _indent_pop = Module["_indent_pop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["indent_pop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_hex = Module["_get_hex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_hex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _parse_string_literal = Module["_parse_string_literal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["parse_string_literal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raise_NotImplementedError_o = Module["_mp_raise_NotImplementedError_o"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raise_NotImplementedError_o"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _skip_whitespace = Module["_skip_whitespace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["skip_whitespace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_lexer_to_next = Module["_mp_lexer_to_next"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_lexer_to_next"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_lexer_new = Module["_mp_lexer_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_lexer_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_lexer_free = Module["_mp_lexer_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_lexer_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_rule_arg = Module["_get_rule_arg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_rule_arg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _parser_alloc = Module["_parser_alloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["parser_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _push_rule = Module["_push_rule"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["push_rule"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _push_rule_from_arg = Module["_push_rule_from_arg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["push_rule_from_arg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pop_rule = Module["_pop_rule"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pop_rule"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_node_is_const_false = Module["_mp_parse_node_is_const_false"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_node_is_const_false"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_node_is_const_true = Module["_mp_parse_node_is_const_true"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_node_is_const_true"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_node_get_int_maybe = Module["_mp_parse_node_get_int_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_node_get_int_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_node_extract_list = Module["_mp_parse_node_extract_list"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_node_extract_list"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pop_result = Module["_pop_result"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pop_result"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _peek_result = Module["_peek_result"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["peek_result"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _push_result_node = Module["_push_result_node"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["push_result_node"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _make_node_const_object = Module["_make_node_const_object"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["make_node_const_object"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_node_new_small_int_checked = Module["_mp_parse_node_new_small_int_checked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_node_new_small_int_checked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _push_result_token = Module["_push_result_token"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["push_result_token"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_num_integer = Module["_mp_parse_num_integer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_num_integer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_num_decimal = Module["_mp_parse_num_decimal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_num_decimal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_str_copy = Module["_mp_obj_new_str_copy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_str_copy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fold_logical_constants = Module["_fold_logical_constants"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fold_logical_constants"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fold_constants = Module["_fold_constants"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fold_constants"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _push_result_rule = Module["_push_result_rule"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["push_result_rule"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_map_init = Module["_mp_map_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_map_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_map_deinit = Module["_mp_map_deinit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_map_deinit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_tree_clear = Module["_mp_parse_tree_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_tree_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_new = Module["_scope_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_glue_new_raw_code = Module["_mp_emit_glue_new_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_glue_new_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_free = Module["_scope_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_find_or_add_id = Module["_scope_find_or_add_id"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_find_or_add_id"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_find = Module["_scope_find"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_find"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_find_global = Module["_scope_find_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_find_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_close_over_in_parents = Module["_scope_close_over_in_parents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_close_over_in_parents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_check_to_close_over = Module["_scope_check_to_close_over"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_check_to_close_over"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_error_set_line = Module["_compile_error_set_line"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_error_set_line"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_syntax_error = Module["_compile_syntax_error"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_syntax_error"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _comp_next_label = Module["_comp_next_label"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["comp_next_label"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_increase_except_level = Module["_compile_increase_except_level"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_increase_except_level"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_setup_block = Module["_mp_emit_bc_setup_block"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_setup_block"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_decrease_except_level = Module["_compile_decrease_except_level"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_decrease_except_level"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_end_finally = Module["_mp_emit_bc_end_finally"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_end_finally"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_new_and_link = Module["_scope_new_and_link"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_new_and_link"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _apply_to_single_or_list = Module["_apply_to_single_or_list"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["apply_to_single_or_list"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_generic_all_nodes = Module["_compile_generic_all_nodes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_generic_all_nodes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_node = Module["_compile_node"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_node"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_const_small_int = Module["_mp_emit_bc_load_const_small_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_const_small_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_load_id = Module["_compile_load_id"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_load_id"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_const_str = Module["_mp_emit_bc_load_const_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_const_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_const_obj = Module["_mp_emit_bc_load_const_obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_const_obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_bytes = Module["_mp_obj_new_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_const_tok = Module["_mp_emit_bc_load_const_tok"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_const_tok"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_set_source_line = Module["_mp_emit_bc_set_source_line"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_set_source_line"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_common_id_op = Module["_mp_emit_common_id_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_common_id_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_store_id = Module["_compile_store_id"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_store_id"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_common_get_id_for_modification = Module["_mp_emit_common_get_id_for_modification"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_common_get_id_for_modification"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_delete_id = Module["_compile_delete_id"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_delete_id"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c_tuple = Module["_c_tuple"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c_tuple"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_build = Module["_mp_emit_bc_build"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_build"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_generic_tuple = Module["_compile_generic_tuple"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_generic_tuple"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c_if_cond = Module["_c_if_cond"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c_if_cond"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_jump = Module["_mp_emit_bc_jump"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_jump"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_pop_jump_if = Module["_mp_emit_bc_pop_jump_if"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_pop_jump_if"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_label_assign = Module["_mp_emit_bc_label_assign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_label_assign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c_assign_atom_expr = Module["_c_assign_atom_expr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c_assign_atom_expr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_rot_three = Module["_mp_emit_bc_rot_three"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_rot_three"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_subscr = Module["_mp_emit_bc_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_dup_top_two = Module["_mp_emit_bc_dup_top_two"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_dup_top_two"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_dup_top = Module["_mp_emit_bc_dup_top"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_dup_top"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_attr = Module["_mp_emit_bc_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_rot_two = Module["_mp_emit_bc_rot_two"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_rot_two"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c_assign_tuple = Module["_c_assign_tuple"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c_assign_tuple"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_unpack_ex = Module["_mp_emit_bc_unpack_ex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_unpack_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c_assign = Module["_c_assign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c_assign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_unpack_sequence = Module["_mp_emit_bc_unpack_sequence"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_unpack_sequence"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _close_over_variables_etc = Module["_close_over_variables_etc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["close_over_variables_etc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_local = Module["_mp_emit_bc_load_local"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_local"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_make_closure = Module["_mp_emit_bc_make_closure"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_make_closure"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_make_function = Module["_mp_emit_bc_make_function"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_make_function"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_funcdef_lambdef_param = Module["_compile_funcdef_lambdef_param"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_funcdef_lambdef_param"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_null = Module["_mp_emit_bc_load_null"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_null"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_store_map = Module["_mp_emit_bc_store_map"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_store_map"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_funcdef_lambdef = Module["_compile_funcdef_lambdef"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_funcdef_lambdef"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_funcdef_helper = Module["_compile_funcdef_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_funcdef_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_classdef_helper = Module["_compile_classdef_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_classdef_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_build_class = Module["_mp_emit_bc_load_build_class"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_build_class"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_trailer_paren_helper = Module["_compile_trailer_paren_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_trailer_paren_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_comprehension = Module["_compile_comprehension"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_comprehension"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_call_method = Module["_mp_emit_bc_call_method"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_call_method"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_call_function = Module["_mp_emit_bc_call_function"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_call_function"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_built_in_decorator = Module["_compile_built_in_decorator"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_built_in_decorator"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_decorated = Module["_compile_decorated"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_decorated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_funcdef = Module["_compile_funcdef"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_funcdef"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c_del_stmt = Module["_c_del_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c_del_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_del_stmt = Module["_compile_del_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_del_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_break_cont_stmt = Module["_compile_break_cont_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_break_cont_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_unwind_jump = Module["_mp_emit_bc_unwind_jump"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_unwind_jump"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_return_stmt = Module["_compile_return_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_return_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_return_value = Module["_mp_emit_bc_return_value"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_return_value"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_yield_stmt = Module["_compile_yield_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_yield_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_pop_top = Module["_mp_emit_bc_pop_top"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_pop_top"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_raise_stmt = Module["_compile_raise_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_raise_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_raise_varargs = Module["_mp_emit_bc_raise_varargs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_raise_varargs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _do_import_name = Module["_do_import_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["do_import_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_import = Module["_mp_emit_bc_import"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_import"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_dotted_as_name = Module["_compile_dotted_as_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_dotted_as_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_import_name = Module["_compile_import_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_import_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_import_from = Module["_compile_import_from"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_import_from"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_declare_global = Module["_compile_declare_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_declare_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_declare_nonlocal = Module["_compile_declare_nonlocal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_declare_nonlocal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_global_nonlocal_stmt = Module["_compile_global_nonlocal_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_global_nonlocal_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_assert_stmt = Module["_compile_assert_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_assert_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_global = Module["_mp_emit_bc_load_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_if_stmt = Module["_compile_if_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_if_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_last_emit_was_return_value = Module["_mp_emit_bc_last_emit_was_return_value"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_last_emit_was_return_value"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_while_stmt = Module["_compile_while_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_while_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_for_stmt_optimised_range = Module["_compile_for_stmt_optimised_range"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_for_stmt_optimised_range"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_binary_op = Module["_mp_emit_bc_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_adjust_stack_size = Module["_mp_emit_bc_adjust_stack_size"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_adjust_stack_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_for_stmt = Module["_compile_for_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_for_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_get_iter = Module["_mp_emit_bc_get_iter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_get_iter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_for_iter = Module["_mp_emit_bc_for_iter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_for_iter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_for_iter_end = Module["_mp_emit_bc_for_iter_end"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_for_iter_end"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_try_except = Module["_compile_try_except"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_try_except"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_pop_except_jump = Module["_mp_emit_bc_pop_except_jump"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_pop_except_jump"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_start_except_handler = Module["_mp_emit_bc_start_except_handler"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_start_except_handler"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_end_except_handler = Module["_mp_emit_bc_end_except_handler"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_end_except_handler"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_try_finally = Module["_compile_try_finally"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_try_finally"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_try_stmt = Module["_compile_try_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_try_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_with_stmt_helper = Module["_compile_with_stmt_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_with_stmt_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_with_cleanup = Module["_mp_emit_bc_with_cleanup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_with_cleanup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_with_stmt = Module["_compile_with_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_with_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_yield_from = Module["_compile_yield_from"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_yield_from"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_yield = Module["_mp_emit_bc_yield"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_yield"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_await_object_method = Module["_compile_await_object_method"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_await_object_method"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_load_method = Module["_mp_emit_bc_load_method"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_load_method"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_async_for_stmt = Module["_compile_async_for_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_async_for_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_async_with_stmt_helper = Module["_compile_async_with_stmt_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_async_with_stmt_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_async_with_stmt = Module["_compile_async_with_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_async_with_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_async_stmt = Module["_compile_async_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_async_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_expr_stmt = Module["_compile_expr_stmt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_expr_stmt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_test_if_expr = Module["_compile_test_if_expr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_test_if_expr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_lambdef = Module["_compile_lambdef"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_lambdef"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_or_and_test = Module["_compile_or_and_test"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_or_and_test"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_jump_if_or_pop = Module["_mp_emit_bc_jump_if_or_pop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_jump_if_or_pop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_not_test_2 = Module["_compile_not_test_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_not_test_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_unary_op = Module["_mp_emit_bc_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_comparison = Module["_compile_comparison"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_comparison"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_star_expr = Module["_compile_star_expr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_star_expr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_binary_op = Module["_compile_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_term = Module["_compile_term"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_term"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_factor_2 = Module["_compile_factor_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_factor_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_atom_expr_normal = Module["_compile_atom_expr_normal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_atom_expr_normal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_atom_brace_helper = Module["_compile_atom_brace_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_atom_brace_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_power = Module["_compile_power"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_power"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_atom_paren = Module["_compile_atom_paren"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_atom_paren"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_atom_bracket = Module["_compile_atom_bracket"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_atom_bracket"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_atom_brace = Module["_compile_atom_brace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_atom_brace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_trailer_paren = Module["_compile_trailer_paren"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_trailer_paren"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_trailer_bracket = Module["_compile_trailer_bracket"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_trailer_bracket"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_trailer_period = Module["_compile_trailer_period"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_trailer_period"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_subscript = Module["_compile_subscript"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_subscript"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_dictorsetmaker_item = Module["_compile_dictorsetmaker_item"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_dictorsetmaker_item"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_classdef = Module["_compile_classdef"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_classdef"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_yield_expr = Module["_compile_yield_expr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_yield_expr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_atom_expr_await = Module["_compile_atom_expr_await"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_atom_expr_await"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_const_object = Module["_get_const_object"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_const_object"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_const_object = Module["_compile_const_object"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_const_object"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_scope_func_lambda_param = Module["_compile_scope_func_lambda_param"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_scope_func_lambda_param"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_scope_func_param = Module["_compile_scope_func_param"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_scope_func_param"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_scope_lambda_param = Module["_compile_scope_lambda_param"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_scope_lambda_param"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_scope_comp_iter = Module["_compile_scope_comp_iter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_scope_comp_iter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_store_comp = Module["_mp_emit_bc_store_comp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_store_comp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _check_for_doc_string = Module["_check_for_doc_string"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["check_for_doc_string"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compile_scope = Module["_compile_scope"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compile_scope"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_start_pass = Module["_mp_emit_bc_start_pass"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_start_pass"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_end_pass = Module["_mp_emit_bc_end_pass"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_end_pass"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scope_compute_things = Module["_scope_compute_things"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scope_compute_things"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_compile_to_raw_code = Module["_mp_compile_to_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_compile_to_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_bc_new = Module["_emit_bc_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_bc_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_bc_set_max_num_labels = Module["_emit_bc_set_max_num_labels"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_bc_set_max_num_labels"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_bc_free = Module["_emit_bc_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_bc_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_uint = Module["_emit_write_uint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_uint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_get_cur_to_write_code_info = Module["_emit_get_cur_to_write_code_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_get_cur_to_write_code_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_code_info_byte = Module["_emit_write_code_info_byte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_code_info_byte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_code_info_qstr = Module["_emit_write_code_info_qstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_code_info_qstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_code_info_bytes_lines = Module["_emit_write_code_info_bytes_lines"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_code_info_bytes_lines"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_get_cur_to_write_bytecode = Module["_emit_get_cur_to_write_bytecode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_get_cur_to_write_bytecode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_raw_byte = Module["_emit_write_bytecode_raw_byte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_raw_byte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte = Module["_emit_write_bytecode_byte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_int = Module["_emit_write_bytecode_byte_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_uint = Module["_emit_write_bytecode_byte_uint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_uint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_const = Module["_emit_write_bytecode_byte_const"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_const"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_qstr = Module["_emit_write_bytecode_byte_qstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_qstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_obj = Module["_emit_write_bytecode_byte_obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_raw_code = Module["_emit_write_bytecode_byte_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_unsigned_label = Module["_emit_write_bytecode_byte_unsigned_label"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_unsigned_label"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_write_bytecode_byte_signed_label = Module["_emit_write_bytecode_byte_signed_label"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_write_bytecode_byte_signed_label"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_glue_assign_bytecode = Module["_mp_emit_glue_assign_bytecode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_glue_assign_bytecode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_store_local = Module["_mp_emit_bc_store_local"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_store_local"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_store_global = Module["_mp_emit_bc_store_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_store_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_delete_local = Module["_mp_emit_bc_delete_local"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_delete_local"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_emit_bc_delete_global = Module["_mp_emit_bc_delete_global"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_emit_bc_delete_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emit_bc_call_function_method_helper = Module["_emit_bc_call_function_method_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emit_bc_call_function_method_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_num_base = Module["_mp_parse_num_base"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_num_base"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _raise_exc = Module["_raise_exc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["raise_exc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raise_ValueError_o = Module["_mp_raise_ValueError_o"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raise_ValueError_o"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_small_int_mul_overflow = Module["_mp_small_int_mul_overflow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_small_int_mul_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_int_from_str_len = Module["_mp_obj_new_int_from_str_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_int_from_str_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_str_print_quoted = Module["_mp_str_print_quoted"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_str_print_quoted"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_str_from_vstr = Module["_mp_obj_new_str_from_vstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_str_from_vstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nan = Module["_nan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pow = Module["_pow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_complex = Module["_mp_obj_new_complex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_complex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_float = Module["_mp_obj_new_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_fun_bc = Module["_mp_obj_new_fun_bc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_fun_bc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_closure = Module["_mp_obj_new_closure"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_closure"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_small_int_bits = Module["_mp_small_int_bits"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_small_int_bits"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_window_push = Module["_qstr_window_push"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_window_push"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_window_pull = Module["_qstr_window_pull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_window_pull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_window_access = Module["_qstr_window_access"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_window_access"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qstr_window_insert = Module["_qstr_window_insert"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qstr_window_insert"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _extract_prelude = Module["_extract_prelude"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["extract_prelude"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _read_byte = Module["_read_byte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["read_byte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _read_bytes = Module["_read_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["read_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _read_uint = Module["_read_uint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["read_uint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _load_qstr = Module["_load_qstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["load_qstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _load_obj = Module["_load_obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["load_obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _load_prelude_qstrs = Module["_load_prelude_qstrs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["load_prelude_qstrs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _load_prelude = Module["_load_prelude"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["load_prelude"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _load_bytecode = Module["_load_bytecode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["load_bytecode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_opcode_format = Module["_mp_opcode_format"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_opcode_format"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _load_raw_code = Module["_load_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["load_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raw_code_load = Module["_mp_raw_code_load"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raw_code_load"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raw_code_load_mem = Module["_mp_raw_code_load_mem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raw_code_load_mem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raw_code_load_file = Module["_mp_raw_code_load_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raw_code_load_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_reader_new_file = Module["_mp_reader_new_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_reader_new_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_print_bytes = Module["_mp_print_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_print_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_print_uint = Module["_mp_print_uint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_print_uint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _save_qstr = Module["_save_qstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["save_qstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _save_obj = Module["_save_obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["save_obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_binary_op = Module["_mp_obj_str_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_get_data = Module["_mp_obj_str_get_data"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_get_data"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_print_helper = Module["_mp_obj_print_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_print_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _save_prelude_qstrs = Module["_save_prelude_qstrs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["save_prelude_qstrs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _save_bytecode = Module["_save_bytecode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["save_bytecode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _save_raw_code = Module["_save_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["save_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raw_code_has_native = Module["_mp_raw_code_has_native"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raw_code_has_native"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raw_code_save = Module["_mp_raw_code_save"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raw_code_save"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fd_print_strn = Module["_fd_print_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fd_print_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _write = Module["_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raw_code_save_file = Module["_mp_raw_code_save_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raw_code_save_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open = Module["_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _close = Module["_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_init_emergency_exception_buf = Module["_mp_init_emergency_exception_buf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_init_emergency_exception_buf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_dict_init = Module["_mp_obj_dict_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_dict_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_deinit = Module["_mp_deinit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_deinit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_dict_delete = Module["_mp_obj_dict_delete"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_dict_delete"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_int = Module["_mp_obj_new_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_equal_not_equal = Module["_mp_obj_equal_not_equal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_equal_not_equal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_is_exception_type = Module["_mp_obj_is_exception_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_is_exception_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_int_from_ll = Module["_mp_obj_new_int_from_ll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_int_from_ll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_small_int_floor_divide = Module["_mp_small_int_floor_divide"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_small_int_floor_divide"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_small_int_modulo = Module["_mp_small_int_modulo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_small_int_modulo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_float_binary_op = Module["_mp_obj_float_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_float_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_complex_binary_op = Module["_mp_obj_complex_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_complex_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_iternext = Module["_mp_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_equal = Module["_mp_obj_equal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_equal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_identity_getiter = Module["_mp_identity_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_identity_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_getiter = Module["_mp_obj_instance_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_getitem_iter = Module["_mp_obj_new_getitem_iter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_getitem_iter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_exception = Module["_mp_obj_new_exception"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_function_n_kw = Module["_mp_call_function_n_kw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_function_n_kw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_function_1 = Module["_mp_call_function_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_function_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_function_2 = Module["_mp_call_function_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_function_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_dict_len = Module["_mp_obj_dict_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_dict_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_array = Module["_mp_obj_get_array"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_array"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_intern_checked = Module["_mp_obj_str_intern_checked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_intern_checked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_list_set_len = Module["_mp_obj_list_set_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_list_set_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_bound_meth = Module["_mp_obj_new_bound_meth"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_bound_meth"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_convert_member_lookup = Module["_mp_convert_member_lookup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_convert_member_lookup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_load_method_protected = Module["_mp_load_method_protected"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_load_method_protected"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_iternext_allow_raise = Module["_mp_iternext_allow_raise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_iternext_allow_raise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_iternext2 = Module["_mp_iternext2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_iternext2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_iternext_had_exc = Module["_mp_iternext_had_exc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_iternext_had_exc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_gen_resume = Module["_mp_obj_gen_resume"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_gen_resume"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_is_exception_instance = Module["_mp_obj_is_exception_instance"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_is_exception_instance"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_import_name = Module["_mp_import_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_import_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_is_package = Module["_mp_obj_is_package"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_is_package"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_get_str = Module["_mp_obj_str_get_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_get_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_get_qstr = Module["_mp_obj_str_get_qstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_get_qstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_parse_compile_execute = Module["_mp_parse_compile_execute"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_parse_compile_execute"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raise_recursion_depth = Module["_mp_raise_recursion_depth"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raise_recursion_depth"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raise_TypeError_o = Module["_mp_raise_TypeError_o"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raise_TypeError_o"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_raise_OSError_o = Module["_mp_raise_OSError_o"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_raise_OSError_o"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_function_1_protected = Module["_mp_call_function_1_protected"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_function_1_protected"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_function_2_protected = Module["_mp_call_function_2_protected"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_function_2_protected"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_keyboard_interrupt = Module["_mp_keyboard_interrupt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_keyboard_interrupt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_pairheap_meld = Module["_mp_pairheap_meld"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_pairheap_meld"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_pairheap_pairing = Module["_mp_pairheap_pairing"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_pairheap_pairing"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_pairheap_delete = Module["_mp_pairheap_delete"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_pairheap_delete"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ringbuf_get16 = Module["_ringbuf_get16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ringbuf_get16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ringbuf_peek16 = Module["_ringbuf_peek16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ringbuf_peek16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ringbuf_put16 = Module["_ringbuf_put16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ringbuf_put16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stack_ctrl_init = Module["_mp_stack_ctrl_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stack_ctrl_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stack_set_top = Module["_mp_stack_set_top"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stack_set_top"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stack_usage = Module["_mp_stack_usage"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stack_usage"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_arg_check_num_sig = Module["_mp_arg_check_num_sig"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_arg_check_num_sig"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_arg_parse_all = Module["_mp_arg_parse_all"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_arg_parse_all"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_arg_parse_all_kw_array = Module["_mp_arg_parse_all_kw_array"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_arg_parse_all_kw_array"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_map_init_fixed_table = Module["_mp_map_init_fixed_table"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_map_init_fixed_table"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_arg_error_terse_mismatch = Module["_mp_arg_error_terse_mismatch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_arg_error_terse_mismatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_arg_error_unimpl_kw = Module["_mp_arg_error_unimpl_kw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_arg_error_unimpl_kw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_hash_alloc_greater_or_equal_to = Module["_get_hash_alloc_greater_or_equal_to"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_hash_alloc_greater_or_equal_to"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_map_clear = Module["_mp_map_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_map_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_map_rehash = Module["_mp_map_rehash"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_map_rehash"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_set_init = Module["_mp_set_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_set_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_set_rehash = Module["_mp_set_rehash"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_set_rehash"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_set_lookup = Module["_mp_set_lookup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_set_lookup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_set_remove_first = Module["_mp_set_remove_first"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_set_remove_first"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_set_clear = Module["_mp_set_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_set_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_print = Module["_mp_obj_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_get_traceback = Module["_mp_obj_exception_get_traceback"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_get_traceback"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_len_maybe = Module["_mp_obj_len_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_len_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_is_callable = Module["_mp_obj_is_callable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_is_callable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_call = Module["_mp_obj_instance_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_is_callable = Module["_mp_obj_instance_is_callable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_is_callable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_equal = Module["_mp_obj_str_equal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_equal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_get_checked = Module["_mp_obj_int_get_checked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_get_checked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_int_truncated = Module["_mp_obj_get_int_truncated"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_int_truncated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_get_truncated = Module["_mp_obj_int_get_truncated"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_get_truncated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_int_maybe = Module["_mp_obj_get_int_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_int_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_float_maybe = Module["_mp_obj_get_float_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_float_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_as_float_impl = Module["_mp_obj_int_as_float_impl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_as_float_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_float_get = Module["_mp_obj_float_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_float_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_float = Module["_mp_obj_get_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_complex = Module["_mp_obj_get_complex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_complex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_complex_get = Module["_mp_obj_complex_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_complex_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_get = Module["_mp_obj_tuple_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_list_get = Module["_mp_obj_list_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_list_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_get_array_fixed_n = Module["_mp_obj_get_array_fixed_n"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_get_array_fixed_n"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_get_index = Module["_mp_get_index"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_get_index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_id = Module["_mp_obj_id"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_id"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_int_from_uint = Module["_mp_obj_new_int_from_uint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_int_from_uint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_len = Module["_mp_obj_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_identity = Module["_mp_identity"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_identity"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_get_buffer = Module["_mp_get_buffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_get_buffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_get_buffer_raise = Module["_mp_get_buffer_raise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_get_buffer_raise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_generic_unary_op = Module["_mp_generic_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_generic_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_print = Module["_array_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_get_val_array = Module["_mp_binary_get_val_array"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_get_val_array"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_new = Module["_array_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_get_size = Module["_mp_binary_get_size"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_get_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_construct = Module["_array_construct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_construct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_append = Module["_array_append"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_append"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_set_val_array = Module["_mp_binary_set_val_array"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_set_val_array"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_make_new = Module["_array_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bytearray_make_new = Module["_bytearray_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bytearray_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_memoryview = Module["_mp_obj_new_memoryview"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_memoryview"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memoryview_make_new = Module["_memoryview_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memoryview_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_unary_op = Module["_array_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_binary_op = Module["_array_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_get_buffer = Module["_array_get_buffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_get_buffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_extend = Module["_array_extend"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_extend"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _find_subbytes = Module["_find_subbytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["find_subbytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_seq_cmp_bytes = Module["_mp_seq_cmp_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_seq_cmp_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_subscr = Module["_array_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_seq_get_fast_slice_indexes = Module["_mp_seq_get_fast_slice_indexes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_seq_get_fast_slice_indexes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_iterator_new = Module["_array_iterator_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_iterator_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_bytearray = Module["_mp_obj_new_bytearray"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_bytearray"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_bytearray_by_ref = Module["_mp_obj_new_bytearray_by_ref"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_bytearray_by_ref"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _array_it_iternext = Module["_array_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["array_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_attrtuple_print_helper = Module["_mp_obj_attrtuple_print_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_attrtuple_print_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_attrtuple_print = Module["_mp_obj_attrtuple_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_attrtuple_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_attrtuple_attr = Module["_mp_obj_attrtuple_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_attrtuple_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_attrtuple = Module["_mp_obj_new_attrtuple"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_attrtuple"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_unary_op = Module["_mp_obj_tuple_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_binary_op = Module["_mp_obj_tuple_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_subscr = Module["_mp_obj_tuple_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_getiter = Module["_mp_obj_tuple_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bool_print = Module["_bool_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bool_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bool_make_new = Module["_bool_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bool_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bool_unary_op = Module["_bool_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bool_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bool_binary_op = Module["_bool_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bool_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bound_meth_print = Module["_bound_meth_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bound_meth_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_call_method_self_n_kw = Module["_mp_call_method_self_n_kw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_call_method_self_n_kw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bound_meth_call = Module["_bound_meth_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bound_meth_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bound_meth_attr = Module["_bound_meth_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bound_meth_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cell_print = Module["_cell_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cell_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_cell = Module["_mp_obj_new_cell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_cell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _closure_call = Module["_closure_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["closure_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _closure_print = Module["_closure_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["closure_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _complex_print = Module["_complex_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["complex_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _complex_make_new = Module["_complex_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["complex_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _complex_unary_op = Module["_complex_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["complex_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _complex_binary_op = Module["_complex_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["complex_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan2 = Module["_atan2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log = Module["_log"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp = Module["_exp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sin = Module["_sin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cos = Module["_cos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _complex_attr = Module["_complex_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["complex_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_iter_next = Module["_dict_iter_next"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_iter_next"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_print = Module["_dict_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_make_new = Module["_dict_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_update = Module["_dict_update"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_update"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_ensure_not_fixed = Module["_mp_ensure_not_fixed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_ensure_not_fixed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_unary_op = Module["_dict_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_binary_op = Module["_dict_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_dict_get = Module["_mp_obj_dict_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_dict_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_subscr = Module["_dict_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_get_helper = Module["_dict_get_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_get_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_clear = Module["_dict_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_copy = Module["_dict_copy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_copy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_fromkeys = Module["_dict_fromkeys"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_fromkeys"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_get = Module["_dict_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_pop = Module["_dict_pop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_pop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_setdefault = Module["_dict_setdefault"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_setdefault"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_popitem = Module["_dict_popitem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_popitem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_view_it_iternext = Module["_dict_view_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_view_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_view_getiter = Module["_dict_view_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_view_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_view_print = Module["_dict_view_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_view_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_view_binary_op = Module["_dict_view_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_view_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_dict_view = Module["_mp_obj_new_dict_view"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_dict_view"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_view = Module["_dict_view"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_view"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_items = Module["_dict_items"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_items"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_keys = Module["_dict_keys"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_keys"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_values = Module["_dict_values"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_values"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dict_getiter = Module["_dict_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dict_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _enumerate_make_new = Module["_enumerate_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["enumerate_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _enumerate_iternext = Module["_enumerate_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["enumerate_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_alloc_emergency_exception_buf = Module["_mp_alloc_emergency_exception_buf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_alloc_emergency_exception_buf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _decompress_error_text_maybe = Module["_decompress_error_text_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["decompress_error_text_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_print = Module["_mp_obj_exception_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_errno_to_str = Module["_mp_errno_to_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_errno_to_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_print = Module["_mp_obj_tuple_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_make_new = Module["_mp_obj_exception_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_attr = Module["_mp_obj_exception_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_exception_args = Module["_mp_obj_new_exception_args"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_exception_args"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exc_add_strn = Module["_exc_add_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exc_add_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_exception_msg_vlist = Module["_mp_obj_new_exception_msg_vlist"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_exception_msg_vlist"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_exception_clear_traceback = Module["_mp_obj_exception_clear_traceback"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_exception_clear_traceback"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _filter_make_new = Module["_filter_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["filter_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _filter_iternext = Module["_filter_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["filter_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _float_print = Module["_float_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["float_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strchr = Module["_strchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _float_make_new = Module["_float_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["float_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _float_unary_op = Module["_float_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["float_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _float_binary_op = Module["_float_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["float_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_float_divmod = Module["_mp_obj_float_divmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_float_divmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmod = Module["_fmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_builtin_0_call = Module["_fun_builtin_0_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_builtin_0_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_builtin_1_call = Module["_fun_builtin_1_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_builtin_1_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_builtin_2_call = Module["_fun_builtin_2_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_builtin_2_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_builtin_3_call = Module["_fun_builtin_3_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_builtin_3_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_builtin_var_call = Module["_fun_builtin_var_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_builtin_var_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_code_get_name = Module["_mp_obj_code_get_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_code_get_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_bc_print = Module["_fun_bc_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_bc_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_fun_bc_attr = Module["_mp_obj_fun_bc_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_fun_bc_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_native_call = Module["_fun_native_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_native_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_fun_native = Module["_mp_obj_new_fun_native"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_fun_native"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_wrap_call = Module["_gen_wrap_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_wrap_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _native_gen_wrap_call = Module["_native_gen_wrap_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["native_gen_wrap_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_instance_print = Module["_gen_instance_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_instance_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_resume_and_raise = Module["_gen_resume_and_raise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_resume_and_raise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_instance_send = Module["_gen_instance_send"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_instance_send"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_instance_throw = Module["_gen_instance_throw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_instance_throw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_instance_close = Module["_gen_instance_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_instance_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gen_instance_pend_throw = Module["_gen_instance_pend_throw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gen_instance_pend_throw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _it_iternext = Module["_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_make_new = Module["_mp_obj_int_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_int_from_float = Module["_mp_obj_new_int_from_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_int_from_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpclassifyf = Module["___fpclassifyf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpclassifyf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_classify_fp_as_int = Module["_mp_classify_fp_as_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_classify_fp_as_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_new_mpz = Module["_mp_obj_int_new_mpz"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_new_mpz"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_print = Module["_mp_obj_int_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_int_format_size = Module["_mp_int_format_size"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_int_format_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_formatted_impl = Module["_mp_obj_int_formatted_impl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_formatted_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_binary_op_extra_cases = Module["_mp_obj_int_binary_op_extra_cases"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_binary_op_extra_cases"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _int_from_bytes = Module["_int_from_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["int_from_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_from_bytes_impl = Module["_mp_obj_int_from_bytes_impl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_from_bytes_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _int_to_bytes = Module["_int_to_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["int_to_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_to_bytes_impl = Module["_mp_obj_int_to_bytes_impl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_to_bytes_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_set_int = Module["_mp_binary_set_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_set_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_unary_op = Module["_mp_obj_int_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_binary_op = Module["_mp_obj_int_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_int_from_ull = Module["_mp_obj_new_int_from_ull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_int_from_ull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_int_get_uint_checked = Module["_mp_obj_int_get_uint_checked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_int_get_uint_checked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_print = Module["_list_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_extend_from_iter = Module["_list_extend_from_iter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_extend_from_iter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_make_new = Module["_list_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_new = Module["_list_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_unary_op = Module["_list_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_binary_op = Module["_list_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_seq_multiply = Module["_mp_seq_multiply"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_seq_multiply"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_seq_cmp_objs = Module["_mp_seq_cmp_objs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_seq_cmp_objs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_extend = Module["_list_extend"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_extend"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_subscr = Module["_list_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_pop = Module["_list_pop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_pop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_seq_extract_slice = Module["_mp_seq_extract_slice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_seq_extract_slice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_list_store = Module["_mp_obj_list_store"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_list_store"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_getiter = Module["_list_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_list_iterator = Module["_mp_obj_new_list_iterator"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_list_iterator"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_it_iternext = Module["_list_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_quicksort = Module["_mp_quicksort"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_quicksort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_list_sort = Module["_mp_obj_list_sort"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_list_sort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_clear = Module["_list_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_copy = Module["_list_copy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_copy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_count = Module["_list_count"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_seq_count_obj = Module["_mp_seq_count_obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_seq_count_obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_index = Module["_list_index"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_seq_index_obj = Module["_mp_seq_index_obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_seq_index_obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_insert = Module["_list_insert"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_insert"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_list_remove = Module["_mp_obj_list_remove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_list_remove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _list_reverse = Module["_list_reverse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["list_reverse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _map_make_new = Module["_map_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["map_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _map_iternext = Module["_map_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["map_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _module_print = Module["_module_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["module_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _module_attr = Module["_module_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["module_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_module = Module["_mp_obj_new_module"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_module"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_module_get = Module["_mp_module_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_module_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_module_register = Module["_mp_module_register"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_module_register"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _object_make_new = Module["_object_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["object_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _object___init__ = Module["_object___init__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["object___init__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _object___new__ = Module["_object___new__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["object___new__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_make_new = Module["_mp_obj_instance_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_instance = Module["_mp_obj_new_instance"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_instance"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _object___setattr__ = Module["_object___setattr__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["object___setattr__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _object___delattr__ = Module["_object___delattr__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["object___delattr__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _polymorph_it_iternext = Module["_polymorph_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["polymorph_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _property_make_new = Module["_property_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["property_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _property_getter = Module["_property_getter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["property_getter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _property_setter = Module["_property_setter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["property_setter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _property_deleter = Module["_property_deleter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["property_deleter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_property_get = Module["_mp_obj_property_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_property_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _none_print = Module["_none_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["none_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_namedtuple_find_field = Module["_mp_obj_namedtuple_find_field"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_namedtuple_find_field"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _namedtuple_print = Module["_namedtuple_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["namedtuple_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _namedtuple_attr = Module["_namedtuple_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["namedtuple_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _namedtuple_make_new = Module["_namedtuple_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["namedtuple_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_namedtuple_base = Module["_mp_obj_new_namedtuple_base"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_namedtuple_base"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_namedtuple_type = Module["_mp_obj_new_namedtuple_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_namedtuple_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _new_namedtuple_type = Module["_new_namedtuple_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["new_namedtuple_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_split = Module["_mp_obj_str_split"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_split"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_it_iternext = Module["_range_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_range_iterator = Module["_mp_obj_new_range_iterator"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_range_iterator"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_print = Module["_range_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_make_new = Module["_range_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_len = Module["_range_len"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_len"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_unary_op = Module["_range_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_subscr = Module["_range_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_getiter = Module["_range_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _range_attr = Module["_range_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["range_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _reversed_make_new = Module["_reversed_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["reversed_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _reversed_iternext = Module["_reversed_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["reversed_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _is_set_or_frozenset = Module["_is_set_or_frozenset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["is_set_or_frozenset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_print = Module["_set_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_make_new = Module["_set_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_it_iternext = Module["_set_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_getiter = Module["_set_getiter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_getiter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_add = Module["_set_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_clear = Module["_set_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_copy = Module["_set_copy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_copy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_discard = Module["_set_discard"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_discard"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_diff_int = Module["_set_diff_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_diff_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_diff = Module["_set_diff"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_diff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_diff_update = Module["_set_diff_update"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_diff_update"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_intersect_int = Module["_set_intersect_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_intersect_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_intersect = Module["_set_intersect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_intersect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_intersect_update = Module["_set_intersect_update"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_intersect_update"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_isdisjoint = Module["_set_isdisjoint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_isdisjoint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_issubset_internal = Module["_set_issubset_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_issubset_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_issubset = Module["_set_issubset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_issubset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_issubset_proper = Module["_set_issubset_proper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_issubset_proper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_issuperset = Module["_set_issuperset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_issuperset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_issuperset_proper = Module["_set_issuperset_proper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_issuperset_proper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_equal = Module["_set_equal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_equal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_pop = Module["_set_pop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_pop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_remove = Module["_set_remove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_remove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_symmetric_difference_update = Module["_set_symmetric_difference_update"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_symmetric_difference_update"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_symmetric_difference = Module["_set_symmetric_difference"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_symmetric_difference"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_update_int = Module["_set_update_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_update_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_update = Module["_set_update"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_update"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_union = Module["_set_union"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_union"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_unary_op = Module["_set_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_binary_op = Module["_set_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _singleton_print = Module["_singleton_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["singleton_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _slice_print = Module["_slice_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["slice_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _slice_attr = Module["_slice_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["slice_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_slice_indices = Module["_mp_obj_slice_indices"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_slice_indices"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_str_print_json = Module["_mp_str_print_json"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_str_print_json"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_print = Module["_str_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_make_new = Module["_mp_obj_str_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_str = Module["_mp_obj_new_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bytes_make_new = Module["_bytes_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bytes_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_modulo_format = Module["_str_modulo_format"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_modulo_format"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bad_implicit_conversion = Module["_bad_implicit_conversion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bad_implicit_conversion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_str_via_qstr = Module["_mp_obj_new_str_via_qstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_str_via_qstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_to_int = Module["_str_to_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_to_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _arg_as_int = Module["_arg_as_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["arg_as_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _arg_looks_integer = Module["_arg_looks_integer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["arg_looks_integer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bytes_subscr = Module["_bytes_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bytes_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_str_of_type = Module["_mp_obj_new_str_of_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_str_of_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_join = Module["_str_join"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_join"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_splitlines = Module["_str_splitlines"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_splitlines"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_rsplit = Module["_str_rsplit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_rsplit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_finder = Module["_str_finder"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_finder"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_index_to_ptr = Module["_str_index_to_ptr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_index_to_ptr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_find = Module["_str_find"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_find"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_rfind = Module["_str_rfind"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_rfind"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_index = Module["_str_index"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_rindex = Module["_str_rindex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_rindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_startswith = Module["_str_startswith"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_startswith"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_endswith = Module["_str_endswith"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_endswith"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_uni_strip = Module["_str_uni_strip"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_uni_strip"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_strip = Module["_str_strip"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_strip"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_lstrip = Module["_str_lstrip"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_lstrip"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_rstrip = Module["_str_rstrip"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_rstrip"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_center = Module["_str_center"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_center"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalignment = Module["_isalignment"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalignment"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memchr = Module["_memchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _istype = Module["_istype"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["istype"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _arg_looks_numeric = Module["_arg_looks_numeric"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["arg_looks_numeric"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_format_helper = Module["_mp_obj_str_format_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_format_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_format = Module["_mp_obj_str_format"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_format"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_replace = Module["_str_replace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_replace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_count = Module["_str_count"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_partitioner = Module["_str_partitioner"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_partitioner"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_partition = Module["_str_partition"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_partition"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_rpartition = Module["_str_rpartition"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_rpartition"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_caseconv = Module["_str_caseconv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_caseconv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_lower = Module["_str_lower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_lower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_upper = Module["_str_upper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_upper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_uni_istype = Module["_str_uni_istype"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_uni_istype"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_isspace = Module["_str_isspace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_isspace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_isalpha = Module["_str_isalpha"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_isalpha"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_isdigit = Module["_str_isdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_isdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_isupper = Module["_str_isupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_isupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_islower = Module["_str_islower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_islower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bytes_decode = Module["_bytes_decode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bytes_decode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_encode = Module["_str_encode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_encode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_get_buffer = Module["_mp_obj_str_get_buffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_get_buffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_bytes_iterator = Module["_mp_obj_new_bytes_iterator"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_bytes_iterator"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bytes_it_iternext = Module["_bytes_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bytes_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_str_intern = Module["_mp_obj_str_intern"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_str_intern"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uni_print_quoted = Module["_uni_print_quoted"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uni_print_quoted"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uni_print = Module["_uni_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uni_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uni_unary_op = Module["_uni_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uni_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_subscr = Module["_str_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_str_iterator = Module["_mp_obj_new_str_iterator"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_str_iterator"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_it_iternext = Module["_str_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _check_stringio_is_open = Module["_check_stringio_is_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["check_stringio_is_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_print = Module["_stringio_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_read = Module["_stringio_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_copy_on_write = Module["_stringio_copy_on_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_copy_on_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_write = Module["_stringio_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_ioctl = Module["_stringio_ioctl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_ioctl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_getvalue = Module["_stringio_getvalue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_getvalue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio___exit__ = Module["_stringio___exit__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio___exit__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stream_close = Module["_mp_stream_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stream_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_new = Module["_stringio_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stringio_make_new = Module["_stringio_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stringio_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stream_unbuffered_iter = Module["_mp_stream_unbuffered_iter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stream_unbuffered_iter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_make_new = Module["_mp_obj_tuple_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tuple_cmp_helper = Module["_tuple_cmp_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tuple_cmp_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_cast_to_native_base = Module["_mp_obj_cast_to_native_base"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_cast_to_native_base"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tuple_it_iternext = Module["_tuple_it_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tuple_it_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tuple_count = Module["_tuple_count"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tuple_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tuple_index = Module["_tuple_index"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tuple_index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_tuple_del = Module["_mp_obj_tuple_del"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_tuple_del"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _instance_count_native_bases = Module["_instance_count_native_bases"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["instance_count_native_bases"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_class_lookup = Module["_mp_obj_class_lookup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_class_lookup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _native_base_init_wrapper = Module["_native_base_init_wrapper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["native_base_init_wrapper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _instance_print = Module["_instance_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["instance_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _instance_unary_op = Module["_instance_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["instance_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _instance_binary_op = Module["_instance_binary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["instance_binary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_load_attr = Module["_mp_obj_instance_load_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_load_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_store_attr = Module["_mp_obj_instance_store_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_store_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_attr = Module["_mp_obj_instance_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _instance_subscr = Module["_instance_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["instance_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_instance_get_call = Module["_mp_obj_instance_get_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_instance_get_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _instance_get_buffer = Module["_instance_get_buffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["instance_get_buffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _check_for_special_accessors = Module["_check_for_special_accessors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["check_for_special_accessors"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _type_print = Module["_type_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["type_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _type_make_new = Module["_type_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["type_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_new_type = Module["_mp_obj_new_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_new_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _static_class_method_make_new = Module["_static_class_method_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["static_class_method_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _type_call = Module["_type_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["type_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _type_attr = Module["_type_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["type_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _super_print = Module["_super_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["super_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _super_make_new = Module["_super_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["super_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _super_attr = Module["_super_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["super_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_obj_is_subclass = Module["_mp_obj_is_subclass"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_obj_is_subclass"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_issubclass = Module["_mp_builtin_issubclass"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_issubclass"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_isinstance = Module["_mp_builtin_isinstance"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_isinstance"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _zip_make_new = Module["_zip_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["zip_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _zip_iternext = Module["_zip_iternext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["zip_iternext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _op_getitem = Module["_op_getitem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["op_getitem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _op_setitem = Module["_op_setitem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["op_setitem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _op_delitem = Module["_op_delitem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["op_delitem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _op_contains = Module["_op_contains"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["op_contains"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stream_rw = Module["_mp_stream_rw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stream_rw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_get_stream_raise = Module["_mp_get_stream_raise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_get_stream_raise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_read_generic = Module["_stream_read_generic"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_read_generic"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_readall = Module["_stream_readall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_readall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_read = Module["_stream_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_read1 = Module["_stream_read1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_read1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stream_write = Module["_mp_stream_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stream_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_stream_write_adaptor = Module["_mp_stream_write_adaptor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_stream_write_adaptor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_write_method = Module["_stream_write_method"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_write_method"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_write1_method = Module["_stream_write1_method"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_write1_method"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_readinto = Module["_stream_readinto"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_readinto"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_unbuffered_readline = Module["_stream_unbuffered_readline"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_unbuffered_readline"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_unbuffered_readlines = Module["_stream_unbuffered_readlines"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_unbuffered_readlines"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_seek = Module["_stream_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_tell = Module["_stream_tell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_tell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_flush = Module["_stream_flush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_flush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stream_ioctl = Module["_stream_ioctl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stream_ioctl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_get_int = Module["_mp_binary_get_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_get_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_get_val = Module["_mp_binary_get_val"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_get_val"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_set_val = Module["_mp_binary_set_val"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_set_val"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_binary_set_val_array_from_int = Module["_mp_binary_set_val_array_from_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_binary_set_val_array_from_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_import_stat_any = Module["_mp_import_stat_any"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_import_stat_any"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_frozen_stat = Module["_mp_frozen_stat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_frozen_stat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_import_stat = Module["_mp_import_stat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_import_stat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stat_file_py_or_mpy = Module["_stat_file_py_or_mpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stat_file_py_or_mpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stat_dir_or_file = Module["_stat_dir_or_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stat_dir_or_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _find_file = Module["_find_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["find_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _do_load_from_lexer = Module["_do_load_from_lexer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["do_load_from_lexer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _do_execute_raw_code = Module["_do_execute_raw_code"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["do_execute_raw_code"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _do_load = Module["_do_load"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["do_load"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_find_frozen_module = Module["_mp_find_frozen_module"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_find_frozen_module"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_lexer_new_from_file = Module["_mp_lexer_new_from_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_lexer_new_from_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _chop_component = Module["_chop_component"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["chop_component"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _code_execute = Module["_code_execute"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["code_execute"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_compile = Module["_mp_builtin_compile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_compile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _eval_exec_helper = Module["_eval_exec_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["eval_exec_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_eval = Module["_mp_builtin_eval"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_eval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_exec = Module["_mp_builtin_exec"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_exec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_execfile = Module["_mp_builtin_execfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_execfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin___build_class__ = Module["_mp_builtin___build_class__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin___build_class__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_abs = Module["_mp_builtin_abs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_abs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_all = Module["_mp_builtin_all"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_all"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_any = Module["_mp_builtin_any"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_any"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_bin = Module["_mp_builtin_bin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_bin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_callable = Module["_mp_builtin_callable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_callable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_chr = Module["_mp_builtin_chr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_chr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_dir = Module["_mp_builtin_dir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_dir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_divmod = Module["_mp_builtin_divmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_divmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_hash = Module["_mp_builtin_hash"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_hash"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_hex = Module["_mp_builtin_hex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_hex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_input = Module["_mp_builtin_input"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_input"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readline = Module["_readline"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readline"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_iter = Module["_mp_builtin_iter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_iter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_min_max = Module["_mp_builtin_min_max"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_min_max"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_max = Module["_mp_builtin_max"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_max"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_min = Module["_mp_builtin_min"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_min"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_next = Module["_mp_builtin_next"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_next"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_oct = Module["_mp_builtin_oct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_oct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_ord = Module["_mp_builtin_ord"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_ord"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_pow = Module["_mp_builtin_pow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_pow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_print = Module["_mp_builtin_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin___repl_print__ = Module["_mp_builtin___repl_print__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin___repl_print__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_repr = Module["_mp_builtin_repr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_repr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_round = Module["_mp_builtin_round"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_round"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_sum = Module["_mp_builtin_sum"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_sum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_sorted = Module["_mp_builtin_sorted"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_sorted"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_getattr = Module["_mp_builtin_getattr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_getattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_setattr = Module["_mp_builtin_setattr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_setattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_delattr = Module["_mp_builtin_delattr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_delattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_hasattr = Module["_mp_builtin_hasattr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_hasattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_globals = Module["_mp_builtin_globals"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_globals"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_locals = Module["_mp_builtin_locals"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_locals"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _py_gc_collect = Module["_py_gc_collect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["py_gc_collect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_disable = Module["_gc_disable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_disable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_enable = Module["_gc_enable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_enable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_isenabled = Module["_gc_isenabled"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_isenabled"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_mem_free = Module["_gc_mem_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_mem_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_mem_alloc = Module["_gc_mem_alloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_mem_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gc_threshold = Module["_gc_threshold"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gc_threshold"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iobase_make_new = Module["_iobase_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iobase_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iobase_read_write = Module["_iobase_read_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iobase_read_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iobase_read = Module["_iobase_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iobase_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iobase_write = Module["_iobase_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iobase_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iobase_ioctl = Module["_iobase_ioctl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iobase_ioctl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bufwriter_make_new = Module["_bufwriter_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bufwriter_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bufwriter_write = Module["_bufwriter_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bufwriter_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bufwriter_flush = Module["_bufwriter_flush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bufwriter_flush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _resource_stream = Module["_resource_stream"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["resource_stream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_find_frozen_str = Module["_mp_find_frozen_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_find_frozen_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_builtin_open = Module["_mp_builtin_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_builtin_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _math_error = Module["_math_error"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["math_error"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _math_generic_1 = Module["_math_generic_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["math_generic_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _math_generic_2 = Module["_math_generic_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["math_generic_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_sqrt = Module["_mp_math_sqrt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_sqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sqrt = Module["_sqrt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_pow = Module["_mp_math_pow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_pow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_exp = Module["_mp_math_exp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_exp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_expm1 = Module["_mp_math_expm1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_expm1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expm1 = Module["_expm1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expm1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_log2 = Module["_mp_math_log2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_log2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log2 = Module["_log2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_log10 = Module["_mp_math_log10"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_log10"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log10 = Module["_log10"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log10"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_cosh = Module["_mp_math_cosh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_cosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cosh = Module["_cosh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_sinh = Module["_mp_math_sinh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_sinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinh = Module["_sinh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_tanh = Module["_mp_math_tanh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_tanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanh = Module["_tanh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_acosh = Module["_mp_math_acosh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_acosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acosh = Module["_acosh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_asinh = Module["_mp_math_asinh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_asinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinh = Module["_asinh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_atanh = Module["_mp_math_atanh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_atanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanh = Module["_atanh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_cos = Module["_mp_math_cos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_sin = Module["_mp_math_sin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_tan = Module["_mp_math_tan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tan = Module["_tan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_acos = Module["_mp_math_acos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_acos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acos = Module["_acos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_asin = Module["_mp_math_asin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_asin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asin = Module["_asin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_atan = Module["_mp_math_atan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_atan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan = Module["_atan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_atan2 = Module["_mp_math_atan2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_atan2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_ceil = Module["_mp_math_ceil"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_ceil"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copysign_func = Module["_copysign_func"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copysign_func"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_copysign = Module["_mp_math_copysign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_copysign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fabs_func = Module["_fabs_func"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fabs_func"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_fabs = Module["_mp_math_fabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_fabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_floor = Module["_mp_math_floor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_floor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_fmod = Module["_mp_math_fmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_fmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_isfinite = Module["_mp_math_isfinite"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_isfinite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_isinf = Module["_mp_math_isinf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_isinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_isnan = Module["_mp_math_isnan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_isnan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_trunc = Module["_mp_math_trunc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_trunc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_ldexp = Module["_mp_math_ldexp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_ldexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldexp = Module["_ldexp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_erf = Module["_mp_math_erf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_erf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erf = Module["_erf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_erfc = Module["_mp_math_erfc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_erfc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfc = Module["_erfc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_gamma = Module["_mp_math_gamma"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_gamma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tgamma = Module["_tgamma"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tgamma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_lgamma = Module["_mp_math_lgamma"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_lgamma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgamma = Module["_lgamma"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgamma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_log = Module["_mp_math_log"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_frexp = Module["_mp_math_frexp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_frexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _frexp = Module["_frexp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["frexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_modf = Module["_mp_math_modf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_modf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _modf = Module["_modf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["modf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_radians = Module["_mp_math_radians"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_radians"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_degrees = Module["_mp_math_degrees"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_degrees"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_math_factorial = Module["_mp_math_factorial"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_math_factorial"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_phase = Module["_mp_cmath_phase"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_phase"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_polar = Module["_mp_cmath_polar"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_polar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_rect = Module["_mp_cmath_rect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_rect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_exp = Module["_mp_cmath_exp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_exp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_log = Module["_mp_cmath_log"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_log10 = Module["_mp_cmath_log10"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_log10"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_sqrt = Module["_mp_cmath_sqrt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_sqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_cos = Module["_mp_cmath_cos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_cmath_sin = Module["_mp_cmath_sin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_cmath_sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_opt_level = Module["_mp_micropython_opt_level"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_opt_level"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_mem_total = Module["_mp_micropython_mem_total"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_mem_total"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_mem_current = Module["_mp_micropython_mem_current"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_mem_current"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_mem_peak = Module["_mp_micropython_mem_peak"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_mem_peak"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_mem_info = Module["_mp_micropython_mem_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_mem_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_qstr_info = Module["_mp_micropython_qstr_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_qstr_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_stack_use = Module["_mp_micropython_stack_use"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_stack_use"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_pystack_use = Module["_mp_micropython_pystack_use"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_pystack_use"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_heap_lock = Module["_mp_micropython_heap_lock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_heap_lock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_heap_unlock = Module["_mp_micropython_heap_unlock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_heap_unlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_micropython_kbd_intr = Module["_mp_micropython_kbd_intr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_micropython_kbd_intr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_fmt_type = Module["_get_fmt_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_fmt_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_fmt_num = Module["_get_fmt_num"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_fmt_num"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _calc_size_items = Module["_calc_size_items"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["calc_size_items"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _struct_calcsize = Module["_struct_calcsize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["struct_calcsize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _struct_unpack_from = Module["_struct_unpack_from"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["struct_unpack_from"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _struct_pack_into_internal = Module["_struct_pack_into_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["struct_pack_into_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _struct_pack = Module["_struct_pack"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["struct_pack"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _struct_pack_into = Module["_struct_pack_into"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["struct_pack_into"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_sys_exit = Module["_mp_sys_exit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_sys_exit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_sys_print_exception = Module["_mp_sys_print_exception"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_sys_print_exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_sys_getsizeof = Module["_mp_sys_getsizeof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_sys_getsizeof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwrite = Module["_fwrite"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputc = Module["_fputc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_decode_uint = Module["_mp_decode_uint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_decode_uint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fun_pos_args_mismatch = Module["_fun_pos_args_mismatch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fun_pos_args_mismatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_startswith_word = Module["_str_startswith_word"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_startswith_word"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_repl_continue_with_input = Module["_mp_repl_continue_with_input"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_repl_continue_with_input"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_repl_autocomplete = Module["_mp_repl_autocomplete"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_repl_autocomplete"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncmp = Module["_strncmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_lexer_frozen_str = Module["_mp_lexer_frozen_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_lexer_frozen_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_find_frozen_mpy = Module["_mp_find_frozen_mpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_find_frozen_mpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_frozen_stat_helper = Module["_mp_frozen_stat_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_frozen_stat_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _syntax_error = Module["_syntax_error"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["syntax_error"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_make_new = Module["_uctypes_struct_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_print = Module["_uctypes_struct_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_agg_size = Module["_uctypes_struct_agg_size"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_agg_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_size = Module["_uctypes_struct_size"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_sizeof = Module["_uctypes_struct_sizeof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_sizeof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_aligned = Module["_get_aligned"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_aligned"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _set_aligned = Module["_set_aligned"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["set_aligned"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_attr_op = Module["_uctypes_struct_attr_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_attr_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_attr = Module["_uctypes_struct_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_subscr = Module["_uctypes_struct_subscr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_subscr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_unary_op = Module["_uctypes_struct_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_get_buffer = Module["_uctypes_get_buffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_get_buffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_addressof = Module["_uctypes_struct_addressof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_addressof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_bytearray_at = Module["_uctypes_struct_bytearray_at"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_bytearray_at"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uctypes_struct_bytes_at = Module["_uctypes_struct_bytes_at"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uctypes_struct_bytes_at"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ujson_dump = Module["_mod_ujson_dump"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ujson_dump"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ujson_dumps = Module["_mod_ujson_dumps"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ujson_dumps"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ujson_stream_next = Module["_ujson_stream_next"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ujson_stream_next"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ujson_load = Module["_mod_ujson_load"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ujson_load"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ujson_loads = Module["_mod_ujson_loads"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ujson_loads"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _match_print = Module["_match_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["match_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _match_group = Module["_match_group"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["match_group"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re_print = Module["_re_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ure_exec = Module["_ure_exec"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ure_exec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re1_5_recursiveloopprog = Module["_re1_5_recursiveloopprog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re1_5_recursiveloopprog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re_match = Module["_re_match"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re_match"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re_search = Module["_re_search"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re_search"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re_split = Module["_re_split"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re_split"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re_sub_helper = Module["_re_sub_helper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re_sub_helper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re_sub = Module["_re_sub"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re_sub"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_re_compile = Module["_mod_re_compile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_re_compile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re1_5_sizecode = Module["_re1_5_sizecode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re1_5_sizecode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _re1_5_compilecode = Module["_re1_5_compilecode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["re1_5_compilecode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_re_exec = Module["_mod_re_exec"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_re_exec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_re_match = Module["_mod_re_match"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_re_match"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_re_search = Module["_mod_re_search"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_re_search"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_re_sub = Module["_mod_re_sub"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_re_sub"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __re1_5_namedclassmatch = Module["__re1_5_namedclassmatch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_re1_5_namedclassmatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __re1_5_classmatch = Module["__re1_5_classmatch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_re1_5_classmatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _read_src_stream = Module["_read_src_stream"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["read_src_stream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _decompio_make_new = Module["_decompio_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["decompio_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_gzip_parse_header = Module["_uzlib_gzip_parse_header"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_gzip_parse_header"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_zlib_parse_header = Module["_uzlib_zlib_parse_header"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_zlib_parse_header"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_uncompress_init = Module["_uzlib_uncompress_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_uncompress_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_get_byte = Module["_uzlib_get_byte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_get_byte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tinf_skip_bytes = Module["_tinf_skip_bytes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tinf_skip_bytes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tinf_get_uint16 = Module["_tinf_get_uint16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tinf_get_uint16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _decompio_read = Module["_decompio_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["decompio_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_uncompress_chksum = Module["_uzlib_uncompress_chksum"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_uncompress_chksum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_uncompress = Module["_uzlib_uncompress"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_uncompress"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_adler32 = Module["_uzlib_adler32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_adler32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_crc32 = Module["_uzlib_crc32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_crc32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tinf_get_be_uint32 = Module["_tinf_get_be_uint32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tinf_get_be_uint32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tinf_get_le_uint32 = Module["_tinf_get_le_uint32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tinf_get_le_uint32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_uzlib_decompress = Module["_mod_uzlib_decompress"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_uzlib_decompress"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uzlib_init = Module["_uzlib_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uzlib_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uheapq_get_heap = Module["_uheapq_get_heap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uheapq_get_heap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uheapq_heap_siftdown = Module["_uheapq_heap_siftdown"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uheapq_heap_siftdown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uheapq_heap_siftup = Module["_uheapq_heap_siftup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uheapq_heap_siftup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_uheapq_heappush = Module["_mod_uheapq_heappush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_uheapq_heappush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_uheapq_heappop = Module["_mod_uheapq_heappop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_uheapq_heappop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_uheapq_heapify = Module["_mod_uheapq_heapify"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_uheapq_heapify"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utimeq_get_heap = Module["_utimeq_get_heap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utimeq_get_heap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_less_than = Module["_time_less_than"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_less_than"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utimeq_make_new = Module["_utimeq_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utimeq_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utimeq_heap_siftdown = Module["_utimeq_heap_siftdown"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utimeq_heap_siftdown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utimeq_heap_siftup = Module["_utimeq_heap_siftup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utimeq_heap_siftup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_utimeq_heappush = Module["_mod_utimeq_heappush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_utimeq_heappush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_utimeq_heappop = Module["_mod_utimeq_heappop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_utimeq_heappop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_utimeq_peektime = Module["_mod_utimeq_peektime"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_utimeq_peektime"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utimeq_unary_op = Module["_utimeq_unary_op"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utimeq_unary_op"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sha256_init = Module["_sha256_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sha256_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sha256_update = Module["_sha256_update"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sha256_update"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sha256_final = Module["_sha256_final"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sha256_final"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uhashlib_sha256_make_new = Module["_uhashlib_sha256_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uhashlib_sha256_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uhashlib_sha256_update = Module["_uhashlib_sha256_update"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uhashlib_sha256_update"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uhashlib_sha256_digest = Module["_uhashlib_sha256_digest"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uhashlib_sha256_digest"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_binascii_hexlify = Module["_mod_binascii_hexlify"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_binascii_hexlify"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_binascii_unhexlify = Module["_mod_binascii_unhexlify"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_binascii_unhexlify"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_binascii_a2b_base64 = Module["_mod_binascii_a2b_base64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_binascii_a2b_base64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_binascii_b2a_base64 = Module["_mod_binascii_b2a_base64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_binascii_b2a_base64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_virtual_pin_read = Module["_mp_virtual_pin_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_virtual_pin_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_virtual_pin_write = Module["_mp_virtual_pin_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_virtual_pin_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yasmarang = Module["_yasmarang"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yasmarang"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yasmarang_randbelow = Module["_yasmarang_randbelow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yasmarang_randbelow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_urandom_getrandbits = Module["_mod_urandom_getrandbits"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_urandom_getrandbits"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_urandom_seed = Module["_mod_urandom_seed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_urandom_seed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_urandom_randrange = Module["_mod_urandom_randrange"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_urandom_randrange"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_urandom_randint = Module["_mod_urandom_randint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_urandom_randint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_urandom_choice = Module["_mod_urandom_choice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_urandom_choice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yasmarang_float = Module["_yasmarang_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yasmarang_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_urandom_random = Module["_mod_urandom_random"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_urandom_random"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_urandom_uniform = Module["_mod_urandom_uniform"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_urandom_uniform"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_sleep = Module["_time_sleep"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_sleep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_sleep_ms = Module["_time_sleep_ms"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_sleep_ms"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_sleep_us = Module["_time_sleep_us"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_sleep_us"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_ticks_ms = Module["_time_ticks_ms"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_ticks_ms"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_ticks_us = Module["_time_ticks_us"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_ticks_us"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_ticks_cpu = Module["_time_ticks_cpu"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_ticks_cpu"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_ticks_diff = Module["_time_ticks_diff"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_ticks_diff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _time_ticks_add = Module["_time_ticks_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["time_ticks_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_uos_deactivate = Module["_mp_uos_deactivate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_uos_deactivate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_uos_dupterm_poll = Module["_mp_uos_dupterm_poll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_uos_dupterm_poll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_uos_dupterm_rx_chr = Module["_mp_uos_dupterm_rx_chr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_uos_dupterm_rx_chr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_uos_dupterm_tx_strn = Module["_mp_uos_dupterm_tx_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_uos_dupterm_tx_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_uos_dupterm = Module["_mp_uos_dupterm"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_uos_dupterm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _abort_ = Module["_abort_"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["abort_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iprintf = Module["_iprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fseek = Module["_fseek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fseek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftell = Module["_ftell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fread = Module["_fread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_lexer_new_from_fd = Module["_mp_lexer_new_from_fd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_lexer_new_from_fd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_reader_new_file_from_fd = Module["_mp_reader_new_file_from_fd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_reader_new_file_from_fd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _read = Module["_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__errno_location"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_reader_posix_close = Module["_mp_reader_posix_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_reader_posix_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_reader_posix_readbyte = Module["_mp_reader_posix_readbyte"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_reader_posix_readbyte"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbb_free_space = Module["_rbb_free_space"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbb_free_space"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_t_new = Module["_rbo_t_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_t_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_init = Module["_rbo_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_append = Module["_rbo_append"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_append"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_is_empty = Module["_rbo_is_empty"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_is_empty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_is_full = Module["_rbo_is_full"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_is_full"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_incr_start = Module["_rbo_incr_start"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_incr_start"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_incr_end = Module["_rbo_incr_end"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_incr_end"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_next_end_index = Module["_rbo_next_end_index"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_next_end_index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_pop = Module["_rbo_pop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_pop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_peek = Module["_rbo_peek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_peek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_count = Module["_rbo_count"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rbo_delete = Module["_rbo_delete"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rbo_delete"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _check_fd_is_open = Module["_check_fd_is_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["check_fd_is_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile_print = Module["_fdfile_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile_read = Module["_fdfile_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile_write = Module["_fdfile_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile_ioctl = Module["_fdfile_ioctl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile_ioctl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lseek = Module["_lseek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lseek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fsync = Module["_fsync"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fsync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile___exit__ = Module["_fdfile___exit__"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile___exit__"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile_fileno = Module["_fdfile_fileno"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile_fileno"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile_open = Module["_fdfile_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdfile_make_new = Module["_fdfile_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdfile_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_os_stat = Module["_mod_os_stat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_os_stat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_os_remove = Module["_mod_os_remove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_os_remove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unlink = Module["_unlink"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_os_system = Module["_mod_os_system"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_os_system"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_os_getenv = Module["_mod_os_getenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_os_getenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getenv = Module["_getenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_os_mkdir = Module["_mod_os_mkdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_os_mkdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkdir = Module["_mkdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _listdir_next = Module["_listdir_next"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["listdir_next"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir = Module["_readdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _closedir = Module["_closedir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["closedir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_os_ilistdir = Module["_mod_os_ilistdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_os_ilistdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _opendir = Module["_opendir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["opendir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_os_errno = Module["_mod_os_errno"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_os_errno"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_time_clock = Module["_mod_time_clock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_time_clock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_time_time = Module["_mod_time_time"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_time_time"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_time_time_ns = Module["_mod_time_time_ns"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_time_time_ns"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_time_sleep = Module["_mod_time_sleep"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_time_sleep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_time_sleep_ms = Module["_mod_time_sleep_ms"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_time_sleep_ms"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_time_sleep_us = Module["_mod_time_sleep_us"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_time_sleep_us"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_time_localtime = Module["_mod_time_localtime"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_time_localtime"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _char2ffi_type = Module["_char2ffi_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["char2ffi_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_ffi_type = Module["_get_ffi_type"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_ffi_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _return_ffi_value = Module["_return_ffi_value"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["return_ffi_value"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffimod_print = Module["_ffimod_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffimod_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffimod_close = Module["_ffimod_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffimod_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _make_func = Module["_make_func"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["make_func"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_prep_cif = Module["_ffi_prep_cif"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_prep_cif"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffimod_func = Module["_ffimod_func"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffimod_func"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ffi_func = Module["_mod_ffi_func"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ffi_func"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _call_py_func = Module["_call_py_func"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["call_py_func"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ffi_callback = Module["_mod_ffi_callback"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ffi_callback"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_closure_alloc = Module["_ffi_closure_alloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_closure_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_prep_closure_loc = Module["_ffi_prep_closure_loc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_prep_closure_loc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffimod_var = Module["_ffimod_var"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffimod_var"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffimod_addr = Module["_ffimod_addr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffimod_addr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffimod_make_new = Module["_ffimod_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffimod_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffifunc_print = Module["_ffifunc_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffifunc_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffifunc_call = Module["_ffifunc_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffifunc_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_call = Module["_ffi_call"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_call"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fficallback_print = Module["_fficallback_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fficallback_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffivar_print = Module["_ffivar_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffivar_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffivar_get = Module["_ffivar_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffivar_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffivar_set = Module["_ffivar_set"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffivar_set"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ffi_open = Module["_mod_ffi_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ffi_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mod_ffi_as_bytearray = Module["_mod_ffi_as_bytearray"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mod_ffi_as_bytearray"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_prep_cif_machdep = Module["_ffi_prep_cif_machdep"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_prep_cif_machdep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_prep_cif_core = Module["_ffi_prep_cif_core"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_prep_cif_core"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_prep_cif_var = Module["_ffi_prep_cif_var"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_prep_cif_var"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_prep_closure = Module["_ffi_prep_closure"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_prep_closure"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffi_get_struct_offsets = Module["_ffi_get_struct_offsets"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffi_get_struct_offsets"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _PyBytes_FromString = Module["_PyBytes_FromString"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["PyBytes_FromString"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _raw_code_save_file = Module["_raw_code_save_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["raw_code_save_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _execute_from_str = Module["_execute_from_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["execute_from_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _coropass = Module["_coropass"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["coropass"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_hello___del___obj = Module["_embed_hello___del___obj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_hello___del___obj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_hello_print = Module["_embed_hello_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_hello_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_hello_make_new = Module["_embed_hello_make_new"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_hello_make_new"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _new_on_del = Module["_new_on_del"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["new_on_del"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _on_del_del = Module["_on_del_del"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["on_del_del"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _on_del_attr = Module["_on_del_attr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["on_del_attr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_CLI = Module["_embed_CLI"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_CLI"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_STI = Module["_embed_STI"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_STI"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_FLAGS_IF = Module["_embed_FLAGS_IF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_FLAGS_IF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_WAPY = Module["_embed_WAPY"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_WAPY"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_sdl = Module["_embed_sdl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_sdl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_print = Module["_embed_os_print"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_print"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_write = Module["_embed_os_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_stderr = Module["_embed_os_stderr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_stderr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_log = Module["_embed_log"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_builtins_vars = Module["_embed_builtins_vars"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_builtins_vars"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_compile = Module["_embed_os_compile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_compile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_showloop = Module["_embed_os_showloop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_showloop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_hideloop = Module["_embed_os_hideloop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_hideloop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_hook = Module["_embed_os_hook"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_hook"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_time_ns = Module["_embed_time_ns"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_time_ns"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_time_ms = Module["_embed_time_ms"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_time_ms"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_ticks_add = Module["_embed_ticks_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_ticks_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_sleep_ms = Module["_embed_sleep_ms"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_sleep_ms"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_sleep = Module["_embed_sleep"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_sleep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_ticks_period = Module["_embed_ticks_period"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_ticks_period"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_os_read_useless = Module["_embed_os_read_useless"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_os_read_useless"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_echosum1 = Module["_embed_echosum1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_echosum1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_callsome = Module["_embed_callsome"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_callsome"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _embed_somecall = Module["_embed_somecall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["embed_somecall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _example_add_ints = Module["_example_add_ints"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["example_add_ints"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_stdout_tx_str = Module["_mp_hal_stdout_tx_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_stdout_tx_str"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stderr_print_strn = Module["_stderr_print_strn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stderr_print_strn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _parse_compile_execute = Module["_parse_compile_execute"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["parse_compile_execute"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readline_init = Module["_readline_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readline_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_raw_repl_process_char = Module["_pyexec_raw_repl_process_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_raw_repl_process_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readline_process_char = Module["_readline_process_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readline_process_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readline_note_newline = Module["_readline_note_newline"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readline_note_newline"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_event_repl_process_char = Module["_pyexec_event_repl_process_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_event_repl_process_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_file = Module["_pyexec_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_file_if_exists = Module["_pyexec_file_if_exists"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_file_if_exists"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyexec_frozen_module = Module["_pyexec_frozen_module"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyexec_frozen_module"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pyb_set_repl_info = Module["_pyb_set_repl_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pyb_set_repl_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_set_interrupt_char = Module["_mp_hal_set_interrupt_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_set_interrupt_char"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readline_init0 = Module["_readline_init0"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readline_init0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _str_dup_maybe = Module["_str_dup_maybe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["str_dup_maybe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_move_cursor_back = Module["_mp_hal_move_cursor_back"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_move_cursor_back"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mp_hal_erase_line_from_cursor = Module["_mp_hal_erase_line_from_cursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mp_hal_erase_line_from_cursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readline_push_history = Module["_readline_push_history"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readline_push_history"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetMainReady = Module["_SDL_SetMainReady"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetMainReady"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_InitSubSystem = Module["_SDL_InitSubSystem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_InitSubSystem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ClearError = Module["_SDL_ClearError"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ClearError"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TicksInit = Module["_SDL_TicksInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TicksInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EventsInit = Module["_SDL_EventsInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EventsInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TimerInit = Module["_SDL_TimerInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TimerInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_VideoInit = Module["_SDL_VideoInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_VideoInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AudioInit = Module["_SDL_AudioInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AudioInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickInit = Module["_SDL_JoystickInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerInit = Module["_SDL_GameControllerInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetError = Module["_SDL_SetError"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetError"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorInit = Module["_SDL_SensorInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Init = Module["_SDL_Init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_QuitSubSystem = Module["_SDL_QuitSubSystem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_QuitSubSystem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorQuit = Module["_SDL_SensorQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerQuit = Module["_SDL_GameControllerQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickQuit = Module["_SDL_JoystickQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AudioQuit = Module["_SDL_AudioQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AudioQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_VideoQuit = Module["_SDL_VideoQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_VideoQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TimerQuit = Module["_SDL_TimerQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TimerQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EventsQuit = Module["_SDL_EventsQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EventsQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WasInit = Module["_SDL_WasInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WasInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Quit = Module["_SDL_Quit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Quit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TicksQuit = Module["_SDL_TicksQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TicksQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ClearHints = Module["_SDL_ClearHints"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ClearHints"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AssertionsQuit = Module["_SDL_AssertionsQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AssertionsQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogResetPriorities = Module["_SDL_LogResetPriorities"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogResetPriorities"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_memset = Module["_SDL_memset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_memset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetVersion = Module["_SDL_GetVersion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetVersion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRevision = Module["_SDL_GetRevision"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRevision"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRevisionNumber = Module["_SDL_GetRevisionNumber"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRevisionNumber"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetPlatform = Module["_SDL_GetPlatform"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetPlatform"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsTablet = Module["_SDL_IsTablet"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsTablet"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReportAssertion = Module["_SDL_ReportAssertion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReportAssertion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetAssertionHandler = Module["_SDL_SetAssertionHandler"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetAssertionHandler"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_snprintf = Module["_SDL_snprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_snprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_getenv = Module["_SDL_getenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_getenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strcmp = Module["_SDL_strcmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetFocusWindow = Module["_SDL_GetFocusWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetFocusWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowFlags = Module["_SDL_GetWindowFlags"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowFlags"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MinimizeWindow = Module["_SDL_MinimizeWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MinimizeWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ShowMessageBox = Module["_SDL_ShowMessageBox"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ShowMessageBox"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RestoreWindow = Module["_SDL_RestoreWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RestoreWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetAssertionReport = Module["_SDL_GetAssertionReport"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetAssertionReport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ResetAssertionReport = Module["_SDL_ResetAssertionReport"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ResetAssertionReport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDefaultAssertionHandler = Module["_SDL_GetDefaultAssertionHandler"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDefaultAssertionHandler"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetAssertionHandler = Module["_SDL_GetAssertionHandler"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetAssertionHandler"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogMessageV = Module["_SDL_LogMessageV"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogMessageV"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_NewDataQueue = Module["_SDL_NewDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_NewDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_malloc = Module["_SDL_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_malloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Error = Module["_SDL_Error"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Error"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeDataQueue = Module["_SDL_FreeDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_free = Module["_SDL_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ClearDataQueue = Module["_SDL_ClearDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ClearDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteToDataQueue = Module["_SDL_WriteToDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteToDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_memcpy = Module["_SDL_memcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_memcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PeekIntoDataQueue = Module["_SDL_PeekIntoDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PeekIntoDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadFromDataQueue = Module["_SDL_ReadFromDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadFromDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CountDataQueue = Module["_SDL_CountDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CountDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReserveSpaceInDataQueue = Module["_SDL_ReserveSpaceInDataQueue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReserveSpaceInDataQueue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strlcpy = Module["_SDL_strlcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strlcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogGetPriority = Module["_SDL_LogGetPriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogGetPriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogDebug = Module["_SDL_LogDebug"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogDebug"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetError = Module["_SDL_GetError"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetError"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetHintWithPriority = Module["_SDL_SetHintWithPriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetHintWithPriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strdup = Module["_SDL_strdup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetHint = Module["_SDL_SetHint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetHint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetHint = Module["_SDL_GetHint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetHint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetHintBoolean = Module["_SDL_GetHintBoolean"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetHintBoolean"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strcasecmp = Module["_SDL_strcasecmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strcasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddHintCallback = Module["_SDL_AddHintCallback"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddHintCallback"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DelHintCallback = Module["_SDL_DelHintCallback"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DelHintCallback"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogSetAllPriority = Module["_SDL_LogSetAllPriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogSetAllPriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogSetPriority = Module["_SDL_LogSetPriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogSetPriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Log = Module["_SDL_Log"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_vsnprintf = Module["_SDL_vsnprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_vsnprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strlen = Module["_SDL_strlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogVerbose = Module["_SDL_LogVerbose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogVerbose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogInfo = Module["_SDL_LogInfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogInfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogWarn = Module["_SDL_LogWarn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogWarn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogError = Module["_SDL_LogError"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogError"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogCritical = Module["_SDL_LogCritical"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogCritical"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogMessage = Module["_SDL_LogMessage"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogMessage"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogGetOutputFunction = Module["_SDL_LogGetOutputFunction"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogGetOutputFunction"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LogSetOutputFunction = Module["_SDL_LogSetOutputFunction"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LogSetOutputFunction"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicCAS = Module["_SDL_AtomicCAS"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicCAS"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicCASPtr = Module["_SDL_AtomicCASPtr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicCASPtr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicSet = Module["_SDL_AtomicSet"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicSet"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicSetPtr = Module["_SDL_AtomicSetPtr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicSetPtr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicAdd = Module["_SDL_AtomicAdd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicAdd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicGet = Module["_SDL_AtomicGet"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicGet"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicGetPtr = Module["_SDL_AtomicGetPtr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicGetPtr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MemoryBarrierReleaseFunction = Module["_SDL_MemoryBarrierReleaseFunction"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MemoryBarrierReleaseFunction"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicLock = Module["_SDL_AtomicLock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicLock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicUnlock = Module["_SDL_AtomicUnlock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicUnlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MemoryBarrierAcquireFunction = Module["_SDL_MemoryBarrierAcquireFunction"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MemoryBarrierAcquireFunction"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AtomicTryLock = Module["_SDL_AtomicTryLock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AtomicTryLock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Delay = Module["_SDL_Delay"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Delay"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddAudioDevice = Module["_SDL_AddAudioDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddAudioDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EventState = Module["_SDL_EventState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EventState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PushEvent = Module["_SDL_PushEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PushEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OpenedAudioDeviceDisconnected = Module["_SDL_OpenedAudioDeviceDisconnected"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OpenedAudioDeviceDisconnected"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RemoveAudioDevice = Module["_SDL_RemoveAudioDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RemoveAudioDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LockMutex = Module["_SDL_LockMutex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LockMutex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnlockMutex = Module["_SDL_UnlockMutex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnlockMutex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_QueueAudio = Module["_SDL_QueueAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_QueueAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DequeueAudio = Module["_SDL_DequeueAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DequeueAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetQueuedAudioSize = Module["_SDL_GetQueuedAudioSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetQueuedAudioSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ClearQueuedAudio = Module["_SDL_ClearQueuedAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ClearQueuedAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumAudioDrivers = Module["_SDL_GetNumAudioDrivers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumAudioDrivers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetAudioDriver = Module["_SDL_GetAudioDriver"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetAudioDriver"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strncasecmp = Module["_SDL_strncasecmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strncasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateMutex = Module["_SDL_CreateMutex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateMutex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DestroyMutex = Module["_SDL_DestroyMutex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DestroyMutex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeResampleFilter = Module["_SDL_FreeResampleFilter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeResampleFilter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetCurrentAudioDriver = Module["_SDL_GetCurrentAudioDriver"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetCurrentAudioDriver"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumAudioDevices = Module["_SDL_GetNumAudioDevices"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumAudioDevices"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetAudioDeviceName = Module["_SDL_GetAudioDeviceName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetAudioDeviceName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OpenAudio = Module["_SDL_OpenAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OpenAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_atoi = Module["_SDL_atoi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_atoi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_calloc = Module["_SDL_calloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_calloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_NewAudioStream = Module["_SDL_NewAudioStream"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_NewAudioStream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateThreadInternal = Module["_SDL_CreateThreadInternal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateThreadInternal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OpenAudioDevice = Module["_SDL_OpenAudioDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OpenAudioDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetAudioDeviceStatus = Module["_SDL_GetAudioDeviceStatus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetAudioDeviceStatus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetAudioStatus = Module["_SDL_GetAudioStatus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetAudioStatus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PauseAudioDevice = Module["_SDL_PauseAudioDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PauseAudioDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PauseAudio = Module["_SDL_PauseAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PauseAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LockAudioDevice = Module["_SDL_LockAudioDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LockAudioDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LockAudio = Module["_SDL_LockAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LockAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnlockAudioDevice = Module["_SDL_UnlockAudioDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnlockAudioDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnlockAudio = Module["_SDL_UnlockAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnlockAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CloseAudioDevice = Module["_SDL_CloseAudioDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CloseAudioDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WaitThread = Module["_SDL_WaitThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WaitThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeAudioStream = Module["_SDL_FreeAudioStream"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeAudioStream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CloseAudio = Module["_SDL_CloseAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CloseAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FirstAudioFormat = Module["_SDL_FirstAudioFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FirstAudioFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_NextAudioFormat = Module["_SDL_NextAudioFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_NextAudioFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateAudioSpec = Module["_SDL_CalculateAudioSpec"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateAudioSpec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MixAudio = Module["_SDL_MixAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MixAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MixAudioFormat = Module["_SDL_MixAudioFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MixAudioFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ThreadID = Module["_SDL_ThreadID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ThreadID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetThreadPriority = Module["_SDL_SetThreadPriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetThreadPriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AudioStreamClear = Module["_SDL_AudioStreamClear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AudioStreamClear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AudioStreamPut = Module["_SDL_AudioStreamPut"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AudioStreamPut"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AudioStreamAvailable = Module["_SDL_AudioStreamAvailable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AudioStreamAvailable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AudioStreamGet = Module["_SDL_AudioStreamGet"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AudioStreamGet"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrepareResampleFilter = Module["_SDL_PrepareResampleFilter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrepareResampleFilter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_pow = Module["_SDL_pow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_pow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_sqrt = Module["_SDL_sqrt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_sqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_sinf = Module["_SDL_sinf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_sinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ConvertAudio = Module["_SDL_ConvertAudio"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ConvertAudio"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BuildAudioCVT = Module["_SDL_BuildAudioCVT"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BuildAudioCVT"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ChooseAudioConverters = Module["_SDL_ChooseAudioConverters"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ChooseAudioConverters"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ceil = Module["_SDL_ceil"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ceil"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_realloc = Module["_SDL_realloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_realloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AudioStreamFlush = Module["_SDL_AudioStreamFlush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AudioStreamFlush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_memmove = Module["_SDL_memmove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_memmove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LoadWAV_RW = Module["_SDL_LoadWAV_RW"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LoadWAV_RW"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_sscanf = Module["_SDL_sscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_sscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWtell = Module["_SDL_RWtell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWtell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWseek = Module["_SDL_RWseek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWseek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWread = Module["_SDL_RWread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWFromConstMem = Module["_SDL_RWFromConstMem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWFromConstMem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadLE16 = Module["_SDL_ReadLE16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadLE16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadLE32 = Module["_SDL_ReadLE32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadLE32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWclose = Module["_SDL_RWclose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWclose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_memcmp = Module["_SDL_memcmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_memcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeWAV = Module["_SDL_FreeWAV"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeWAV"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetCPUCount = Module["_SDL_GetCPUCount"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetCPUCount"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetCPUCacheLineSize = Module["_SDL_GetCPUCacheLineSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetCPUCacheLineSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasRDTSC = Module["_SDL_HasRDTSC"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasRDTSC"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasAltiVec = Module["_SDL_HasAltiVec"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasAltiVec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasMMX = Module["_SDL_HasMMX"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasMMX"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Has3DNow = Module["_SDL_Has3DNow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Has3DNow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasSSE = Module["_SDL_HasSSE"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasSSE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasSSE2 = Module["_SDL_HasSSE2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasSSE2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasSSE3 = Module["_SDL_HasSSE3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasSSE3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasSSE41 = Module["_SDL_HasSSE41"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasSSE41"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasSSE42 = Module["_SDL_HasSSE42"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasSSE42"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasAVX = Module["_SDL_HasAVX"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasAVX"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasAVX2 = Module["_SDL_HasAVX2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasAVX2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasAVX512F = Module["_SDL_HasAVX512F"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasAVX512F"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasNEON = Module["_SDL_HasNEON"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasNEON"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetSystemRAM = Module["_SDL_GetSystemRAM"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetSystemRAM"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SIMDGetAlignment = Module["_SDL_SIMDGetAlignment"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SIMDGetAlignment"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SIMDAlloc = Module["_SDL_SIMDAlloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SIMDAlloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SIMDFree = Module["_SDL_SIMDFree"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SIMDFree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendClipboardUpdate = Module["_SDL_SendClipboardUpdate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendClipboardUpdate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendDropFile = Module["_SDL_SendDropFile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendDropFile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendDropText = Module["_SDL_SendDropText"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendDropText"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendDropComplete = Module["_SDL_SendDropComplete"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendDropComplete"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_StopEventLoop = Module["_SDL_StopEventLoop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_StopEventLoop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_StartEventLoop = Module["_SDL_StartEventLoop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_StartEventLoop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FlushEvents = Module["_SDL_FlushEvents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FlushEvents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ToggleDragAndDropSupport = Module["_SDL_ToggleDragAndDropSupport"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ToggleDragAndDropSupport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PeepEvents = Module["_SDL_PeepEvents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PeepEvents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasEvent = Module["_SDL_HasEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasEvents = Module["_SDL_HasEvents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasEvents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FlushEvent = Module["_SDL_FlushEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FlushEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PumpEvents = Module["_SDL_PumpEvents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PumpEvents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetVideoDevice = Module["_SDL_GetVideoDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetVideoDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickEventState = Module["_SDL_JoystickEventState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickEventState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickUpdate = Module["_SDL_JoystickUpdate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickUpdate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorUpdate = Module["_SDL_SensorUpdate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorUpdate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendPendingSignalEvents = Module["_SDL_SendPendingSignalEvents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendPendingSignalEvents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PollEvent = Module["_SDL_PollEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PollEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WaitEventTimeout = Module["_SDL_WaitEventTimeout"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WaitEventTimeout"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTicks = Module["_SDL_GetTicks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTicks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WaitEvent = Module["_SDL_WaitEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WaitEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GestureProcessEvent = Module["_SDL_GestureProcessEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GestureProcessEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetEventFilter = Module["_SDL_SetEventFilter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetEventFilter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetEventFilter = Module["_SDL_GetEventFilter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetEventFilter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddEventWatch = Module["_SDL_AddEventWatch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddEventWatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DelEventWatch = Module["_SDL_DelEventWatch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DelEventWatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FilterEvents = Module["_SDL_FilterEvents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FilterEvents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RegisterEvents = Module["_SDL_RegisterEvents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RegisterEvents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendAppEvent = Module["_SDL_SendAppEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendAppEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendSysWMEvent = Module["_SDL_SendSysWMEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendSysWMEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendKeymapChangedEvent = Module["_SDL_SendKeymapChangedEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendKeymapChangedEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_QuitInit = Module["_SDL_QuitInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_QuitInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_QuitQuit = Module["_SDL_QuitQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_QuitQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RecordGesture = Module["_SDL_RecordGesture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RecordGesture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GestureQuit = Module["_SDL_GestureQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GestureQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SaveAllDollarTemplates = Module["_SDL_SaveAllDollarTemplates"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SaveAllDollarTemplates"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWwrite = Module["_SDL_RWwrite"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWwrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SaveDollarTemplate = Module["_SDL_SaveDollarTemplate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SaveDollarTemplate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LoadDollarTemplates = Module["_SDL_LoadDollarTemplates"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LoadDollarTemplates"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GestureAddTouch = Module["_SDL_GestureAddTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GestureAddTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GestureDelTouch = Module["_SDL_GestureDelTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GestureDelTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_fabs = Module["_SDL_fabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_fabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_atan2 = Module["_SDL_atan2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_atan2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_cos = Module["_SDL_cos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_sin = Module["_SDL_sin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UCS4ToUTF8 = Module["_SDL_UCS4ToUTF8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UCS4ToUTF8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_KeyboardInit = Module["_SDL_KeyboardInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_KeyboardInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ResetKeyboard = Module["_SDL_ResetKeyboard"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ResetKeyboard"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendKeyboardKey = Module["_SDL_SendKeyboardKey"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendKeyboardKey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDefaultKeymap = Module["_SDL_GetDefaultKeymap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDefaultKeymap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetKeymap = Module["_SDL_SetKeymap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetKeymap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetScancodeName = Module["_SDL_SetScancodeName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetScancodeName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetKeyboardFocus = Module["_SDL_GetKeyboardFocus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetKeyboardFocus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetKeyboardFocus = Module["_SDL_SetKeyboardFocus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetKeyboardFocus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CaptureMouse = Module["_SDL_CaptureMouse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CaptureMouse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendWindowEvent = Module["_SDL_SendWindowEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendWindowEvent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendKeyboardText = Module["_SDL_SendKeyboardText"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendKeyboardText"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_utf8strlcpy = Module["_SDL_utf8strlcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_utf8strlcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendEditingText = Module["_SDL_SendEditingText"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendEditingText"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_KeyboardQuit = Module["_SDL_KeyboardQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_KeyboardQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetKeyboardState = Module["_SDL_GetKeyboardState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetKeyboardState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetModState = Module["_SDL_GetModState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetModState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetModState = Module["_SDL_SetModState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetModState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ToggleModState = Module["_SDL_ToggleModState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ToggleModState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetKeyFromScancode = Module["_SDL_GetKeyFromScancode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetKeyFromScancode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetScancodeFromKey = Module["_SDL_GetScancodeFromKey"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetScancodeFromKey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetScancodeName = Module["_SDL_GetScancodeName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetScancodeName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetScancodeFromName = Module["_SDL_GetScancodeFromName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetScancodeFromName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetKeyName = Module["_SDL_GetKeyName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetKeyName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetKeyFromName = Module["_SDL_GetKeyFromName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetKeyFromName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MouseInit = Module["_SDL_MouseInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MouseInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetMouse = Module["_SDL_GetMouse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetMouse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_atof = Module["_SDL_atof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_atof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddTouch = Module["_SDL_AddTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetDefaultCursor = Module["_SDL_SetDefaultCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetDefaultCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetCursor = Module["_SDL_SetCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetMouseFocus = Module["_SDL_GetMouseFocus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetMouseFocus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetMouseFocus = Module["_SDL_SetMouseFocus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetMouseFocus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendMouseMotion = Module["_SDL_SendMouseMotion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendMouseMotion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowSize = Module["_SDL_GetWindowSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendTouchMotion = Module["_SDL_SendTouchMotion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendTouchMotion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_floor = Module["_SDL_floor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_floor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendMouseButtonClicks = Module["_SDL_SendMouseButtonClicks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendMouseButtonClicks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendTouch = Module["_SDL_SendTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_abs = Module["_SDL_abs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_abs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendMouseButton = Module["_SDL_SendMouseButton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendMouseButton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendMouseWheel = Module["_SDL_SendMouseWheel"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendMouseWheel"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MouseQuit = Module["_SDL_MouseQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MouseQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetRelativeMouseMode = Module["_SDL_SetRelativeMouseMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetRelativeMouseMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UpdateWindowGrab = Module["_SDL_UpdateWindowGrab"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UpdateWindowGrab"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ShowCursor = Module["_SDL_ShowCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ShowCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeCursor = Module["_SDL_FreeCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetMouseState = Module["_SDL_GetMouseState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetMouseState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRelativeMouseState = Module["_SDL_GetRelativeMouseState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRelativeMouseState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetGlobalMouseState = Module["_SDL_GetGlobalMouseState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetGlobalMouseState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WarpMouseInWindow = Module["_SDL_WarpMouseInWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WarpMouseInWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WarpMouseGlobal = Module["_SDL_WarpMouseGlobal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WarpMouseGlobal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRelativeMouseMode = Module["_SDL_GetRelativeMouseMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRelativeMouseMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateCursor = Module["_SDL_CreateCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateRGBSurface = Module["_SDL_CreateRGBSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateRGBSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateColorCursor = Module["_SDL_CreateColorCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateColorCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeSurface = Module["_SDL_FreeSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ConvertSurfaceFormat = Module["_SDL_ConvertSurfaceFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ConvertSurfaceFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateSystemCursor = Module["_SDL_CreateSystemCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateSystemCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetCursor = Module["_SDL_GetCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDefaultCursor = Module["_SDL_GetDefaultCursor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDefaultCursor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SendQuit = Module["_SDL_SendQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SendQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TouchInit = Module["_SDL_TouchInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TouchInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumTouchDevices = Module["_SDL_GetNumTouchDevices"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumTouchDevices"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTouchDevice = Module["_SDL_GetTouchDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTouchDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTouch = Module["_SDL_GetTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTouchDeviceType = Module["_SDL_GetTouchDeviceType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTouchDeviceType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumTouchFingers = Module["_SDL_GetNumTouchFingers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumTouchFingers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTouchFinger = Module["_SDL_GetTouchFinger"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTouchFinger"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DelTouch = Module["_SDL_DelTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DelTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TouchQuit = Module["_SDL_TouchQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TouchQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowShown = Module["_SDL_OnWindowShown"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowShown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowHidden = Module["_SDL_OnWindowHidden"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowHidden"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowResized = Module["_SDL_OnWindowResized"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowResized"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowMinimized = Module["_SDL_OnWindowMinimized"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowMinimized"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowRestored = Module["_SDL_OnWindowRestored"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowRestored"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowEnter = Module["_SDL_OnWindowEnter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowEnter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowLeave = Module["_SDL_OnWindowLeave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowLeave"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowFocusGained = Module["_SDL_OnWindowFocusGained"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowFocusGained"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnWindowFocusLost = Module["_SDL_OnWindowFocusLost"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnWindowFocusLost"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWFromFile = Module["_SDL_RWFromFile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWFromFile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWFromFP = Module["_SDL_RWFromFP"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWFromFP"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AllocRW = Module["_SDL_AllocRW"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AllocRW"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fseeko = Module["_fseeko"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fseeko"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftello = Module["_ftello"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftello"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ferror = Module["_ferror"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ferror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fclose = Module["_fclose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fclose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWFromMem = Module["_SDL_RWFromMem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWFromMem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeRW = Module["_SDL_FreeRW"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeRW"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LoadFile_RW = Module["_SDL_LoadFile_RW"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LoadFile_RW"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RWsize = Module["_SDL_RWsize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RWsize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LoadFile = Module["_SDL_LoadFile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LoadFile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadU8 = Module["_SDL_ReadU8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadU8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadBE16 = Module["_SDL_ReadBE16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadBE16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadBE32 = Module["_SDL_ReadBE32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadBE32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadLE64 = Module["_SDL_ReadLE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadLE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ReadBE64 = Module["_SDL_ReadBE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ReadBE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteU8 = Module["_SDL_WriteU8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteU8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteLE16 = Module["_SDL_WriteLE16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteLE16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteBE16 = Module["_SDL_WriteBE16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteBE16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteLE32 = Module["_SDL_WriteLE32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteLE32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteBE32 = Module["_SDL_WriteBE32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteBE32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteLE64 = Module["_SDL_WriteLE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteLE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_WriteBE64 = Module["_SDL_WriteBE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_WriteBE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticInit = Module["_SDL_HapticInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticInit = Module["_SDL_SYS_HapticInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_NumHaptics = Module["_SDL_NumHaptics"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_NumHaptics"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_NumHaptics = Module["_SDL_SYS_NumHaptics"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_NumHaptics"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticName = Module["_SDL_HapticName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticName = Module["_SDL_SYS_HapticName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticOpen = Module["_SDL_HapticOpen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticOpen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticOpen = Module["_SDL_SYS_HapticOpen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticOpen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticSetGain = Module["_SDL_HapticSetGain"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticSetGain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticSetAutocenter = Module["_SDL_SYS_HapticSetAutocenter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticSetAutocenter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticSetGain = Module["_SDL_SYS_HapticSetGain"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticSetGain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticSetAutocenter = Module["_SDL_HapticSetAutocenter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticSetAutocenter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticOpened = Module["_SDL_HapticOpened"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticOpened"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticIndex = Module["_SDL_HapticIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MouseIsHaptic = Module["_SDL_MouseIsHaptic"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MouseIsHaptic"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticMouse = Module["_SDL_SYS_HapticMouse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticMouse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticOpenFromMouse = Module["_SDL_HapticOpenFromMouse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticOpenFromMouse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickIsHaptic = Module["_SDL_JoystickIsHaptic"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickIsHaptic"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickValid = Module["_SDL_PrivateJoystickValid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickValid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_JoystickIsHaptic = Module["_SDL_SYS_JoystickIsHaptic"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_JoystickIsHaptic"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticOpenFromJoystick = Module["_SDL_HapticOpenFromJoystick"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticOpenFromJoystick"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_JoystickSameHaptic = Module["_SDL_SYS_JoystickSameHaptic"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_JoystickSameHaptic"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticOpenFromJoystick = Module["_SDL_SYS_HapticOpenFromJoystick"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticOpenFromJoystick"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticClose = Module["_SDL_HapticClose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticClose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticDestroyEffect = Module["_SDL_SYS_HapticDestroyEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticDestroyEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticClose = Module["_SDL_SYS_HapticClose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticClose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticDestroyEffect = Module["_SDL_HapticDestroyEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticDestroyEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticQuit = Module["_SDL_HapticQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticQuit = Module["_SDL_SYS_HapticQuit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticQuit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticNumEffects = Module["_SDL_HapticNumEffects"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticNumEffects"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticNumEffectsPlaying = Module["_SDL_HapticNumEffectsPlaying"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticNumEffectsPlaying"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticQuery = Module["_SDL_HapticQuery"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticQuery"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticNumAxes = Module["_SDL_HapticNumAxes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticNumAxes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticEffectSupported = Module["_SDL_HapticEffectSupported"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticEffectSupported"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticNewEffect = Module["_SDL_HapticNewEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticNewEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticNewEffect = Module["_SDL_SYS_HapticNewEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticNewEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticUpdateEffect = Module["_SDL_HapticUpdateEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticUpdateEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticUpdateEffect = Module["_SDL_SYS_HapticUpdateEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticUpdateEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticRunEffect = Module["_SDL_HapticRunEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticRunEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticRunEffect = Module["_SDL_SYS_HapticRunEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticRunEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticStopEffect = Module["_SDL_HapticStopEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticStopEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticStopEffect = Module["_SDL_SYS_HapticStopEffect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticStopEffect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticGetEffectStatus = Module["_SDL_HapticGetEffectStatus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticGetEffectStatus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticGetEffectStatus = Module["_SDL_SYS_HapticGetEffectStatus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticGetEffectStatus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticPause = Module["_SDL_HapticPause"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticPause"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticPause = Module["_SDL_SYS_HapticPause"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticPause"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticUnpause = Module["_SDL_HapticUnpause"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticUnpause"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticUnpause = Module["_SDL_SYS_HapticUnpause"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticUnpause"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticStopAll = Module["_SDL_HapticStopAll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticStopAll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_HapticStopAll = Module["_SDL_SYS_HapticStopAll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_HapticStopAll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticRumbleSupported = Module["_SDL_HapticRumbleSupported"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticRumbleSupported"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticRumbleInit = Module["_SDL_HapticRumbleInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticRumbleInit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticRumblePlay = Module["_SDL_HapticRumblePlay"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticRumblePlay"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HapticRumbleStop = Module["_SDL_HapticRumbleStop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HapticRumbleStop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetAxisFromString = Module["_SDL_GameControllerGetAxisFromString"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetAxisFromString"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetStringForAxis = Module["_SDL_GameControllerGetStringForAxis"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetStringForAxis"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetButtonFromString = Module["_SDL_GameControllerGetButtonFromString"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetButtonFromString"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetStringForButton = Module["_SDL_GameControllerGetStringForButton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetStringForButton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerAddMappingsFromRW = Module["_SDL_GameControllerAddMappingsFromRW"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerAddMappingsFromRW"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strchr = Module["_SDL_strchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strstr = Module["_SDL_strstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerAddMapping = Module["_SDL_GameControllerAddMapping"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerAddMapping"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetGUIDFromString = Module["_SDL_JoystickGetGUIDFromString"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetGUIDFromString"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerNumMappings = Module["_SDL_GameControllerNumMappings"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerNumMappings"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerMappingForIndex = Module["_SDL_GameControllerMappingForIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerMappingForIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetGUIDString = Module["_SDL_JoystickGetGUIDString"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetGUIDString"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerMappingForGUID = Module["_SDL_GameControllerMappingForGUID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerMappingForGUID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsJoystickHIDAPI = Module["_SDL_IsJoystickHIDAPI"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsJoystickHIDAPI"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerMapping = Module["_SDL_GameControllerMapping"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerMapping"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerInitMappings = Module["_SDL_GameControllerInitMappings"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerInitMappings"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_NumJoysticks = Module["_SDL_NumJoysticks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_NumJoysticks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsGameController = Module["_SDL_IsGameController"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsGameController"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerNameForIndex = Module["_SDL_GameControllerNameForIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerNameForIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickNameForIndex = Module["_SDL_JoystickNameForIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickNameForIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LockJoysticks = Module["_SDL_LockJoysticks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LockJoysticks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDeviceGUID = Module["_SDL_JoystickGetDeviceGUID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDeviceGUID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnlockJoysticks = Module["_SDL_UnlockJoysticks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnlockJoysticks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerMappingForDeviceIndex = Module["_SDL_GameControllerMappingForDeviceIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerMappingForDeviceIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsGameControllerNameAndGUID = Module["_SDL_IsGameControllerNameAndGUID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsGameControllerNameAndGUID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ShouldIgnoreGameController = Module["_SDL_ShouldIgnoreGameController"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ShouldIgnoreGameController"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetJoystickGUIDInfo = Module["_SDL_GetJoystickGUIDInfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetJoystickGUIDInfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerOpen = Module["_SDL_GameControllerOpen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerOpen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDeviceInstanceID = Module["_SDL_JoystickGetDeviceInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDeviceInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickOpen = Module["_SDL_JoystickOpen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickOpen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickClose = Module["_SDL_JoystickClose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickClose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerUpdate = Module["_SDL_GameControllerUpdate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerUpdate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetAxis = Module["_SDL_GameControllerGetAxis"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetAxis"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetAxis = Module["_SDL_JoystickGetAxis"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetAxis"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetButton = Module["_SDL_JoystickGetButton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetButton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetHat = Module["_SDL_JoystickGetHat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetHat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetButton = Module["_SDL_GameControllerGetButton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetButton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerName = Module["_SDL_GameControllerName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickName = Module["_SDL_JoystickName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetJoystick = Module["_SDL_GameControllerGetJoystick"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetJoystick"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetPlayerIndex = Module["_SDL_GameControllerGetPlayerIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetPlayerIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetPlayerIndex = Module["_SDL_JoystickGetPlayerIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetPlayerIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetVendor = Module["_SDL_GameControllerGetVendor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetVendor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetVendor = Module["_SDL_JoystickGetVendor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetVendor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetProduct = Module["_SDL_GameControllerGetProduct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetProduct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetProduct = Module["_SDL_JoystickGetProduct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetProduct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetProductVersion = Module["_SDL_GameControllerGetProductVersion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetProductVersion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetProductVersion = Module["_SDL_JoystickGetProductVersion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetProductVersion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetAttached = Module["_SDL_GameControllerGetAttached"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetAttached"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetAttached = Module["_SDL_JoystickGetAttached"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetAttached"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerFromInstanceID = Module["_SDL_GameControllerFromInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerFromInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetBindForAxis = Module["_SDL_GameControllerGetBindForAxis"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetBindForAxis"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerGetBindForButton = Module["_SDL_GameControllerGetBindForButton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerGetBindForButton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerRumble = Module["_SDL_GameControllerRumble"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerRumble"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickRumble = Module["_SDL_JoystickRumble"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickRumble"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerClose = Module["_SDL_GameControllerClose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerClose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerQuitMappings = Module["_SDL_GameControllerQuitMappings"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerQuitMappings"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerEventState = Module["_SDL_GameControllerEventState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerEventState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GameControllerHandleDelayedGuideButton = Module["_SDL_GameControllerHandleDelayedGuideButton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GameControllerHandleDelayedGuideButton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strtol = Module["_SDL_strtol"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strtol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_isdigit = Module["_SDL_isdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_isdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNextJoystickInstanceID = Module["_SDL_GetNextJoystickInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNextJoystickInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDriverAndJoystickIndex = Module["_SDL_GetDriverAndJoystickIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDriverAndJoystickIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strncmp = Module["_SDL_strncmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strncmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDevicePlayerIndex = Module["_SDL_JoystickGetDevicePlayerIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDevicePlayerIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickNumAxes = Module["_SDL_JoystickNumAxes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickNumAxes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickNumHats = Module["_SDL_JoystickNumHats"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickNumHats"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickNumBalls = Module["_SDL_JoystickNumBalls"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickNumBalls"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickNumButtons = Module["_SDL_JoystickNumButtons"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickNumButtons"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetAxisInitialState = Module["_SDL_JoystickGetAxisInitialState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetAxisInitialState"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetBall = Module["_SDL_JoystickGetBall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetBall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickInstanceID = Module["_SDL_JoystickInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickFromInstanceID = Module["_SDL_JoystickFromInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickFromInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickAdded = Module["_SDL_PrivateJoystickAdded"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickAdded"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDeviceIndexFromInstanceID = Module["_SDL_JoystickGetDeviceIndexFromInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDeviceIndexFromInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickRemoved = Module["_SDL_PrivateJoystickRemoved"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickRemoved"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickAxis = Module["_SDL_PrivateJoystickAxis"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickAxis"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasWindows = Module["_SDL_HasWindows"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasWindows"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickHat = Module["_SDL_PrivateJoystickHat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickHat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickBall = Module["_SDL_PrivateJoystickBall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickBall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickButton = Module["_SDL_PrivateJoystickButton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickButton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsJoystickPS4 = Module["_SDL_IsJoystickPS4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsJoystickPS4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsJoystickNintendoSwitchPro = Module["_SDL_IsJoystickNintendoSwitchPro"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsJoystickNintendoSwitchPro"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsJoystickSteamController = Module["_SDL_IsJoystickSteamController"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsJoystickSteamController"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsJoystickXbox360 = Module["_SDL_IsJoystickXbox360"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsJoystickXbox360"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsJoystickXboxOne = Module["_SDL_IsJoystickXboxOne"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsJoystickXboxOne"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsJoystickXInput = Module["_SDL_IsJoystickXInput"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsJoystickXInput"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ShouldIgnoreJoystick = Module["_SDL_ShouldIgnoreJoystick"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ShouldIgnoreJoystick"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDeviceVendor = Module["_SDL_JoystickGetDeviceVendor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDeviceVendor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDeviceProduct = Module["_SDL_JoystickGetDeviceProduct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDeviceProduct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDeviceProductVersion = Module["_SDL_JoystickGetDeviceProductVersion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDeviceProductVersion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetDeviceType = Module["_SDL_JoystickGetDeviceType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetDeviceType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetGUID = Module["_SDL_JoystickGetGUID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetGUID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickGetType = Module["_SDL_JoystickGetType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickGetType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateJoystickBatteryLevel = Module["_SDL_PrivateJoystickBatteryLevel"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateJoystickBatteryLevel"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_JoystickCurrentPowerLevel = Module["_SDL_JoystickCurrentPowerLevel"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_JoystickCurrentPowerLevel"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_atan2 = Module["_SDL_uclibc_atan2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_atan2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_atan = Module["_SDL_uclibc_atan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_atan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_fabs = Module["_SDL_uclibc_fabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_fabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_log = Module["_SDL_uclibc_log"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_pow = Module["_SDL_uclibc_pow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_pow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_sqrt = Module["_SDL_uclibc_sqrt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_sqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_scalbn = Module["_SDL_uclibc_scalbn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_scalbn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ieee754_rem_pio2 = Module["___ieee754_rem_pio2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ieee754_rem_pio2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___kernel_rem_pio2 = Module["___kernel_rem_pio2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__kernel_rem_pio2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___kernel_cos = Module["___kernel_cos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__kernel_cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_floor = Module["_SDL_uclibc_floor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_floor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___kernel_sin = Module["___kernel_sin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__kernel_sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___kernel_tan = Module["___kernel_tan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__kernel_tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_copysign = Module["_SDL_uclibc_copysign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_copysign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_cos = Module["_SDL_uclibc_cos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_scalbln = Module["_SDL_uclibc_scalbln"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_scalbln"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_sin = Module["_SDL_uclibc_sin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uclibc_tan = Module["_SDL_uclibc_tan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uclibc_tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetPowerInfo = Module["_SDL_GetPowerInfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetPowerInfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetPowerInfo_Emscripten = Module["_SDL_GetPowerInfo_Emscripten"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetPowerInfo_Emscripten"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderFlush = Module["_SDL_RenderFlush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderFlush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AllocateRenderVertices = Module["_SDL_AllocateRenderVertices"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AllocateRenderVertices"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumRenderDrivers = Module["_SDL_GetNumRenderDrivers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumRenderDrivers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRenderDriverInfo = Module["_SDL_GetRenderDriverInfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRenderDriverInfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateWindowAndRenderer = Module["_SDL_CreateWindowAndRenderer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateWindowAndRenderer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateWindow = Module["_SDL_CreateWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateRenderer = Module["_SDL_CreateRenderer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateRenderer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowData = Module["_SDL_GetWindowData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowData = Module["_SDL_SetWindowData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderSetViewport = Module["_SDL_RenderSetViewport"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderSetViewport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRenderer = Module["_SDL_GetRenderer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRenderer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowFromID = Module["_SDL_GetWindowFromID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowFromID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetRenderTarget = Module["_SDL_SetRenderTarget"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetRenderTarget"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRendererOutputSize = Module["_SDL_GetRendererOutputSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRendererOutputSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateSoftwareRenderer = Module["_SDL_CreateSoftwareRenderer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateSoftwareRenderer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SW_CreateRendererForSurface = Module["_SW_CreateRendererForSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SW_CreateRendererForSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRendererInfo = Module["_SDL_GetRendererInfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRendererInfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_QueryTexture = Module["_SDL_QueryTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_QueryTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateTexture = Module["_SDL_CreateTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_CreateYUVTexture = Module["_SDL_SW_CreateYUVTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_CreateYUVTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DestroyTexture = Module["_SDL_DestroyTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DestroyTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_DestroyYUVTexture = Module["_SDL_SW_DestroyYUVTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_DestroyYUVTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateTextureFromSurface = Module["_SDL_CreateTextureFromSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateTextureFromSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasColorKey = Module["_SDL_HasColorKey"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasColorKey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LockSurface = Module["_SDL_LockSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LockSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UpdateTexture = Module["_SDL_UpdateTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UpdateTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnlockSurface = Module["_SDL_UnlockSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnlockSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AllocFormat = Module["_SDL_AllocFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AllocFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ConvertSurface = Module["_SDL_ConvertSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ConvertSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeFormat = Module["_SDL_FreeFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetSurfaceColorMod = Module["_SDL_GetSurfaceColorMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetSurfaceColorMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetSurfaceAlphaMod = Module["_SDL_GetSurfaceAlphaMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetSurfaceAlphaMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetSurfaceBlendMode = Module["_SDL_GetSurfaceBlendMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetSurfaceBlendMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_UpdateYUVTexture = Module["_SDL_SW_UpdateYUVTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_UpdateYUVTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LockTexture = Module["_SDL_LockTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LockTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_CopyYUVToRGB = Module["_SDL_SW_CopyYUVToRGB"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_CopyYUVToRGB"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnlockTexture = Module["_SDL_UnlockTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnlockTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ConvertPixels = Module["_SDL_ConvertPixels"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ConvertPixels"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetTextureColorMod = Module["_SDL_SetTextureColorMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetTextureColorMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetTextureAlphaMod = Module["_SDL_SetTextureAlphaMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetTextureAlphaMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetTextureBlendMode = Module["_SDL_SetTextureBlendMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetTextureBlendMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTextureColorMod = Module["_SDL_GetTextureColorMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTextureColorMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTextureAlphaMod = Module["_SDL_GetTextureAlphaMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTextureAlphaMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetTextureBlendMode = Module["_SDL_GetTextureBlendMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetTextureBlendMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UpdateYUVTexture = Module["_SDL_UpdateYUVTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UpdateYUVTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_UpdateYUVTexturePlanar = Module["_SDL_SW_UpdateYUVTexturePlanar"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_UpdateYUVTexturePlanar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_LockYUVTexture = Module["_SDL_SW_LockYUVTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_LockYUVTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderTargetSupported = Module["_SDL_RenderTargetSupported"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderTargetSupported"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRenderTarget = Module["_SDL_GetRenderTarget"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRenderTarget"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderSetLogicalSize = Module["_SDL_RenderSetLogicalSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderSetLogicalSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderSetScale = Module["_SDL_RenderSetScale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderSetScale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderGetLogicalSize = Module["_SDL_RenderGetLogicalSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderGetLogicalSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderSetIntegerScale = Module["_SDL_RenderSetIntegerScale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderSetIntegerScale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderGetIntegerScale = Module["_SDL_RenderGetIntegerScale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderGetIntegerScale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderGetViewport = Module["_SDL_RenderGetViewport"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderGetViewport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderSetClipRect = Module["_SDL_RenderSetClipRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderSetClipRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderGetClipRect = Module["_SDL_RenderGetClipRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderGetClipRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderIsClipEnabled = Module["_SDL_RenderIsClipEnabled"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderIsClipEnabled"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderGetScale = Module["_SDL_RenderGetScale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderGetScale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetRenderDrawColor = Module["_SDL_SetRenderDrawColor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetRenderDrawColor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRenderDrawColor = Module["_SDL_GetRenderDrawColor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRenderDrawColor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetRenderDrawBlendMode = Module["_SDL_SetRenderDrawBlendMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetRenderDrawBlendMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRenderDrawBlendMode = Module["_SDL_GetRenderDrawBlendMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRenderDrawBlendMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderClear = Module["_SDL_RenderClear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderClear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawPoint = Module["_SDL_RenderDrawPoint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawPoint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawPointsF = Module["_SDL_RenderDrawPointsF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawPointsF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawPointF = Module["_SDL_RenderDrawPointF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawPointF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawPoints = Module["_SDL_RenderDrawPoints"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawPoints"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawLine = Module["_SDL_RenderDrawLine"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawLine"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawLinesF = Module["_SDL_RenderDrawLinesF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawLinesF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawLineF = Module["_SDL_RenderDrawLineF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawLineF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawLines = Module["_SDL_RenderDrawLines"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawLines"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawRect = Module["_SDL_RenderDrawRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawRectF = Module["_SDL_RenderDrawRectF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawRectF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawRects = Module["_SDL_RenderDrawRects"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawRects"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderDrawRectsF = Module["_SDL_RenderDrawRectsF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderDrawRectsF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderFillRect = Module["_SDL_RenderFillRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderFillRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderFillRectsF = Module["_SDL_RenderFillRectsF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderFillRectsF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderFillRectF = Module["_SDL_RenderFillRectF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderFillRectF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderFillRects = Module["_SDL_RenderFillRects"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderFillRects"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderCopy = Module["_SDL_RenderCopy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderCopy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderCopyF = Module["_SDL_RenderCopyF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderCopyF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IntersectRect = Module["_SDL_IntersectRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IntersectRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderCopyEx = Module["_SDL_RenderCopyEx"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderCopyEx"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderCopyExF = Module["_SDL_RenderCopyExF"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderCopyExF"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderReadPixels = Module["_SDL_RenderReadPixels"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderReadPixels"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowPixelFormat = Module["_SDL_GetWindowPixelFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowPixelFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderPresent = Module["_SDL_RenderPresent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderPresent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DestroyRenderer = Module["_SDL_DestroyRenderer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DestroyRenderer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_BindTexture = Module["_SDL_GL_BindTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_BindTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_UnbindTexture = Module["_SDL_GL_UnbindTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_UnbindTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderGetMetalLayer = Module["_SDL_RenderGetMetalLayer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderGetMetalLayer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RenderGetMetalCommandEncoder = Module["_SDL_RenderGetMetalCommandEncoder"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RenderGetMetalCommandEncoder"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ComposeCustomBlendMode = Module["_SDL_ComposeCustomBlendMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ComposeCustomBlendMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetBlendModeSrcColorFactor = Module["_SDL_GetBlendModeSrcColorFactor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetBlendModeSrcColorFactor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetBlendModeDstColorFactor = Module["_SDL_GetBlendModeDstColorFactor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetBlendModeDstColorFactor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetBlendModeColorOperation = Module["_SDL_GetBlendModeColorOperation"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetBlendModeColorOperation"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetBlendModeSrcAlphaFactor = Module["_SDL_GetBlendModeSrcAlphaFactor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetBlendModeSrcAlphaFactor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetBlendModeDstAlphaFactor = Module["_SDL_GetBlendModeDstAlphaFactor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetBlendModeDstAlphaFactor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetBlendModeAlphaOperation = Module["_SDL_GetBlendModeAlphaOperation"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetBlendModeAlphaOperation"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_QueryYUVTexturePixels = Module["_SDL_SW_QueryYUVTexturePixels"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_QueryYUVTexturePixels"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SW_UnlockYUVTexture = Module["_SDL_SW_UnlockYUVTexture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SW_UnlockYUVTexture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PixelFormatEnumToMasks = Module["_SDL_PixelFormatEnumToMasks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PixelFormatEnumToMasks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateRGBSurfaceFrom = Module["_SDL_CreateRGBSurfaceFrom"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateRGBSurfaceFrom"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SoftStretch = Module["_SDL_SoftStretch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SoftStretch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_GetAttribute = Module["_SDL_GL_GetAttribute"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_GetAttribute"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_SetAttribute = Module["_SDL_GL_SetAttribute"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_SetAttribute"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RecreateWindow = Module["_SDL_RecreateWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RecreateWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_CreateContext = Module["_SDL_GL_CreateContext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_CreateContext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_MakeCurrent = Module["_SDL_GL_MakeCurrent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_MakeCurrent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_DeleteContext = Module["_SDL_GL_DeleteContext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_DeleteContext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_GetProcAddress = Module["_SDL_GL_GetProcAddress"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_GetProcAddress"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_SetSwapInterval = Module["_SDL_GL_SetSwapInterval"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_SetSwapInterval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_GetSwapInterval = Module["_SDL_GL_GetSwapInterval"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_GetSwapInterval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_GetCurrentContext = Module["_SDL_GL_GetCurrentContext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_GetCurrentContext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_GetDrawableSize = Module["_SDL_GL_GetDrawableSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_GetDrawableSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_SwapWindow = Module["_SDL_GL_SwapWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_SwapWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetYUVConversionModeForResolution = Module["_SDL_GetYUVConversionModeForResolution"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetYUVConversionModeForResolution"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _GLES2_GetShader = Module["_GLES2_GetShader"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["GLES2_GetShader"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BlendFillRect = Module["_SDL_BlendFillRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BlendFillRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BlendFillRects = Module["_SDL_BlendFillRects"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BlendFillRects"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BlendLine = Module["_SDL_BlendLine"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BlendLine"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IntersectRectAndLine = Module["_SDL_IntersectRectAndLine"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IntersectRectAndLine"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BlendLines = Module["_SDL_BlendLines"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BlendLines"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BlendPoint = Module["_SDL_BlendPoint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BlendPoint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BlendPoints = Module["_SDL_BlendPoints"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BlendPoints"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DrawLine = Module["_SDL_DrawLine"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DrawLine"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DrawLines = Module["_SDL_DrawLines"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DrawLines"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DrawPoint = Module["_SDL_DrawPoint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DrawPoint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRGBA = Module["_SDL_GetRGBA"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRGBA"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DrawPoints = Module["_SDL_DrawPoints"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DrawPoints"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowSurface = Module["_SDL_GetWindowSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetSurfaceColorMod = Module["_SDL_SetSurfaceColorMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetSurfaceColorMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetSurfaceAlphaMod = Module["_SDL_SetSurfaceAlphaMod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetSurfaceAlphaMod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetSurfaceBlendMode = Module["_SDL_SetSurfaceBlendMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetSurfaceBlendMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetSurfaceRLE = Module["_SDL_SetSurfaceRLE"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetSurfaceRLE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetClipRect = Module["_SDL_SetClipRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetClipRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MapRGBA = Module["_SDL_MapRGBA"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MapRGBA"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FillRect = Module["_SDL_FillRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FillRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FillRects = Module["_SDL_FillRects"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FillRects"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UpperBlit = Module["_SDL_UpperBlit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UpperBlit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UpperBlitScaled = Module["_SDL_UpperBlitScaled"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UpperBlitScaled"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDLgfx_rotozoomSurfaceSizeTrig = Module["_SDLgfx_rotozoomSurfaceSizeTrig"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDLgfx_rotozoomSurfaceSizeTrig"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDLgfx_rotateSurface = Module["_SDLgfx_rotateSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDLgfx_rotateSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UpdateWindowSurface = Module["_SDL_UpdateWindowSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UpdateWindowSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetColorKey = Module["_SDL_GetColorKey"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetColorKey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetColorKey = Module["_SDL_SetColorKey"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetColorKey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_NumSensors = Module["_SDL_NumSensors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_NumSensors"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNextSensorInstanceID = Module["_SDL_GetNextSensorInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNextSensorInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetDeviceName = Module["_SDL_SensorGetDeviceName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetDeviceName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetDeviceType = Module["_SDL_SensorGetDeviceType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetDeviceType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetDeviceNonPortableType = Module["_SDL_SensorGetDeviceNonPortableType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetDeviceNonPortableType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetDeviceInstanceID = Module["_SDL_SensorGetDeviceInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetDeviceInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorOpen = Module["_SDL_SensorOpen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorOpen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorFromInstanceID = Module["_SDL_SensorFromInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorFromInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetName = Module["_SDL_SensorGetName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetType = Module["_SDL_SensorGetType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetNonPortableType = Module["_SDL_SensorGetNonPortableType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetNonPortableType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetInstanceID = Module["_SDL_SensorGetInstanceID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetInstanceID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorGetData = Module["_SDL_SensorGetData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorGetData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SensorClose = Module["_SDL_SensorClose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SensorClose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_PrivateSensorUpdate = Module["_SDL_PrivateSensorUpdate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_PrivateSensorUpdate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_setenv = Module["_SDL_setenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_setenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setenv = Module["_setenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_iconv_open = Module["_SDL_iconv_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_iconv_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iconv_open = Module["_iconv_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iconv_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_iconv_close = Module["_SDL_iconv_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_iconv_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iconv_close = Module["_iconv_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iconv_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_iconv = Module["_SDL_iconv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_iconv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iconv = Module["_iconv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iconv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_iconv_string = Module["_SDL_iconv_string"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_iconv_string"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetMemoryFunctions = Module["_SDL_GetMemoryFunctions"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetMemoryFunctions"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetMemoryFunctions = Module["_SDL_SetMemoryFunctions"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetMemoryFunctions"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumAllocations = Module["_SDL_GetNumAllocations"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumAllocations"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _calloc = Module["_calloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["calloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _realloc = Module["_realloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["realloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_qsort = Module["_SDL_qsort"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_qsort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qsort = Module["_qsort"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qsort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_atan = Module["_SDL_atan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_atan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_atanf = Module["_SDL_atanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_atanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_atan2f = Module["_SDL_atan2f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_atan2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_acos = Module["_SDL_acos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_acos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_acosf = Module["_SDL_acosf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_acosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_asin = Module["_SDL_asin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_asin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_asinf = Module["_SDL_asinf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_asinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ceilf = Module["_SDL_ceilf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ceilf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_copysign = Module["_SDL_copysign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_copysign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_copysignf = Module["_SDL_copysignf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_copysignf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_cosf = Module["_SDL_cosf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_cosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cosf = Module["_cosf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_exp = Module["_SDL_exp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_exp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_expf = Module["_SDL_expf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_expf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_fabsf = Module["_SDL_fabsf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_fabsf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_floorf = Module["_SDL_floorf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_floorf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_fmod = Module["_SDL_fmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_fmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_fmodf = Module["_SDL_fmodf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_fmodf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_log = Module["_SDL_log"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_logf = Module["_SDL_logf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_logf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_log10 = Module["_SDL_log10"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_log10"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_log10f = Module["_SDL_log10f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_log10f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_powf = Module["_SDL_powf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_powf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_scalbn = Module["_SDL_scalbn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_scalbn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbn = Module["_scalbn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_scalbnf = Module["_SDL_scalbnf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_scalbnf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinf = Module["_sinf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_sqrtf = Module["_SDL_sqrtf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_sqrtf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_tan = Module["_SDL_tan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_tanf = Module["_SDL_tanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_tanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanf = Module["_tanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_isspace = Module["_SDL_isspace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_isspace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isspace = Module["_isspace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isspace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_toupper = Module["_SDL_toupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_toupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _toupper = Module["_toupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["toupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_tolower = Module["_SDL_tolower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_tolower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tolower = Module["_tolower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tolower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_wcsdup = Module["_SDL_wcsdup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_wcsdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_wcslen = Module["_SDL_wcslen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_wcslen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_wcslcpy = Module["_SDL_wcslcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_wcslcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_wcslcat = Module["_SDL_wcslcat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_wcslcat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_wcscmp = Module["_SDL_wcscmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_wcscmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_utf8strlen = Module["_SDL_utf8strlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_utf8strlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strlcat = Module["_SDL_strlcat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strlcat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strrev = Module["_SDL_strrev"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strrev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strupr = Module["_SDL_strupr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strupr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strlwr = Module["_SDL_strlwr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strlwr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strrchr = Module["_SDL_strrchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strrchr = Module["_strrchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strstr = Module["_strstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_itoa = Module["_SDL_itoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_itoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ltoa = Module["_SDL_ltoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ltoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_uitoa = Module["_SDL_uitoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_uitoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ultoa = Module["_SDL_ultoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ultoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_lltoa = Module["_SDL_lltoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_lltoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ulltoa = Module["_SDL_ulltoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ulltoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atoi = Module["_atoi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atoi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atof = Module["_atof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtol = Module["_strtol"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strtoul = Module["_SDL_strtoul"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strtoul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoul = Module["_strtoul"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strtoll = Module["_SDL_strtoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strtoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoll = Module["_strtoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strtoull = Module["_SDL_strtoull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strtoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoull = Module["_strtoull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_strtod = Module["_SDL_strtod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_strtod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtod = Module["_strtod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcasecmp = Module["_strcasecmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncasecmp = Module["_strncasecmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsscanf = Module["_vsscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_vsscanf = Module["_SDL_vsscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_vsscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsnprintf = Module["_vsnprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsnprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TLSCreate = Module["_SDL_TLSCreate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TLSCreate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TLSGet = Module["_SDL_TLSGet"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TLSGet"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_GetTLSData = Module["_SDL_SYS_GetTLSData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_GetTLSData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TLSSet = Module["_SDL_TLSSet"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TLSSet"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_SetTLSData = Module["_SDL_SYS_SetTLSData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_SetTLSData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Generic_GetTLSData = Module["_SDL_Generic_GetTLSData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Generic_GetTLSData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Generic_SetTLSData = Module["_SDL_Generic_SetTLSData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Generic_SetTLSData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetErrBuf = Module["_SDL_GetErrBuf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetErrBuf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RunThread = Module["_SDL_RunThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RunThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_SetupThread = Module["_SDL_SYS_SetupThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_SetupThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SemPost = Module["_SDL_SemPost"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SemPost"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateThreadWithStackSize = Module["_SDL_CreateThreadWithStackSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateThreadWithStackSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateSemaphore = Module["_SDL_CreateSemaphore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateSemaphore"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_CreateThread = Module["_SDL_SYS_CreateThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_CreateThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SemWait = Module["_SDL_SemWait"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SemWait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DestroySemaphore = Module["_SDL_DestroySemaphore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DestroySemaphore"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateThread = Module["_SDL_CreateThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetThreadID = Module["_SDL_GetThreadID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetThreadID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetThreadName = Module["_SDL_GetThreadName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetThreadName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_SetThreadPriority = Module["_SDL_SYS_SetThreadPriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_SetThreadPriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_WaitThread = Module["_SDL_SYS_WaitThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_WaitThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DetachThread = Module["_SDL_DetachThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DetachThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SYS_DetachThread = Module["_SDL_SYS_DetachThread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SYS_DetachThread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddTimer = Module["_SDL_AddTimer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddTimer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RemoveTimer = Module["_SDL_RemoveTimer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RemoveTimer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RLEBlit = Module["_SDL_RLEBlit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RLEBlit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RLEAlphaBlit = Module["_SDL_RLEAlphaBlit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RLEAlphaBlit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RLESurface = Module["_SDL_RLESurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RLESurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnRLESurface = Module["_SDL_UnRLESurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnRLESurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateBlit = Module["_SDL_CalculateBlit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateBlit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_InvalidateMap = Module["_SDL_InvalidateMap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_InvalidateMap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_BlitCopy = Module["_SDL_BlitCopy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_BlitCopy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateBlit0 = Module["_SDL_CalculateBlit0"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateBlit0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateBlit1 = Module["_SDL_CalculateBlit1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateBlit1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateBlitA = Module["_SDL_CalculateBlitA"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateBlitA"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateBlitN = Module["_SDL_CalculateBlitN"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateBlitN"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Blit_Slow = Module["_SDL_Blit_Slow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Blit_Slow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LoadBMP_RW = Module["_SDL_LoadBMP_RW"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LoadBMP_RW"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SaveBMP_RW = Module["_SDL_SaveBMP_RW"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SaveBMP_RW"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_InitFormat = Module["_SDL_InitFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_InitFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetClipboardText = Module["_SDL_SetClipboardText"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetClipboardText"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetClipboardText = Module["_SDL_GetClipboardText"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetClipboardText"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasClipboardText = Module["_SDL_HasClipboardText"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasClipboardText"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_SetErrorEx = Module["_SDL_EGL_SetErrorEx"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_SetErrorEx"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_GetProcAddress = Module["_SDL_EGL_GetProcAddress"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_GetProcAddress"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_UnloadLibrary = Module["_SDL_EGL_UnloadLibrary"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_UnloadLibrary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnloadObject = Module["_SDL_UnloadObject"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnloadObject"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_LoadLibrary = Module["_SDL_EGL_LoadLibrary"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_LoadLibrary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LoadObject = Module["_SDL_LoadObject"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LoadObject"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LoadFunction = Module["_SDL_LoadFunction"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LoadFunction"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_SetRequiredVisualId = Module["_SDL_EGL_SetRequiredVisualId"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_SetRequiredVisualId"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_ChooseConfig = Module["_SDL_EGL_ChooseConfig"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_ChooseConfig"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_CreateContext = Module["_SDL_EGL_CreateContext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_CreateContext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_MakeCurrent = Module["_SDL_EGL_MakeCurrent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_MakeCurrent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_DeleteContext = Module["_SDL_EGL_DeleteContext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_DeleteContext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_SetSwapInterval = Module["_SDL_EGL_SetSwapInterval"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_SetSwapInterval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_GetSwapInterval = Module["_SDL_EGL_GetSwapInterval"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_GetSwapInterval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_SwapBuffers = Module["_SDL_EGL_SwapBuffers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_SwapBuffers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_CreateSurface = Module["_SDL_EGL_CreateSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_CreateSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EGL_DestroySurface = Module["_SDL_EGL_DestroySurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EGL_DestroySurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetPixelFormatName = Module["_SDL_GetPixelFormatName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetPixelFormatName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MasksToPixelFormatEnum = Module["_SDL_MasksToPixelFormatEnum"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MasksToPixelFormatEnum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreePalette = Module["_SDL_FreePalette"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreePalette"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AllocPalette = Module["_SDL_AllocPalette"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AllocPalette"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetPixelFormatPalette = Module["_SDL_SetPixelFormatPalette"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetPixelFormatPalette"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetPaletteColors = Module["_SDL_SetPaletteColors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetPaletteColors"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DitherColors = Module["_SDL_DitherColors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DitherColors"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FindColor = Module["_SDL_FindColor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FindColor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MapRGB = Module["_SDL_MapRGB"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MapRGB"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetRGB = Module["_SDL_GetRGB"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetRGB"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AllocBlitMap = Module["_SDL_AllocBlitMap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AllocBlitMap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MapSurface = Module["_SDL_MapSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MapSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeBlitMap = Module["_SDL_FreeBlitMap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeBlitMap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateGammaRamp = Module["_SDL_CalculateGammaRamp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateGammaRamp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasIntersection = Module["_SDL_HasIntersection"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasIntersection"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UnionRect = Module["_SDL_UnionRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UnionRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EnclosePoints = Module["_SDL_EnclosePoints"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EnclosePoints"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetSpanEnclosingRect = Module["_SDL_GetSpanEnclosingRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetSpanEnclosingRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateShapedWindow = Module["_SDL_CreateShapedWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateShapedWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DestroyWindow = Module["_SDL_DestroyWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DestroyWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsShapedWindow = Module["_SDL_IsShapedWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsShapedWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateShapeBitmap = Module["_SDL_CalculateShapeBitmap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateShapeBitmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CalculateShapeTree = Module["_SDL_CalculateShapeTree"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CalculateShapeTree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TraverseShapeTree = Module["_SDL_TraverseShapeTree"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TraverseShapeTree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_FreeShapeTree = Module["_SDL_FreeShapeTree"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_FreeShapeTree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowShape = Module["_SDL_SetWindowShape"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowShape"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowPosition = Module["_SDL_SetWindowPosition"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowPosition"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetShapedWindowMode = Module["_SDL_GetShapedWindowMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetShapedWindowMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateRGBSurfaceWithFormat = Module["_SDL_CreateRGBSurfaceWithFormat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateRGBSurfaceWithFormat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetSurfacePalette = Module["_SDL_SetSurfacePalette"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetSurfacePalette"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateRGBSurfaceWithFormatFrom = Module["_SDL_CreateRGBSurfaceWithFormatFrom"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateRGBSurfaceWithFormatFrom"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetClipRect = Module["_SDL_GetClipRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetClipRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LowerBlit = Module["_SDL_LowerBlit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LowerBlit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_LowerBlitScaled = Module["_SDL_LowerBlitScaled"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_LowerBlitScaled"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DuplicateSurface = Module["_SDL_DuplicateSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DuplicateSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ConvertPixels_YUV_to_YUV = Module["_SDL_ConvertPixels_YUV_to_YUV"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ConvertPixels_YUV_to_YUV"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ConvertPixels_YUV_to_RGB = Module["_SDL_ConvertPixels_YUV_to_RGB"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ConvertPixels_YUV_to_RGB"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ConvertPixels_RGB_to_YUV = Module["_SDL_ConvertPixels_RGB_to_YUV"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ConvertPixels_RGB_to_YUV"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumVideoDrivers = Module["_SDL_GetNumVideoDrivers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumVideoDrivers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetVideoDriver = Module["_SDL_GetVideoDriver"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetVideoDriver"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_ResetAttributes = Module["_SDL_GL_ResetAttributes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_ResetAttributes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DisableScreenSaver = Module["_SDL_DisableScreenSaver"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DisableScreenSaver"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HasScreenKeyboardSupport = Module["_SDL_HasScreenKeyboardSupport"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HasScreenKeyboardSupport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_StartTextInput = Module["_SDL_StartTextInput"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_StartTextInput"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetCurrentVideoDriver = Module["_SDL_GetCurrentVideoDriver"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetCurrentVideoDriver"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddBasicVideoDisplay = Module["_SDL_AddBasicVideoDisplay"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddBasicVideoDisplay"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddVideoDisplay = Module["_SDL_AddVideoDisplay"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddVideoDisplay"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumVideoDisplays = Module["_SDL_GetNumVideoDisplays"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumVideoDisplays"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetIndexOfDisplay = Module["_SDL_GetIndexOfDisplay"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetIndexOfDisplay"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayDriverData = Module["_SDL_GetDisplayDriverData"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayDriverData"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayName = Module["_SDL_GetDisplayName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayBounds = Module["_SDL_GetDisplayBounds"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayBounds"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayUsableBounds = Module["_SDL_GetDisplayUsableBounds"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayUsableBounds"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayDPI = Module["_SDL_GetDisplayDPI"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayDPI"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayOrientation = Module["_SDL_GetDisplayOrientation"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayOrientation"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_AddDisplayMode = Module["_SDL_AddDisplayMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_AddDisplayMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetNumDisplayModes = Module["_SDL_GetNumDisplayModes"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetNumDisplayModes"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayMode = Module["_SDL_GetDisplayMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDesktopDisplayMode = Module["_SDL_GetDesktopDisplayMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDesktopDisplayMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetCurrentDisplayMode = Module["_SDL_GetCurrentDisplayMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetCurrentDisplayMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetClosestDisplayMode = Module["_SDL_GetClosestDisplayMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetClosestDisplayMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplay = Module["_SDL_GetDisplay"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplay"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowDisplayIndex = Module["_SDL_GetWindowDisplayIndex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowDisplayIndex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetDisplayForWindow = Module["_SDL_GetDisplayForWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetDisplayForWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowDisplayMode = Module["_SDL_SetWindowDisplayMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowDisplayMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowDisplayMode = Module["_SDL_GetWindowDisplayMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowDisplayMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_LoadLibrary = Module["_SDL_GL_LoadLibrary"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_LoadLibrary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Vulkan_LoadLibrary = Module["_SDL_Vulkan_LoadLibrary"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Vulkan_LoadLibrary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_HideWindow = Module["_SDL_HideWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_HideWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowTitle = Module["_SDL_SetWindowTitle"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowTitle"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowFullscreen = Module["_SDL_SetWindowFullscreen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowFullscreen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowGrab = Module["_SDL_SetWindowGrab"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowGrab"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateWindowFrom = Module["_SDL_CreateWindowFrom"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateWindowFrom"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_UnloadLibrary = Module["_SDL_GL_UnloadLibrary"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_UnloadLibrary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowID = Module["_SDL_GetWindowID"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowID"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowTitle = Module["_SDL_GetWindowTitle"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowTitle"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowIcon = Module["_SDL_SetWindowIcon"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowIcon"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowPosition = Module["_SDL_GetWindowPosition"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowPosition"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowBordered = Module["_SDL_SetWindowBordered"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowBordered"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowResizable = Module["_SDL_SetWindowResizable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowResizable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowSize = Module["_SDL_SetWindowSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowBordersSize = Module["_SDL_GetWindowBordersSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowBordersSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowMinimumSize = Module["_SDL_SetWindowMinimumSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowMinimumSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowMinimumSize = Module["_SDL_GetWindowMinimumSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowMinimumSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowMaximumSize = Module["_SDL_SetWindowMaximumSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowMaximumSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowMaximumSize = Module["_SDL_GetWindowMaximumSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowMaximumSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ShowWindow = Module["_SDL_ShowWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ShowWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_RaiseWindow = Module["_SDL_RaiseWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_RaiseWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_MaximizeWindow = Module["_SDL_MaximizeWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_MaximizeWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_UpdateWindowSurfaceRects = Module["_SDL_UpdateWindowSurfaceRects"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_UpdateWindowSurfaceRects"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowBrightness = Module["_SDL_SetWindowBrightness"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowBrightness"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowGammaRamp = Module["_SDL_SetWindowGammaRamp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowGammaRamp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowGammaRamp = Module["_SDL_GetWindowGammaRamp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowGammaRamp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowBrightness = Module["_SDL_GetWindowBrightness"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowBrightness"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowOpacity = Module["_SDL_SetWindowOpacity"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowOpacity"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowOpacity = Module["_SDL_GetWindowOpacity"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowOpacity"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowModalFor = Module["_SDL_SetWindowModalFor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowModalFor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowInputFocus = Module["_SDL_SetWindowInputFocus"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowInputFocus"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowGrab = Module["_SDL_GetWindowGrab"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowGrab"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetGrabbedWindow = Module["_SDL_GetGrabbedWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetGrabbedWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Vulkan_UnloadLibrary = Module["_SDL_Vulkan_UnloadLibrary"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Vulkan_UnloadLibrary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsScreenSaverEnabled = Module["_SDL_IsScreenSaverEnabled"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsScreenSaverEnabled"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_EnableScreenSaver = Module["_SDL_EnableScreenSaver"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_EnableScreenSaver"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_ExtensionSupported = Module["_SDL_GL_ExtensionSupported"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_ExtensionSupported"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_DeduceMaxSupportedESProfile = Module["_SDL_GL_DeduceMaxSupportedESProfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_DeduceMaxSupportedESProfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GL_GetCurrentWindow = Module["_SDL_GL_GetCurrentWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GL_GetCurrentWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetWindowWMInfo = Module["_SDL_GetWindowWMInfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetWindowWMInfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsTextInputActive = Module["_SDL_IsTextInputActive"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsTextInputActive"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_StopTextInput = Module["_SDL_StopTextInput"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_StopTextInput"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetTextInputRect = Module["_SDL_SetTextInputRect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetTextInputRect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_IsScreenKeyboardShown = Module["_SDL_IsScreenKeyboardShown"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_IsScreenKeyboardShown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ShowSimpleMessageBox = Module["_SDL_ShowSimpleMessageBox"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ShowSimpleMessageBox"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ShouldAllowTopmost = Module["_SDL_ShouldAllowTopmost"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ShouldAllowTopmost"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetWindowHitTest = Module["_SDL_SetWindowHitTest"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetWindowHitTest"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_ComputeDiagonalDPI = Module["_SDL_ComputeDiagonalDPI"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_ComputeDiagonalDPI"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnApplicationWillTerminate = Module["_SDL_OnApplicationWillTerminate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnApplicationWillTerminate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnApplicationDidReceiveMemoryWarning = Module["_SDL_OnApplicationDidReceiveMemoryWarning"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnApplicationDidReceiveMemoryWarning"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnApplicationWillResignActive = Module["_SDL_OnApplicationWillResignActive"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnApplicationWillResignActive"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnApplicationDidEnterBackground = Module["_SDL_OnApplicationDidEnterBackground"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnApplicationDidEnterBackground"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnApplicationWillEnterForeground = Module["_SDL_OnApplicationWillEnterForeground"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnApplicationWillEnterForeground"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_OnApplicationDidBecomeActive = Module["_SDL_OnApplicationDidBecomeActive"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_OnApplicationDidBecomeActive"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Vulkan_GetVkGetInstanceProcAddr = Module["_SDL_Vulkan_GetVkGetInstanceProcAddr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Vulkan_GetVkGetInstanceProcAddr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Vulkan_GetInstanceExtensions = Module["_SDL_Vulkan_GetInstanceExtensions"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Vulkan_GetInstanceExtensions"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Vulkan_CreateSurface = Module["_SDL_Vulkan_CreateSurface"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Vulkan_CreateSurface"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_Vulkan_GetDrawableSize = Module["_SDL_Vulkan_GetDrawableSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_Vulkan_GetDrawableSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SetYUVConversionMode = Module["_SDL_SetYUVConversionMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SetYUVConversionMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetYUVConversionMode = Module["_SDL_GetYUVConversionMode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetYUVConversionMode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuvnv12_rgba_std = Module["_yuvnv12_rgba_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuvnv12_rgba_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuvnv12_rgb24_std = Module["_yuvnv12_rgb24_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuvnv12_rgb24_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuvnv12_abgr_std = Module["_yuvnv12_abgr_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuvnv12_abgr_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuvnv12_rgb565_std = Module["_yuvnv12_rgb565_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuvnv12_rgb565_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuvnv12_bgra_std = Module["_yuvnv12_bgra_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuvnv12_bgra_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuvnv12_argb_std = Module["_yuvnv12_argb_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuvnv12_argb_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv420_rgba_std = Module["_yuv420_rgba_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv420_rgba_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv420_rgb24_std = Module["_yuv420_rgb24_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv420_rgb24_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv420_abgr_std = Module["_yuv420_abgr_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv420_abgr_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv422_rgba_std = Module["_yuv422_rgba_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv422_rgba_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv422_rgb24_std = Module["_yuv422_rgb24_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv422_rgb24_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv422_abgr_std = Module["_yuv422_abgr_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv422_abgr_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv420_rgb565_std = Module["_yuv420_rgb565_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv420_rgb565_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv422_rgb565_std = Module["_yuv422_rgb565_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv422_rgb565_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv422_bgra_std = Module["_yuv422_bgra_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv422_bgra_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv422_argb_std = Module["_yuv422_argb_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv422_argb_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv420_bgra_std = Module["_yuv420_bgra_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv420_bgra_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yuv420_argb_std = Module["_yuv420_argb_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yuv420_argb_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_HandleCanvasResize = Module["_Emscripten_HandleCanvasResize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_HandleCanvasResize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_RegisterEventHandlers = Module["_Emscripten_RegisterEventHandlers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_RegisterEventHandlers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_UnregisterEventHandlers = Module["_Emscripten_UnregisterEventHandlers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_UnregisterEventHandlers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_CreateWindowFramebuffer = Module["_Emscripten_CreateWindowFramebuffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_CreateWindowFramebuffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_UpdateWindowFramebuffer = Module["_Emscripten_UpdateWindowFramebuffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_UpdateWindowFramebuffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_DestroyWindowFramebuffer = Module["_Emscripten_DestroyWindowFramebuffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_DestroyWindowFramebuffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_InitMouse = Module["_Emscripten_InitMouse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_InitMouse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_FiniMouse = Module["_Emscripten_FiniMouse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_FiniMouse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_GLES_LoadLibrary = Module["_Emscripten_GLES_LoadLibrary"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_GLES_LoadLibrary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_GLES_CreateContext = Module["_Emscripten_GLES_CreateContext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_GLES_CreateContext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_GLES_MakeCurrent = Module["_Emscripten_GLES_MakeCurrent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_GLES_MakeCurrent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_GLES_SwapWindow = Module["_Emscripten_GLES_SwapWindow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_GLES_SwapWindow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Emscripten_GLES_GetDrawableSize = Module["_Emscripten_GLES_GetDrawableSize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Emscripten_GLES_GetDrawableSize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rgb24_yuv420_std = Module["_rgb24_yuv420_std"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rgb24_yuv420_std"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetBasePath = Module["_SDL_GetBasePath"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetBasePath"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetPrefPath = Module["_SDL_GetPrefPath"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetPrefPath"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strerror = Module["_strerror"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strerror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetPerformanceCounter = Module["_SDL_GetPerformanceCounter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetPerformanceCounter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_GetPerformanceFrequency = Module["_SDL_GetPerformanceFrequency"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_GetPerformanceFrequency"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_main_stub_symbol = Module["_SDL_main_stub_symbol"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_main_stub_symbol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CreateCond = Module["_SDL_CreateCond"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CreateCond"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_DestroyCond = Module["_SDL_DestroyCond"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_DestroyCond"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CondSignal = Module["_SDL_CondSignal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CondSignal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CondBroadcast = Module["_SDL_CondBroadcast"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CondBroadcast"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CondWaitTimeout = Module["_SDL_CondWaitTimeout"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CondWaitTimeout"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SemWaitTimeout = Module["_SDL_SemWaitTimeout"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SemWaitTimeout"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_CondWait = Module["_SDL_CondWait"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_CondWait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_TryLockMutex = Module["_SDL_TryLockMutex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_TryLockMutex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SemTryWait = Module["_SDL_SemTryWait"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SemTryWait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _SDL_SemValue = Module["_SDL_SemValue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["SDL_SemValue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_block_init = Module["_vorbis_block_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_block_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vorbis_block_alloc = Module["__vorbis_block_alloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vorbis_block_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vorbis_block_ripcord = Module["__vorbis_block_ripcord"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vorbis_block_ripcord"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_block_clear = Module["_vorbis_block_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_block_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_analysis_init = Module["_vorbis_analysis_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_analysis_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_global_look = Module["__vp_global_look"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_global_look"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ve_envelope_init = Module["__ve_envelope_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ve_envelope_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_bitrate_init = Module["_vorbis_bitrate_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_bitrate_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_ilog = Module["_ov_ilog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_ilog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mdct_init = Module["_mdct_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mdct_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drft_init = Module["_drft_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drft_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_init_encode = Module["_vorbis_book_init_encode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_init_encode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_psy_init = Module["__vp_psy_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_psy_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_init_decode = Module["_vorbis_book_init_decode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_init_decode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_staticbook_destroy = Module["_vorbis_staticbook_destroy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_staticbook_destroy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_dsp_clear = Module["_vorbis_dsp_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_dsp_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ve_envelope_clear = Module["__ve_envelope_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ve_envelope_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mdct_clear = Module["_mdct_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mdct_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_psy_clear = Module["__vp_psy_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_psy_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_global_free = Module["__vp_global_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_global_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_bitrate_clear = Module["_vorbis_bitrate_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_bitrate_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drft_clear = Module["_drft_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drft_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_analysis_buffer = Module["_vorbis_analysis_buffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_analysis_buffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_analysis_wrote = Module["_vorbis_analysis_wrote"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_analysis_wrote"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_lpc_from_data = Module["_vorbis_lpc_from_data"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_lpc_from_data"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_lpc_predict = Module["_vorbis_lpc_predict"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_lpc_predict"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_analysis_blockout = Module["_vorbis_analysis_blockout"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_analysis_blockout"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ve_envelope_search = Module["__ve_envelope_search"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ve_envelope_search"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ve_envelope_mark = Module["__ve_envelope_mark"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ve_envelope_mark"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_ampmax_decay = Module["__vp_ampmax_decay"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_ampmax_decay"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ve_envelope_shift = Module["__ve_envelope_shift"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ve_envelope_shift"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_restart = Module["_vorbis_synthesis_restart"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_restart"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_init = Module["_vorbis_synthesis_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_blockin = Module["_vorbis_synthesis_blockin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_blockin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vorbis_window_get = Module["__vorbis_window_get"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vorbis_window_get"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_pcmout = Module["_vorbis_synthesis_pcmout"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_pcmout"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_read = Module["_vorbis_synthesis_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_lapout = Module["_vorbis_synthesis_lapout"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_lapout"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_window = Module["_vorbis_window"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_window"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_bitrate_managed = Module["_vorbis_bitrate_managed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_bitrate_managed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_bitrate_addblock = Module["_vorbis_bitrate_addblock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_bitrate_addblock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_bitrate_flushpacket = Module["_vorbis_bitrate_flushpacket"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_bitrate_flushpacket"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_clear = Module["_ov_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_info_clear = Module["_vorbis_info_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_info_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_comment_clear = Module["_vorbis_comment_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_comment_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_open_callbacks = Module["_ov_open_callbacks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_open_callbacks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_raw_seek = Module["_ov_raw_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_raw_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_open = Module["_ov_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_fopen = Module["_ov_fopen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_fopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_halfrate = Module["_ov_halfrate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_halfrate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_pcm_seek = Module["_ov_pcm_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_pcm_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_halfrate = Module["_vorbis_synthesis_halfrate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_halfrate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_pcm_seek_page = Module["_ov_pcm_seek_page"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_pcm_seek_page"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_packet_blocksize = Module["_vorbis_packet_blocksize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_packet_blocksize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_info_blocksize = Module["_vorbis_info_blocksize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_info_blocksize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_trackonly = Module["_vorbis_synthesis_trackonly"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_trackonly"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_halfrate_p = Module["_vorbis_synthesis_halfrate_p"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_halfrate_p"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_pcm_total = Module["_ov_pcm_total"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_pcm_total"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_halfrate_p = Module["_ov_halfrate_p"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_halfrate_p"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_test_callbacks = Module["_ov_test_callbacks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_test_callbacks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_test = Module["_ov_test"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_test"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_test_open = Module["_ov_test_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_test_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_streams = Module["_ov_streams"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_streams"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_seekable = Module["_ov_seekable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_seekable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_bitrate = Module["_ov_bitrate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_bitrate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_time_total = Module["_ov_time_total"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_time_total"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_bitrate_instant = Module["_ov_bitrate_instant"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_bitrate_instant"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_serialnumber = Module["_ov_serialnumber"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_serialnumber"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_raw_total = Module["_ov_raw_total"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_raw_total"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis = Module["_vorbis_synthesis"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_time_seek = Module["_ov_time_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_time_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_time_seek_page = Module["_ov_time_seek_page"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_time_seek_page"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_raw_tell = Module["_ov_raw_tell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_raw_tell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_pcm_tell = Module["_ov_pcm_tell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_pcm_tell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_time_tell = Module["_ov_time_tell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_time_tell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_info = Module["_ov_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_comment = Module["_ov_comment"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_comment"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_read_filter = Module["_ov_read_filter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_read_filter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_read = Module["_ov_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_read_float = Module["_ov_read_float"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_read_float"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_crosslap = Module["_ov_crosslap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_crosslap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_raw_seek_lap = Module["_ov_raw_seek_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_raw_seek_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_pcm_seek_lap = Module["_ov_pcm_seek_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_pcm_seek_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_pcm_seek_page_lap = Module["_ov_pcm_seek_page_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_pcm_seek_page_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_time_seek_lap = Module["_ov_time_seek_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_time_seek_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ov_time_seek_page_lap = Module["_ov_time_seek_page_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ov_time_seek_page_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_info_init = Module["_vorbis_info_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_info_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_comment_init = Module["_vorbis_comment_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_comment_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_idheader = Module["_vorbis_synthesis_idheader"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_idheader"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_synthesis_headerin = Module["_vorbis_synthesis_headerin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_synthesis_headerin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vorbis_apply_window = Module["__vorbis_apply_window"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vorbis_apply_window"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_lsp_to_curve = Module["_vorbis_lsp_to_curve"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_lsp_to_curve"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_lpc_to_lsp = Module["_vorbis_lpc_to_lsp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_lpc_to_lsp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mdct_forward = Module["_mdct_forward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mdct_forward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_encode_setup_init = Module["_vorbis_encode_setup_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_encode_setup_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_encode_setup_vbr = Module["_vorbis_encode_setup_vbr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_encode_setup_vbr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_encode_init_vbr = Module["_vorbis_encode_init_vbr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_encode_init_vbr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_encode_setup_managed = Module["_vorbis_encode_setup_managed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_encode_setup_managed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_encode_init = Module["_vorbis_encode_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_encode_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_encode_ctl = Module["_vorbis_encode_ctl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_encode_ctl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drft_forward = Module["_drft_forward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drft_forward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_noisemask = Module["__vp_noisemask"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_noisemask"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_tonemask = Module["__vp_tonemask"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_tonemask"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_offset_and_mix = Module["__vp_offset_and_mix"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_offset_and_mix"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floor1_fit = Module["_floor1_fit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floor1_fit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floor1_interpolate_fit = Module["_floor1_interpolate_fit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floor1_interpolate_fit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floor1_encode = Module["_floor1_encode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floor1_encode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vp_couple_quantize_normalize = Module["__vp_couple_quantize_normalize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vp_couple_quantize_normalize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mdct_backward = Module["_mdct_backward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mdct_backward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res0_free_info = Module["_res0_free_info"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res0_free_info"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res0_free_look = Module["_res0_free_look"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res0_free_look"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res0_pack = Module["_res0_pack"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res0_pack"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res0_unpack = Module["_res0_unpack"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res0_unpack"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res0_look = Module["_res0_look"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res0_look"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res0_inverse = Module["_res0_inverse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res0_inverse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_decodevs_add = Module["_vorbis_book_decodevs_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_decodevs_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_decode = Module["_vorbis_book_decode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_decode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res1_forward = Module["_res1_forward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res1_forward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_encode = Module["_vorbis_book_encode"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_encode"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res1_class = Module["_res1_class"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res1_class"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res1_inverse = Module["_res1_inverse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res1_inverse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_decodev_add = Module["_vorbis_book_decodev_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_decodev_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res2_class = Module["_res2_class"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res2_class"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res2_forward = Module["_res2_forward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res2_forward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res2_inverse = Module["_res2_inverse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res2_inverse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_decodevv_add = Module["_vorbis_book_decodevv_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_decodevv_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __float32_pack = Module["__float32_pack"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_float32_pack"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __float32_unpack = Module["__float32_unpack"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_float32_unpack"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __make_words = Module["__make_words"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_make_words"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __book_maptype1_quantvals = Module["__book_maptype1_quantvals"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_book_maptype1_quantvals"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __book_unquantize = Module["__book_unquantize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_book_unquantize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_clear = Module["_vorbis_book_clear"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_clear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_codeword = Module["_vorbis_book_codeword"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_codeword"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_codelen = Module["_vorbis_book_codelen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_codelen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drft_backward = Module["_drft_backward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drft_backward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_comment_add = Module["_vorbis_comment_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_comment_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_comment_add_tag = Module["_vorbis_comment_add_tag"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_comment_add_tag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcat = Module["_strcat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_comment_query = Module["_vorbis_comment_query"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_comment_query"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_comment_query_count = Module["_vorbis_comment_query_count"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_comment_query_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vi_psy_free = Module["__vi_psy_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vi_psy_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_staticbook_unpack = Module["_vorbis_staticbook_unpack"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_staticbook_unpack"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_commentheader_out = Module["_vorbis_commentheader_out"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_commentheader_out"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_analysis_headerout = Module["_vorbis_analysis_headerout"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_analysis_headerout"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_staticbook_pack = Module["_vorbis_staticbook_pack"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_staticbook_pack"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_granule_time = Module["_vorbis_granule_time"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_granule_time"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_version_string = Module["_vorbis_version_string"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_version_string"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __vi_gpsy_free = Module["__vi_gpsy_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_vi_gpsy_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_book_decodev_set = Module["_vorbis_book_decodev_set"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_book_decodev_set"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vorbis_analysis = Module["_vorbis_analysis"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vorbis_analysis"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fesetround = Module["_fesetround"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fesetround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fesetround = Module["___fesetround"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fesetround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fesetexceptflag = Module["_fesetexceptflag"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fesetexceptflag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feclearexcept = Module["_feclearexcept"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feclearexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feraiseexcept = Module["_feraiseexcept"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feraiseexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fegetexceptflag = Module["_fegetexceptflag"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fegetexceptflag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fetestexcept = Module["_fetestexcept"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fetestexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feholdexcept = Module["_feholdexcept"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feholdexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fegetenv = Module["_fegetenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fegetenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feupdateenv = Module["_feupdateenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feupdateenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fesetenv = Module["_fesetenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fesetenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___flt_rounds = Module["___flt_rounds"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__flt_rounds"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fegetround = Module["_fegetround"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fegetround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfgetospeed = Module["_cfgetospeed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfgetospeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfgetispeed = Module["_cfgetispeed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfgetispeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcsendbreak = Module["_tcsendbreak"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcsendbreak"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ioctl = Module["_ioctl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ioctl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcdrain = Module["_tcdrain"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcdrain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___syscall_ret = Module["___syscall_ret"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__syscall_ret"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcflush = Module["_tcflush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcflush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcgetsid = Module["_tcgetsid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcgetsid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfmakeraw = Module["_cfmakeraw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfmakeraw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcflow = Module["_tcflow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcgetattr = Module["_tcgetattr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcgetattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcsetattr = Module["_tcsetattr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcsetattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfsetospeed = Module["_cfsetospeed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfsetospeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfsetispeed = Module["_cfsetispeed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfsetispeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfsetspeed = Module["_cfsetspeed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfsetspeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openat = Module["_openat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openat64 = Module["_openat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creat = Module["_creat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creat64 = Module["_creat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fadvise = Module["_posix_fadvise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fadvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fadvise64 = Module["_posix_fadvise64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fadvise64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fcntl = Module["_fcntl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fcntl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fallocate = Module["_posix_fallocate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fallocate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fallocate64 = Module["_posix_fallocate64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fallocate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open64 = Module["_open64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towupper = Module["_towupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalpha = Module["_iswalpha"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalpha"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towlower = Module["_towlower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towlower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towupper_l = Module["___towupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towlower_l = Module["___towlower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towupper_l = Module["_towupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towlower_l = Module["_towlower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isgraph = Module["_isgraph"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isgraph"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isgraph_l = Module["___isgraph_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isgraph_l = Module["_isgraph_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswctype = Module["_iswctype"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswctype"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalnum = Module["_iswalnum"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalnum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswblank = Module["_iswblank"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswblank"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswcntrl = Module["_iswcntrl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswcntrl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswdigit = Module["_iswdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswgraph = Module["_iswgraph"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswgraph"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswlower = Module["_iswlower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswlower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswprint = Module["_iswprint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswpunct = Module["_iswpunct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswpunct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswspace = Module["_iswspace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswspace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswupper = Module["_iswupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswxdigit = Module["_iswxdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswxdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctype = Module["_wctype"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctype"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswctype_l = Module["___iswctype_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wctype_l = Module["___wctype_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswctype_l = Module["_iswctype_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctype_l = Module["_wctype_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_b_loc = Module["___ctype_b_loc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_b_loc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalpha = Module["_isalpha"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalpha"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isalpha_l = Module["___isalpha_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalpha_l = Module["_isalpha_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswdigit_l = Module["___iswdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswdigit_l = Module["_iswdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_get_mb_cur_max = Module["___ctype_get_mb_cur_max"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_get_mb_cur_max"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_self = Module["_pthread_self"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_self"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswalnum_l = Module["___iswalnum_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalnum_l = Module["_iswalnum_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswalpha_l = Module["___iswalpha_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalpha_l = Module["_iswalpha_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isspace_l = Module["___isspace_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isspace_l = Module["_isspace_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _islower = Module["_islower"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["islower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___islower_l = Module["___islower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__islower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _islower_l = Module["_islower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["islower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iscntrl = Module["_iscntrl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iscntrl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iscntrl_l = Module["___iscntrl_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iscntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iscntrl_l = Module["_iscntrl_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iscntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isxdigit = Module["_isxdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isxdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isdigit = Module["_isdigit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isxdigit_l = Module["___isxdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isxdigit_l = Module["_isxdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_toupper_loc = Module["___ctype_toupper_loc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_toupper_loc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswprint_l = Module["___iswprint_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswprint_l = Module["_iswprint_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isprint = Module["_isprint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isprint_l = Module["___isprint_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isprint_l = Module["_isprint_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswlower_l = Module["___iswlower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswlower_l = Module["_iswlower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isupper = Module["_isupper"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tolower_l = Module["___tolower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tolower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tolower_l = Module["_tolower_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tolower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctrans = Module["_wctrans"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctrans"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towctrans = Module["_towctrans"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towctrans"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wctrans_l = Module["___wctrans_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towctrans_l = Module["___towctrans_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctrans_l = Module["_wctrans_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towctrans_l = Module["_towctrans_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isblank = Module["_isblank"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isblank"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswblank_l = Module["___iswblank_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswblank_l = Module["_iswblank_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcswidth = Module["_wcswidth"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcswidth"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcwidth = Module["_wcwidth"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcwidth"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isupper_l = Module["___isupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isupper_l = Module["_isupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___toupper_l = Module["___toupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__toupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _toupper_l = Module["_toupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["toupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isblank_l = Module["___isblank_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isblank_l = Module["_isblank_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _toascii = Module["_toascii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["toascii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isdigit_l = Module["___isdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isdigit_l = Module["_isdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswxdigit_l = Module["___iswxdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswxdigit_l = Module["_iswxdigit_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswpunct_l = Module["___iswpunct_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswpunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswpunct_l = Module["_iswpunct_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswpunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isascii = Module["_isascii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isascii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswcntrl_l = Module["___iswcntrl_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswcntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswcntrl_l = Module["_iswcntrl_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswcntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswgraph_l = Module["___iswgraph_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswgraph_l = Module["_iswgraph_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswupper_l = Module["___iswupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswupper_l = Module["_iswupper_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalnum = Module["_isalnum"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalnum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isalnum_l = Module["___isalnum_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalnum_l = Module["_isalnum_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcschr = Module["_wcschr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcschr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswspace_l = Module["___iswspace_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswspace_l = Module["_iswspace_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ispunct = Module["_ispunct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ispunct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ispunct_l = Module["___ispunct_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ispunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ispunct_l = Module["_ispunct_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ispunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_tolower_loc = Module["___ctype_tolower_loc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_tolower_loc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _umask = Module["_umask"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["umask"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatat = Module["_fstatat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatat64 = Module["_fstatat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lchmod = Module["_lchmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lchmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchmodat = Module["_fchmodat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchmodat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___futimesat = Module["___futimesat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__futimesat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utimensat = Module["_utimensat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utimensat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _futimesat = Module["_futimesat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["futimesat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _futimens = Module["_futimens"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["futimens"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkfifo = Module["_mkfifo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkfifo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mknod = Module["_mknod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mknod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _chmod = Module["_chmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["chmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lstat = Module["_lstat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lstat64 = Module["_lstat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstat = Module["___fxstat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstat = Module["_fstat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstatat = Module["___fxstatat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstatat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lxstat = Module["___lxstat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lxstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xstat = Module["___xstat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xmknod = Module["___xmknod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xmknod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xmknodat = Module["___xmknodat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xmknodat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mknodat = Module["_mknodat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mknodat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstat64 = Module["___fxstat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstatat64 = Module["___fxstatat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstatat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lxstat64 = Module["___lxstat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lxstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xstat64 = Module["___xstat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkfifoat = Module["_mkfifoat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkfifoat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___procfdname = Module["___procfdname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__procfdname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkdirat = Module["_mkdirat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkdirat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchmod = Module["_fchmod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wasi_fd_is_valid = Module["___wasi_fd_is_valid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasi_fd_is_valid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstat64 = Module["_fstat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stat64 = Module["_stat64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___statfs = Module["___statfs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__statfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fstatfs = Module["___fstatfs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fstatfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statvfs = Module["_statvfs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statvfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatvfs = Module["_fstatvfs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatvfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statfs = Module["_statfs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatfs = Module["_fstatfs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statvfs64 = Module["_statvfs64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statvfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statfs64 = Module["_statfs64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatvfs64 = Module["_fstatvfs64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatvfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatfs64 = Module["_fstatfs64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mktemp = Module["_mktemp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mktemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___randname = Module["___randname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__randname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemp = Module["_mkostemp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mkostemps = Module["___mkostemps"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mkostemps"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemp64 = Module["_mkostemp64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemp64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkdtemp = Module["_mkdtemp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkdtemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemps = Module["_mkostemps"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemps"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemps64 = Module["_mkostemps64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemps64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemp = Module["_mkstemp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemp64 = Module["_mkstemp64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemp64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemps = Module["_mkstemps"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemps"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemps64 = Module["_mkstemps64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemps64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlwr = Module["_strlwr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlwr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _aligned_alloc = Module["_aligned_alloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["aligned_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_memalign = Module["_posix_memalign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_memalign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___synccall = Module["___synccall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__synccall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoull_l = Module["_strtoull_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoull_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoll_l = Module["_strtoll_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoul_l = Module["_strtoul_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoul_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtol_l = Module["_strtol_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtol_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strupr = Module["_strupr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strupr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___libc_get_version = Module["___libc_get_version"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__libc_get_version"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___intscan = Module["___intscan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__intscan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___shgetc = Module["___shgetc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__shgetc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___shlim = Module["___shlim"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__shlim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___multi3 = Module["___multi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__multi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatscan = Module["___floatscan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatscan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___extendsftf2 = Module["___extendsftf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__extendsftf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatsitf = Module["___floatsitf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatsitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___multf3 = Module["___multf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__multf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___addtf3 = Module["___addtf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__addtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___extenddftf2 = Module["___extenddftf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__extenddftf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getf2 = Module["___getf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copysignl = Module["_copysignl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copysignl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___netf2 = Module["___netf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__netf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatunsitf = Module["___floatunsitf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatunsitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___subtf3 = Module["___subtf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__subtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbnl = Module["_scalbnl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbnl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divtf3 = Module["___divtf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmodl = Module["_fmodl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmodl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___trunctfdf2 = Module["___trunctfdf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__trunctfdf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fabs = Module["_fabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___uflow = Module["___uflow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__uflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _select = Module["_select"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["select"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pselect = Module["_pselect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pselect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _poll = Module["_poll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["poll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tre_mem_new_impl = Module["___tre_mem_new_impl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tre_mem_new_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tre_mem_destroy = Module["___tre_mem_destroy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tre_mem_destroy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tre_mem_alloc_impl = Module["___tre_mem_alloc_impl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tre_mem_alloc_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regcomp = Module["_regcomp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regcomp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regfree = Module["_regfree"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regfree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbtowc = Module["_mbtowc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbtowc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _glob = Module["_glob"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["glob"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir_r = Module["_readdir_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fnmatch = Module["_fnmatch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fnmatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _globfree = Module["_globfree"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["globfree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _glob64 = Module["_glob64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["glob64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _globfree64 = Module["_globfree64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["globfree64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regexec = Module["_regexec"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regexec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regerror = Module["_regerror"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regerror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lctrans_cur = Module["___lctrans_cur"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lctrans_cur"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strnlen = Module["_strnlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strnlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getdents = Module["___getdents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getdents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdents = Module["_getdents"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdents64 = Module["_getdents64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdents64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdopendir = Module["_fdopendir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdopendir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _alphasort = Module["_alphasort"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["alphasort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcoll = Module["_strcoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _alphasort64 = Module["_alphasort64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["alphasort64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lock = Module["___lock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unlock = Module["___unlock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir64_r = Module["_readdir64_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir64_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scandir = Module["_scandir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scandir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scandir64 = Module["_scandir64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scandir64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _versionsort = Module["_versionsort"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["versionsort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strverscmp = Module["_strverscmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strverscmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _versionsort64 = Module["_versionsort64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["versionsort64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir64 = Module["_readdir64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dirfd = Module["_dirfd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dirfd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rewinddir = Module["_rewinddir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rewinddir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _telldir = Module["_telldir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["telldir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _seekdir = Module["_seekdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["seekdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _login_tty = Module["_login_tty"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["login_tty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setsid = Module["_setsid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setsid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dup2 = Module["_dup2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dup2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffs = Module["_ffs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdomainname = Module["_getdomainname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdomainname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uname = Module["_uname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setlogmask = Module["_setlogmask"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setlogmask"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _closelog = Module["_closelog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["closelog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openlog = Module["_openlog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openlog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___vsyslog = Module["___vsyslog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__vsyslog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpid = Module["_getpid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _send = Module["_send"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["send"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _connect = Module["_connect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["connect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dprintf = Module["_dprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _syslog = Module["_syslog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["syslog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _socket = Module["_socket"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["socket"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsyslog = Module["_vsyslog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsyslog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getresgid = Module["_getresgid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getresgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffsll = Module["_ffsll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffsll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setpriority = Module["_setpriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setpriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getopt_long = Module["_getopt_long"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getopt_long"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getopt_long_only = Module["_getopt_long_only"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getopt_long_only"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getopt_msg = Module["___getopt_msg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getopt_msg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getopt = Module["_getopt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lockf = Module["_lockf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lockf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lockf64 = Module["_lockf64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lockf64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getresuid = Module["_getresuid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getresuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _basename = Module["_basename"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["basename"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xpg_basename = Module["___xpg_basename"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xpg_basename"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getrlimit = Module["_getrlimit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getrlimit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getrlimit64 = Module["_getrlimit64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getrlimit64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setmntent = Module["_setmntent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endmntent = Module["_endmntent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getmntent_r = Module["_getmntent_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getmntent_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feof = Module["_feof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fscanf = Module["_fscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sscanf = Module["_sscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getmntent = Module["_getmntent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _addmntent = Module["_addmntent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["addmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hasmntopt = Module["_hasmntopt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hasmntopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dirname = Module["_dirname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dirname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpriority = Module["_getpriority"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nftw = Module["_nftw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nftw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nftw64 = Module["_nftw64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nftw64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmtmsg = Module["_fmtmsg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmtmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _forkpty = Module["_forkpty"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["forkpty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openpty = Module["_openpty"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openpty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pipe2 = Module["_pipe2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pipe2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _flockfile = Module["_flockfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["flockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putc = Module["_putc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _funlockfile = Module["_funlockfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["funlockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___posix_getopt = Module["___posix_getopt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__posix_getopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getauxval = Module["_getauxval"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getauxval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_openpt = Module["_posix_openpt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_openpt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _grantpt = Module["_grantpt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["grantpt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unlockpt = Module["_unlockpt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unlockpt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ptsname_r = Module["___ptsname_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ptsname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ptsname_r = Module["_ptsname_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ptsname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gethostid = Module["_gethostid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gethostid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___emscripten_pthread_data_constructor = Module["___emscripten_pthread_data_constructor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__emscripten_pthread_data_constructor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _realpath = Module["_realpath"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["realpath"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readlink = Module["_readlink"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strdup = Module["_strdup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getsubopt = Module["_getsubopt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getsubopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffsl = Module["_ffsl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffsl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___setrlimit = Module["___setrlimit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__setrlimit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setrlimit = Module["_setrlimit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setrlimit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setrlimit64 = Module["_setrlimit64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setrlimit64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_current_dir_name = Module["_get_current_dir_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_current_dir_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getcwd = Module["_getcwd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getcwd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _issetugid = Module["_issetugid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["issetugid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ptsname = Module["_ptsname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ptsname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getrusage = Module["_getrusage"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getrusage"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setdomainname = Module["_setdomainname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setdomainname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _a64l = Module["_a64l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["a64l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _l64a = Module["_l64a"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["l64a"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sendmmsg = Module["_sendmmsg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sendmmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dn_comp = Module["___dn_comp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dn_comp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dn_comp = Module["_dn_comp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dn_comp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getnetbyaddr = Module["_getnetbyaddr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getnetbyaddr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getnetbyname = Module["_getnetbyname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getnetbyname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_send = Module["___res_send"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_send"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_msend = Module["___res_msend"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_msend"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res_send = Module["_res_send"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res_send"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___inet_aton = Module["___inet_aton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__inet_aton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_aton = Module["_inet_aton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_aton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyport_r = Module["_getservbyport_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyport_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___get_resolv_conf = Module["___get_resolv_conf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__get_resolv_conf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fopen_rb_ca = Module["___fopen_rb_ca"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fopen_rb_ca"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fclose_ca = Module["___fclose_ca"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fclose_ca"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getc = Module["_getc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lookup_ipliteral = Module["___lookup_ipliteral"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lookup_ipliteral"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_msend_rc = Module["___res_msend_rc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_msend_rc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _htons = Module["_htons"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["htons"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bind = Module["_bind"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bind"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setsockopt = Module["_setsockopt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setsockopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sendto = Module["_sendto"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sendto"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _recvfrom = Module["_recvfrom"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["recvfrom"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res_init = Module["_res_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sockatmark = Module["_sockatmark"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sockatmark"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hstrerror = Module["_hstrerror"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hstrerror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_pton = Module["_inet_pton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_pton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _accept4 = Module["_accept4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["accept4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _accept = Module["_accept"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["accept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_aton_r = Module["_ether_aton_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_aton_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_aton = Module["_ether_aton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_aton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_ntoa_r = Module["_ether_ntoa_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_ntoa_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sprintf = Module["_sprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_ntoa = Module["_ether_ntoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_ntoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_line = Module["_ether_line"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_line"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_ntohost = Module["_ether_ntohost"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_ntohost"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_hostton = Module["_ether_hostton"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_hostton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___h_errno_location = Module["___h_errno_location"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__h_errno_location"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_nametoindex = Module["_if_nametoindex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_nametoindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dn_skipname = Module["_dn_skipname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dn_skipname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyport = Module["_getservbyport"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_network = Module["_inet_network"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_network"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ntohl = Module["_ntohl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ntohl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_makeaddr = Module["_inet_makeaddr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_makeaddr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_lnaof = Module["_inet_lnaof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_lnaof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_netof = Module["_inet_netof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_netof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_mkquery = Module["___res_mkquery"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_mkquery"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res_mkquery = Module["_res_mkquery"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res_mkquery"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyname = Module["_getservbyname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyname_r = Module["_getservbyname_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _recvmmsg = Module["_recvmmsg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["recvmmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endservent = Module["_endservent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endservent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setservent = Module["_setservent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setservent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservent = Module["_getservent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _herror = Module["_herror"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["herror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sethostent = Module["_sethostent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sethostent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gethostent = Module["_gethostent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gethostent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endhostent = Module["_endhostent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endhostent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setnetent = Module["_setnetent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setnetent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getnetent = Module["_getnetent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getnetent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endnetent = Module["_endnetent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endnetent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_state = Module["___res_state"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_state"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_get16 = Module["_ns_get16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_get16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_get32 = Module["_ns_get32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_get32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_put16 = Module["_ns_put16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_put16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_put32 = Module["_ns_put32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_put32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_skiprr = Module["_ns_skiprr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_skiprr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_initparse = Module["_ns_initparse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_initparse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_name_uncompress = Module["_ns_name_uncompress"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_name_uncompress"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dn_expand = Module["_dn_expand"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dn_expand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_parserr = Module["_ns_parserr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_parserr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ntohs = Module["_ntohs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ntohs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_nameindex = Module["_if_nameindex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_nameindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rtnetlink_enumerate = Module["___rtnetlink_enumerate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rtnetlink_enumerate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freeifaddrs = Module["_freeifaddrs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freeifaddrs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getifaddrs = Module["_getifaddrs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getifaddrs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_ntoa = Module["_inet_ntoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_ntoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_indextoname = Module["_if_indextoname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_indextoname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncpy = Module["_strncpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_freenameindex = Module["_if_freenameindex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_freenameindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dn_expand = Module["___dn_expand"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dn_expand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _recv = Module["_recv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["recv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lookup_serv = Module["___lookup_serv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lookup_serv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dns_parse = Module["___dns_parse"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dns_parse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _htonl = Module["_htonl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["htonl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lookup_name = Module["___lookup_name"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lookup_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getsockname = Module["_getsockname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getsockname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbstowcs = Module["_mbstowcs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbstowcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_ntop = Module["_inet_ntop"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_ntop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strspn = Module["_strspn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_sha256 = Module["___crypt_sha256"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_sha256"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _crypt = Module["_crypt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["crypt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_r = Module["___crypt_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_md5 = Module["___crypt_md5"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_md5"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_blowfish = Module["___crypt_blowfish"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_blowfish"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_sha512 = Module["___crypt_sha512"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_sha512"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_des = Module["___crypt_des"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_des"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _crypt_r = Module["_crypt_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["crypt_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setkey = Module["_setkey"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setkey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___des_setkey = Module["___des_setkey"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__des_setkey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _encrypt = Module["_encrypt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["encrypt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___do_des = Module["___do_des"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__do_des"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcrtomb = Module["_wcrtomb"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcrtomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsrtombs = Module["_wcsrtombs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsrtombs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbsrtowcs = Module["_mbsrtowcs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbsrtowcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbsinit = Module["_mbsinit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbsinit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctomb = Module["_wctomb"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctob = Module["_wctob"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctob"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrtoc16 = Module["_mbrtoc16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrtoc16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrtowc = Module["_mbrtowc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrtowc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mblen = Module["_mblen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mblen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrlen = Module["_mbrlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbsnrtowcs = Module["_mbsnrtowcs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbsnrtowcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrtoc32 = Module["_mbrtoc32"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrtoc32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _btowc = Module["_btowc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["btowc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c16rtomb = Module["_c16rtomb"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c16rtomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsnrtombs = Module["_wcsnrtombs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsnrtombs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstombs = Module["_wcstombs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstombs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c32rtomb = Module["_c32rtomb"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c32rtomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strerror_l = Module["___strerror_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strerror_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lctrans = Module["___lctrans"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lctrans"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strerror_l = Module["_strerror_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strerror_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rmdir = Module["_rmdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rmdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwrite = Module["_pwrite"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwrite64 = Module["_pwrite64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwrite64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setgid = Module["_setgid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___setxid = Module["___setxid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__setxid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _renameat = Module["_renameat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["renameat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _seteuid = Module["_seteuid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["seteuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getegid = Module["_getegid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getegid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setpgrp = Module["_setpgrp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setpgid = Module["_setpgid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setpgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwritev = Module["_pwritev"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwritev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwritev64 = Module["_pwritev64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwritev64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _link = Module["_link"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["link"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchdir = Module["_fchdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unlinkat = Module["_unlinkat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unlinkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readlinkat = Module["_readlinkat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readlinkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getppid = Module["_getppid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getppid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncate = Module["_truncate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncate64 = Module["_truncate64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setresuid = Module["_setresuid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setresuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sleep = Module["_sleep"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sleep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pread = Module["_pread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pread64 = Module["_pread64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pread64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcsetpgrp = Module["_tcsetpgrp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcsetpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ualarm = Module["_ualarm"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ualarm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcgetpgrp = Module["_tcgetpgrp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcgetpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gethostname = Module["_gethostname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gethostname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setegid = Module["_setegid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setegid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setuid = Module["_setuid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpgrp = Module["_getpgrp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dup3 = Module["___dup3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dup3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dup3 = Module["_dup3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dup3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ttyname = Module["_ttyname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ttyname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ttyname_r = Module["_ttyname_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ttyname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _writev = Module["_writev"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["writev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _geteuid = Module["_geteuid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["geteuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _linkat = Module["_linkat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["linkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getlogin_r = Module["_getlogin_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getlogin_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getlogin = Module["_getlogin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getlogin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpgid = Module["_getpgid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readv = Module["_readv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wasi_syscall_ret = Module["___wasi_syscall_ret"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasi_syscall_ret"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_close = Module["_posix_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dup = Module["_dup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdatasync = Module["_fdatasync"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdatasync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getsid = Module["_getsid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getsid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pipe = Module["_pipe"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pipe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isatty = Module["_isatty"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isatty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setregid = Module["_setregid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setregid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _symlinkat = Module["_symlinkat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["symlinkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setreuid = Module["_setreuid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setreuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getuid = Module["_getuid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lchown = Module["_lchown"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lchown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctermid = Module["_ctermid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctermid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getgroups = Module["_getgroups"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getgroups"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nice = Module["_nice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setresgid = Module["_setresgid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setresgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _symlink = Module["_symlink"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["symlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___aio_close = Module["___aio_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__aio_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _preadv = Module["_preadv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["preadv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _preadv64 = Module["_preadv64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["preadv64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lseek64 = Module["_lseek64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lseek64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchown = Module["_fchown"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pause = Module["_pause"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pause"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getgid = Module["_getgid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acct = Module["_acct"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sync = Module["_sync"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _chown = Module["_chown"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["chown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _chdir = Module["_chdir"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["chdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftruncate = Module["_ftruncate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftruncate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftruncate64 = Module["_ftruncate64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftruncate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchownat = Module["_fchownat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchownat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncasecmp = Module["_wcsncasecmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlcpy = Module["_strlcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsstr = Module["_wcsstr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemcmp = Module["_wmemcmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemchr = Module["_wmemchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _index = Module["_index"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcswcs = Module["_wcswcs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcswcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___memrchr = Module["___memrchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__memrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memrchr = Module["_memrchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtok = Module["_strtok"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtok"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcspn = Module["_strcspn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strchrnul = Module["___strchrnul"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strchrnul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strchrnul = Module["_strchrnul"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strchrnul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strpbrk = Module["_strpbrk"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strpbrk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsdup = Module["_wcsdup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcslen = Module["_wcslen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcslen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemcpy = Module["_wmemcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncat = Module["_wcsncat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stpncpy = Module["___stpncpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stpncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stpncpy = Module["_stpncpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stpncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _swab = Module["_swab"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["swab"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memmem = Module["_memmem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memmem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncpy = Module["_wcsncpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemset = Module["_wmemset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstok = Module["_wcstok"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstok"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsspn = Module["_wcsspn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscspn = Module["_wcscspn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcpncpy = Module["_wcpncpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcpncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsnlen = Module["_wcsnlen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsnlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlcat = Module["_strlcat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlcat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bzero = Module["_bzero"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bzero"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcspbrk = Module["_wcspbrk"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcspbrk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strncasecmp_l = Module["___strncasecmp_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strncasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncasecmp_l = Module["_strncasecmp_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strndup = Module["_strndup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strndup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcpcpy = Module["_wcpcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcpcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscpy = Module["_wcscpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscasecmp_l = Module["_wcscasecmp_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscasecmp = Module["_wcscasecmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtok_r = Module["_strtok_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtok_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bcmp = Module["_bcmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strcasecmp_l = Module["___strcasecmp_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strcasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcasecmp_l = Module["_strcasecmp_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memccpy = Module["_memccpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memccpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncasecmp_l = Module["_wcsncasecmp_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncat = Module["_strncat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rindex = Module["_rindex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemmove = Module["_wmemmove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemmove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strsep = Module["_strsep"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strsep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mempcpy = Module["_mempcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mempcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stpcpy = Module["___stpcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stpcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stpcpy = Module["_stpcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stpcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncmp = Module["_wcsncmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strerror_r = Module["_strerror_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strerror_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xpg_strerror_r = Module["___xpg_strerror_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xpg_strerror_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcasestr = Module["_strcasestr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcasestr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscat = Module["_wcscat"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bcopy = Module["_bcopy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bcopy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsrchr = Module["_wcsrchr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscmp = Module["_wcscmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strsignal = Module["_strsignal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strsignal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strdup = Module["___strdup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___shm_mapname = Module["___shm_mapname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__shm_mapname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _shm_open = Module["_shm_open"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["shm_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _shm_unlink = Module["_shm_unlink"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["shm_unlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mremap = Module["___mremap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mremap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___vm_wait = Module["___vm_wait"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__vm_wait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mremap = Module["_mremap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mremap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mincore = Module["_mincore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mincore"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mprotect = Module["___mprotect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mprotect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mprotect = Module["_mprotect"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mprotect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _msync = Module["_msync"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["msync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___munmap = Module["___munmap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__munmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _munmap = Module["_munmap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["munmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _munlock = Module["_munlock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["munlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mlockall = Module["_mlockall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mlockall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_madvise = Module["_posix_madvise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_madvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___madvise = Module["___madvise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__madvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _madvise = Module["_madvise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["madvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _munlockall = Module["_munlockall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["munlockall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mlock = Module["_mlock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mmap = Module["___mmap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mmap = Module["_mmap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mmap64 = Module["_mmap64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mmap64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccosf = Module["_ccosf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccoshf = Module["_ccoshf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccoshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ldexp_cexp = Module["___ldexp_cexp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ldexp_cexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creall = Module["_creall"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clogl = Module["_clogl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clogl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cabsl = Module["_cabsl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cabsl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cargl = Module["_cargl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cargl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logl = Module["_logl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccoshl = Module["_ccoshl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccoshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccosh = Module["_ccosh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacosl = Module["_cacosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinl = Module["_casinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catan = Module["_catan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creal = Module["_creal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacosf = Module["_cacosf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinf = Module["_casinf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csqrtf = Module["_csqrtf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csqrtf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fabsf = Module["_fabsf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fabsf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copysignf = Module["_copysignf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copysignf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hypot = Module["_hypot"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hypot"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccos = Module["_ccos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cexpf = Module["_cexpf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expf = Module["_expf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ldexp_cexpf = Module["___ldexp_cexpf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ldexp_cexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _coshf = Module["_coshf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["coshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinhf = Module["_sinhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacosh = Module["_cacosh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacos = Module["_cacos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanhf = Module["_ctanhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sqrtf = Module["_sqrtf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sqrtf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinhl = Module["_csinhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinh = Module["_csinh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cproj = Module["_cproj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cproj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copysign = Module["_copysign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copysign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _conjf = Module["_conjf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["conjf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanl = Module["_catanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___gttf2 = Module["___gttf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__gttf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___eqtf2 = Module["___eqtf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__eqtf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan2l = Module["_atan2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixtfsi = Module["___fixtfsi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixtfsi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cargf = Module["_cargf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cargf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan2f = Module["_atan2f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinhl = Module["_casinhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanl = Module["_ctanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanhl = Module["_ctanhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanhf = Module["_catanhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanf = Module["_catanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cpowf = Module["_cpowf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cpowf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clogf = Module["_clogf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clogf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mulsc3 = Module["___mulsc3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mulsc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csqrtl = Module["_csqrtl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csqrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csqrt = Module["_csqrt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___muldc3 = Module["___muldc3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__muldc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctan = Module["_ctan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanh = Module["_ctanh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinhf = Module["_casinhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinf = Module["_csinf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinhf = Module["_csinhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cexp = Module["_cexp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cpowl = Module["_cpowl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cpowl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unordtf2 = Module["___unordtf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unordtf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___multc3 = Module["___multc3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__multc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cexpl = Module["_cexpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _carg = Module["_carg"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["carg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cabsf = Module["_cabsf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cabsf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hypotf = Module["_hypotf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hypotf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hypotl = Module["_hypotl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hypotl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _conjl = Module["_conjl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["conjl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logf = Module["_logf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanhl = Module["_catanhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cabs = Module["_cabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cprojf = Module["_cprojf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cprojf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cprojl = Module["_cprojl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cprojl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpclassifyl = Module["___fpclassifyl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpclassifyl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanh = Module["_catanh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccosl = Module["_ccosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casin = Module["_casin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanf = Module["_ctanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinh = Module["_casinh"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cimag = Module["_cimag"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cimag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacoshf = Module["_cacoshf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacoshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _conj = Module["_conj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["conj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cpow = Module["_cpow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cpow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clog = Module["_clog"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csin = Module["_csin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cimagl = Module["_cimagl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cimagl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cimagf = Module["_cimagf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cimagf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinl = Module["_csinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacoshl = Module["_cacoshl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacoshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _crealf = Module["_crealf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["crealf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cbrtf = Module["_cbrtf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cbrtf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrint = Module["_lrint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rint = Module["_rint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbnf = Module["_scalbnf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbnf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log10l = Module["_log10l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___invtrigl_R = Module["___invtrigl_R"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__invtrigl_R"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalb = Module["_scalb"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tgammaf = Module["_tgammaf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tgammaf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j1f = Module["_j1f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j1f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y1f = Module["_y1f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y1f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrintf = Module["_lrintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rintf = Module["_rintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdimf = Module["_fdimf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdimf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nearbyintl = Module["_nearbyintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nearbyintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rintl = Module["_rintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nextafterf = Module["_nextafterf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nextafterf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncl = Module["_truncl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2 = Module["___rem_pio2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2_large = Module["___rem_pio2_large"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2_large"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log1p = Module["_log1p"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log1p"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j1 = Module["_j1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y1 = Module["_y1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ilogbl = Module["_ilogbl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ilogbl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llrintl = Module["_llrintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llrintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixtfdi = Module["___fixtfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixtfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floor = Module["_floor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfl = Module["_erfl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfcl = Module["_erfcl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfcl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdim = Module["_fdim"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _significandf = Module["_significandf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["significandf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ilogbf = Module["_ilogbf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ilogbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinhl = Module["_asinhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lgammal_r = Module["___lgammal_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lgammal_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lgamma_r = Module["___lgamma_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lgamma_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammal = Module["_lgammal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammal_r = Module["_lgammal_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammal_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log1pl = Module["_log1pl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log1pl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logbl = Module["_logbl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logbl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sin = Module["___sin"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cos = Module["___cos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgamma_r = Module["_lgamma_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgamma_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llrintf = Module["_llrintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llrintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lgammaf_r = Module["___lgammaf_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lgammaf_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floorf = Module["_floorf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floorf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sindf = Module["___sindf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sindf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cosdf = Module["___cosdf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cosdf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammaf_r = Module["_lgammaf_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammaf_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nearbyintf = Module["_nearbyintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nearbyintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nextafter = Module["_nextafter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nextafter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cbrt = Module["_cbrt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cbrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nanl = Module["_nanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _significand = Module["_significand"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["significand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ilogb = Module["_ilogb"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ilogb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _modfl = Module["_modfl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["modfl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _coshl = Module["_coshl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["coshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remquof = Module["_remquof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remquof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log1pf = Module["_log1pf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log1pf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpclassify = Module["___fpclassify"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpclassify"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrintl = Module["_lrintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmal = Module["_fmal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _frexpl = Module["_frexpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["frexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lttf2 = Module["___lttf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lttf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nextafterl = Module["_nextafterl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nextafterl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalblnl = Module["_scalblnl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalblnl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j0 = Module["_j0"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y0 = Module["_y0"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acoshf = Module["_acoshf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acoshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___expo2f = Module["___expo2f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__expo2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remainderf = Module["_remainderf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remainderf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dremf = Module["_dremf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dremf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _finitef = Module["_finitef"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["finitef"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logb = Module["_logb"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nanf = Module["_nanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expm1f = Module["_expm1f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expm1f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sinl = Module["___sinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cosl = Module["___cosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llroundl = Module["_llroundl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llroundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _roundl = Module["_roundl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["roundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___expo2 = Module["___expo2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__expo2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llround = Module["_llround"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remainder = Module["_remainder"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remainder"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remquo = Module["_remquo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remquo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drem = Module["_drem"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _frexpf = Module["_frexpf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["frexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanhf = Module["_tanhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbln = Module["_scalbln"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbln"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmaf = Module["_fmaf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmaf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logbf = Module["_logbf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldexpl = Module["_ldexpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remainderl = Module["_remainderl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remainderl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remquol = Module["_remquol"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remquol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erff = Module["_erff"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfcf = Module["_erfcf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfcf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ceilf = Module["_ceilf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ceilf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log2l = Module["_log2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nearbyint = Module["_nearbyint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nearbyint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp10l = Module["_exp10l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp2l = Module["_exp2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _powl = Module["_powl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["powl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pow10l = Module["_pow10l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pow10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___letf2 = Module["___letf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__letf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2f = Module["___rem_pio2f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbf = Module["_scalbf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sincosl = Module["_sincosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sincosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2l = Module["___rem_pio2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fma = Module["_fma"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tgammal = Module["_tgammal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tgammal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lroundf = Module["_lroundf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lroundf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llroundf = Module["_llroundf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llroundf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _jn = Module["_jn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yn = Module["_yn"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___polevll = Module["___polevll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__polevll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___p1evll = Module["___p1evll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__p1evll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nexttoward = Module["_nexttoward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nexttoward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___signbitl = Module["___signbitl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__signbitl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalblnf = Module["_scalblnf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalblnf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinhl = Module["_sinhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sincosf = Module["_sincosf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sincosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acoshl = Module["_acoshl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acoshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tanl = Module["___tanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fabsl = Module["_fabsl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fabsl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanhf = Module["_atanhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdiml = Module["_fdiml"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdiml"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sqrtl = Module["_sqrtl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sqrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nexttowardl = Module["_nexttowardl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nexttowardl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanhl = Module["_atanhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinhf = Module["_asinhf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ceil = Module["_ceil"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ceil"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cbrtl = Module["_cbrtl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cbrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___trunctfsf2 = Module["___trunctfsf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__trunctfsf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _finite = Module["_finite"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["finite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lroundl = Module["_lroundl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lroundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tan = Module["___tan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nexttowardf = Module["_nexttowardf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nexttowardf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expm1l = Module["_expm1l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expm1l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llrint = Module["_llrint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llrint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j0f = Module["_j0f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j0f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y0f = Module["_y0f"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y0f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _jnf = Module["_jnf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jnf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ynf = Module["_ynf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ynf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammaf = Module["_lgammaf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammaf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sincos = Module["_sincos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sincos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncf = Module["_truncf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _modff = Module["_modff"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["modff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tandf = Module["___tandf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tandf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lround = Module["_lround"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _trunc = Module["_trunc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["trunc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldexpf = Module["_ldexpf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanhl = Module["_tanhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _srand48 = Module["_srand48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["srand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _seed48 = Module["_seed48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["seed48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _jrand48 = Module["_jrand48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rand48_step = Module["___rand48_step"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rand48_step"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mrand48 = Module["_mrand48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _srandom = Module["_srandom"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["srandom"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _initstate = Module["_initstate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["initstate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setstate = Module["_setstate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setstate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _random = Module["_random"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["random"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erand48 = Module["_erand48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drand48 = Module["_drand48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lcong48 = Module["_lcong48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lcong48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rand_r = Module["_rand_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rand_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _srand = Module["_srand"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["srand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rand = Module["_rand"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nrand48 = Module["_nrand48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrand48 = Module["_lrand48"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_exit = Module["___stdio_exit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_exit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ofl_lock = Module["___ofl_lock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ofl_lock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lockfile = Module["___lockfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_exit_needed = Module["___stdio_exit_needed"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_exit_needed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tmpnam = Module["_tmpnam"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tmpnam"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fdopen = Module["___fdopen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fdopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_seek = Module["___stdio_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_write = Module["___stdio_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_read = Module["___stdio_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_close = Module["___stdio_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ofl_add = Module["___ofl_add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ofl_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdopen = Module["_fdopen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfscanf = Module["_vfscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unlockfile = Module["___unlockfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unlockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vfscanf = Module["___isoc99_vfscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vfscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___string_read = Module["___string_read"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__string_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vdprintf = Module["_vdprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vdprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ftello_unlocked = Module["___ftello_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ftello_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ftello = Module["___ftello"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ftello"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftello64 = Module["_ftello64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftello64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getchar_unlocked = Module["_getchar_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___do_orphaned_stdio_locks = Module["___do_orphaned_stdio_locks"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__do_orphaned_stdio_locks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unlist_locked_file = Module["___unlist_locked_file"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unlist_locked_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftrylockfile = Module["_ftrylockfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftrylockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open_wmemstream = Module["_open_wmemstream"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open_wmemstream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___overflow = Module["___overflow"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remove = Module["_remove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ferror_unlocked = Module["_ferror_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ferror_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_ferror_unlocked = Module["__IO_ferror_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_ferror_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_fscanf = Module["___isoc99_fscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_fscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetln = Module["_fgetln"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetln"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ungetc = Module["_ungetc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ungetc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getline = Module["_getline"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getline"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___toread = Module["___toread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__toread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vwscanf = Module["_vwscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfwscanf = Module["_vfwscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vwscanf = Module["___isoc99_vwscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fputwc_unlocked = Module["___fputwc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fputwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwide = Module["_fwide"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwide"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fwritex = Module["___fwritex"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fwritex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputwc = Module["_fputwc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputwc_unlocked = Module["_fputwc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwc_unlocked = Module["_putwc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ofl_unlock = Module["___ofl_unlock"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ofl_unlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fflush = Module["_fflush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fflush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadahead = Module["___freadahead"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadahead"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadptr = Module["___freadptr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadptr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadptrinc = Module["___freadptrinc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadptrinc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fseterr = Module["___fseterr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fseterr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fflush_unlocked = Module["_fflush_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fflush_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fsetpos = Module["_fsetpos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fsetpos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fseeko = Module["___fseeko"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fseeko"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fsetpos64 = Module["_fsetpos64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fsetpos64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vprintf = Module["_vprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putw = Module["_putw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ungetwc = Module["_ungetwc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ungetwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setvbuf = Module["_setvbuf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setvbuf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwchar = Module["_getwchar"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetwc = Module["_fgetwc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwchar_unlocked = Module["_getwchar_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open_memstream = Module["_open_memstream"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open_memstream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asprintf = Module["_asprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vasprintf = Module["_vasprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vasprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsprintf = Module["_vsprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsiprintf = Module["_vsiprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsiprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsniprintf = Module["_vsniprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsniprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_vsprintf = Module["___small_vsprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_vsprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_vsnprintf = Module["___small_vsnprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_vsnprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setbuffer = Module["_setbuffer"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setbuffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wprintf = Module["_wprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vwprintf = Module["_vwprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vwprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fseeko_unlocked = Module["___fseeko_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fseeko_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fseeko64 = Module["_fseeko64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fseeko64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fmodeflags = Module["___fmodeflags"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fmodeflags"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fopen64 = Module["_fopen64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fopen64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wscanf = Module["_wscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_wscanf = Module["___isoc99_wscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_wscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scanf = Module["_scanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vscanf = Module["_vscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_scanf = Module["___isoc99_scanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_scanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfiprintf = Module["_vfiprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfiprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_vfprintf = Module["___small_vfprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_vfprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fread_unlocked = Module["_fread_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fread_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putchar = Module["_putchar"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwscanf = Module["_fwscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_fwscanf = Module["___isoc99_fwscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_fwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getw = Module["_getw"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tmpfile = Module["_tmpfile"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tmpfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tmpfile64 = Module["_tmpfile64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tmpfile64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clearerr = Module["_clearerr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clearerr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clearerr_unlocked = Module["_clearerr_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clearerr_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _siprintf = Module["_siprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["siprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_sprintf = Module["___small_sprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_sprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gets = Module["_gets"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gets"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _swprintf = Module["_swprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["swprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vswprintf = Module["_vswprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vswprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwc = Module["_putwc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdelim = Module["_getdelim"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdelim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getdelim = Module["___getdelim"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getdelim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _swscanf = Module["_swscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["swscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vswscanf = Module["_vswscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vswscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_swscanf = Module["___isoc99_swscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_swscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___toread_needs_stdio_exit = Module["___toread_needs_stdio_exit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__toread_needs_stdio_exit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwc = Module["_getwc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vfwscanf = Module["___isoc99_vfwscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vfwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rewind = Module["_rewind"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rewind"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgets_unlocked = Module["_fgets_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgets_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___vfprintf_internal = Module["___vfprintf_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__vfprintf_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getchar = Module["_getchar"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vscanf = Module["___isoc99_vscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_fprintf = Module["___small_fprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_fprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmemopen = Module["_fmemopen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmemopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freopen = Module["_freopen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freopen64 = Module["_freopen64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freopen64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tempnam = Module["_tempnam"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tempnam"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putchar_unlocked = Module["_putchar_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_getc = Module["__IO_getc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_getc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pclose = Module["_pclose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pclose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwprintf = Module["_fwprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfwprintf = Module["_vfwprintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfwprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setbuf = Module["_setbuf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setbuf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vsscanf = Module["___isoc99_vsscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vsscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_sscanf = Module["___isoc99_sscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_sscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_putc = Module["__IO_putc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_putc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __flushlbf = Module["__flushlbf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_flushlbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fsetlocking = Module["___fsetlocking"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fsetlocking"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fwriting = Module["___fwriting"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fwriting"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freading = Module["___freading"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freading"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadable = Module["___freadable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fwritable = Module["___fwritable"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fwritable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___flbf = Module["___flbf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__flbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fbufsize = Module["___fbufsize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fbufsize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpending = Module["___fpending"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpending"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpurge = Module["___fpurge"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpurge"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fpurge = Module["_fpurge"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fpurge"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputws = Module["_fputws"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputws"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputws_unlocked = Module["_fputws_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputws_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdout_write = Module["___stdout_write"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdout_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fgetwc_unlocked = Module["___fgetwc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fgetwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetwc_unlocked = Module["_fgetwc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwc_unlocked = Module["_getwc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setlinebuf = Module["_setlinebuf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setlinebuf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fileno_unlocked = Module["_fileno_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fileno_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getc_unlocked = Module["_getc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetc_unlocked = Module["_fgetc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_getc_unlocked = Module["__IO_getc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_getc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetws = Module["_fgetws"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetws"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetws_unlocked = Module["_fgetws_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetws_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vswscanf = Module["___isoc99_vswscanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vswscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetpos = Module["_fgetpos"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetpos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetpos64 = Module["_fgetpos64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetpos64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rename = Module["_rename"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rename"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feof_unlocked = Module["_feof_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feof_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_feof_unlocked = Module["__IO_feof_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_feof_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putc_unlocked = Module["_putc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputc_unlocked = Module["_fputc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_putc_unlocked = Module["__IO_putc_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_putc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _perror = Module["_perror"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["perror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwchar = Module["_putwchar"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwchar_unlocked = Module["_putwchar_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ecvt = Module["_ecvt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ecvt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstof = Module["_wcstof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstod = Module["_wcstod"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstold = Module["_wcstold"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstold"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoimax = Module["_strtoimax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoimax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoumax = Module["_strtoumax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoumax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtol_internal = Module["___strtol_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtol_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoul_internal = Module["___strtoul_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoul_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoll_internal = Module["___strtoll_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoll_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoull_internal = Module["___strtoull_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoull_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoimax_internal = Module["___strtoimax_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoimax_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoumax_internal = Module["___strtoumax_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoumax_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _labs = Module["_labs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["labs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atoll = Module["_atoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoull = Module["_wcstoull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoll = Module["_wcstoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoul = Module["_wcstoul"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstol = Module["_wcstol"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoimax = Module["_wcstoimax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoimax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoumax = Module["_wcstoumax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoumax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lldiv = Module["_lldiv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lldiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _imaxabs = Module["_imaxabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["imaxabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bsearch = Module["_bsearch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bsearch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _imaxdiv = Module["_imaxdiv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["imaxdiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llabs = Module["_llabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fcvt = Module["_fcvt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fcvt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _div = Module["_div"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["div"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atol = Module["_atol"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gcvt = Module["_gcvt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gcvt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtof = Module["_strtof"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtold = Module["_strtold"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtold"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtof_l = Module["_strtof_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtof_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtod_l = Module["_strtod_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtod_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtold_l = Module["_strtold_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtold_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldiv = Module["_ldiv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freelocale = Module["_freelocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freelocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___loc_is_allocated = Module["___loc_is_allocated"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__loc_is_allocated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freelocale = Module["___freelocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freelocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wcsxfrm_l = Module["___wcsxfrm_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wcsxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsxfrm = Module["_wcsxfrm"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsxfrm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsxfrm_l = Module["_wcsxfrm_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___gettextdomain = Module["___gettextdomain"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__gettextdomain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _textdomain = Module["_textdomain"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["textdomain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gettext = Module["_gettext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dgettext = Module["_dgettext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dgettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ngettext = Module["_ngettext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ngettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dngettext = Module["_dngettext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dngettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catclose = Module["_catclose"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catclose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strcoll_l = Module["___strcoll_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strcoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcoll_l = Module["_strcoll_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _localeconv = Module["_localeconv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["localeconv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bind_textdomain_codeset = Module["_bind_textdomain_codeset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bind_textdomain_codeset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___pleval = Module["___pleval"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__pleval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strfmon_l = Module["_strfmon_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strfmon_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strfmon = Module["_strfmon"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strfmon"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___newlocale = Module["___newlocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__newlocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___get_locale = Module["___get_locale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__get_locale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _newlocale = Module["_newlocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["newlocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___nl_langinfo_l = Module["___nl_langinfo_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__nl_langinfo_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___nl_langinfo = Module["___nl_langinfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__nl_langinfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nl_langinfo = Module["_nl_langinfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nl_langinfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nl_langinfo_l = Module["_nl_langinfo_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nl_langinfo_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bindtextdomain = Module["_bindtextdomain"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bindtextdomain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dcngettext = Module["_dcngettext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dcngettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mo_lookup = Module["___mo_lookup"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mo_lookup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dcgettext = Module["_dcgettext"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dcgettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___uselocale = Module["___uselocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__uselocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uselocale = Module["_uselocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uselocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strxfrm_l = Module["___strxfrm_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strxfrm = Module["_strxfrm"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strxfrm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strxfrm_l = Module["_strxfrm_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catopen = Module["_catopen"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wcscoll_l = Module["___wcscoll_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wcscoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscoll = Module["_wcscoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscoll_l = Module["_wcscoll_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lctrans_impl = Module["___lctrans_impl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lctrans_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___duplocale = Module["___duplocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__duplocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _duplocale = Module["_duplocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["duplocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catgets = Module["_catgets"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catgets"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setlocale = Module["_setlocale"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setlocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clock_settime = Module["_clock_settime"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clock_settime"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpagesize = Module["_getpagesize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpagesize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___emscripten_environ_constructor = Module["___emscripten_environ_constructor"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__emscripten_environ_constructor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___putenv = Module["___putenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__putenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unsetenv = Module["_unsetenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unsetenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putenv = Module["_putenv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sched_yield = Module["_sched_yield"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sched_yield"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __get_tzname = Module["__get_tzname"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_get_tzname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __get_daylight = Module["__get_daylight"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_get_daylight"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __get_timezone = Module["__get_timezone"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_get_timezone"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashlti3 = Module["___ashlti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashlti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lshrti3 = Module["___lshrti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lshrti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashldi3 = Module["___ashldi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashldi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashrdi3 = Module["___ashrdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashrdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashrti3 = Module["___ashrti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashrti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load = Module["___atomic_load"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store = Module["___atomic_store"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange = Module["___atomic_compare_exchange"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange = Module["___atomic_exchange"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_1 = Module["___atomic_load_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_2 = Module["___atomic_load_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_4 = Module["___atomic_load_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_8 = Module["___atomic_load_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_16 = Module["___atomic_load_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_1 = Module["___atomic_store_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_2 = Module["___atomic_store_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_4 = Module["___atomic_store_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_8 = Module["___atomic_store_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_16 = Module["___atomic_store_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_1 = Module["___atomic_exchange_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_2 = Module["___atomic_exchange_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_4 = Module["___atomic_exchange_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_8 = Module["___atomic_exchange_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_16 = Module["___atomic_exchange_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_1 = Module["___atomic_compare_exchange_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_2 = Module["___atomic_compare_exchange_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_4 = Module["___atomic_compare_exchange_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_8 = Module["___atomic_compare_exchange_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_16 = Module["___atomic_compare_exchange_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_1 = Module["___atomic_fetch_add_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_2 = Module["___atomic_fetch_add_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_4 = Module["___atomic_fetch_add_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_8 = Module["___atomic_fetch_add_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_16 = Module["___atomic_fetch_add_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_1 = Module["___atomic_fetch_sub_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_2 = Module["___atomic_fetch_sub_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_4 = Module["___atomic_fetch_sub_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_8 = Module["___atomic_fetch_sub_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_16 = Module["___atomic_fetch_sub_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_1 = Module["___atomic_fetch_and_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_2 = Module["___atomic_fetch_and_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_4 = Module["___atomic_fetch_and_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_8 = Module["___atomic_fetch_and_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_16 = Module["___atomic_fetch_and_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_1 = Module["___atomic_fetch_or_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_2 = Module["___atomic_fetch_or_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_4 = Module["___atomic_fetch_or_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_8 = Module["___atomic_fetch_or_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_16 = Module["___atomic_fetch_or_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_1 = Module["___atomic_fetch_xor_1"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_2 = Module["___atomic_fetch_xor_2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_4 = Module["___atomic_fetch_xor_4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_8 = Module["___atomic_fetch_xor_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_16 = Module["___atomic_fetch_xor_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___clzti2 = Module["___clzti2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__clzti2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divdc3 = Module["___divdc3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divdc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmax = Module["_fmax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divdi3 = Module["___divdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivmoddi4 = Module["___udivmoddi4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivmoddi4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divmoddi4 = Module["___divmoddi4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divmoddi4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divsc3 = Module["___divsc3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divsc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmaxf = Module["_fmaxf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmaxf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divti3 = Module["___divti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivmodti4 = Module["___udivmodti4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivmodti4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixdfdi = Module["___fixdfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixdfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunsdfdi = Module["___fixunsdfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunsdfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixdfti = Module["___fixdfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixdfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixsfti = Module["___fixsfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixsfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixtfti = Module["___fixtfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixtfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunsdfti = Module["___fixunsdfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunsdfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunssfti = Module["___fixunssfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunssfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunstfdi = Module["___fixunstfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunstfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunstfsi = Module["___fixunstfsi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunstfsi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunstfti = Module["___fixunstfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunstfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatdidf = Module["___floatdidf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatdidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatditf = Module["___floatditf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatditf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floattidf = Module["___floattidf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floattidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floattisf = Module["___floattisf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floattisf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floattitf = Module["___floattitf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floattitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatunditf = Module["___floatunditf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatunditf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatuntidf = Module["___floatuntidf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatuntidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatuntisf = Module["___floatuntisf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatuntisf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lshrdi3 = Module["___lshrdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lshrdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___moddi3 = Module["___moddi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__moddi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___modti3 = Module["___modti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__modti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___muldi3 = Module["___muldi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__muldi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___powidf2 = Module["___powidf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__powidf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___powisf2 = Module["___powisf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__powisf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___powitf2 = Module["___powitf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__powitf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivdi3 = Module["___udivdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivti3 = Module["___udivti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___umoddi3 = Module["___umoddi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__umoddi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___umodti3 = Module["___umodti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__umodti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setThrew = Module["_setThrew"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setThrew"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cosl = Module["_cosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinl = Module["_sinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanl = Module["_tanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acosf = Module["_acosf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acosl = Module["_acosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinf = Module["_asinf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinl = Module["_asinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanf = Module["_atanf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanl = Module["_atanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expl = Module["_expl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _powf = Module["_powf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["powf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ceill = Module["_ceill"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ceill"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floorl = Module["_floorl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floorl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __emscripten_get_fetch_queue = Module["__emscripten_get_fetch_queue"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_emscripten_get_fetch_queue"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_proxy_fetch = Module["_emscripten_proxy_fetch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_proxy_fetch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_attr_init = Module["_emscripten_fetch_attr_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_attr_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch = Module["_emscripten_fetch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_free = Module["_emscripten_fetch_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_wait = Module["_emscripten_fetch_wait"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_wait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_close = Module["_emscripten_fetch_close"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_get_response_headers_length = Module["_emscripten_fetch_get_response_headers_length"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_get_response_headers_length"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_get_response_headers = Module["_emscripten_fetch_get_response_headers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_get_response_headers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_unpack_response_headers = Module["_emscripten_fetch_unpack_response_headers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_unpack_response_headers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __Z6strchrUa9enable_ifIXLb1EEEPKci = Module["__Z6strchrUa9enable_ifIXLb1EEEPKci"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_Z6strchrUa9enable_ifIXLb1EEEPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __Z15__libcpp_strchrPKci = Module["__Z15__libcpp_strchrPKci"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_Z15__libcpp_strchrPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_fetch_free_unpacked_response_headers = Module["_emscripten_fetch_free_unpacked_response_headers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_fetch_free_unpacked_response_headers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __webgl1_match_ext_proc_address_without_suffix = Module["__webgl1_match_ext_proc_address_without_suffix"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_webgl1_match_ext_proc_address_without_suffix"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_webgl1_get_proc_address = Module["_emscripten_webgl1_get_proc_address"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_webgl1_get_proc_address"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_webgl_get_proc_address = Module["_emscripten_webgl_get_proc_address"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_webgl_get_proc_address"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sbrk = Module["_sbrk"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sbrk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _realloc_in_place = Module["_realloc_in_place"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["realloc_in_place"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memalign = Module["_memalign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memalign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _valloc = Module["_valloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["valloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pvalloc = Module["_pvalloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pvalloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mallinfo = Module["_mallinfo"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mallinfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mallopt = Module["_mallopt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mallopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_trim = Module["_malloc_trim"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_trim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_stats = Module["_malloc_stats"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_stats"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_usable_size = Module["_malloc_usable_size"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_usable_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_footprint = Module["_malloc_footprint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_footprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_max_footprint = Module["_malloc_max_footprint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_max_footprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_footprint_limit = Module["_malloc_footprint_limit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_footprint_limit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_set_footprint_limit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _independent_calloc = Module["_independent_calloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["independent_calloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _independent_comalloc = Module["_independent_comalloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["independent_comalloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bulk_free = Module["_bulk_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bulk_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_builtin_malloc = Module["_emscripten_builtin_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_builtin_malloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_builtin_free = Module["_emscripten_builtin_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_builtin_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_builtin_memalign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _brk = Module["_brk"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["brk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towrite = Module["___towrite"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towrite_needs_stdio_exit = Module["___towrite_needs_stdio_exit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towrite_needs_stdio_exit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwrite_unlocked = Module["_fwrite_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwrite_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputs_unlocked = Module["_fputs_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputs_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_printf = Module["___small_printf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_printf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_v = Module["dynCall_v"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_v"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_vii = Module["dynCall_vii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viii = Module["dynCall_viii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_ii = Module["dynCall_ii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiii = Module["dynCall_iiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___set_stack_limit = Module["___set_stack_limit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__set_stack_limit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackSave"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackAlloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackRestore"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __growWasmMemory = Module["__growWasmMemory"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__growWasmMemory"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___assign_got_enties = Module["___assign_got_enties"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__assign_got_enties"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_vi = Module["dynCall_vi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iii = Module["dynCall_iii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiii = Module["dynCall_viiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_i = Module["dynCall_i"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_i"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_ddd = Module["dynCall_ddd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ddd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_dd = Module["dynCall_dd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_dd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_jiji"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_ji = Module["dynCall_ji"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ji"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiiiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiiidii = Module["dynCall_iiiiiidii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiiidii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiiiiiiiiii = Module["dynCall_viiiiiiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiiiiiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiji = Module["dynCall_iiji"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiji"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iidiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iij = Module["dynCall_iij"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iij"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iid = Module["dynCall_iid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$mpz_set_from_ll = Module["_orig$mpz_set_from_ll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$mpz_set_from_ll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$mp_obj_new_int_from_ll = Module["_orig$mp_obj_new_int_from_ll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$mp_obj_new_int_from_ll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$mp_obj_new_int_from_ull = Module["_orig$mp_obj_new_int_from_ull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$mp_obj_new_int_from_ull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$mp_binary_get_int = Module["_orig$mp_binary_get_int"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$mp_binary_get_int"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lseek = Module["_orig$lseek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lseek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_RWtell = Module["_orig$SDL_RWtell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_RWtell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_RWseek = Module["_orig$SDL_RWseek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_RWseek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_RecordGesture = Module["_orig$SDL_RecordGesture"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_RecordGesture"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_SaveDollarTemplate = Module["_orig$SDL_SaveDollarTemplate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_SaveDollarTemplate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_LoadDollarTemplates = Module["_orig$SDL_LoadDollarTemplates"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_LoadDollarTemplates"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GestureAddTouch = Module["_orig$SDL_GestureAddTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GestureAddTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GestureDelTouch = Module["_orig$SDL_GestureDelTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GestureDelTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_AddTouch = Module["_orig$SDL_AddTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_AddTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_SendTouchMotion = Module["_orig$SDL_SendTouchMotion"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_SendTouchMotion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_SendTouch = Module["_orig$SDL_SendTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_SendTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GetTouchDevice = Module["_orig$SDL_GetTouchDevice"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GetTouchDevice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GetTouch = Module["_orig$SDL_GetTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GetTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GetTouchDeviceType = Module["_orig$SDL_GetTouchDeviceType"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GetTouchDeviceType"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GetNumTouchFingers = Module["_orig$SDL_GetNumTouchFingers"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GetNumTouchFingers"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GetTouchFinger = Module["_orig$SDL_GetTouchFinger"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GetTouchFinger"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_DelTouch = Module["_orig$SDL_DelTouch"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_DelTouch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$fseeko = Module["_orig$fseeko"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$fseeko"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ftello = Module["_orig$ftello"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ftello"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_RWsize = Module["_orig$SDL_RWsize"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_RWsize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_ReadLE64 = Module["_orig$SDL_ReadLE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_ReadLE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_ReadBE64 = Module["_orig$SDL_ReadBE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_ReadBE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_WriteLE64 = Module["_orig$SDL_WriteLE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_WriteLE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_WriteBE64 = Module["_orig$SDL_WriteBE64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_WriteBE64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_lltoa = Module["_orig$SDL_lltoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_lltoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_ulltoa = Module["_orig$SDL_ulltoa"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_ulltoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_strtoll = Module["_orig$SDL_strtoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_strtoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$strtoll = Module["_orig$strtoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$strtoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_strtoull = Module["_orig$SDL_strtoull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_strtoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$strtoull = Module["_orig$strtoull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$strtoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GetPerformanceCounter = Module["_orig$SDL_GetPerformanceCounter"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GetPerformanceCounter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$SDL_GetPerformanceFrequency = Module["_orig$SDL_GetPerformanceFrequency"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$SDL_GetPerformanceFrequency"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_raw_seek = Module["_orig$ov_raw_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_raw_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_pcm_seek = Module["_orig$ov_pcm_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_pcm_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_pcm_seek_page = Module["_orig$ov_pcm_seek_page"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_pcm_seek_page"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_pcm_total = Module["_orig$ov_pcm_total"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_pcm_total"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_raw_total = Module["_orig$ov_raw_total"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_raw_total"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_raw_tell = Module["_orig$ov_raw_tell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_raw_tell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_pcm_tell = Module["_orig$ov_pcm_tell"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_pcm_tell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_raw_seek_lap = Module["_orig$ov_raw_seek_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_raw_seek_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_pcm_seek_lap = Module["_orig$ov_pcm_seek_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_pcm_seek_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ov_pcm_seek_page_lap = Module["_orig$ov_pcm_seek_page_lap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ov_pcm_seek_page_lap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$vorbis_granule_time = Module["_orig$vorbis_granule_time"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$vorbis_granule_time"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$posix_fadvise = Module["_orig$posix_fadvise"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$posix_fadvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$posix_fadvise64 = Module["_orig$posix_fadvise64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$posix_fadvise64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$posix_fallocate = Module["_orig$posix_fallocate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$posix_fallocate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$posix_fallocate64 = Module["_orig$posix_fallocate64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$posix_fallocate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$strtoull_l = Module["_orig$strtoull_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$strtoull_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$strtoll_l = Module["_orig$strtoll_l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$strtoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__intscan = Module["_orig$__intscan"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__intscan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__shlim = Module["_orig$__shlim"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__shlim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__multi3 = Module["_orig$__multi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__multi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__multf3 = Module["_orig$__multf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__multf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__addtf3 = Module["_orig$__addtf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__addtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__getf2 = Module["_orig$__getf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__getf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$copysignl = Module["_orig$copysignl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$copysignl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__netf2 = Module["_orig$__netf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__netf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__subtf3 = Module["_orig$__subtf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__subtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$scalbnl = Module["_orig$scalbnl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$scalbnl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__divtf3 = Module["_orig$__divtf3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__divtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$fmodl = Module["_orig$fmodl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$fmodl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__trunctfdf2 = Module["_orig$__trunctfdf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__trunctfdf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ffsll = Module["_orig$ffsll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ffsll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lockf = Module["_orig$lockf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lockf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lockf64 = Module["_orig$lockf64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lockf64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$pwrite = Module["_orig$pwrite"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$pwrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$pwrite64 = Module["_orig$pwrite64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$pwrite64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$pwritev = Module["_orig$pwritev"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$pwritev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$pwritev64 = Module["_orig$pwritev64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$pwritev64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$truncate = Module["_orig$truncate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$truncate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$truncate64 = Module["_orig$truncate64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$truncate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$pread = Module["_orig$pread"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$pread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$pread64 = Module["_orig$pread64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$pread64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$preadv = Module["_orig$preadv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$preadv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$preadv64 = Module["_orig$preadv64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$preadv64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lseek64 = Module["_orig$lseek64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lseek64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ftruncate = Module["_orig$ftruncate"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ftruncate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ftruncate64 = Module["_orig$ftruncate64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ftruncate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__mmap = Module["_orig$__mmap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__mmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$mmap = Module["_orig$mmap"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$mmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$mmap64 = Module["_orig$mmap64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$mmap64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$logl = Module["_orig$logl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$logl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__gttf2 = Module["_orig$__gttf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__gttf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__eqtf2 = Module["_orig$__eqtf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__eqtf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$atan2l = Module["_orig$atan2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$atan2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixtfsi = Module["_orig$__fixtfsi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixtfsi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__unordtf2 = Module["_orig$__unordtf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__unordtf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__multc3 = Module["_orig$__multc3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__multc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$hypotl = Module["_orig$hypotl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$hypotl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fpclassifyl = Module["_orig$__fpclassifyl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fpclassifyl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$log10l = Module["_orig$log10l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$log10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__invtrigl_R = Module["_orig$__invtrigl_R"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__invtrigl_R"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$nearbyintl = Module["_orig$nearbyintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$nearbyintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$rintl = Module["_orig$rintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$rintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$truncl = Module["_orig$truncl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$truncl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ilogbl = Module["_orig$ilogbl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ilogbl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$llrintl = Module["_orig$llrintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$llrintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixtfdi = Module["_orig$__fixtfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixtfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$erfl = Module["_orig$erfl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$erfl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$erfcl = Module["_orig$erfcl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$erfcl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$asinhl = Module["_orig$asinhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$asinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__lgammal_r = Module["_orig$__lgammal_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__lgammal_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lgammal = Module["_orig$lgammal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lgammal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lgammal_r = Module["_orig$lgammal_r"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lgammal_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$log1pl = Module["_orig$log1pl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$log1pl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$logbl = Module["_orig$logbl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$logbl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$llrintf = Module["_orig$llrintf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$llrintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$modfl = Module["_orig$modfl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$modfl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$coshl = Module["_orig$coshl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$coshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lrintl = Module["_orig$lrintl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lrintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$fmal = Module["_orig$fmal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$fmal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$frexpl = Module["_orig$frexpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$frexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__lttf2 = Module["_orig$__lttf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__lttf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$nextafterl = Module["_orig$nextafterl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$nextafterl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$scalblnl = Module["_orig$scalblnl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$scalblnl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__sinl = Module["_orig$__sinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__sinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__cosl = Module["_orig$__cosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__cosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$llroundl = Module["_orig$llroundl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$llroundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$roundl = Module["_orig$roundl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$roundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$llround = Module["_orig$llround"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$llround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ldexpl = Module["_orig$ldexpl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ldexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$remainderl = Module["_orig$remainderl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$remainderl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$remquol = Module["_orig$remquol"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$remquol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$log2l = Module["_orig$log2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$log2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$exp10l = Module["_orig$exp10l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$exp10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$exp2l = Module["_orig$exp2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$exp2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$powl = Module["_orig$powl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$powl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$pow10l = Module["_orig$pow10l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$pow10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__letf2 = Module["_orig$__letf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__letf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$sincosl = Module["_orig$sincosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$sincosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__rem_pio2l = Module["_orig$__rem_pio2l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__rem_pio2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$tgammal = Module["_orig$tgammal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$tgammal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$llroundf = Module["_orig$llroundf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$llroundf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__polevll = Module["_orig$__polevll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__polevll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__p1evll = Module["_orig$__p1evll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__p1evll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$nexttoward = Module["_orig$nexttoward"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$nexttoward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__signbitl = Module["_orig$__signbitl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__signbitl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$sinhl = Module["_orig$sinhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$sinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$acoshl = Module["_orig$acoshl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$acoshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__tanl = Module["_orig$__tanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__tanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$fabsl = Module["_orig$fabsl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$fabsl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$fdiml = Module["_orig$fdiml"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$fdiml"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$sqrtl = Module["_orig$sqrtl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$sqrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$nexttowardl = Module["_orig$nexttowardl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$nexttowardl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$atanhl = Module["_orig$atanhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$atanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$cbrtl = Module["_orig$cbrtl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$cbrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__trunctfsf2 = Module["_orig$__trunctfsf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__trunctfsf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lroundl = Module["_orig$lroundl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lroundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$nexttowardf = Module["_orig$nexttowardf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$nexttowardf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$expm1l = Module["_orig$expm1l"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$expm1l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$llrint = Module["_orig$llrint"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$llrint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$tanhl = Module["_orig$tanhl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$tanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__rand48_step = Module["_orig$__rand48_step"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__rand48_step"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__stdio_seek = Module["_orig$__stdio_seek"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__stdio_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__ftello_unlocked = Module["_orig$__ftello_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__ftello_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__ftello = Module["_orig$__ftello"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__ftello"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ftello64 = Module["_orig$ftello64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ftello64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fseeko = Module["_orig$__fseeko"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fseeko"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fseeko_unlocked = Module["_orig$__fseeko_unlocked"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fseeko_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$fseeko64 = Module["_orig$fseeko64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$fseeko64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$strtoimax = Module["_orig$strtoimax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$strtoimax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$strtoumax = Module["_orig$strtoumax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$strtoumax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__strtoll_internal = Module["_orig$__strtoll_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__strtoll_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__strtoull_internal = Module["_orig$__strtoull_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__strtoull_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__strtoimax_internal = Module["_orig$__strtoimax_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__strtoimax_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__strtoumax_internal = Module["_orig$__strtoumax_internal"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__strtoumax_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$atoll = Module["_orig$atoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$atoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$wcstoull = Module["_orig$wcstoull"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$wcstoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$wcstoll = Module["_orig$wcstoll"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$wcstoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$wcstoimax = Module["_orig$wcstoimax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$wcstoimax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$wcstoumax = Module["_orig$wcstoumax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$wcstoumax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$lldiv = Module["_orig$lldiv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$lldiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$imaxabs = Module["_orig$imaxabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$imaxabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$imaxdiv = Module["_orig$imaxdiv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$imaxdiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$llabs = Module["_orig$llabs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$llabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__ashlti3 = Module["_orig$__ashlti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__ashlti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__lshrti3 = Module["_orig$__lshrti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__lshrti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__ashldi3 = Module["_orig$__ashldi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__ashldi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__ashrdi3 = Module["_orig$__ashrdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__ashrdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__ashrti3 = Module["_orig$__ashrti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__ashrti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_load_8 = Module["_orig$__atomic_load_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_load_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_store_8 = Module["_orig$__atomic_store_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_store_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_store_16 = Module["_orig$__atomic_store_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_store_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_exchange_8 = Module["_orig$__atomic_exchange_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_exchange_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_exchange_16 = Module["_orig$__atomic_exchange_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_exchange_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_compare_exchange_8 = Module["_orig$__atomic_compare_exchange_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_compare_exchange_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_compare_exchange_16 = Module["_orig$__atomic_compare_exchange_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_compare_exchange_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_add_8 = Module["_orig$__atomic_fetch_add_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_add_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_add_16 = Module["_orig$__atomic_fetch_add_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_add_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_sub_8 = Module["_orig$__atomic_fetch_sub_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_sub_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_sub_16 = Module["_orig$__atomic_fetch_sub_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_sub_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_and_8 = Module["_orig$__atomic_fetch_and_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_and_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_and_16 = Module["_orig$__atomic_fetch_and_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_and_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_or_8 = Module["_orig$__atomic_fetch_or_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_or_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_or_16 = Module["_orig$__atomic_fetch_or_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_or_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_xor_8 = Module["_orig$__atomic_fetch_xor_8"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_xor_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__atomic_fetch_xor_16 = Module["_orig$__atomic_fetch_xor_16"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__atomic_fetch_xor_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__clzti2 = Module["_orig$__clzti2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__clzti2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__divdi3 = Module["_orig$__divdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__divdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__udivmoddi4 = Module["_orig$__udivmoddi4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__udivmoddi4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__divmoddi4 = Module["_orig$__divmoddi4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__divmoddi4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__divti3 = Module["_orig$__divti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__divti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__udivmodti4 = Module["_orig$__udivmodti4"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__udivmodti4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixdfdi = Module["_orig$__fixdfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixdfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixunsdfdi = Module["_orig$__fixunsdfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixunsdfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixtfti = Module["_orig$__fixtfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixtfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixunstfdi = Module["_orig$__fixunstfdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixunstfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixunstfsi = Module["_orig$__fixunstfsi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixunstfsi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__fixunstfti = Module["_orig$__fixunstfti"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__fixunstfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floatdidf = Module["_orig$__floatdidf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floatdidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floatditf = Module["_orig$__floatditf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floatditf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floattidf = Module["_orig$__floattidf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floattidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floattisf = Module["_orig$__floattisf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floattisf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floattitf = Module["_orig$__floattitf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floattitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floatunditf = Module["_orig$__floatunditf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floatunditf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floatuntidf = Module["_orig$__floatuntidf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floatuntidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__floatuntisf = Module["_orig$__floatuntisf"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__floatuntisf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__lshrdi3 = Module["_orig$__lshrdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__lshrdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__moddi3 = Module["_orig$__moddi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__moddi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__modti3 = Module["_orig$__modti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__modti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__muldi3 = Module["_orig$__muldi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__muldi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__powitf2 = Module["_orig$__powitf2"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__powitf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__udivdi3 = Module["_orig$__udivdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__udivdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__udivti3 = Module["_orig$__udivti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__udivti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__umoddi3 = Module["_orig$__umoddi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__umoddi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$__umodti3 = Module["_orig$__umodti3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$__umodti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$cosl = Module["_orig$cosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$cosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$sinl = Module["_orig$sinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$sinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$tanl = Module["_orig$tanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$tanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$acosl = Module["_orig$acosl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$acosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$asinl = Module["_orig$asinl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$asinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$atanl = Module["_orig$atanl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$atanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$expl = Module["_orig$expl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$expl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$ceill = Module["_orig$ceill"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$ceill"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _orig$floorl = Module["_orig$floorl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["orig$floorl"].apply(null, arguments)
};


var NAMED_GLOBALS = {
  "stderr": 991592,
  "stdout": 990408,
  "i_main": 4588,
  "i_state": 4624,
  "mp_state_ctx": 124420,
  "ts": 70288,
  "stdin": 992320,
  "out_rbb": 4452,
  "mp_type_SystemExit": 140500,
  "mp_stderr_print2": 120592,
  "mp_type_TypeError": 141760,
  "VMFLAGS_IF": 117288,
  "mp_type_NameError": 141460,
  "mp_type_fun_bc": 142476,
  "mp_type_RuntimeError": 141520,
  "mp_type_GeneratorExit": 140620,
  "mp_type_StopIteration": 140380,
  "mp_type_NotImplementedError": 141580,
  "mp_const_GeneratorExit_obj": 142560,
  "out_rbb_data_space": 352,
  "mp_plat_print": 133356,
  "mp_type_tuple": 149788,
  "mp_type_list": 143576,
  "mp_type_dict": 139440,
  "mp_type_str": 149304,
  "mp_type_bytes": 146652,
  "mp_type_bytearray": 138464,
  "mp_type_array": 138524,
  "mp_type_float": 142000,
  "mp_type_module": 144188,
  "mp_qstr_frozen_const_pool": 200292,
  "mp_qstr_const_pool": 131000,
  "mp_type_int": 143408,
  "attr": 133440,
  "tok_kw": 133904,
  "tok_enc_kind": 133648,
  "tok_enc": 133636,
  "rule_arg_combined_table": 134256,
  "rule_arg_offset_table": 135152,
  "mp_type_SyntaxError": 141640,
  "mp_constants_map": 135344,
  "rule_act_table": 134080,
  "mp_type_IndentationError": 141700,
  "mp_constants_table": 135328,
  "mp_module_uerrno": 158192,
  "mp_module_uctypes": 159392,
  "scope_simple_name_table": 135514,
  "compile_function": 136240,
  "mp_emit_bc_method_table_load_id_ops": 136508,
  "mp_emit_bc_method_table_store_id_ops": 136516,
  "mp_emit_bc_method_table_delete_id_ops": 136524,
  "mp_const_ellipsis_obj": 146504,
  "mp_type_ValueError": 141820,
  "mp_type_gen_wrap": 142636,
  "mp_type_complex": 139292,
  "mp_const_empty_tuple_obj": 149780,
  "mp_type_KeyboardInterrupt": 140560,
  "mp_module_builtins_globals": 153840,
  "mp_builtin___build_class___obj": 151828,
  "mp_unary_op_method_name": 150086,
  "mp_type_ZeroDivisionError": 140920,
  "mp_binary_op_method_name": 150096,
  "mp_type_type": 150308,
  "mp_type_AttributeError": 141040,
  "mp_type_staticmethod": 150456,
  "mp_type_classmethod": 150756,
  "mp_builtin_next_obj": 152336,
  "mp_type_gen_instance": 142576,
  "mp_type_ImportError": 141160,
  "mp_type_MemoryError": 141400,
  "mp_type_OSError": 140304,
  "mp_module___main__": 136848,
  "hash_allocation_sizes": 137808,
  "mp_const_empty_map": 137796,
  "mp_sys_stdout_print": 157400,
  "mp_type_IndexError": 141280,
  "mp_type_NoneType": 145072,
  "mp_type_bool": 138948,
  "mp_identity_obj": 138380,
  "mp_type_fun_builtin_1": 142176,
  "mp_type_memoryview": 138584,
  "mp_type_slice": 146524,
  "array_it_type": 138792,
  "array_locals_dict": 138776,
  "array_append_obj": 138660,
  "mp_type_fun_builtin_2": 142236,
  "array_extend_obj": 138688,
  "array_locals_dict_table": 138752,
  "bytes_decode_obj": 148572,
  "mp_type_attrtuple": 138864,
  "mp_type_bound_meth": 139032,
  "mp_type_cell": 139112,
  "closure_type": 139216,
  "mp_type_ordereddict": 139520,
  "mp_type_KeyError": 141340,
  "dict_view_it_type": 139928,
  "mp_dict_view_names": 139916,
  "dict_view_type": 139996,
  "dict_locals_dict": 140208,
  "dict_clear_obj": 139592,
  "dict_copy_obj": 139616,
  "dict_fromkeys_fun_obj": 139644,
  "mp_type_fun_builtin_var": 142356,
  "dict_fromkeys_obj": 139660,
  "dict_get_obj": 139680,
  "dict_pop_obj": 139708,
  "dict_setdefault_obj": 139740,
  "dict_popitem_obj": 139800,
  "dict_update_obj": 139864,
  "dict_items_obj": 140056,
  "dict_keys_obj": 140068,
  "dict_values_obj": 140080,
  "dict_locals_dict_table": 140096,
  "mp_op_getitem_obj": 150888,
  "mp_op_setitem_obj": 150912,
  "mp_op_delitem_obj": 150936,
  "mp_type_enumerate": 140240,
  "mp_type_BaseException": 140440,
  "mp_type_Exception": 140680,
  "mp_type_StopAsyncIteration": 140740,
  "mp_type_ArithmeticError": 140800,
  "mp_type_OverflowError": 140860,
  "mp_type_AssertionError": 140980,
  "mp_type_EOFError": 141100,
  "mp_type_LookupError": 141220,
  "mp_type_UnicodeError": 141880,
  "mp_type_filter": 141940,
  "mp_const_float_e_obj": 142064,
  "mp_const_float_pi_obj": 142080,
  "mp_type_fun_native": 142416,
  "mp_type_native_gen_wrap": 142696,
  "mp_type_fun_builtin_3": 142296,
  "mp_type_fun_builtin_0": 142116,
  "gen_instance_locals_dict": 143152,
  "gen_instance_send_obj": 142920,
  "gen_instance_throw_obj": 142952,
  "gen_instance_close_obj": 143020,
  "gen_instance_pend_throw_obj": 143100,
  "gen_instance_locals_dict_table": 143120,
  "it_type": 143168,
  "log_base2_floor": 143280,
  "int_from_bytes_fun_obj": 143312,
  "int_from_bytes_obj": 143328,
  "int_to_bytes_obj": 143352,
  "int_locals_dict_table": 143376,
  "int_locals_dict": 143392,
  "maxsize_dig": 143468,
  "mp_sys_maxsize_obj": 143472,
  "mp_type_polymorph_iter": 144764,
  "list_locals_dict": 144072,
  "list_append_obj": 143700,
  "list_extend_obj": 143724,
  "list_clear_obj": 143748,
  "list_copy_obj": 143772,
  "list_count_obj": 143796,
  "list_index_obj": 143820,
  "list_insert_obj": 143848,
  "list_pop_obj": 143872,
  "list_remove_obj": 143908,
  "list_reverse_obj": 143936,
  "list_sort_obj": 143968,
  "list_locals_dict_table": 143984,
  "mp_type_map": 144088,
  "mp_builtin_module_map": 144472,
  "mp_builtin_module_table": 144256,
  "mp_module_builtins": 152592,
  "mp_module_micropython": 157168,
  "mp_module_io": 154536,
  "mp_module_collections": 153896,
  "mp_module_ustruct": 157392,
  "mp_module_math": 156032,
  "mp_module_cmath": 156416,
  "mp_module_sys": 157776,
  "mp_module_gc": 154176,
  "mp_module_uzlib": 160456,
  "mp_module_ujson": 159624,
  "mp_module_ure": 160216,
  "mp_module_uheapq": 160928,
  "mp_module_utimeq": 161216,
  "mp_module_uhashlib": 161424,
  "mp_module_ubinascii": 161960,
  "mp_module_urandom": 162304,
  "mp_module_time": 308296,
  "mp_module_ffi": 309192,
  "mp_module_os": 307944,
  "mp_module_embed": 314096,
  "example_user_cmodule": 314288,
  "mp_module_uarray": 151792,
  "object___init___obj": 144500,
  "object___new___fun_obj": 144552,
  "object___new___obj": 144564,
  "object___setattr___obj": 144592,
  "object___delattr___obj": 144644,
  "object_locals_dict_table": 144656,
  "object_locals_dict": 144688,
  "mp_type_object": 144704,
  "property_getter_obj": 144880,
  "property_setter_obj": 144908,
  "property_deleter_obj": 144940,
  "property_locals_dict_table": 144960,
  "property_locals_dict": 144984,
  "mp_type_property": 145000,
  "mp_namedtuple_obj": 145308,
  "range_it_type": 145320,
  "mp_type_range": 145412,
  "mp_type_reversed": 145472,
  "mp_type_set": 145532,
  "mp_type_frozenset": 145592,
  "set_locals_dict": 146336,
  "frozenset_locals_dict": 146424,
  "set_add_obj": 145696,
  "set_clear_obj": 145720,
  "set_copy_obj": 145744,
  "set_discard_obj": 145768,
  "set_diff_obj": 145792,
  "set_diff_update_obj": 145824,
  "set_intersect_obj": 145856,
  "set_intersect_update_obj": 145892,
  "set_isdisjoint_obj": 145920,
  "set_issubset_obj": 145948,
  "set_issuperset_obj": 145976,
  "set_pop_obj": 146020,
  "set_remove_obj": 146044,
  "set_symmetric_difference_update_obj": 146088,
  "set_symmetric_difference_obj": 146128,
  "set_update_obj": 146152,
  "set_union_obj": 146180,
  "set_locals_dict_table": 146192,
  "mp_op_contains_obj": 150960,
  "frozenset_locals_dict_table": 146352,
  "mp_type_singleton": 146444,
  "mp_const_empty_bytes_obj": 146712,
  "str8_locals_dict": 148840,
  "str_join_obj": 146908,
  "str_split_obj": 146956,
  "str_splitlines_obj": 146996,
  "str_rsplit_obj": 147040,
  "str_find_obj": 147088,
  "str_rfind_obj": 147116,
  "str_index_obj": 147144,
  "str_rindex_obj": 147172,
  "str_startswith_obj": 147204,
  "str_endswith_obj": 147252,
  "str_strip_obj": 147288,
  "str_lstrip_obj": 147316,
  "str_rstrip_obj": 147344,
  "str_center_obj": 147372,
  "str_format_obj": 148032,
  "str_replace_obj": 148288,
  "str_count_obj": 148316,
  "str_partition_obj": 148348,
  "str_rpartition_obj": 148376,
  "str_lower_obj": 148400,
  "str_upper_obj": 148424,
  "str_isspace_obj": 148448,
  "str_isalpha_obj": 148472,
  "str_isdigit_obj": 148496,
  "str_isupper_obj": 148520,
  "str_islower_obj": 148544,
  "str_encode_obj": 148600,
  "str8_locals_dict_table": 148624,
  "struni_locals_dict_table": 149072,
  "struni_locals_dict": 149288,
  "mp_type_stringio": 149396,
  "stringio_stream_p": 149672,
  "stringio_locals_dict": 149656,
  "stringio_getvalue_obj": 149512,
  "stringio___exit___obj": 149544,
  "stringio_locals_dict_table": 149568,
  "mp_stream_read_obj": 151040,
  "mp_stream_readinto_obj": 151176,
  "mp_stream_unbuffered_readline_obj": 151220,
  "mp_stream_write_obj": 151108,
  "mp_stream_seek_obj": 151316,
  "mp_stream_tell_obj": 151344,
  "mp_stream_flush_obj": 151372,
  "mp_stream_close_obj": 151292,
  "bytesio_stream_p": 149688,
  "mp_type_bytesio": 149704,
  "tuple_locals_dict": 149968,
  "tuple_count_obj": 149912,
  "tuple_index_obj": 149936,
  "tuple_locals_dict_table": 149952,
  "native_base_init_wrapper_obj": 150012,
  "mp_type_super": 150532,
  "mp_builtin_issubclass_obj": 150708,
  "mp_builtin_isinstance_obj": 150744,
  "mp_type_zip": 150816,
  "mp_stream_read1_obj": 151072,
  "mp_stream_write1_obj": 151148,
  "mp_stream_unbuffered_readlines_obj": 151264,
  "mp_stream_ioctl_obj": 151400,
  "mp_builtin___import___obj": 151520,
  "mp_type_code": 151536,
  "mp_builtin_compile_obj": 151632,
  "mp_builtin_eval_obj": 151664,
  "mp_builtin_exec_obj": 151696,
  "mp_builtin_execfile_obj": 151732,
  "mp_module_array_globals_table": 151760,
  "mp_module_array_globals": 151776,
  "mp_builtin_abs_obj": 151860,
  "mp_builtin_all_obj": 151888,
  "mp_builtin_any_obj": 151916,
  "mp_builtin_bin_obj": 151944,
  "mp_builtin_callable_obj": 151976,
  "mp_builtin_chr_obj": 152036,
  "mp_builtin_dir_obj": 152064,
  "mp_builtin_divmod_obj": 152100,
  "mp_builtin_hash_obj": 152128,
  "mp_builtin_hex_obj": 152156,
  "mp_builtin_input_obj": 152188,
  "mp_builtin_iter_obj": 152220,
  "mp_builtin_max_obj": 152272,
  "mp_builtin_min_obj": 152304,
  "mp_builtin_oct_obj": 152368,
  "mp_builtin_ord_obj": 152456,
  "mp_builtin_pow_obj": 152512,
  "mp_sys_stdout_obj": 307624,
  "mp_builtin_print_obj": 152572,
  "mp_builtin___repl_print___obj": 152628,
  "mp_builtin_repr_obj": 152656,
  "mp_builtin_round_obj": 152688,
  "mp_builtin_sum_obj": 152720,
  "mp_builtin_sorted_obj": 152800,
  "mp_builtin_getattr_obj": 152836,
  "mp_builtin_setattr_obj": 152872,
  "mp_builtin_delattr_obj": 152904,
  "mp_builtin_hasattr_obj": 152936,
  "mp_builtin_globals_obj": 152968,
  "mp_builtin_locals_obj": 153000,
  "mp_builtin_id_obj": 153024,
  "mp_builtin_len_obj": 153048,
  "mp_module_builtins_globals_table": 153072,
  "mp_builtin_open_obj": 307600,
  "mp_module_collections_globals_table": 153856,
  "mp_module_collections_globals": 153880,
  "gc_collect_obj": 153920,
  "gc_disable_obj": 153944,
  "gc_enable_obj": 153968,
  "gc_isenabled_obj": 153996,
  "gc_mem_free_obj": 154020,
  "gc_mem_alloc_obj": 154048,
  "gc_threshold_obj": 154076,
  "mp_module_gc_globals_table": 154096,
  "mp_module_gc_globals": 154160,
  "iobase_singleton": 154244,
  "mp_type_iobase": 154184,
  "iobase_p": 154248,
  "bufwriter_flush_obj": 154280,
  "bufwriter_locals_dict_table": 154304,
  "bufwriter_locals_dict": 154320,
  "bufwriter_stream_p": 154336,
  "bufwriter_type": 154352,
  "resource_stream_obj": 154428,
  "mp_module_io_globals_table": 154448,
  "mp_type_fileio": 307312,
  "mp_type_textio": 307372,
  "mp_module_io_globals": 154520,
  "mp_math_sqrt_obj": 154576,
  "mp_math_pow_obj": 154600,
  "mp_math_exp_obj": 154624,
  "mp_math_expm1_obj": 154652,
  "mp_math_log2_obj": 154680,
  "mp_math_log10_obj": 154708,
  "mp_math_cosh_obj": 154736,
  "mp_math_sinh_obj": 154764,
  "mp_math_tanh_obj": 154792,
  "mp_math_acosh_obj": 154820,
  "mp_math_asinh_obj": 154848,
  "mp_math_atanh_obj": 154876,
  "mp_math_cos_obj": 154900,
  "mp_math_sin_obj": 154924,
  "mp_math_tan_obj": 154948,
  "mp_math_acos_obj": 154976,
  "mp_math_asin_obj": 155004,
  "mp_math_atan_obj": 155032,
  "mp_math_atan2_obj": 155060,
  "mp_math_ceil_obj": 155088,
  "mp_math_copysign_obj": 155120,
  "mp_math_fabs_obj": 155148,
  "mp_math_floor_obj": 155176,
  "mp_math_fmod_obj": 155204,
  "mp_math_isfinite_obj": 155236,
  "mp_math_isinf_obj": 155264,
  "mp_math_isnan_obj": 155292,
  "mp_math_trunc_obj": 155320,
  "mp_math_ldexp_obj": 155348,
  "mp_math_erf_obj": 155372,
  "mp_math_erfc_obj": 155400,
  "mp_math_gamma_obj": 155428,
  "mp_math_lgamma_obj": 155456,
  "mp_math_log_obj": 155496,
  "mp_math_frexp_obj": 155528,
  "mp_math_modf_obj": 155556,
  "mp_math_radians_obj": 155584,
  "mp_math_degrees_obj": 155612,
  "mp_math_factorial_obj": 155664,
  "mp_module_math_globals_table": 155680,
  "mp_module_math_globals": 156016,
  "mp_cmath_phase_obj": 156056,
  "mp_cmath_polar_obj": 156084,
  "mp_cmath_rect_obj": 156112,
  "mp_cmath_exp_obj": 156140,
  "mp_cmath_log_obj": 156168,
  "mp_cmath_log10_obj": 156196,
  "mp_cmath_sqrt_obj": 156224,
  "mp_cmath_cos_obj": 156252,
  "mp_cmath_sin_obj": 156280,
  "mp_module_cmath_globals_table": 156304,
  "mp_module_cmath_globals": 156400,
  "mp_micropython_opt_level_obj": 156452,
  "mp_micropython_mem_total_obj": 156496,
  "mp_micropython_mem_current_obj": 156536,
  "mp_micropython_mem_peak_obj": 156572,
  "mp_micropython_mem_info_obj": 156656,
  "mp_micropython_qstr_info_obj": 156772,
  "mp_micropython_stack_use_obj": 156816,
  "mp_micropython_pystack_use_obj": 156856,
  "mp_micropython_heap_lock_obj": 156896,
  "mp_micropython_heap_unlock_obj": 156936,
  "mp_alloc_emergency_exception_buf_obj": 156984,
  "mp_micropython_kbd_intr_obj": 157020,
  "mp_module_micropython_globals_table": 157040,
  "mp_module_micropython_globals": 157152,
  "struct_calcsize_obj": 157192,
  "struct_unpack_from_obj": 157240,
  "struct_pack_obj": 157268,
  "struct_pack_into_obj": 157304,
  "mp_module_struct_globals_table": 157328,
  "mp_module_struct_globals": 157376,
  "mp_sys_version_obj": 157416,
  "mp_sys_version_info_obj": 157432,
  "mp_sys_implementation_version_info_obj": 157452,
  "impl_fields": 157472,
  "mp_sys_implementation_obj": 157484,
  "mp_sys_platform_obj": 157516,
  "mp_sys_exit_obj": 157544,
  "mp_sys_print_exception_obj": 157584,
  "mp_sys_getsizeof_obj": 157620,
  "mp_module_sys_globals_table": 157632,
  "mp_sys_stdin_obj": 307616,
  "mp_sys_stderr_obj": 307632,
  "mp_module_sys_globals": 157760,
  "errorcode_dict": 157968,
  "errorcode_table": 157792,
  "mp_module_uerrno_globals_table": 157984,
  "mp_module_uerrno_globals": 158176,
  "mp_frozen_str_names": 162743,
  "mp_frozen_str_sizes": 162748,
  "mp_frozen_str_content": 162748,
  "mp_frozen_mpy_names": 306016,
  "mp_frozen_mpy_content": 306848,
  "uctypes_struct_type": 159004,
  "uctypes_struct_sizeof_obj": 158808,
  "uctypes_struct_addressof_obj": 158916,
  "uctypes_struct_bytearray_at_obj": 158956,
  "uctypes_struct_bytes_at_obj": 158992,
  "mp_module_uctypes_globals_table": 159072,
  "mp_module_uctypes_globals": 159376,
  "mod_ujson_dump_obj": 159440,
  "mod_ujson_dumps_obj": 159468,
  "mod_ujson_load_obj": 159516,
  "mod_ujson_loads_obj": 159544,
  "mp_module_ujson_globals_table": 159568,
  "mp_module_ujson_globals": 159608,
  "match_type": 159696,
  "re_type": 159952,
  "match_group_obj": 159660,
  "match_locals_dict_table": 159672,
  "match_locals_dict": 159680,
  "re_match_obj": 159776,
  "re_search_obj": 159804,
  "re_split_obj": 159860,
  "re_sub_obj": 159884,
  "re_locals_dict_table": 159904,
  "re_locals_dict": 159936,
  "mod_re_compile_obj": 160044,
  "mod_re_match_obj": 160076,
  "mod_re_search_obj": 160108,
  "mod_re_sub_obj": 160136,
  "mp_module_re_globals_table": 160160,
  "mp_module_re_globals": 160200,
  "clcidx": 160656,
  "length_bits": 160464,
  "length_base": 160496,
  "dist_bits": 160560,
  "dist_base": 160592,
  "decompio_locals_dict_table": 160256,
  "decompio_locals_dict": 160280,
  "decompio_stream_p": 160296,
  "decompio_type": 160312,
  "mod_uzlib_decompress_obj": 160396,
  "mp_module_uzlib_globals_table": 160416,
  "mp_module_uzlib_globals": 160440,
  "mod_uheapq_heappush_obj": 160792,
  "mod_uheapq_heappop_obj": 160836,
  "mod_uheapq_heapify_obj": 160868,
  "mp_module_uheapq_globals_table": 160880,
  "mp_module_uheapq_globals": 160912,
  "utimeq_id": 160952,
  "mod_utimeq_heappush_obj": 160976,
  "mod_utimeq_heappop_obj": 161024,
  "mod_utimeq_peektime_obj": 161056,
  "utimeq_locals_dict_table": 161072,
  "utimeq_locals_dict": 161096,
  "utimeq_type": 161112,
  "mp_module_utimeq_globals_table": 161184,
  "mp_module_utimeq_globals": 161200,
  "uhashlib_sha256_update_obj": 161248,
  "uhashlib_sha256_digest_obj": 161284,
  "uhashlib_sha256_locals_dict_table": 161296,
  "uhashlib_sha256_locals_dict": 161312,
  "uhashlib_sha256_type": 161328,
  "mp_module_uhashlib_globals_table": 161392,
  "mp_module_uhashlib_globals": 161408,
  "mod_binascii_hexlify_obj": 161720,
  "mod_binascii_unhexlify_obj": 161800,
  "mod_binascii_a2b_base64_obj": 161856,
  "mod_binascii_b2a_base64_obj": 161892,
  "mp_module_binascii_globals_table": 161904,
  "mp_module_binascii_globals": 161944,
  "yasmarang_pad": 161968,
  "yasmarang_n": 161972,
  "yasmarang_d": 161976,
  "yasmarang_dat": 161980,
  "mod_urandom_getrandbits_obj": 162008,
  "mod_urandom_seed_obj": 162040,
  "mod_urandom_randrange_obj": 162076,
  "mod_urandom_randint_obj": 162112,
  "mod_urandom_choice_obj": 162144,
  "mod_urandom_random_obj": 162176,
  "mod_urandom_uniform_obj": 162208,
  "mp_module_urandom_globals_table": 162224,
  "mp_module_urandom_globals": 162288,
  "mp_utime_sleep_obj": 162324,
  "mp_utime_sleep_ms_obj": 162352,
  "mp_utime_sleep_us_obj": 162380,
  "mp_utime_ticks_ms_obj": 162408,
  "mp_utime_ticks_us_obj": 162436,
  "mp_utime_ticks_cpu_obj": 162464,
  "mp_utime_ticks_diff_obj": 162492,
  "mp_utime_ticks_add_obj": 162520,
  "__THREW__": 1123776,
  "__threwValue": 1123780,
  "mp_interrupt_char": 314612,
  "mp_uos_dupterm_obj": 162712,
  "fun_data_aio_aio_cpy__lt_module_gt__aio_main": 209728,
  "const_obj_aio_aio_cpy__lt_module_gt__aio_main_0": 210012,
  "const_obj_aio_aio_cpy__lt_module_gt__aio_main_1": 210032,
  "const_table_data_aio_aio_cpy__lt_module_gt__aio_main": 210048,
  "raw_code_aio_aio_cpy__lt_module_gt__aio_main": 210072,
  "fun_data_aio_aio_cpy__lt_module_gt__aio__run": 210096,
  "const_obj_aio_aio_cpy__lt_module_gt__aio__run_0": 210252,
  "const_table_data_aio_aio_cpy__lt_module_gt__aio__run": 210268,
  "raw_code_aio_aio_cpy__lt_module_gt__aio__run": 210280,
  "fun_data_aio_aio_cpy__lt_module_gt__aio": 210304,
  "const_table_data_aio_aio_cpy__lt_module_gt__aio": 210364,
  "raw_code_aio_aio_cpy__lt_module_gt__aio": 210372,
  "fun_data_aio_aio_cpy__lt_module_gt__End": 210400,
  "const_obj_aio_aio_cpy__lt_module_gt__End_0": 210516,
  "const_table_data_aio_aio_cpy__lt_module_gt__End": 210532,
  "raw_code_aio_aio_cpy__lt_module_gt__End": 210536,
  "fun_data_aio_aio_cpy__lt_module_gt_": 210560,
  "const_obj_aio_aio_cpy__lt_module_gt__0": 210728,
  "const_table_data_aio_aio_cpy__lt_module_gt_": 210744,
  "raw_code_aio_aio_cpy__lt_module_gt_": 210756,
  "fun_data_aio___init____lt_module_gt_": 210784,
  "raw_code_aio___init____lt_module_gt_": 210924,
  "fun_data_aio_input_upy__lt_module_gt__ainput_switch": 210944,
  "const_table_data_aio_input_upy__lt_module_gt__ainput_switch": 210992,
  "raw_code_aio_input_upy__lt_module_gt__ainput_switch": 210996,
  "fun_data_aio_input_upy__lt_module_gt__ainput": 211024,
  "const_obj_aio_input_upy__lt_module_gt__ainput_0": 211344,
  "const_table_data_aio_input_upy__lt_module_gt__ainput": 211360,
  "raw_code_aio_input_upy__lt_module_gt__ainput": 211376,
  "fun_data_aio_input_upy__lt_module_gt__test": 211408,
  "const_obj_aio_input_upy__lt_module_gt__test_0": 211492,
  "const_table_data_aio_input_upy__lt_module_gt__test": 211508,
  "raw_code_aio_input_upy__lt_module_gt__test": 211512,
  "fun_data_aio_input_upy__lt_module_gt_": 211536,
  "const_table_data_aio_input_upy__lt_module_gt_": 211672,
  "raw_code_aio_input_upy__lt_module_gt_": 211680,
  "fun_data_aio_input___init____lt_module_gt_": 211712,
  "raw_code_aio_input___init____lt_module_gt_": 211752,
  "fun_data_aio_input_cpy__lt_module_gt_": 211772,
  "raw_code_aio_input_cpy__lt_module_gt_": 211784,
  "fun_data_aio_core__lt_module_gt__use_gc": 211808,
  "const_table_data_aio_core__lt_module_gt__use_gc": 211828,
  "raw_code_aio_core__lt_module_gt__use_gc": 211832,
  "fun_data_aio_core__lt_module_gt__use": 211856,
  "const_table_data_aio_core__lt_module_gt__use": 211900,
  "raw_code_aio_core__lt_module_gt__use": 211904,
  "fun_data_aio_core__lt_module_gt__task": 211936,
  "const_obj_aio_core__lt_module_gt__task_0": 212092,
  "const_table_data_aio_core__lt_module_gt__task": 212108,
  "raw_code_aio_core__lt_module_gt__task": 212116,
  "fun_data_aio_core__lt_module_gt__tasks": 212144,
  "raw_code_aio_core__lt_module_gt__tasks": 212180,
  "fun_data_aio_core__lt_module_gt__idle": 212208,
  "raw_code_aio_core__lt_module_gt__idle": 212232,
  "fun_data_aio_core__lt_module_gt__load": 212256,
  "const_table_data_aio_core__lt_module_gt__load": 212344,
  "raw_code_aio_core__lt_module_gt__load": 212348,
  "fun_data_aio_core__lt_module_gt__step": 212368,
  "const_obj_aio_core__lt_module_gt__step_0": 212600,
  "const_obj_aio_core__lt_module_gt__step_1": 212628,
  "const_obj_aio_core__lt_module_gt__step_2": 212660,
  "const_obj_aio_core__lt_module_gt__step_3": 212692,
  "const_table_data_aio_core__lt_module_gt__step": 212720,
  "raw_code_aio_core__lt_module_gt__step": 212736,
  "fun_data_aio_core__lt_module_gt__run": 212768,
  "const_table_data_aio_core__lt_module_gt__run": 212816,
  "raw_code_aio_core__lt_module_gt__run": 212820,
  "fun_data_aio_core__lt_module_gt__step2": 212848,
  "const_obj_aio_core__lt_module_gt__step2_0": 213048,
  "const_obj_aio_core__lt_module_gt__step2_1": 213064,
  "const_obj_aio_core__lt_module_gt__step2_2": 213100,
  "const_table_data_aio_core__lt_module_gt__step2": 213116,
  "raw_code_aio_core__lt_module_gt__step2": 213128,
  "fun_data_aio_core__lt_module_gt__asleep_ms": 213152,
  "const_table_data_aio_core__lt_module_gt__asleep_ms": 213188,
  "raw_code_aio_core__lt_module_gt__asleep_ms": 213192,
  "fun_data_aio_core__lt_module_gt_": 213216,
  "const_obj_aio_core__lt_module_gt__0": 213764,
  "const_obj_aio_core__lt_module_gt__1": 213820,
  "const_obj_aio_core__lt_module_gt__2": 213880,
  "const_obj_aio_core__lt_module_gt__3": 213912,
  "const_obj_aio_core__lt_module_gt__4": 213948,
  "const_table_data_aio_core__lt_module_gt_": 213968,
  "raw_code_aio_core__lt_module_gt_": 214024,
  "fun_data_aio_io__lt_module_gt__finalize": 214048,
  "raw_code_aio_io__lt_module_gt__finalize": 214128,
  "fun_data_aio_io__lt_module_gt__step": 214160,
  "const_obj_aio_io__lt_module_gt__step_0": 214444,
  "const_table_data_aio_io__lt_module_gt__step": 214460,
  "raw_code_aio_io__lt_module_gt__step": 214464,
  "fun_data_aio_io__lt_module_gt__ctl": 214496,
  "const_obj_aio_io__lt_module_gt__ctl_0": 214604,
  "const_table_data_aio_io__lt_module_gt__ctl": 214624,
  "raw_code_aio_io__lt_module_gt__ctl": 214640,
  "fun_data_aio_io__lt_module_gt__network": 214672,
  "raw_code_aio_io__lt_module_gt__network": 214736,
  "fun_data_aio_io__lt_module_gt_": 214768,
  "const_table_data_aio_io__lt_module_gt_": 214896,
  "raw_code_aio_io__lt_module_gt_": 214912,
  "fun_data_aio_synchro__lt_module_gt__Lock___init__": 214944,
  "const_table_data_aio_synchro__lt_module_gt__Lock___init__": 214968,
  "raw_code_aio_synchro__lt_module_gt__Lock___init__": 214972,
  "fun_data_aio_synchro__lt_module_gt__Lock_release": 214992,
  "const_table_data_aio_synchro__lt_module_gt__Lock_release": 215060,
  "raw_code_aio_synchro__lt_module_gt__Lock_release": 215064,
  "fun_data_aio_synchro__lt_module_gt__Lock_acquire": 215088,
  "const_table_data_aio_synchro__lt_module_gt__Lock_acquire": 215156,
  "raw_code_aio_synchro__lt_module_gt__Lock_acquire": 215160,
  "fun_data_aio_synchro__lt_module_gt__Lock": 215184,
  "const_table_data_aio_synchro__lt_module_gt__Lock": 215228,
  "raw_code_aio_synchro__lt_module_gt__Lock": 215240,
  "fun_data_aio_synchro__lt_module_gt_": 215264,
  "const_table_data_aio_synchro__lt_module_gt_": 215288,
  "raw_code_aio_synchro__lt_module_gt_": 215292,
  "fun_data_aio_network__lt_module_gt__StreamReader___init__": 215312,
  "const_table_data_aio_network__lt_module_gt__StreamReader___init__": 215348,
  "raw_code_aio_network__lt_module_gt__StreamReader___init__": 215360,
  "fun_data_aio_network__lt_module_gt__StreamReader_read": 215392,
  "const_table_data_aio_network__lt_module_gt__StreamReader_read": 215464,
  "raw_code_aio_network__lt_module_gt__StreamReader_read": 215472,
  "fun_data_aio_network__lt_module_gt__StreamReader_readexactly": 215504,
  "const_obj_aio_network__lt_module_gt__StreamReader_readexactly_0": 215600,
  "const_table_data_aio_network__lt_module_gt__StreamReader_readexactly": 215616,
  "raw_code_aio_network__lt_module_gt__StreamReader_readexactly": 215628,
  "fun_data_aio_network__lt_module_gt__StreamReader_readline": 215648,
  "const_obj_aio_network__lt_module_gt__StreamReader_readline_0": 215804,
  "const_obj_aio_network__lt_module_gt__StreamReader_readline_1": 215820,
  "const_obj_aio_network__lt_module_gt__StreamReader_readline_2": 215864,
  "const_table_data_aio_network__lt_module_gt__StreamReader_readline": 215888,
  "raw_code_aio_network__lt_module_gt__StreamReader_readline": 215904,
  "fun_data_aio_network__lt_module_gt__StreamReader_aclose": 215936,
  "const_table_data_aio_network__lt_module_gt__StreamReader_aclose": 215972,
  "raw_code_aio_network__lt_module_gt__StreamReader_aclose": 215976,
  "fun_data_aio_network__lt_module_gt__StreamReader___repr__": 216000,
  "const_obj_aio_network__lt_module_gt__StreamReader___repr___0": 216044,
  "const_table_data_aio_network__lt_module_gt__StreamReader___repr__": 216060,
  "raw_code_aio_network__lt_module_gt__StreamReader___repr__": 216068,
  "fun_data_aio_network__lt_module_gt__StreamReader": 216096,
  "const_table_data_aio_network__lt_module_gt__StreamReader": 216176,
  "raw_code_aio_network__lt_module_gt__StreamReader": 216200,
  "fun_data_aio_network__lt_module_gt__StreamWriter___init__": 216224,
  "const_table_data_aio_network__lt_module_gt__StreamWriter___init__": 216248,
  "raw_code_aio_network__lt_module_gt__StreamWriter___init__": 216260,
  "fun_data_aio_network__lt_module_gt__StreamWriter_awrite": 216288,
  "const_obj_aio_network__lt_module_gt__StreamWriter_awrite_0": 216508,
  "const_obj_aio_network__lt_module_gt__StreamWriter_awrite_1": 216576,
  "const_obj_aio_network__lt_module_gt__StreamWriter_awrite_2": 216640,
  "const_obj_aio_network__lt_module_gt__StreamWriter_awrite_3": 216696,
  "const_table_data_aio_network__lt_module_gt__StreamWriter_awrite": 216720,
  "raw_code_aio_network__lt_module_gt__StreamWriter_awrite": 216752,
  "fun_data_aio_network__lt_module_gt__StreamWriter_awritestr": 216784,
  "const_table_data_aio_network__lt_module_gt__StreamWriter_awritestr": 216812,
  "raw_code_aio_network__lt_module_gt__StreamWriter_awritestr": 216820,
  "fun_data_aio_network__lt_module_gt__StreamWriter_awriteiter": 216848,
  "const_table_data_aio_network__lt_module_gt__StreamWriter_awriteiter": 216884,
  "raw_code_aio_network__lt_module_gt__StreamWriter_awriteiter": 216892,
  "fun_data_aio_network__lt_module_gt__StreamWriter_aclose": 216912,
  "const_table_data_aio_network__lt_module_gt__StreamWriter_aclose": 216948,
  "raw_code_aio_network__lt_module_gt__StreamWriter_aclose": 216952,
  "fun_data_aio_network__lt_module_gt__StreamWriter_get_extra_info": 216976,
  "const_table_data_aio_network__lt_module_gt__StreamWriter_get_extra_info": 217000,
  "raw_code_aio_network__lt_module_gt__StreamWriter_get_extra_info": 217012,
  "fun_data_aio_network__lt_module_gt__StreamWriter___repr__": 217040,
  "const_obj_aio_network__lt_module_gt__StreamWriter___repr___0": 217076,
  "const_table_data_aio_network__lt_module_gt__StreamWriter___repr__": 217092,
  "raw_code_aio_network__lt_module_gt__StreamWriter___repr__": 217100,
  "fun_data_aio_network__lt_module_gt__StreamWriter": 217120,
  "const_table_data_aio_network__lt_module_gt__StreamWriter": 217200,
  "raw_code_aio_network__lt_module_gt__StreamWriter": 217228,
  "fun_data_aio_network__lt_module_gt__open_connection": 217248,
  "const_obj_aio_network__lt_module_gt__open_connection_0": 217548,
  "const_obj_aio_network__lt_module_gt__open_connection_1": 217596,
  "const_obj_aio_network__lt_module_gt__open_connection_2": 217648,
  "const_obj_aio_network__lt_module_gt__open_connection_3": 217704,
  "const_table_data_aio_network__lt_module_gt__open_connection": 217728,
  "raw_code_aio_network__lt_module_gt__open_connection": 217756,
  "fun_data_aio_network__lt_module_gt__start_server": 217776,
  "const_obj_aio_network__lt_module_gt__start_server_0": 218076,
  "const_obj_aio_network__lt_module_gt__start_server_1": 218120,
  "const_obj_aio_network__lt_module_gt__start_server_2": 218164,
  "const_obj_aio_network__lt_module_gt__start_server_3": 218212,
  "const_table_data_aio_network__lt_module_gt__start_server": 218240,
  "raw_code_aio_network__lt_module_gt__start_server": 218272,
  "fun_data_aio_network__lt_module_gt_": 218304,
  "const_table_data_aio_network__lt_module_gt_": 218400,
  "raw_code_aio_network__lt_module_gt_": 218416,
  "fun_data_imp__lt_module_gt__new_module": 218448,
  "const_table_data_imp__lt_module_gt__new_module": 218468,
  "raw_code_imp__lt_module_gt__new_module": 218472,
  "fun_data_imp__lt_module_gt__importer": 218496,
  "const_obj_imp__lt_module_gt__importer_0": 219064,
  "const_obj_imp__lt_module_gt__importer_1": 219124,
  "const_obj_imp__lt_module_gt__importer_2": 219160,
  "const_obj_imp__lt_module_gt__importer_3": 219228,
  "const_table_data_imp__lt_module_gt__importer": 219248,
  "raw_code_imp__lt_module_gt__importer": 219268,
  "fun_data_imp__lt_module_gt__restore": 219296,
  "const_obj_imp__lt_module_gt__restore_0": 219368,
  "const_table_data_imp__lt_module_gt__restore": 219384,
  "raw_code_imp__lt_module_gt__restore": 219388,
  "fun_data_imp__lt_module_gt_": 219408,
  "const_obj_imp__lt_module_gt__0": 219528,
  "const_table_data_imp__lt_module_gt_": 219552,
  "raw_code_imp__lt_module_gt_": 219568,
  "fun_data_typing__lt_module_gt___Subscriptable___getitem__": 219588,
  "const_table_data_typing__lt_module_gt___Subscriptable___getitem__": 219600,
  "raw_code_typing__lt_module_gt___Subscriptable___getitem__": 219608,
  "fun_data_typing__lt_module_gt___Subscriptable": 219632,
  "const_table_data_typing__lt_module_gt___Subscriptable": 219660,
  "raw_code_typing__lt_module_gt___Subscriptable": 219664,
  "fun_data_typing__lt_module_gt__TypeVar": 219684,
  "const_table_data_typing__lt_module_gt__TypeVar": 219700,
  "raw_code_typing__lt_module_gt__TypeVar": 219704,
  "fun_data_typing__lt_module_gt__Any": 219728,
  "raw_code_typing__lt_module_gt__Any": 219752,
  "fun_data_typing__lt_module_gt__NoReturn": 219776,
  "raw_code_typing__lt_module_gt__NoReturn": 219800,
  "fun_data_typing__lt_module_gt__ClassVar": 219824,
  "raw_code_typing__lt_module_gt__ClassVar": 219848,
  "fun_data_typing__lt_module_gt__Hashable": 219872,
  "raw_code_typing__lt_module_gt__Hashable": 219896,
  "fun_data_typing__lt_module_gt__Awaitable": 219920,
  "raw_code_typing__lt_module_gt__Awaitable": 219944,
  "fun_data_typing__lt_module_gt__Coroutine": 219968,
  "raw_code_typing__lt_module_gt__Coroutine": 219992,
  "fun_data_typing__lt_module_gt__AsyncIterable": 220016,
  "raw_code_typing__lt_module_gt__AsyncIterable": 220040,
  "fun_data_typing__lt_module_gt__AsyncIterator": 220064,
  "raw_code_typing__lt_module_gt__AsyncIterator": 220088,
  "fun_data_typing__lt_module_gt__Iterable": 220112,
  "raw_code_typing__lt_module_gt__Iterable": 220136,
  "fun_data_typing__lt_module_gt__Iterator": 220160,
  "raw_code_typing__lt_module_gt__Iterator": 220184,
  "fun_data_typing__lt_module_gt__Reversible": 220208,
  "raw_code_typing__lt_module_gt__Reversible": 220232,
  "fun_data_typing__lt_module_gt__Sized": 220256,
  "raw_code_typing__lt_module_gt__Sized": 220280,
  "fun_data_typing__lt_module_gt__Container": 220304,
  "raw_code_typing__lt_module_gt__Container": 220328,
  "fun_data_typing__lt_module_gt__Collection": 220352,
  "raw_code_typing__lt_module_gt__Collection": 220376,
  "fun_data_typing__lt_module_gt__ByteString": 220400,
  "raw_code_typing__lt_module_gt__ByteString": 220424,
  "fun_data_typing__lt_module_gt__Deque": 220448,
  "raw_code_typing__lt_module_gt__Deque": 220472,
  "fun_data_typing__lt_module_gt__MappingView": 220496,
  "raw_code_typing__lt_module_gt__MappingView": 220520,
  "fun_data_typing__lt_module_gt__KeysView": 220544,
  "raw_code_typing__lt_module_gt__KeysView": 220568,
  "fun_data_typing__lt_module_gt__ItemsView": 220592,
  "raw_code_typing__lt_module_gt__ItemsView": 220616,
  "fun_data_typing__lt_module_gt__ValuesView": 220640,
  "raw_code_typing__lt_module_gt__ValuesView": 220664,
  "fun_data_typing__lt_module_gt__ContextManager": 220688,
  "raw_code_typing__lt_module_gt__ContextManager": 220712,
  "fun_data_typing__lt_module_gt__AsyncContextManager": 220736,
  "raw_code_typing__lt_module_gt__AsyncContextManager": 220760,
  "fun_data_typing__lt_module_gt__Counter": 220784,
  "raw_code_typing__lt_module_gt__Counter": 220808,
  "fun_data_typing__lt_module_gt__ChainMap": 220832,
  "raw_code_typing__lt_module_gt__ChainMap": 220856,
  "fun_data_typing__lt_module_gt__Generator": 220880,
  "raw_code_typing__lt_module_gt__Generator": 220904,
  "fun_data_typing__lt_module_gt__AsyncGenerator": 220928,
  "raw_code_typing__lt_module_gt__AsyncGenerator": 220952,
  "fun_data_typing__lt_module_gt__Type": 220976,
  "raw_code_typing__lt_module_gt__Type": 221000,
  "fun_data_typing__lt_module_gt__cast": 221020,
  "const_table_data_typing__lt_module_gt__cast": 221032,
  "raw_code_typing__lt_module_gt__cast": 221040,
  "fun_data_typing__lt_module_gt___overload_dummy": 221072,
  "const_obj_typing__lt_module_gt___overload_dummy_0": 221280,
  "const_table_data_typing__lt_module_gt___overload_dummy": 221296,
  "raw_code_typing__lt_module_gt___overload_dummy": 221300,
  "fun_data_typing__lt_module_gt__overload": 221320,
  "const_table_data_typing__lt_module_gt__overload": 221336,
  "raw_code_typing__lt_module_gt__overload": 221340,
  "fun_data_typing__lt_module_gt_": 221360,
  "const_table_data_typing__lt_module_gt_": 221920,
  "raw_code_typing__lt_module_gt_": 222048,
  "fun_data___future____lt_module_gt_": 222068,
  "raw_code___future____lt_module_gt_": 222084,
  "fun_data_uwebsockets__lt_module_gt__urlparse": 222112,
  "const_table_data_uwebsockets__lt_module_gt__urlparse": 222172,
  "raw_code_uwebsockets__lt_module_gt__urlparse": 222176,
  "fun_data_uwebsockets__lt_module_gt__Websocket___init__": 222208,
  "const_table_data_uwebsockets__lt_module_gt__Websocket___init__": 222240,
  "raw_code_uwebsockets__lt_module_gt__Websocket___init__": 222252,
  "fun_data_uwebsockets__lt_module_gt__Websocket___enter__": 222272,
  "const_table_data_uwebsockets__lt_module_gt__Websocket___enter__": 222284,
  "raw_code_uwebsockets__lt_module_gt__Websocket___enter__": 222288,
  "fun_data_uwebsockets__lt_module_gt__Websocket___exit__": 222320,
  "const_table_data_uwebsockets__lt_module_gt__Websocket___exit__": 222352,
  "raw_code_uwebsockets__lt_module_gt__Websocket___exit__": 222368,
  "fun_data_uwebsockets__lt_module_gt__Websocket_settimeout": 222400,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_settimeout": 222428,
  "raw_code_uwebsockets__lt_module_gt__Websocket_settimeout": 222436,
  "fun_data_uwebsockets__lt_module_gt__Websocket_read_frame__lt_genexpr_gt_": 222464,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_read_frame__lt_genexpr_gt_": 222500,
  "raw_code_uwebsockets__lt_module_gt__Websocket_read_frame__lt_genexpr_gt_": 222508,
  "fun_data_uwebsockets__lt_module_gt__Websocket_read_frame": 222528,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_read_frame": 222780,
  "raw_code_uwebsockets__lt_module_gt__Websocket_read_frame": 222792,
  "fun_data_uwebsockets__lt_module_gt__Websocket_write_frame__lt_genexpr_gt_": 222816,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_write_frame__lt_genexpr_gt_": 222852,
  "raw_code_uwebsockets__lt_module_gt__Websocket_write_frame__lt_genexpr_gt_": 222860,
  "fun_data_uwebsockets__lt_module_gt__Websocket_write_frame": 222880,
  "const_obj_uwebsockets__lt_module_gt__Websocket_write_frame_0": 223160,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_write_frame": 223184,
  "raw_code_uwebsockets__lt_module_gt__Websocket_write_frame": 223204,
  "fun_data_uwebsockets__lt_module_gt__Websocket_recv": 223232,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_recv": 223448,
  "raw_code_uwebsockets__lt_module_gt__Websocket_recv": 223452,
  "fun_data_uwebsockets__lt_module_gt__Websocket_send": 223472,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_send": 223560,
  "raw_code_uwebsockets__lt_module_gt__Websocket_send": 223568,
  "fun_data_uwebsockets__lt_module_gt__Websocket_close": 223600,
  "const_table_data_uwebsockets__lt_module_gt__Websocket_close": 223668,
  "raw_code_uwebsockets__lt_module_gt__Websocket_close": 223680,
  "fun_data_uwebsockets__lt_module_gt__Websocket__close": 223712,
  "const_table_data_uwebsockets__lt_module_gt__Websocket__close": 223740,
  "raw_code_uwebsockets__lt_module_gt__Websocket__close": 223744,
  "fun_data_uwebsockets__lt_module_gt__Websocket": 223776,
  "const_obj_uwebsockets__lt_module_gt__Websocket_0": 223888,
  "const_table_data_uwebsockets__lt_module_gt__Websocket": 223904,
  "raw_code_uwebsockets__lt_module_gt__Websocket": 223948,
  "fun_data_uwebsockets__lt_module_gt__client_connect_send_header": 223968,
  "const_table_data_uwebsockets__lt_module_gt__client_connect_send_header": 224000,
  "raw_code_uwebsockets__lt_module_gt__client_connect_send_header": 224008,
  "fun_data_uwebsockets__lt_module_gt__client_connect__lt_genexpr_gt_": 224032,
  "const_table_data_uwebsockets__lt_module_gt__client_connect__lt_genexpr_gt_": 224068,
  "raw_code_uwebsockets__lt_module_gt__client_connect__lt_genexpr_gt_": 224072,
  "fun_data_uwebsockets__lt_module_gt__client_connect": 224096,
  "const_obj_uwebsockets__lt_module_gt__client_connect_0": 224356,
  "const_obj_uwebsockets__lt_module_gt__client_connect_1": 224384,
  "const_obj_uwebsockets__lt_module_gt__client_connect_2": 224420,
  "const_obj_uwebsockets__lt_module_gt__client_connect_3": 224456,
  "const_obj_uwebsockets__lt_module_gt__client_connect_4": 224496,
  "const_obj_uwebsockets__lt_module_gt__client_connect_5": 224540,
  "const_obj_uwebsockets__lt_module_gt__client_connect_6": 224584,
  "const_obj_uwebsockets__lt_module_gt__client_connect_7": 224600,
  "const_obj_uwebsockets__lt_module_gt__client_connect_8": 224652,
  "const_table_data_uwebsockets__lt_module_gt__client_connect": 224672,
  "raw_code_uwebsockets__lt_module_gt__client_connect": 224724,
  "fun_data_uwebsockets__lt_module_gt__client": 224752,
  "const_table_data_uwebsockets__lt_module_gt__client": 224788,
  "raw_code_uwebsockets__lt_module_gt__client": 224792,
  "fun_data_uwebsockets__lt_module_gt_": 224816,
  "const_obj_uwebsockets__lt_module_gt__0": 225112,
  "const_table_data_uwebsockets__lt_module_gt_": 225136,
  "raw_code_uwebsockets__lt_module_gt_": 225152,
  "fun_data_imp_pivot__lt_module_gt_": 225184,
  "raw_code_imp_pivot__lt_module_gt_": 225252,
  "fun_data_pystone__lt_module_gt__Record___init__": 225280,
  "const_table_data_pystone__lt_module_gt__Record___init__": 225328,
  "raw_code_pystone__lt_module_gt__Record___init__": 225352,
  "fun_data_pystone__lt_module_gt__Record_copy": 225376,
  "const_table_data_pystone__lt_module_gt__Record_copy": 225412,
  "raw_code_pystone__lt_module_gt__Record_copy": 225416,
  "fun_data_pystone__lt_module_gt__Record": 225440,
  "const_table_data_pystone__lt_module_gt__Record": 225484,
  "raw_code_pystone__lt_module_gt__Record": 225492,
  "fun_data_pystone__lt_module_gt__main": 225520,
  "const_obj_pystone__lt_module_gt__main_0": 225608,
  "const_obj_pystone__lt_module_gt__main_1": 225672,
  "const_table_data_pystone__lt_module_gt__main": 225688,
  "raw_code_pystone__lt_module_gt__main": 225700,
  "fun_data_pystone__lt_module_gt__pystones": 225728,
  "const_table_data_pystone__lt_module_gt__pystones": 225748,
  "raw_code_pystone__lt_module_gt__pystones": 225752,
  "fun_data_pystone__lt_module_gt___lt_listcomp_gt_": 225776,
  "const_table_data_pystone__lt_module_gt___lt_listcomp_gt_": 225808,
  "raw_code_pystone__lt_module_gt___lt_listcomp_gt_": 225812,
  "fun_data_pystone__lt_module_gt__Proc0": 225840,
  "const_obj_pystone__lt_module_gt__Proc0_0": 226296,
  "const_obj_pystone__lt_module_gt__Proc0_1": 226344,
  "const_obj_pystone__lt_module_gt__Proc0_2": 226392,
  "const_obj_pystone__lt_module_gt__Proc0_3": 226408,
  "const_obj_pystone__lt_module_gt__Proc0_4": 226424,
  "const_obj_pystone__lt_module_gt__Proc0_5": 226452,
  "const_table_data_pystone__lt_module_gt__Proc0": 226480,
  "raw_code_pystone__lt_module_gt__Proc0": 226508,
  "fun_data_pystone__lt_module_gt__Proc1": 226528,
  "const_table_data_pystone__lt_module_gt__Proc1": 226668,
  "raw_code_pystone__lt_module_gt__Proc1": 226672,
  "fun_data_pystone__lt_module_gt__Proc2": 226704,
  "const_table_data_pystone__lt_module_gt__Proc2": 226768,
  "raw_code_pystone__lt_module_gt__Proc2": 226772,
  "fun_data_pystone__lt_module_gt__Proc3": 226800,
  "const_table_data_pystone__lt_module_gt__Proc3": 226856,
  "raw_code_pystone__lt_module_gt__Proc3": 226860,
  "fun_data_pystone__lt_module_gt__Proc4": 226880,
  "raw_code_pystone__lt_module_gt__Proc4": 226916,
  "fun_data_pystone__lt_module_gt__Proc5": 226944,
  "raw_code_pystone__lt_module_gt__Proc5": 226972,
  "fun_data_pystone__lt_module_gt__Proc6": 226992,
  "const_table_data_pystone__lt_module_gt__Proc6": 227124,
  "raw_code_pystone__lt_module_gt__Proc6": 227128,
  "fun_data_pystone__lt_module_gt__Proc7": 227152,
  "const_table_data_pystone__lt_module_gt__Proc7": 227176,
  "raw_code_pystone__lt_module_gt__Proc7": 227184,
  "fun_data_pystone__lt_module_gt__Proc8": 227216,
  "const_table_data_pystone__lt_module_gt__Proc8": 227328,
  "raw_code_pystone__lt_module_gt__Proc8": 227344,
  "fun_data_pystone__lt_module_gt__Func1": 227376,
  "const_table_data_pystone__lt_module_gt__Func1": 227412,
  "raw_code_pystone__lt_module_gt__Func1": 227420,
  "fun_data_pystone__lt_module_gt__Func2": 227440,
  "const_table_data_pystone__lt_module_gt__Func2": 227552,
  "raw_code_pystone__lt_module_gt__Func2": 227560,
  "fun_data_pystone__lt_module_gt__Func3": 227584,
  "const_table_data_pystone__lt_module_gt__Func3": 227616,
  "raw_code_pystone__lt_module_gt__Func3": 227620,
  "fun_data_pystone__lt_module_gt____main___error": 227648,
  "const_obj_pystone__lt_module_gt____main___error_0": 227748,
  "const_table_data_pystone__lt_module_gt____main___error": 227764,
  "raw_code_pystone__lt_module_gt____main___error": 227776,
  "fun_data_pystone__lt_module_gt____main__": 227808,
  "const_obj_pystone__lt_module_gt____main___0": 228016,
  "const_obj_pystone__lt_module_gt____main___1": 228056,
  "const_table_data_pystone__lt_module_gt____main__": 228072,
  "raw_code_pystone__lt_module_gt____main__": 228084,
  "fun_data_pystone__lt_module_gt_": 228112,
  "const_table_data_pystone__lt_module_gt_": 228448,
  "raw_code_pystone__lt_module_gt_": 228516,
  "fun_data_types__lt_module_gt__ModuleType": 228544,
  "const_obj_types__lt_module_gt__ModuleType_0": 228672,
  "const_obj_types__lt_module_gt__ModuleType_1": 228712,
  "const_obj_types__lt_module_gt__ModuleType_2": 228728,
  "const_table_data_types__lt_module_gt__ModuleType": 228752,
  "raw_code_types__lt_module_gt__ModuleType": 228768,
  "fun_data_types__lt_module_gt_": 228800,
  "const_table_data_types__lt_module_gt_": 228836,
  "raw_code_types__lt_module_gt_": 228840,
  "fun_data_m2__lt_module_gt_": 228864,
  "raw_code_m2__lt_module_gt_": 228884,
  "fun_data_crt_ld__lt_module_gt__base_setup": 228912,
  "const_obj_crt_ld__lt_module_gt__base_setup_0": 229104,
  "const_table_data_crt_ld__lt_module_gt__base_setup": 229120,
  "raw_code_crt_ld__lt_module_gt__base_setup": 229140,
  "fun_data_crt_ld__lt_module_gt__stamp_child": 229168,
  "const_table_data_crt_ld__lt_module_gt__stamp_child": 229212,
  "raw_code_crt_ld__lt_module_gt__stamp_child": 229224,
  "fun_data_crt_ld__lt_module_gt__Node_set_tag": 229248,
  "const_table_data_crt_ld__lt_module_gt__Node_set_tag": 229292,
  "raw_code_crt_ld__lt_module_gt__Node_set_tag": 229304,
  "fun_data_crt_ld__lt_module_gt__Node_setup": 229328,
  "const_table_data_crt_ld__lt_module_gt__Node_setup": 229380,
  "raw_code_crt_ld__lt_module_gt__Node_setup": 229388,
  "fun_data_crt_ld__lt_module_gt_": 229408,
  "const_table_data_crt_ld__lt_module_gt_": 229456,
  "raw_code_crt_ld__lt_module_gt_": 229472,
  "fun_data_machine__lt_module_gt_": 229492,
  "raw_code_machine__lt_module_gt_": 229504,
  "fun_data_readline__lt_module_gt_": 229524,
  "raw_code_readline__lt_module_gt_": 229536,
  "fun_data_picoweb___init____lt_module_gt__resource_stream": 229568,
  "const_table_data_picoweb___init____lt_module_gt__resource_stream": 229736,
  "raw_code_picoweb___init____lt_module_gt__resource_stream": 229744,
  "fun_data_picoweb___init____lt_module_gt__get_mime_type": 229776,
  "const_table_data_picoweb___init____lt_module_gt__get_mime_type": 229856,
  "raw_code_picoweb___init____lt_module_gt__get_mime_type": 229860,
  "fun_data_picoweb___init____lt_module_gt__sendstream": 229888,
  "const_table_data_picoweb___init____lt_module_gt__sendstream": 229948,
  "raw_code_picoweb___init____lt_module_gt__sendstream": 229956,
  "fun_data_picoweb___init____lt_module_gt__jsonify": 229984,
  "const_obj_picoweb___init____lt_module_gt__jsonify_0": 230052,
  "const_table_data_picoweb___init____lt_module_gt__jsonify": 230068,
  "raw_code_picoweb___init____lt_module_gt__jsonify": 230080,
  "fun_data_picoweb___init____lt_module_gt__start_response": 230112,
  "const_obj_picoweb___init____lt_module_gt__start_response_0": 230344,
  "const_obj_picoweb___init____lt_module_gt__start_response_1": 230376,
  "const_table_data_picoweb___init____lt_module_gt__start_response": 230400,
  "raw_code_picoweb___init____lt_module_gt__start_response": 230424,
  "fun_data_picoweb___init____lt_module_gt__http_error": 230448,
  "const_table_data_picoweb___init____lt_module_gt__http_error": 230488,
  "raw_code_picoweb___init____lt_module_gt__http_error": 230496,
  "fun_data_picoweb___init____lt_module_gt__HTTPRequest___init__": 230516,
  "const_table_data_picoweb___init____lt_module_gt__HTTPRequest___init__": 230528,
  "raw_code_picoweb___init____lt_module_gt__HTTPRequest___init__": 230532,
  "fun_data_picoweb___init____lt_module_gt__HTTPRequest_read_form_data": 230560,
  "const_obj_picoweb___init____lt_module_gt__HTTPRequest_read_form_data_0": 230636,
  "const_table_data_picoweb___init____lt_module_gt__HTTPRequest_read_form_data": 230652,
  "raw_code_picoweb___init____lt_module_gt__HTTPRequest_read_form_data": 230660,
  "fun_data_picoweb___init____lt_module_gt__HTTPRequest_parse_qs": 230688,
  "const_table_data_picoweb___init____lt_module_gt__HTTPRequest_parse_qs": 230716,
  "raw_code_picoweb___init____lt_module_gt__HTTPRequest_parse_qs": 230720,
  "fun_data_picoweb___init____lt_module_gt__HTTPRequest": 230752,
  "const_table_data_picoweb___init____lt_module_gt__HTTPRequest": 230796,
  "raw_code_picoweb___init____lt_module_gt__HTTPRequest": 230808,
  "fun_data_picoweb___init____lt_module_gt__WebApp___init__": 230832,
  "const_obj_picoweb___init____lt_module_gt__WebApp___init___0": 230980,
  "const_table_data_picoweb___init____lt_module_gt__WebApp___init__": 231008,
  "raw_code_picoweb___init____lt_module_gt__WebApp___init__": 231028,
  "fun_data_picoweb___init____lt_module_gt__WebApp_parse_headers": 231056,
  "const_obj_picoweb___init____lt_module_gt__WebApp_parse_headers_0": 231128,
  "const_obj_picoweb___init____lt_module_gt__WebApp_parse_headers_1": 231148,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_parse_headers": 231168,
  "raw_code_picoweb___init____lt_module_gt__WebApp_parse_headers": 231184,
  "fun_data_picoweb___init____lt_module_gt__WebApp__handle": 231216,
  "const_obj_picoweb___init____lt_module_gt__WebApp__handle_0": 231984,
  "const_obj_picoweb___init____lt_module_gt__WebApp__handle_1": 232000,
  "const_obj_picoweb___init____lt_module_gt__WebApp__handle_2": 232044,
  "const_obj_picoweb___init____lt_module_gt__WebApp__handle_3": 232080,
  "const_obj_picoweb___init____lt_module_gt__WebApp__handle_4": 232096,
  "const_obj_picoweb___init____lt_module_gt__WebApp__handle_5": 232128,
  "const_obj_picoweb___init____lt_module_gt__WebApp__handle_6": 232180,
  "const_table_data_picoweb___init____lt_module_gt__WebApp__handle": 232208,
  "raw_code_picoweb___init____lt_module_gt__WebApp__handle": 232248,
  "fun_data_picoweb___init____lt_module_gt__WebApp_mount": 232272,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_mount": 232304,
  "raw_code_picoweb___init____lt_module_gt__WebApp_mount": 232316,
  "fun_data_picoweb___init____lt_module_gt__WebApp_route__route": 232336,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_route__route": 232368,
  "raw_code_picoweb___init____lt_module_gt__WebApp_route__route": 232384,
  "fun_data_picoweb___init____lt_module_gt__WebApp_route": 232416,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_route": 232444,
  "raw_code_picoweb___init____lt_module_gt__WebApp_route": 232456,
  "fun_data_picoweb___init____lt_module_gt__WebApp_add_url_rule": 232480,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_add_url_rule": 232508,
  "raw_code_picoweb___init____lt_module_gt__WebApp_add_url_rule": 232520,
  "fun_data_picoweb___init____lt_module_gt__WebApp__load_template": 232544,
  "const_table_data_picoweb___init____lt_module_gt__WebApp__load_template": 232604,
  "raw_code_picoweb___init____lt_module_gt__WebApp__load_template": 232612,
  "fun_data_picoweb___init____lt_module_gt__WebApp_render_template": 232640,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_render_template": 232688,
  "raw_code_picoweb___init____lt_module_gt__WebApp_render_template": 232704,
  "fun_data_picoweb___init____lt_module_gt__WebApp_render_str": 232736,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_render_str": 232772,
  "raw_code_picoweb___init____lt_module_gt__WebApp_render_str": 232784,
  "fun_data_picoweb___init____lt_module_gt__WebApp_sendfile": 232816,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_sendfile": 232960,
  "raw_code_picoweb___init____lt_module_gt__WebApp_sendfile": 232980,
  "fun_data_picoweb___init____lt_module_gt__WebApp_handle_static": 233008,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_handle_static": 233080,
  "raw_code_picoweb___init____lt_module_gt__WebApp_handle_static": 233092,
  "fun_data_picoweb___init____lt_module_gt__WebApp_init": 233120,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_init": 233140,
  "raw_code_picoweb___init____lt_module_gt__WebApp_init": 233144,
  "fun_data_picoweb___init____lt_module_gt__WebApp_run": 233168,
  "const_obj_picoweb___init____lt_module_gt__WebApp_run_0": 233388,
  "const_table_data_picoweb___init____lt_module_gt__WebApp_run": 233408,
  "raw_code_picoweb___init____lt_module_gt__WebApp_run": 233436,
  "fun_data_picoweb___init____lt_module_gt__WebApp": 233456,
  "const_table_data_picoweb___init____lt_module_gt__WebApp": 233600,
  "raw_code_picoweb___init____lt_module_gt__WebApp": 233652,
  "fun_data_picoweb___init____lt_module_gt_": 233680,
  "const_table_data_picoweb___init____lt_module_gt_": 233872,
  "raw_code_picoweb___init____lt_module_gt_": 233904,
  "fun_data_picoweb_utils__lt_module_gt__unquote_plus__lt_listcomp_gt_": 233936,
  "const_table_data_picoweb_utils__lt_module_gt__unquote_plus__lt_listcomp_gt_": 233984,
  "raw_code_picoweb_utils__lt_module_gt__unquote_plus__lt_listcomp_gt_": 233988,
  "fun_data_picoweb_utils__lt_module_gt__unquote_plus": 234016,
  "const_table_data_picoweb_utils__lt_module_gt__unquote_plus": 234076,
  "raw_code_picoweb_utils__lt_module_gt__unquote_plus": 234084,
  "fun_data_picoweb_utils__lt_module_gt__parse_qs__lt_listcomp_gt_": 234112,
  "const_table_data_picoweb_utils__lt_module_gt__parse_qs__lt_listcomp_gt_": 234144,
  "raw_code_picoweb_utils__lt_module_gt__parse_qs__lt_listcomp_gt_": 234148,
  "fun_data_picoweb_utils__lt_module_gt__parse_qs": 234176,
  "const_table_data_picoweb_utils__lt_module_gt__parse_qs": 234324,
  "raw_code_picoweb_utils__lt_module_gt__parse_qs": 234332,
  "fun_data_picoweb_utils__lt_module_gt_": 234352,
  "const_table_data_picoweb_utils__lt_module_gt_": 234376,
  "raw_code_picoweb_utils__lt_module_gt_": 234384,
  "fun_data_crt__lt_module_gt___lt_lambda_gt_": 234416,
  "const_table_data_crt__lt_module_gt___lt_lambda_gt_": 234436,
  "raw_code_crt__lt_module_gt___lt_lambda_gt_": 234444,
  "fun_data_crt__lt_module_gt__base_setup": 234464,
  "const_table_data_crt__lt_module_gt__base_setup": 234480,
  "raw_code_crt__lt_module_gt__base_setup": 234484,
  "fun_data_crt__lt_module_gt__base": 234512,
  "const_table_data_crt__lt_module_gt__base": 234556,
  "raw_code_crt__lt_module_gt__base": 234560,
  "fun_data_crt__lt_module_gt__NodePath": 234592,
  "raw_code_crt__lt_module_gt__NodePath": 234624,
  "fun_data_crt__lt_module_gt__Node_setup": 234644,
  "const_table_data_crt__lt_module_gt__Node_setup": 234660,
  "raw_code_crt__lt_module_gt__Node_setup": 234664,
  "fun_data_crt__lt_module_gt__Node_set_tag": 234684,
  "const_table_data_crt__lt_module_gt__Node_set_tag": 234700,
  "raw_code_crt__lt_module_gt__Node_set_tag": 234704,
  "fun_data_crt__lt_module_gt__Node": 234736,
  "const_table_data_crt__lt_module_gt__Node": 234780,
  "raw_code_crt__lt_module_gt__Node": 234788,
  "fun_data_crt__lt_module_gt__root": 234816,
  "raw_code_crt__lt_module_gt__root": 234844,
  "fun_data_crt__lt_module_gt__blit": 234864,
  "raw_code_crt__lt_module_gt__blit": 235032,
  "fun_data_crt__lt_module_gt__taskMgr": 235056,
  "const_table_data_crt__lt_module_gt__taskMgr": 235092,
  "raw_code_crt__lt_module_gt__taskMgr": 235096,
  "fun_data_crt__lt_module_gt__render___enter__": 235120,
  "const_table_data_crt__lt_module_gt__render___enter__": 235144,
  "raw_code_crt__lt_module_gt__render___enter__": 235148,
  "fun_data_crt__lt_module_gt__render___exit__": 235168,
  "const_table_data_crt__lt_module_gt__render___exit__": 235200,
  "raw_code_crt__lt_module_gt__render___exit__": 235204,
  "fun_data_crt__lt_module_gt__render_draw_child": 235232,
  "const_table_data_crt__lt_module_gt__render_draw_child": 235344,
  "raw_code_crt__lt_module_gt__render_draw_child": 235360,
  "fun_data_crt__lt_module_gt__render": 235392,
  "const_table_data_crt__lt_module_gt__render": 235480,
  "raw_code_crt__lt_module_gt__render": 235492,
  "fun_data_crt__lt_module_gt__set_fps": 235520,
  "const_obj_crt__lt_module_gt__set_fps_0": 235592,
  "const_table_data_crt__lt_module_gt__set_fps": 235608,
  "raw_code_crt__lt_module_gt__set_fps": 235616,
  "fun_data_crt__lt_module_gt__npos": 235648,
  "const_table_data_crt__lt_module_gt__npos": 235680,
  "raw_code_crt__lt_module_gt__npos": 235684,
  "fun_data_crt__lt_module_gt__get_x": 235712,
  "const_table_data_crt__lt_module_gt__get_x": 235732,
  "raw_code_crt__lt_module_gt__get_x": 235736,
  "fun_data_crt__lt_module_gt__get_z": 235760,
  "const_table_data_crt__lt_module_gt__get_z": 235780,
  "raw_code_crt__lt_module_gt__get_z": 235784,
  "fun_data_crt__lt_module_gt__set_any": 235808,
  "const_table_data_crt__lt_module_gt__set_any": 235880,
  "raw_code_crt__lt_module_gt__set_any": 235892,
  "fun_data_crt__lt_module_gt__set_x": 235920,
  "const_table_data_crt__lt_module_gt__set_x": 235940,
  "raw_code_crt__lt_module_gt__set_x": 235948,
  "fun_data_crt__lt_module_gt__set_z": 235968,
  "const_table_data_crt__lt_module_gt__set_z": 235988,
  "raw_code_crt__lt_module_gt__set_z": 235996,
  "fun_data_crt__lt_module_gt__set_text": 236016,
  "const_table_data_crt__lt_module_gt__set_text": 236072,
  "raw_code_crt__lt_module_gt__set_text": 236080,
  "fun_data_crt__lt_module_gt_": 236112,
  "const_obj_crt__lt_module_gt__0": 236536,
  "const_table_data_crt__lt_module_gt_": 236560,
  "raw_code_crt__lt_module_gt_": 236628,
  "fun_data_pystone2__lt_module_gt__Record___init__": 236656,
  "const_table_data_pystone2__lt_module_gt__Record___init__": 236704,
  "raw_code_pystone2__lt_module_gt__Record___init__": 236728,
  "fun_data_pystone2__lt_module_gt__Record_copy": 236752,
  "const_table_data_pystone2__lt_module_gt__Record_copy": 236788,
  "raw_code_pystone2__lt_module_gt__Record_copy": 236792,
  "fun_data_pystone2__lt_module_gt__Record": 236816,
  "const_table_data_pystone2__lt_module_gt__Record": 236860,
  "raw_code_pystone2__lt_module_gt__Record": 236868,
  "fun_data_pystone2__lt_module_gt__main": 236896,
  "const_obj_pystone2__lt_module_gt__main_0": 236948,
  "const_obj_pystone2__lt_module_gt__main_1": 236964,
  "const_table_data_pystone2__lt_module_gt__main": 236980,
  "raw_code_pystone2__lt_module_gt__main": 236992,
  "fun_data_pystone2__lt_module_gt__pystones": 237024,
  "const_table_data_pystone2__lt_module_gt__pystones": 237044,
  "raw_code_pystone2__lt_module_gt__pystones": 237048,
  "fun_data_pystone2__lt_module_gt___lt_listcomp_gt_": 237072,
  "const_table_data_pystone2__lt_module_gt___lt_listcomp_gt_": 237104,
  "raw_code_pystone2__lt_module_gt___lt_listcomp_gt_": 237108,
  "fun_data_pystone2__lt_module_gt__Proc0": 237136,
  "const_obj_pystone2__lt_module_gt__Proc0_0": 237512,
  "const_obj_pystone2__lt_module_gt__Proc0_1": 237528,
  "const_obj_pystone2__lt_module_gt__Proc0_2": 237544,
  "const_obj_pystone2__lt_module_gt__Proc0_3": 237560,
  "const_obj_pystone2__lt_module_gt__Proc0_4": 237576,
  "const_table_data_pystone2__lt_module_gt__Proc0": 237600,
  "raw_code_pystone2__lt_module_gt__Proc0": 237624,
  "fun_data_pystone2__lt_module_gt__Proc1": 237648,
  "const_table_data_pystone2__lt_module_gt__Proc1": 237788,
  "raw_code_pystone2__lt_module_gt__Proc1": 237792,
  "fun_data_pystone2__lt_module_gt__Proc2": 237824,
  "const_table_data_pystone2__lt_module_gt__Proc2": 237888,
  "raw_code_pystone2__lt_module_gt__Proc2": 237892,
  "fun_data_pystone2__lt_module_gt__Proc3": 237920,
  "const_table_data_pystone2__lt_module_gt__Proc3": 237976,
  "raw_code_pystone2__lt_module_gt__Proc3": 237980,
  "fun_data_pystone2__lt_module_gt__Proc4": 238000,
  "raw_code_pystone2__lt_module_gt__Proc4": 238036,
  "fun_data_pystone2__lt_module_gt__Proc5": 238064,
  "raw_code_pystone2__lt_module_gt__Proc5": 238092,
  "fun_data_pystone2__lt_module_gt__Proc6": 238112,
  "const_table_data_pystone2__lt_module_gt__Proc6": 238244,
  "raw_code_pystone2__lt_module_gt__Proc6": 238248,
  "fun_data_pystone2__lt_module_gt__Proc7": 238272,
  "const_table_data_pystone2__lt_module_gt__Proc7": 238296,
  "raw_code_pystone2__lt_module_gt__Proc7": 238304,
  "fun_data_pystone2__lt_module_gt__Proc8": 238336,
  "const_table_data_pystone2__lt_module_gt__Proc8": 238448,
  "raw_code_pystone2__lt_module_gt__Proc8": 238464,
  "fun_data_pystone2__lt_module_gt__Func1": 238496,
  "const_table_data_pystone2__lt_module_gt__Func1": 238532,
  "raw_code_pystone2__lt_module_gt__Func1": 238540,
  "fun_data_pystone2__lt_module_gt__Func2": 238560,
  "const_table_data_pystone2__lt_module_gt__Func2": 238672,
  "raw_code_pystone2__lt_module_gt__Func2": 238680,
  "fun_data_pystone2__lt_module_gt__Func3": 238704,
  "const_table_data_pystone2__lt_module_gt__Func3": 238736,
  "raw_code_pystone2__lt_module_gt__Func3": 238740,
  "fun_data_pystone2__lt_module_gt____main___error": 238768,
  "const_obj_pystone2__lt_module_gt____main___error_0": 238840,
  "const_table_data_pystone2__lt_module_gt____main___error": 238856,
  "raw_code_pystone2__lt_module_gt____main___error": 238868,
  "fun_data_pystone2__lt_module_gt____main__": 238896,
  "const_obj_pystone2__lt_module_gt____main___0": 239080,
  "const_obj_pystone2__lt_module_gt____main___1": 239096,
  "const_table_data_pystone2__lt_module_gt____main__": 239112,
  "raw_code_pystone2__lt_module_gt____main__": 239124,
  "fun_data_pystone2__lt_module_gt_": 239152,
  "const_table_data_pystone2__lt_module_gt_": 239456,
  "raw_code_pystone2__lt_module_gt_": 239524,
  "fun_data_stupyde___init____lt_module_gt_": 239552,
  "const_obj_stupyde___init____lt_module_gt__0": 239612,
  "const_table_data_stupyde___init____lt_module_gt_": 239628,
  "raw_code_stupyde___init____lt_module_gt_": 239632,
  "fun_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___init__": 239664,
  "const_table_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___init__": 239700,
  "raw_code_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___init__": 239708,
  "fun_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout_print": 239728,
  "const_table_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout_print": 239768,
  "raw_code_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout_print": 239772,
  "fun_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___enter__": 239792,
  "const_table_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___enter__": 239824,
  "raw_code_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___enter__": 239828,
  "fun_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout_getvalue": 239856,
  "const_table_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout_getvalue": 239904,
  "raw_code_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout_getvalue": 239908,
  "fun_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___exit__": 239936,
  "const_table_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___exit__": 239964,
  "raw_code_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout___exit__": 239968,
  "fun_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout": 240000,
  "const_table_data_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout": 240080,
  "raw_code_stupyde_fixes_contextlib__lt_module_gt__redirect_stdout": 240100,
  "fun_data_stupyde_fixes_contextlib__lt_module_gt_": 240128,
  "const_table_data_stupyde_fixes_contextlib__lt_module_gt_": 240156,
  "raw_code_stupyde_fixes_contextlib__lt_module_gt_": 240160,
  "fun_data_stupyde_fixes_contextvars__lt_module_gt__LookupError": 240192,
  "raw_code_stupyde_fixes_contextvars__lt_module_gt__LookupError": 240216,
  "fun_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar___init__": 240240,
  "const_obj_stupyde_fixes_contextvars__lt_module_gt__ContextVar___init___0": 240360,
  "const_obj_stupyde_fixes_contextvars__lt_module_gt__ContextVar___init___1": 240404,
  "const_table_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar___init__": 240432,
  "raw_code_stupyde_fixes_contextvars__lt_module_gt__ContextVar___init__": 240452,
  "fun_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar_set": 240480,
  "const_table_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar_set": 240508,
  "raw_code_stupyde_fixes_contextvars__lt_module_gt__ContextVar_set": 240516,
  "fun_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar_get": 240544,
  "const_table_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar_get": 240628,
  "raw_code_stupyde_fixes_contextvars__lt_module_gt__ContextVar_get": 240636,
  "fun_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar": 240656,
  "const_table_data_stupyde_fixes_contextvars__lt_module_gt__ContextVar": 240712,
  "raw_code_stupyde_fixes_contextvars__lt_module_gt__ContextVar": 240724,
  "fun_data_stupyde_fixes_contextvars__lt_module_gt_": 240752,
  "const_table_data_stupyde_fixes_contextvars__lt_module_gt_": 240800,
  "raw_code_stupyde_fixes_contextvars__lt_module_gt_": 240808,
  "fun_data_stupyde_fixes_micropython__lt_module_gt____getattr__": 240832,
  "const_table_data_stupyde_fixes_micropython__lt_module_gt____getattr__": 240852,
  "raw_code_stupyde_fixes_micropython__lt_module_gt____getattr__": 240856,
  "fun_data_stupyde_fixes_micropython__lt_module_gt__scheduler": 240880,
  "raw_code_stupyde_fixes_micropython__lt_module_gt__scheduler": 240936,
  "fun_data_stupyde_fixes_micropython__lt_module_gt__schedule": 240960,
  "const_table_data_stupyde_fixes_micropython__lt_module_gt__schedule": 241016,
  "raw_code_stupyde_fixes_micropython__lt_module_gt__schedule": 241024,
  "fun_data_stupyde_fixes_micropython__lt_module_gt__mem_info": 241044,
  "const_obj_stupyde_fixes_micropython__lt_module_gt__mem_info_0": 241204,
  "const_table_data_stupyde_fixes_micropython__lt_module_gt__mem_info": 241220,
  "raw_code_stupyde_fixes_micropython__lt_module_gt__mem_info": 241224,
  "fun_data_stupyde_fixes_micropython__lt_module_gt_": 241248,
  "const_obj_stupyde_fixes_micropython__lt_module_gt__0": 241348,
  "const_obj_stupyde_fixes_micropython__lt_module_gt__1": 241432,
  "const_table_data_stupyde_fixes_micropython__lt_module_gt_": 241456,
  "raw_code_stupyde_fixes_micropython__lt_module_gt_": 241480,
  "fun_data_stupyde_fixes_machine__lt_module_gt_": 241504,
  "const_obj_stupyde_fixes_machine__lt_module_gt__0": 241540,
  "const_obj_stupyde_fixes_machine__lt_module_gt__1": 241592,
  "const_table_data_stupyde_fixes_machine__lt_module_gt_": 241608,
  "raw_code_stupyde_fixes_machine__lt_module_gt_": 241616,
  "fun_data_stupyde_fixes___init____lt_module_gt__fixme": 241648,
  "const_table_data_stupyde_fixes___init____lt_module_gt__fixme": 241728,
  "raw_code_stupyde_fixes___init____lt_module_gt__fixme": 241732,
  "fun_data_stupyde_fixes___init____lt_module_gt__print_exception": 241760,
  "const_table_data_stupyde_fixes___init____lt_module_gt__print_exception": 241792,
  "raw_code_stupyde_fixes___init____lt_module_gt__print_exception": 241800,
  "fun_data_stupyde_fixes___init____lt_module_gt_": 241824,
  "const_obj_stupyde_fixes___init____lt_module_gt__0": 242312,
  "const_obj_stupyde_fixes___init____lt_module_gt__1": 242328,
  "const_obj_stupyde_fixes___init____lt_module_gt__2": 242368,
  "const_obj_stupyde_fixes___init____lt_module_gt__3": 242400,
  "const_table_data_stupyde_fixes___init____lt_module_gt_": 242416,
  "raw_code_stupyde_fixes___init____lt_module_gt_": 242440,
  "fun_data_stupyde_fixes_utime__lt_module_gt__clock": 242464,
  "raw_code_stupyde_fixes_utime__lt_module_gt__clock": 242484,
  "fun_data_stupyde_fixes_utime__lt_module_gt__sleep": 242512,
  "const_obj_stupyde_fixes_utime__lt_module_gt__sleep_0": 242556,
  "const_table_data_stupyde_fixes_utime__lt_module_gt__sleep": 242572,
  "raw_code_stupyde_fixes_utime__lt_module_gt__sleep": 242580,
  "fun_data_stupyde_fixes_utime__lt_module_gt__sleep_ms": 242608,
  "const_table_data_stupyde_fixes_utime__lt_module_gt__sleep_ms": 242632,
  "raw_code_stupyde_fixes_utime__lt_module_gt__sleep_ms": 242636,
  "fun_data_stupyde_fixes_utime__lt_module_gt__sleep_us": 242656,
  "const_table_data_stupyde_fixes_utime__lt_module_gt__sleep_us": 242680,
  "raw_code_stupyde_fixes_utime__lt_module_gt__sleep_us": 242684,
  "fun_data_stupyde_fixes_utime__lt_module_gt__ticks_ms": 242704,
  "raw_code_stupyde_fixes_utime__lt_module_gt__ticks_ms": 242740,
  "fun_data_stupyde_fixes_utime__lt_module_gt__ticks_us": 242768,
  "raw_code_stupyde_fixes_utime__lt_module_gt__ticks_us": 242804,
  "fun_data_stupyde_fixes_utime__lt_module_gt__ticks_add": 242832,
  "const_table_data_stupyde_fixes_utime__lt_module_gt__ticks_add": 242852,
  "raw_code_stupyde_fixes_utime__lt_module_gt__ticks_add": 242860,
  "fun_data_stupyde_fixes_utime__lt_module_gt__ticks_diff": 242880,
  "const_table_data_stupyde_fixes_utime__lt_module_gt__ticks_diff": 242916,
  "raw_code_stupyde_fixes_utime__lt_module_gt__ticks_diff": 242924,
  "fun_data_stupyde_fixes_utime__lt_module_gt_": 242944,
  "const_obj_stupyde_fixes_utime__lt_module_gt__0": 243208,
  "const_table_data_stupyde_fixes_utime__lt_module_gt_": 243232,
  "raw_code_stupyde_fixes_utime__lt_module_gt_": 243268,
  "fun_data_stupyde_fixes_struct__lt_module_gt____getattr__": 243296,
  "const_table_data_stupyde_fixes_struct__lt_module_gt____getattr__": 243316,
  "raw_code_stupyde_fixes_struct__lt_module_gt____getattr__": 243320,
  "fun_data_stupyde_fixes_struct__lt_module_gt_": 243344,
  "const_table_data_stupyde_fixes_struct__lt_module_gt_": 243368,
  "raw_code_stupyde_fixes_struct__lt_module_gt_": 243372,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt____getattr__": 243392,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt____getattr__": 243412,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt____getattr__": 243416,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__pointer": 243440,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__pointer": 243464,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__pointer": 243468,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PTYPE": 243488,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PTYPE": 243512,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__sizeof": 243536,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__sizeof_0": 243920,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__sizeof_1": 243976,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__sizeof_2": 244024,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__sizeof": 244048,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__sizeof": 244072,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__ancestors": 244096,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__ancestors": 244224,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__ancestors": 244228,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__struct_size_get": 244256,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__struct_size_get_0": 244680,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__struct_size_get_1": 244756,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__struct_size_get": 244784,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__struct_size_get": 244800,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__struct_field_get": 244832,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__struct_field_get_0": 245096,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__struct_field_get": 245120,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__struct_field_get": 245136,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__CSpace___init__": 245168,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__CSpace___init__": 245208,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__CSpace___init__": 245220,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__CSpace": 245248,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__CSpace": 245276,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__CSpace": 245280,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT_sizeof": 245312,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT_sizeof": 245340,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT_sizeof": 245344,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT___init__": 245376,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__PT___init___0": 245512,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT___init__": 245536,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT___init__": 245552,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT___int__": 245584,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__PT___int___0": 245696,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT___int__": 245712,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT___int__": 245720,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT___add__": 245744,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT___add__": 245772,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT___add__": 245780,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT_byref": 245808,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT_byref": 245944,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT_byref": 245948,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT___getattr__": 245968,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT___getattr__": 246064,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT___getattr__": 246072,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT___repr__": 246096,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT___repr__": 246152,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT___repr__": 246156,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__PT": 246176,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__PT": 246288,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__PT": 246316,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__POINTER": 246336,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__POINTER": 246476,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__POINTER": 246480,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__c_void_p": 246512,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__c_void_p": 246536,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__c_char_p": 246560,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__c_char_p": 246584,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__Structure": 246608,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__Structure": 246636,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__CFUNCTYPE___init__": 246656,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__CFUNCTYPE___init__": 246676,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__CFUNCTYPE___init__": 246680,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__CFUNCTYPE": 246704,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__CFUNCTYPE": 246740,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__CFUNCTYPE": 246744,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__memmove": 246768,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__memmove": 246804,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__string_at": 246832,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__string_at": 246868,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__Union": 246896,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__Union": 246924,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt___Pointer": 246944,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt___Pointer": 246980,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__convstack": 247008,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__convstack": 247072,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__convstack": 247084,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___init__": 247104,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___init__": 247164,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___init__": 247172,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call____lt_listcomp_gt_": 247200,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call____lt_listcomp_gt_": 247236,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call____lt_listcomp_gt_": 247240,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___func": 247264,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___func": 247304,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___func": 247316,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___func2": 247344,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___func2": 247380,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___func2": 247388,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call__": 247408,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___0": 247796,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___1": 247844,
  "const_obj_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call___2": 247888,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call__": 247904,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder___call__": 247936,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder": 247968,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder": 248004,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt__ctypes_binder": 248012,
  "fun_data_stupyde_fixes_ctypes__lt_module_gt_": 248032,
  "const_table_data_stupyde_fixes_ctypes__lt_module_gt_": 248688,
  "raw_code_stupyde_fixes_ctypes__lt_module_gt_": 248768,
  "fun_data_warnings__lt_module_gt__warn": 248800,
  "const_table_data_warnings__lt_module_gt__warn": 248844,
  "raw_code_warnings__lt_module_gt__warn": 248856,
  "fun_data_warnings__lt_module_gt_": 248880,
  "const_table_data_warnings__lt_module_gt_": 248900,
  "raw_code_warnings__lt_module_gt_": 248904,
  "fun_data_usdl2__lt_module_gt__SDL_version": 248928,
  "raw_code_usdl2__lt_module_gt__SDL_version": 248984,
  "fun_data_usdl2__lt_module_gt___hidden": 249008,
  "raw_code_usdl2__lt_module_gt___hidden": 249032,
  "fun_data_usdl2__lt_module_gt__SDL_RWopsBase": 249056,
  "raw_code_usdl2__lt_module_gt__SDL_RWopsBase": 249080,
  "fun_data_usdl2__lt_module_gt__SDL_RWops": 249104,
  "raw_code_usdl2__lt_module_gt__SDL_RWops": 249196,
  "fun_data_usdl2__lt_module_gt__SDL_Window": 249216,
  "raw_code_usdl2__lt_module_gt__SDL_Window": 249240,
  "fun_data_usdl2__lt_module_gt__SDL_Rect___init__": 249264,
  "const_table_data_usdl2__lt_module_gt__SDL_Rect___init__": 249328,
  "raw_code_usdl2__lt_module_gt__SDL_Rect___init__": 249348,
  "fun_data_usdl2__lt_module_gt__SDL_Rect___repr__": 249376,
  "const_obj_usdl2__lt_module_gt__SDL_Rect___repr___0": 249440,
  "const_table_data_usdl2__lt_module_gt__SDL_Rect___repr__": 249456,
  "raw_code_usdl2__lt_module_gt__SDL_Rect___repr__": 249464,
  "fun_data_usdl2__lt_module_gt__SDL_Rect___copy__": 249488,
  "const_table_data_usdl2__lt_module_gt__SDL_Rect___copy__": 249520,
  "raw_code_usdl2__lt_module_gt__SDL_Rect___copy__": 249524,
  "fun_data_usdl2__lt_module_gt__SDL_Rect___deepcopy__": 249552,
  "const_table_data_usdl2__lt_module_gt__SDL_Rect___deepcopy__": 249584,
  "raw_code_usdl2__lt_module_gt__SDL_Rect___deepcopy__": 249592,
  "fun_data_usdl2__lt_module_gt__SDL_Rect___eq__": 249616,
  "const_table_data_usdl2__lt_module_gt__SDL_Rect___eq__": 249680,
  "raw_code_usdl2__lt_module_gt__SDL_Rect___eq__": 249688,
  "fun_data_usdl2__lt_module_gt__SDL_Rect___ne__": 249712,
  "const_table_data_usdl2__lt_module_gt__SDL_Rect___ne__": 249776,
  "raw_code_usdl2__lt_module_gt__SDL_Rect___ne__": 249784,
  "fun_data_usdl2__lt_module_gt__SDL_Rect": 249808,
  "const_table_data_usdl2__lt_module_gt__SDL_Rect": 249920,
  "raw_code_usdl2__lt_module_gt__SDL_Rect": 249944,
  "fun_data_usdl2__lt_module_gt__get_dll_file": 249968,
  "raw_code_usdl2__lt_module_gt__get_dll_file": 249996,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_": 250016,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_": 250032,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_": 250036,
  "fun_data_usdl2__lt_module_gt__SDL_Keysym": 250064,
  "raw_code_usdl2__lt_module_gt__SDL_Keysym": 250124,
  "fun_data_usdl2__lt_module_gt__SDL_Joystick": 250144,
  "raw_code_usdl2__lt_module_gt__SDL_Joystick": 250168,
  "fun_data_usdl2__lt_module_gt__SDL_JoystickGUID": 250192,
  "raw_code_usdl2__lt_module_gt__SDL_JoystickGUID": 250232,
  "fun_data_usdl2__lt_module_gt__SDL_Finger": 250256,
  "raw_code_usdl2__lt_module_gt__SDL_Finger": 250316,
  "fun_data_usdl2__lt_module_gt___winmsg": 250336,
  "raw_code_usdl2__lt_module_gt___winmsg": 250400,
  "fun_data_usdl2__lt_module_gt___x11msg": 250432,
  "raw_code_usdl2__lt_module_gt___x11msg": 250468,
  "fun_data_usdl2__lt_module_gt___dfbmsg": 250496,
  "raw_code_usdl2__lt_module_gt___dfbmsg": 250532,
  "fun_data_usdl2__lt_module_gt___cocoamsg": 250560,
  "raw_code_usdl2__lt_module_gt___cocoamsg": 250596,
  "fun_data_usdl2__lt_module_gt___uikitmsg": 250624,
  "raw_code_usdl2__lt_module_gt___uikitmsg": 250660,
  "fun_data_usdl2__lt_module_gt___vivantemsg": 250688,
  "raw_code_usdl2__lt_module_gt___vivantemsg": 250724,
  "fun_data_usdl2__lt_module_gt___msg": 250752,
  "raw_code_usdl2__lt_module_gt___msg": 250844,
  "fun_data_usdl2__lt_module_gt__SDL_SysWMmsg": 250864,
  "raw_code_usdl2__lt_module_gt__SDL_SysWMmsg": 250916,
  "fun_data_usdl2__lt_module_gt___wininfo": 250944,
  "raw_code_usdl2__lt_module_gt___wininfo": 250996,
  "fun_data_usdl2__lt_module_gt___winrtinfo": 251024,
  "raw_code_usdl2__lt_module_gt___winrtinfo": 251060,
  "fun_data_usdl2__lt_module_gt___x11info": 251088,
  "raw_code_usdl2__lt_module_gt___x11info": 251136,
  "fun_data_usdl2__lt_module_gt___dfbinfo": 251168,
  "raw_code_usdl2__lt_module_gt___dfbinfo": 251224,
  "fun_data_usdl2__lt_module_gt___cocoainfo": 251248,
  "raw_code_usdl2__lt_module_gt___cocoainfo": 251288,
  "fun_data_usdl2__lt_module_gt___uikitinfo": 251312,
  "const_obj_usdl2__lt_module_gt___uikitinfo_0": 251384,
  "const_obj_usdl2__lt_module_gt___uikitinfo_1": 251412,
  "const_obj_usdl2__lt_module_gt___uikitinfo_2": 251448,
  "const_table_data_usdl2__lt_module_gt___uikitinfo": 251464,
  "raw_code_usdl2__lt_module_gt___uikitinfo": 251476,
  "fun_data_usdl2__lt_module_gt___wl": 251504,
  "const_obj_usdl2__lt_module_gt___wl_0": 251572,
  "const_table_data_usdl2__lt_module_gt___wl": 251588,
  "raw_code_usdl2__lt_module_gt___wl": 251592,
  "fun_data_usdl2__lt_module_gt___mir": 251616,
  "raw_code_usdl2__lt_module_gt___mir": 251664,
  "fun_data_usdl2__lt_module_gt___android": 251696,
  "raw_code_usdl2__lt_module_gt___android": 251744,
  "fun_data_usdl2__lt_module_gt___vivante": 251776,
  "raw_code_usdl2__lt_module_gt___vivante": 251824,
  "fun_data_usdl2__lt_module_gt___info": 251856,
  "raw_code_usdl2__lt_module_gt___info": 251992,
  "fun_data_usdl2__lt_module_gt__SDL_SysWMinfo": 252016,
  "raw_code_usdl2__lt_module_gt__SDL_SysWMinfo": 252072,
  "fun_data_usdl2__lt_module_gt__SDL_CommonEvent": 252096,
  "raw_code_usdl2__lt_module_gt__SDL_CommonEvent": 252140,
  "fun_data_usdl2__lt_module_gt__SDL_DisplayEvent": 252160,
  "raw_code_usdl2__lt_module_gt__SDL_DisplayEvent": 252260,
  "fun_data_usdl2__lt_module_gt__SDL_WindowEvent": 252288,
  "raw_code_usdl2__lt_module_gt__SDL_WindowEvent": 252400,
  "fun_data_usdl2__lt_module_gt__SDL_KeyboardEvent": 252432,
  "raw_code_usdl2__lt_module_gt__SDL_KeyboardEvent": 252532,
  "fun_data_usdl2__lt_module_gt__SDL_TextEditingEvent": 252560,
  "raw_code_usdl2__lt_module_gt__SDL_TextEditingEvent": 252648,
  "fun_data_usdl2__lt_module_gt__SDL_TextInputEvent": 252672,
  "raw_code_usdl2__lt_module_gt__SDL_TextInputEvent": 252740,
  "fun_data_usdl2__lt_module_gt__SDL_MouseMotionEvent": 252768,
  "raw_code_usdl2__lt_module_gt__SDL_MouseMotionEvent": 252880,
  "fun_data_usdl2__lt_module_gt__SDL_MouseButtonEvent": 252912,
  "raw_code_usdl2__lt_module_gt__SDL_MouseButtonEvent": 253032,
  "fun_data_usdl2__lt_module_gt__SDL_MouseWheelEvent": 253056,
  "raw_code_usdl2__lt_module_gt__SDL_MouseWheelEvent": 253148,
  "fun_data_usdl2__lt_module_gt__SDL_JoyAxisEvent": 253168,
  "raw_code_usdl2__lt_module_gt__SDL_JoyAxisEvent": 253280,
  "fun_data_usdl2__lt_module_gt__SDL_JoyBallEvent": 253312,
  "raw_code_usdl2__lt_module_gt__SDL_JoyBallEvent": 253424,
  "fun_data_usdl2__lt_module_gt__SDL_JoyHatEvent": 253456,
  "raw_code_usdl2__lt_module_gt__SDL_JoyHatEvent": 253548,
  "fun_data_usdl2__lt_module_gt__SDL_JoyButtonEvent": 253568,
  "raw_code_usdl2__lt_module_gt__SDL_JoyButtonEvent": 253660,
  "fun_data_usdl2__lt_module_gt__SDL_JoyDeviceEvent": 253680,
  "raw_code_usdl2__lt_module_gt__SDL_JoyDeviceEvent": 253732,
  "fun_data_usdl2__lt_module_gt__SDL_ControllerAxisEvent": 253760,
  "raw_code_usdl2__lt_module_gt__SDL_ControllerAxisEvent": 253872,
  "fun_data_usdl2__lt_module_gt__SDL_ControllerButtonEvent": 253904,
  "raw_code_usdl2__lt_module_gt__SDL_ControllerButtonEvent": 253996,
  "fun_data_usdl2__lt_module_gt__SDL_ControllerDeviceEvent": 254016,
  "raw_code_usdl2__lt_module_gt__SDL_ControllerDeviceEvent": 254068,
  "fun_data_usdl2__lt_module_gt__SDL_AudioDeviceEvent": 254096,
  "raw_code_usdl2__lt_module_gt__SDL_AudioDeviceEvent": 254188,
  "fun_data_usdl2__lt_module_gt__SDL_TouchFingerEvent": 254208,
  "raw_code_usdl2__lt_module_gt__SDL_TouchFingerEvent": 254320,
  "fun_data_usdl2__lt_module_gt__SDL_MultiGestureEvent": 254352,
  "raw_code_usdl2__lt_module_gt__SDL_MultiGestureEvent": 254464,
  "fun_data_usdl2__lt_module_gt__SDL_DollarGestureEvent": 254496,
  "raw_code_usdl2__lt_module_gt__SDL_DollarGestureEvent": 254596,
  "fun_data_usdl2__lt_module_gt__SDL_DropEvent": 254624,
  "raw_code_usdl2__lt_module_gt__SDL_DropEvent": 254684,
  "fun_data_usdl2__lt_module_gt__SDL_SensorEvent": 254704,
  "raw_code_usdl2__lt_module_gt__SDL_SensorEvent": 254768,
  "fun_data_usdl2__lt_module_gt__SDL_QuitEvent": 254800,
  "raw_code_usdl2__lt_module_gt__SDL_QuitEvent": 254844,
  "fun_data_usdl2__lt_module_gt__SDL_OSEvent": 254864,
  "raw_code_usdl2__lt_module_gt__SDL_OSEvent": 254908,
  "fun_data_usdl2__lt_module_gt__SDL_UserEvent": 254928,
  "raw_code_usdl2__lt_module_gt__SDL_UserEvent": 255012,
  "fun_data_usdl2__lt_module_gt__SDL_SysWMEvent": 255040,
  "raw_code_usdl2__lt_module_gt__SDL_SysWMEvent": 255100,
  "fun_data_usdl2__lt_module_gt__SDL_Event": 255120,
  "raw_code_usdl2__lt_module_gt__SDL_Event": 255408,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_2": 255440,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_2": 255460,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_2": 255464,
  "fun_data_usdl2__lt_module_gt__SDL_QuitRequested": 255488,
  "raw_code_usdl2__lt_module_gt__SDL_QuitRequested": 255524,
  "fun_data_usdl2__lt_module_gt__SDL_TICKS_PASSED": 255544,
  "const_table_data_usdl2__lt_module_gt__SDL_TICKS_PASSED": 255560,
  "raw_code_usdl2__lt_module_gt__SDL_TICKS_PASSED": 255568,
  "fun_data_usdl2__lt_module_gt__SDL_VERSION": 255600,
  "const_table_data_usdl2__lt_module_gt__SDL_VERSION": 255636,
  "raw_code_usdl2__lt_module_gt__SDL_VERSION": 255640,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_3": 255664,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_3": 255688,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_3": 255700,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_4": 255728,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_4": 255752,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_4": 255764,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_5": 255792,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_5": 255820,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_5": 255824,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_6": 255856,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_6": 255904,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_6": 255908,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_7": 255936,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_7": 255980,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_7": 255984,
  "fun_data_usdl2__lt_module_gt__SDL_SwapFloat": 256016,
  "const_table_data_usdl2__lt_module_gt__SDL_SwapFloat": 256056,
  "raw_code_usdl2__lt_module_gt__SDL_SwapFloat": 256060,
  "fun_data_usdl2__lt_module_gt___nop": 256080,
  "const_table_data_usdl2__lt_module_gt___nop": 256092,
  "raw_code_usdl2__lt_module_gt___nop": 256096,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_8": 256128,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_8": 256176,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_8": 256192,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_9": 256224,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_9": 256272,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_9": 256292,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_10": 256312,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_10": 256328,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_10": 256332,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_11": 256352,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_11": 256368,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_11": 256372,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_12": 256392,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_12": 256408,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_12": 256412,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_13": 256432,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_13": 256448,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_13": 256452,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_14": 256480,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_14": 256500,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_14": 256504,
  "fun_data_usdl2__lt_module_gt__SDL_BYTESPERPIXEL": 256528,
  "const_table_data_usdl2__lt_module_gt__SDL_BYTESPERPIXEL": 256588,
  "raw_code_usdl2__lt_module_gt__SDL_BYTESPERPIXEL": 256592,
  "fun_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_INDEXED": 256624,
  "const_table_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_INDEXED": 256684,
  "raw_code_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_INDEXED": 256688,
  "fun_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_PACKED": 256720,
  "const_table_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_PACKED": 256780,
  "raw_code_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_PACKED": 256784,
  "fun_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_ARRAY": 256816,
  "const_table_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_ARRAY": 256904,
  "raw_code_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_ARRAY": 256908,
  "fun_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_ALPHA": 256928,
  "const_table_data_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_ALPHA": 257068,
  "raw_code_usdl2__lt_module_gt__SDL_ISPIXELFORMAT_ALPHA": 257072,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_15": 257104,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_15": 257128,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_15": 257132,
  "fun_data_usdl2__lt_module_gt__SDL_Color___init__": 257152,
  "const_table_data_usdl2__lt_module_gt__SDL_Color___init__": 257216,
  "raw_code_usdl2__lt_module_gt__SDL_Color___init__": 257236,
  "fun_data_usdl2__lt_module_gt__SDL_Color___repr__": 257264,
  "const_obj_usdl2__lt_module_gt__SDL_Color___repr___0": 257332,
  "const_table_data_usdl2__lt_module_gt__SDL_Color___repr__": 257348,
  "raw_code_usdl2__lt_module_gt__SDL_Color___repr__": 257356,
  "fun_data_usdl2__lt_module_gt__SDL_Color___copy__": 257376,
  "const_table_data_usdl2__lt_module_gt__SDL_Color___copy__": 257408,
  "raw_code_usdl2__lt_module_gt__SDL_Color___copy__": 257412,
  "fun_data_usdl2__lt_module_gt__SDL_Color___deepcopy__": 257440,
  "const_table_data_usdl2__lt_module_gt__SDL_Color___deepcopy__": 257472,
  "raw_code_usdl2__lt_module_gt__SDL_Color___deepcopy__": 257480,
  "fun_data_usdl2__lt_module_gt__SDL_Color___eq__": 257504,
  "const_table_data_usdl2__lt_module_gt__SDL_Color___eq__": 257560,
  "raw_code_usdl2__lt_module_gt__SDL_Color___eq__": 257568,
  "fun_data_usdl2__lt_module_gt__SDL_Color___ne__": 257600,
  "const_table_data_usdl2__lt_module_gt__SDL_Color___ne__": 257656,
  "raw_code_usdl2__lt_module_gt__SDL_Color___ne__": 257664,
  "fun_data_usdl2__lt_module_gt__SDL_Color": 257696,
  "const_table_data_usdl2__lt_module_gt__SDL_Color": 257824,
  "raw_code_usdl2__lt_module_gt__SDL_Color": 257848,
  "fun_data_usdl2__lt_module_gt__SDL_Palette": 257872,
  "raw_code_usdl2__lt_module_gt__SDL_Palette": 257940,
  "fun_data_usdl2__lt_module_gt__SDL_PixelFormat": 257968,
  "raw_code_usdl2__lt_module_gt__SDL_PixelFormat": 257992,
  "fun_data_usdl2__lt_module_gt__SDL_Point___init__": 258016,
  "const_table_data_usdl2__lt_module_gt__SDL_Point___init__": 258056,
  "raw_code_usdl2__lt_module_gt__SDL_Point___init__": 258068,
  "fun_data_usdl2__lt_module_gt__SDL_Point___repr__": 258096,
  "const_obj_usdl2__lt_module_gt__SDL_Point___repr___0": 258144,
  "const_table_data_usdl2__lt_module_gt__SDL_Point___repr__": 258160,
  "raw_code_usdl2__lt_module_gt__SDL_Point___repr__": 258168,
  "fun_data_usdl2__lt_module_gt__SDL_Point___copy__": 258192,
  "const_table_data_usdl2__lt_module_gt__SDL_Point___copy__": 258216,
  "raw_code_usdl2__lt_module_gt__SDL_Point___copy__": 258220,
  "fun_data_usdl2__lt_module_gt__SDL_Point___deepcopy__": 258240,
  "const_table_data_usdl2__lt_module_gt__SDL_Point___deepcopy__": 258264,
  "raw_code_usdl2__lt_module_gt__SDL_Point___deepcopy__": 258272,
  "fun_data_usdl2__lt_module_gt__SDL_Point___eq__": 258304,
  "const_table_data_usdl2__lt_module_gt__SDL_Point___eq__": 258336,
  "raw_code_usdl2__lt_module_gt__SDL_Point___eq__": 258344,
  "fun_data_usdl2__lt_module_gt__SDL_Point___ne__": 258368,
  "const_table_data_usdl2__lt_module_gt__SDL_Point___ne__": 258400,
  "raw_code_usdl2__lt_module_gt__SDL_Point___ne__": 258408,
  "fun_data_usdl2__lt_module_gt__SDL_Point": 258432,
  "const_table_data_usdl2__lt_module_gt__SDL_Point": 258528,
  "raw_code_usdl2__lt_module_gt__SDL_Point": 258552,
  "fun_data_usdl2__lt_module_gt__SDL_FPoint___init__": 258576,
  "const_table_data_usdl2__lt_module_gt__SDL_FPoint___init__": 258616,
  "raw_code_usdl2__lt_module_gt__SDL_FPoint___init__": 258628,
  "fun_data_usdl2__lt_module_gt__SDL_FPoint___repr__": 258656,
  "const_obj_usdl2__lt_module_gt__SDL_FPoint___repr___0": 258708,
  "const_table_data_usdl2__lt_module_gt__SDL_FPoint___repr__": 258724,
  "raw_code_usdl2__lt_module_gt__SDL_FPoint___repr__": 258732,
  "fun_data_usdl2__lt_module_gt__SDL_FPoint___copy__": 258752,
  "const_table_data_usdl2__lt_module_gt__SDL_FPoint___copy__": 258776,
  "raw_code_usdl2__lt_module_gt__SDL_FPoint___copy__": 258780,
  "fun_data_usdl2__lt_module_gt__SDL_FPoint___deepcopy__": 258800,
  "const_table_data_usdl2__lt_module_gt__SDL_FPoint___deepcopy__": 258824,
  "raw_code_usdl2__lt_module_gt__SDL_FPoint___deepcopy__": 258832,
  "fun_data_usdl2__lt_module_gt__SDL_FPoint___eq__": 258864,
  "const_table_data_usdl2__lt_module_gt__SDL_FPoint___eq__": 258896,
  "raw_code_usdl2__lt_module_gt__SDL_FPoint___eq__": 258904,
  "fun_data_usdl2__lt_module_gt__SDL_FPoint___ne__": 258928,
  "const_table_data_usdl2__lt_module_gt__SDL_FPoint___ne__": 258960,
  "raw_code_usdl2__lt_module_gt__SDL_FPoint___ne__": 258968,
  "fun_data_usdl2__lt_module_gt__SDL_FPoint": 258992,
  "const_obj_usdl2__lt_module_gt__SDL_FPoint_0": 259080,
  "const_obj_usdl2__lt_module_gt__SDL_FPoint_1": 259096,
  "const_table_data_usdl2__lt_module_gt__SDL_FPoint": 259120,
  "raw_code_usdl2__lt_module_gt__SDL_FPoint": 259152,
  "fun_data_usdl2__lt_module_gt__SDL_FRect___init__": 259184,
  "const_table_data_usdl2__lt_module_gt__SDL_FRect___init__": 259248,
  "raw_code_usdl2__lt_module_gt__SDL_FRect___init__": 259268,
  "fun_data_usdl2__lt_module_gt__SDL_FRect___repr__": 259296,
  "const_obj_usdl2__lt_module_gt__SDL_FRect___repr___0": 259372,
  "const_table_data_usdl2__lt_module_gt__SDL_FRect___repr__": 259388,
  "raw_code_usdl2__lt_module_gt__SDL_FRect___repr__": 259396,
  "fun_data_usdl2__lt_module_gt__SDL_FRect___copy__": 259424,
  "const_table_data_usdl2__lt_module_gt__SDL_FRect___copy__": 259456,
  "raw_code_usdl2__lt_module_gt__SDL_FRect___copy__": 259460,
  "fun_data_usdl2__lt_module_gt__SDL_FRect___deepcopy__": 259488,
  "const_table_data_usdl2__lt_module_gt__SDL_FRect___deepcopy__": 259520,
  "raw_code_usdl2__lt_module_gt__SDL_FRect___deepcopy__": 259528,
  "fun_data_usdl2__lt_module_gt__SDL_FRect___eq__": 259552,
  "const_table_data_usdl2__lt_module_gt__SDL_FRect___eq__": 259616,
  "raw_code_usdl2__lt_module_gt__SDL_FRect___eq__": 259624,
  "fun_data_usdl2__lt_module_gt__SDL_FRect___ne__": 259648,
  "const_table_data_usdl2__lt_module_gt__SDL_FRect___ne__": 259712,
  "raw_code_usdl2__lt_module_gt__SDL_FRect___ne__": 259720,
  "fun_data_usdl2__lt_module_gt__SDL_FRect": 259744,
  "const_obj_usdl2__lt_module_gt__SDL_FRect_0": 259856,
  "const_obj_usdl2__lt_module_gt__SDL_FRect_1": 259872,
  "const_obj_usdl2__lt_module_gt__SDL_FRect_2": 259888,
  "const_obj_usdl2__lt_module_gt__SDL_FRect_3": 259904,
  "const_table_data_usdl2__lt_module_gt__SDL_FRect": 259920,
  "raw_code_usdl2__lt_module_gt__SDL_FRect": 259960,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_16": 259984,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_16": 260016,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_16": 260020,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_17": 260048,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_17": 260104,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_17": 260112,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_18": 260144,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_18": 260212,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_18": 260220,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_19": 260240,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_19": 260260,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_19": 260264,
  "fun_data_usdl2__lt_module_gt__SDL_BlitMap": 260288,
  "raw_code_usdl2__lt_module_gt__SDL_BlitMap": 260312,
  "fun_data_usdl2__lt_module_gt__SDL_Surface": 260336,
  "raw_code_usdl2__lt_module_gt__SDL_Surface": 260484,
  "fun_data_usdl2__lt_module_gt__SDL_DisplayMode___init__": 260512,
  "const_table_data_usdl2__lt_module_gt__SDL_DisplayMode___init__": 260576,
  "raw_code_usdl2__lt_module_gt__SDL_DisplayMode___init__": 260596,
  "fun_data_usdl2__lt_module_gt__SDL_DisplayMode___repr__": 260624,
  "const_obj_usdl2__lt_module_gt__SDL_DisplayMode___repr___0": 260712,
  "const_table_data_usdl2__lt_module_gt__SDL_DisplayMode___repr__": 260728,
  "raw_code_usdl2__lt_module_gt__SDL_DisplayMode___repr__": 260736,
  "fun_data_usdl2__lt_module_gt__SDL_DisplayMode___eq__": 260768,
  "const_table_data_usdl2__lt_module_gt__SDL_DisplayMode___eq__": 260824,
  "raw_code_usdl2__lt_module_gt__SDL_DisplayMode___eq__": 260832,
  "fun_data_usdl2__lt_module_gt__SDL_DisplayMode___ne__": 260864,
  "const_table_data_usdl2__lt_module_gt__SDL_DisplayMode___ne__": 260920,
  "raw_code_usdl2__lt_module_gt__SDL_DisplayMode___ne__": 260928,
  "fun_data_usdl2__lt_module_gt__SDL_DisplayMode": 260960,
  "const_obj_usdl2__lt_module_gt__SDL_DisplayMode_0": 261076,
  "const_table_data_usdl2__lt_module_gt__SDL_DisplayMode": 261104,
  "raw_code_usdl2__lt_module_gt__SDL_DisplayMode": 261124,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_20": 261152,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_20": 261168,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_20": 261172,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_21": 261200,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_21": 261224,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_21": 261228,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_22": 261248,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_22": 261268,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_22": 261272,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_23": 261296,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_23": 261320,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_23": 261324,
  "fun_data_usdl2__lt_module_gt__SDL_RendererInfo": 261344,
  "const_obj_usdl2__lt_module_gt__SDL_RendererInfo_0": 261448,
  "const_obj_usdl2__lt_module_gt__SDL_RendererInfo_1": 261480,
  "const_obj_usdl2__lt_module_gt__SDL_RendererInfo_2": 261516,
  "const_obj_usdl2__lt_module_gt__SDL_RendererInfo_3": 261552,
  "const_table_data_usdl2__lt_module_gt__SDL_RendererInfo": 261568,
  "raw_code_usdl2__lt_module_gt__SDL_RendererInfo": 261584,
  "fun_data_usdl2__lt_module_gt__SDL_Renderer": 261616,
  "raw_code_usdl2__lt_module_gt__SDL_Renderer": 261644,
  "fun_data_usdl2__lt_module_gt__SDL_Texture": 261664,
  "raw_code_usdl2__lt_module_gt__SDL_Texture": 261692,
  "fun_data_usdl2__lt_module_gt___lt_lambda_gt_24": 261712,
  "const_table_data_usdl2__lt_module_gt___lt_lambda_gt_24": 261736,
  "raw_code_usdl2__lt_module_gt___lt_lambda_gt_24": 261740,
  "fun_data_usdl2__lt_module_gt__rw_from_object__rwsize": 261760,
  "const_table_data_usdl2__lt_module_gt__rw_from_object__rwsize": 261884,
  "raw_code_usdl2__lt_module_gt__rw_from_object__rwsize": 261892,
  "fun_data_usdl2__lt_module_gt__rw_from_object__rwseek": 261920,
  "const_table_data_usdl2__lt_module_gt__rw_from_object__rwseek": 262000,
  "raw_code_usdl2__lt_module_gt__rw_from_object__rwseek": 262016,
  "fun_data_usdl2__lt_module_gt__rw_from_object__rwread": 262048,
  "const_table_data_usdl2__lt_module_gt__rw_from_object__rwread": 262144,
  "raw_code_usdl2__lt_module_gt__rw_from_object__rwread": 262164,
  "fun_data_usdl2__lt_module_gt__rw_from_object__rwclose": 262192,
  "const_table_data_usdl2__lt_module_gt__rw_from_object__rwclose": 262252,
  "raw_code_usdl2__lt_module_gt__rw_from_object__rwclose": 262260,
  "fun_data_usdl2__lt_module_gt__rw_from_object__rwwrite": 262288,
  "const_table_data_usdl2__lt_module_gt__rw_from_object__rwwrite": 262416,
  "raw_code_usdl2__lt_module_gt__rw_from_object__rwwrite": 262436,
  "fun_data_usdl2__lt_module_gt__rw_from_object": 262464,
  "const_obj_usdl2__lt_module_gt__rw_from_object_0": 262756,
  "const_obj_usdl2__lt_module_gt__rw_from_object_1": 262816,
  "const_obj_usdl2__lt_module_gt__rw_from_object_2": 262872,
  "const_table_data_usdl2__lt_module_gt__rw_from_object": 262896,
  "raw_code_usdl2__lt_module_gt__rw_from_object": 262932,
  "fun_data_usdl2__lt_module_gt___ptr2obj": 262960,
  "const_table_data_usdl2__lt_module_gt___ptr2obj": 262996,
  "raw_code_usdl2__lt_module_gt___ptr2obj": 263000,
  "fun_data_usdl2__lt_module_gt__SDL_LoadBMP": 263024,
  "const_obj_usdl2__lt_module_gt__SDL_LoadBMP_0": 263056,
  "const_table_data_usdl2__lt_module_gt__SDL_LoadBMP": 263072,
  "raw_code_usdl2__lt_module_gt__SDL_LoadBMP": 263080,
  "fun_data_usdl2__lt_module_gt__SDL_SaveBMP": 263104,
  "const_obj_usdl2__lt_module_gt__SDL_SaveBMP_0": 263136,
  "const_table_data_usdl2__lt_module_gt__SDL_SaveBMP": 263152,
  "raw_code_usdl2__lt_module_gt__SDL_SaveBMP": 263160,
  "fun_data_usdl2__lt_module_gt__SDL_CreateWindow": 263184,
  "const_obj_usdl2__lt_module_gt__SDL_CreateWindow_0": 263300,
  "const_table_data_usdl2__lt_module_gt__SDL_CreateWindow": 263328,
  "raw_code_usdl2__lt_module_gt__SDL_CreateWindow": 263356,
  "fun_data_usdl2__lt_module_gt_": 263376,
  "const_obj_usdl2__lt_module_gt__0": 283100,
  "const_obj_usdl2__lt_module_gt__1": 283124,
  "const_obj_usdl2__lt_module_gt__2": 283156,
  "const_obj_usdl2__lt_module_gt__3": 283188,
  "const_obj_usdl2__lt_module_gt__4": 283248,
  "const_obj_usdl2__lt_module_gt__5": 283300,
  "const_table_data_usdl2__lt_module_gt_": 283328,
  "raw_code_usdl2__lt_module_gt_": 283792,
  "fun_data_imp_empty_pivot_module__lt_module_gt_": 283824,
  "raw_code_imp_empty_pivot_module__lt_module_gt_": 283844,
  "fun_data_pystone1__lt_module_gt__Record___init__": 283872,
  "const_table_data_pystone1__lt_module_gt__Record___init__": 283920,
  "raw_code_pystone1__lt_module_gt__Record___init__": 283944,
  "fun_data_pystone1__lt_module_gt__Record_copy": 283968,
  "const_table_data_pystone1__lt_module_gt__Record_copy": 284004,
  "raw_code_pystone1__lt_module_gt__Record_copy": 284008,
  "fun_data_pystone1__lt_module_gt__Record": 284032,
  "const_table_data_pystone1__lt_module_gt__Record": 284076,
  "raw_code_pystone1__lt_module_gt__Record": 284084,
  "fun_data_pystone1__lt_module_gt__main": 284112,
  "const_table_data_pystone1__lt_module_gt__main": 284148,
  "raw_code_pystone1__lt_module_gt__main": 284152,
  "fun_data_pystone1__lt_module_gt__pystones": 284176,
  "const_table_data_pystone1__lt_module_gt__pystones": 284196,
  "raw_code_pystone1__lt_module_gt__pystones": 284200,
  "fun_data_pystone1__lt_module_gt___lt_listcomp_gt_": 284224,
  "const_table_data_pystone1__lt_module_gt___lt_listcomp_gt_": 284256,
  "raw_code_pystone1__lt_module_gt___lt_listcomp_gt_": 284260,
  "fun_data_pystone1__lt_module_gt__Proc0": 284288,
  "const_obj_pystone1__lt_module_gt__Proc0_0": 284664,
  "const_obj_pystone1__lt_module_gt__Proc0_1": 284680,
  "const_obj_pystone1__lt_module_gt__Proc0_2": 284696,
  "const_obj_pystone1__lt_module_gt__Proc0_3": 284712,
  "const_obj_pystone1__lt_module_gt__Proc0_4": 284728,
  "const_table_data_pystone1__lt_module_gt__Proc0": 284752,
  "raw_code_pystone1__lt_module_gt__Proc0": 284776,
  "fun_data_pystone1__lt_module_gt__Proc1": 284800,
  "const_table_data_pystone1__lt_module_gt__Proc1": 284940,
  "raw_code_pystone1__lt_module_gt__Proc1": 284944,
  "fun_data_pystone1__lt_module_gt__Proc2": 284976,
  "const_table_data_pystone1__lt_module_gt__Proc2": 285040,
  "raw_code_pystone1__lt_module_gt__Proc2": 285044,
  "fun_data_pystone1__lt_module_gt__Proc3": 285072,
  "const_table_data_pystone1__lt_module_gt__Proc3": 285128,
  "raw_code_pystone1__lt_module_gt__Proc3": 285132,
  "fun_data_pystone1__lt_module_gt__Proc4": 285152,
  "raw_code_pystone1__lt_module_gt__Proc4": 285188,
  "fun_data_pystone1__lt_module_gt__Proc5": 285216,
  "raw_code_pystone1__lt_module_gt__Proc5": 285244,
  "fun_data_pystone1__lt_module_gt__Proc6": 285264,
  "const_table_data_pystone1__lt_module_gt__Proc6": 285396,
  "raw_code_pystone1__lt_module_gt__Proc6": 285400,
  "fun_data_pystone1__lt_module_gt__Proc7": 285424,
  "const_table_data_pystone1__lt_module_gt__Proc7": 285448,
  "raw_code_pystone1__lt_module_gt__Proc7": 285456,
  "fun_data_pystone1__lt_module_gt__Proc8": 285488,
  "const_table_data_pystone1__lt_module_gt__Proc8": 285600,
  "raw_code_pystone1__lt_module_gt__Proc8": 285616,
  "fun_data_pystone1__lt_module_gt__Func1": 285648,
  "const_table_data_pystone1__lt_module_gt__Func1": 285684,
  "raw_code_pystone1__lt_module_gt__Func1": 285692,
  "fun_data_pystone1__lt_module_gt__Func2": 285712,
  "const_table_data_pystone1__lt_module_gt__Func2": 285824,
  "raw_code_pystone1__lt_module_gt__Func2": 285832,
  "fun_data_pystone1__lt_module_gt__Func3": 285856,
  "const_table_data_pystone1__lt_module_gt__Func3": 285888,
  "raw_code_pystone1__lt_module_gt__Func3": 285892,
  "fun_data_pystone1__lt_module_gt____main___error": 285920,
  "const_obj_pystone1__lt_module_gt____main___error_0": 285992,
  "const_table_data_pystone1__lt_module_gt____main___error": 286008,
  "raw_code_pystone1__lt_module_gt____main___error": 286020,
  "fun_data_pystone1__lt_module_gt____main__": 286048,
  "const_obj_pystone1__lt_module_gt____main___0": 286224,
  "const_obj_pystone1__lt_module_gt____main___1": 286240,
  "const_table_data_pystone1__lt_module_gt____main__": 286256,
  "raw_code_pystone1__lt_module_gt____main__": 286268,
  "fun_data_pystone1__lt_module_gt_": 286288,
  "const_table_data_pystone1__lt_module_gt_": 286672,
  "raw_code_pystone1__lt_module_gt_": 286740,
  "fun_data_uart_input__lt_module_gt__state": 286768,
  "raw_code_uart_input__lt_module_gt__state": 286792,
  "fun_data_uart_input__lt_module_gt__ainput": 286816,
  "const_obj_uart_input__lt_module_gt__ainput_0": 287184,
  "const_table_data_uart_input__lt_module_gt__ainput": 287200,
  "raw_code_uart_input__lt_module_gt__ainput": 287224,
  "fun_data_uart_input__lt_module_gt_": 287248,
  "const_table_data_uart_input__lt_module_gt_": 287336,
  "raw_code_uart_input__lt_module_gt_": 287344,
  "fun_data_uart___init____lt_module_gt__begin": 287376,
  "raw_code_uart___init____lt_module_gt__begin": 287412,
  "fun_data_uart___init____lt_module_gt__end": 287440,
  "raw_code_uart___init____lt_module_gt__end": 287480,
  "fun_data_uart___init____lt_module_gt__echo": 287504,
  "const_table_data_uart___init____lt_module_gt__echo": 287552,
  "raw_code_uart___init____lt_module_gt__echo": 287556,
  "fun_data_uart___init____lt_module_gt__begin2": 287576,
  "raw_code_uart___init____lt_module_gt__begin2": 287588,
  "fun_data_uart___init____lt_module_gt__end2": 287608,
  "raw_code_uart___init____lt_module_gt__end2": 287620,
  "fun_data_uart___init____lt_module_gt__echo2": 287648,
  "const_table_data_uart___init____lt_module_gt__echo2": 287684,
  "raw_code_uart___init____lt_module_gt__echo2": 287688,
  "fun_data_uart___init____lt_module_gt_": 287712,
  "const_obj_uart___init____lt_module_gt__0": 287852,
  "const_table_data_uart___init____lt_module_gt_": 287872,
  "raw_code_uart___init____lt_module_gt_": 287900,
  "fun_data_uart_output__lt_module_gt__NodePath__lt_lambda_gt_": 287920,
  "const_table_data_uart_output__lt_module_gt__NodePath__lt_lambda_gt_": 287932,
  "raw_code_uart_output__lt_module_gt__NodePath__lt_lambda_gt_": 287936,
  "fun_data_uart_output__lt_module_gt__NodePath___init__": 287968,
  "const_table_data_uart_output__lt_module_gt__NodePath___init__": 288128,
  "raw_code_uart_output__lt_module_gt__NodePath___init__": 288144,
  "fun_data_uart_output__lt_module_gt__NodePath": 288176,
  "const_table_data_uart_output__lt_module_gt__NodePath": 288224,
  "raw_code_uart_output__lt_module_gt__NodePath": 288232,
  "fun_data_uart_output__lt_module_gt__npos": 288256,
  "const_table_data_uart_output__lt_module_gt__npos": 288288,
  "raw_code_uart_output__lt_module_gt__npos": 288292,
  "fun_data_uart_output__lt_module_gt__get_x": 288320,
  "const_table_data_uart_output__lt_module_gt__get_x": 288340,
  "raw_code_uart_output__lt_module_gt__get_x": 288344,
  "fun_data_uart_output__lt_module_gt__get_z": 288368,
  "const_table_data_uart_output__lt_module_gt__get_z": 288388,
  "raw_code_uart_output__lt_module_gt__get_z": 288392,
  "fun_data_uart_output__lt_module_gt__set_any": 288416,
  "const_table_data_uart_output__lt_module_gt__set_any": 288492,
  "raw_code_uart_output__lt_module_gt__set_any": 288504,
  "fun_data_uart_output__lt_module_gt__set_x": 288528,
  "const_table_data_uart_output__lt_module_gt__set_x": 288548,
  "raw_code_uart_output__lt_module_gt__set_x": 288556,
  "fun_data_uart_output__lt_module_gt__set_z": 288576,
  "const_table_data_uart_output__lt_module_gt__set_z": 288596,
  "raw_code_uart_output__lt_module_gt__set_z": 288604,
  "fun_data_uart_output__lt_module_gt__set_text": 288624,
  "const_table_data_uart_output__lt_module_gt__set_text": 288684,
  "raw_code_uart_output__lt_module_gt__set_text": 288692,
  "fun_data_uart_output__lt_module_gt__Node___init__": 288720,
  "const_table_data_uart_output__lt_module_gt__Node___init__": 288768,
  "raw_code_uart_output__lt_module_gt__Node___init__": 288776,
  "fun_data_uart_output__lt_module_gt__Node": 288800,
  "const_table_data_uart_output__lt_module_gt__Node": 288836,
  "raw_code_uart_output__lt_module_gt__Node": 288840,
  "fun_data_uart_output__lt_module_gt__render___init__": 288864,
  "const_table_data_uart_output__lt_module_gt__render___init__": 288904,
  "raw_code_uart_output__lt_module_gt__render___init__": 288908,
  "fun_data_uart_output__lt_module_gt__render___enter__": 288928,
  "const_table_data_uart_output__lt_module_gt__render___enter__": 288952,
  "raw_code_uart_output__lt_module_gt__render___enter__": 288956,
  "fun_data_uart_output__lt_module_gt__render___exit__": 288976,
  "const_table_data_uart_output__lt_module_gt__render___exit__": 289000,
  "raw_code_uart_output__lt_module_gt__render___exit__": 289004,
  "fun_data_uart_output__lt_module_gt__render_draw_child": 289024,
  "const_table_data_uart_output__lt_module_gt__render_draw_child": 289104,
  "raw_code_uart_output__lt_module_gt__render_draw_child": 289120,
  "fun_data_uart_output__lt_module_gt__render___call__": 289152,
  "const_table_data_uart_output__lt_module_gt__render___call__": 289312,
  "raw_code_uart_output__lt_module_gt__render___call__": 289332,
  "fun_data_uart_output__lt_module_gt__render": 289360,
  "const_table_data_uart_output__lt_module_gt__render": 289472,
  "raw_code_uart_output__lt_module_gt__render": 289492,
  "fun_data_uart_output__lt_module_gt_": 289520,
  "const_table_data_uart_output__lt_module_gt_": 289664,
  "raw_code_uart_output__lt_module_gt_": 289704,
  "fun_data_imp_app__lt_module_gt__print": 289728,
  "raw_code_imp_app__lt_module_gt__print": 289844,
  "fun_data_imp_app__lt_module_gt__reload": 289872,
  "raw_code_imp_app__lt_module_gt__reload": 290064,
  "fun_data_imp_app__lt_module_gt_": 290096,
  "const_table_data_imp_app__lt_module_gt_": 290188,
  "raw_code_imp_app__lt_module_gt_": 290196,
  "fun_data_m1__lt_module_gt_": 290224,
  "raw_code_m1__lt_module_gt_": 290252,
  "fun_data_uasyncio_asyncify__lt_module_gt_": 290272,
  "const_obj_uasyncio_asyncify__lt_module_gt__0": 290332,
  "const_table_data_uasyncio_asyncify__lt_module_gt_": 290348,
  "raw_code_uasyncio_asyncify__lt_module_gt_": 290352,
  "fun_data_uasyncio___init____lt_module_gt___lt_lambda_gt_": 290372,
  "raw_code_uasyncio___init____lt_module_gt___lt_lambda_gt_": 290388,
  "fun_data_uasyncio___init____lt_module_gt__task": 290416,
  "const_obj_uasyncio___init____lt_module_gt__task_0": 290512,
  "const_table_data_uasyncio___init____lt_module_gt__task": 290528,
  "raw_code_uasyncio___init____lt_module_gt__task": 290536,
  "fun_data_uasyncio___init____lt_module_gt__start": 290560,
  "const_obj_uasyncio___init____lt_module_gt__start_0": 290728,
  "const_obj_uasyncio___init____lt_module_gt__start_1": 290816,
  "const_table_data_uasyncio___init____lt_module_gt__start": 290832,
  "raw_code_uasyncio___init____lt_module_gt__start": 290840,
  "fun_data_uasyncio___init____lt_module_gt____auto__": 290864,
  "const_obj_uasyncio___init____lt_module_gt____auto___0": 290992,
  "const_table_data_uasyncio___init____lt_module_gt____auto__": 291008,
  "raw_code_uasyncio___init____lt_module_gt____auto__": 291012,
  "fun_data_uasyncio___init____lt_module_gt__select_fake_poll_register": 291040,
  "const_table_data_uasyncio___init____lt_module_gt__select_fake_poll_register": 291064,
  "raw_code_uasyncio___init____lt_module_gt__select_fake_poll_register": 291068,
  "fun_data_uasyncio___init____lt_module_gt__select_fake_poll_unregister": 291088,
  "const_table_data_uasyncio___init____lt_module_gt__select_fake_poll_unregister": 291112,
  "raw_code_uasyncio___init____lt_module_gt__select_fake_poll_unregister": 291116,
  "fun_data_uasyncio___init____lt_module_gt__select_fake_poll_ipoll": 291136,
  "raw_code_uasyncio___init____lt_module_gt__select_fake_poll_ipoll": 291152,
  "fun_data_uasyncio___init____lt_module_gt__select_fake_poll": 291184,
  "const_table_data_uasyncio___init____lt_module_gt__select_fake_poll": 291224,
  "raw_code_uasyncio___init____lt_module_gt__select_fake_poll": 291236,
  "fun_data_uasyncio___init____lt_module_gt__select_poll": 291256,
  "const_table_data_uasyncio___init____lt_module_gt__select_poll": 291272,
  "raw_code_uasyncio___init____lt_module_gt__select_poll": 291276,
  "fun_data_uasyncio___init____lt_module_gt__select": 291296,
  "const_table_data_uasyncio___init____lt_module_gt__select": 291352,
  "raw_code_uasyncio___init____lt_module_gt__select": 291360,
  "fun_data_uasyncio___init____lt_module_gt__convert": 291392,
  "const_obj_uasyncio___init____lt_module_gt__convert_0": 291572,
  "const_table_data_uasyncio___init____lt_module_gt__convert": 291588,
  "raw_code_uasyncio___init____lt_module_gt__convert": 291592,
  "fun_data_uasyncio___init____lt_module_gt__iscoroutine": 291616,
  "const_table_data_uasyncio___init____lt_module_gt__iscoroutine": 291636,
  "raw_code_uasyncio___init____lt_module_gt__iscoroutine": 291640,
  "fun_data_uasyncio___init____lt_module_gt__CancelledError": 291664,
  "raw_code_uasyncio___init____lt_module_gt__CancelledError": 291688,
  "fun_data_uasyncio___init____lt_module_gt__TimeoutError": 291712,
  "raw_code_uasyncio___init____lt_module_gt__TimeoutError": 291736,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop___init__": 291760,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop___init__": 291808,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop___init__": 291820,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_time_ms": 291840,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_time_ms": 291860,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_time_ms": 291864,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_create_task": 291888,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_create_task": 291936,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_create_task": 291944,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_call_soon": 291968,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_call_soon": 292020,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_call_soon": 292028,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_call_later": 292048,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_call_later": 292096,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_call_later": 292108,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_call_later_ms": 292128,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_call_later_ms": 292188,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_call_later_ms": 292200,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_call_at_": 292224,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_call_at_": 292256,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_call_at_": 292272,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_wait": 292304,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_wait": 292332,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_wait": 292340,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_run_once": 292368,
  "const_obj_uasyncio___init____lt_module_gt__EventLoop_run_once_0": 293248,
  "const_obj_uasyncio___init____lt_module_gt__EventLoop_run_once_1": 293264,
  "const_obj_uasyncio___init____lt_module_gt__EventLoop_run_once_2": 293296,
  "const_obj_uasyncio___init____lt_module_gt__EventLoop_run_once_3": 293356,
  "const_obj_uasyncio___init____lt_module_gt__EventLoop_run_once_4": 293424,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_run_once": 293440,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_run_once": 293464,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_run_forever": 293488,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_run_forever": 293520,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_run_forever": 293524,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_run_until_complete__run_and_stop": 293552,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_run_until_complete__run_and_stop": 293580,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_run_until_complete__run_and_stop": 293584,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_run_until_complete": 293616,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_run_until_complete": 293656,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_run_until_complete": 293668,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_stop__lt_lambda_gt_": 293696,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_stop__lt_lambda_gt_": 293716,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_stop": 293744,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_stop": 293768,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_stop": 293776,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop_close": 293796,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop_close": 293808,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop_close": 293812,
  "fun_data_uasyncio___init____lt_module_gt__EventLoop": 293840,
  "const_table_data_uasyncio___init____lt_module_gt__EventLoop": 293968,
  "raw_code_uasyncio___init____lt_module_gt__EventLoop": 294020,
  "fun_data_uasyncio___init____lt_module_gt__SysCall___init__": 294048,
  "const_table_data_uasyncio___init____lt_module_gt__SysCall___init__": 294068,
  "raw_code_uasyncio___init____lt_module_gt__SysCall___init__": 294072,
  "fun_data_uasyncio___init____lt_module_gt__SysCall_handle": 294092,
  "const_table_data_uasyncio___init____lt_module_gt__SysCall_handle": 294108,
  "raw_code_uasyncio___init____lt_module_gt__SysCall_handle": 294112,
  "fun_data_uasyncio___init____lt_module_gt__SysCall": 294144,
  "const_table_data_uasyncio___init____lt_module_gt__SysCall": 294180,
  "raw_code_uasyncio___init____lt_module_gt__SysCall": 294188,
  "fun_data_uasyncio___init____lt_module_gt__SysCall1___init__": 294208,
  "const_table_data_uasyncio___init____lt_module_gt__SysCall1___init__": 294224,
  "raw_code_uasyncio___init____lt_module_gt__SysCall1___init__": 294232,
  "fun_data_uasyncio___init____lt_module_gt__SysCall1": 294256,
  "const_table_data_uasyncio___init____lt_module_gt__SysCall1": 294284,
  "raw_code_uasyncio___init____lt_module_gt__SysCall1": 294288,
  "fun_data_uasyncio___init____lt_module_gt__StopLoop": 294320,
  "raw_code_uasyncio___init____lt_module_gt__StopLoop": 294344,
  "fun_data_uasyncio___init____lt_module_gt__IORead": 294368,
  "raw_code_uasyncio___init____lt_module_gt__IORead": 294392,
  "fun_data_uasyncio___init____lt_module_gt__IOWrite": 294416,
  "raw_code_uasyncio___init____lt_module_gt__IOWrite": 294440,
  "fun_data_uasyncio___init____lt_module_gt__IOReadDone": 294464,
  "raw_code_uasyncio___init____lt_module_gt__IOReadDone": 294488,
  "fun_data_uasyncio___init____lt_module_gt__IOWriteDone": 294512,
  "raw_code_uasyncio___init____lt_module_gt__IOWriteDone": 294536,
  "fun_data_uasyncio___init____lt_module_gt__get_event_loop": 294560,
  "const_table_data_uasyncio___init____lt_module_gt__get_event_loop": 294596,
  "raw_code_uasyncio___init____lt_module_gt__get_event_loop": 294604,
  "fun_data_uasyncio___init____lt_module_gt__sleep": 294624,
  "const_table_data_uasyncio___init____lt_module_gt__sleep": 294648,
  "raw_code_uasyncio___init____lt_module_gt__sleep": 294652,
  "fun_data_uasyncio___init____lt_module_gt__SleepMs___init__": 294672,
  "const_table_data_uasyncio___init____lt_module_gt__SleepMs___init__": 294696,
  "raw_code_uasyncio___init____lt_module_gt__SleepMs___init__": 294700,
  "fun_data_uasyncio___init____lt_module_gt__SleepMs___call__": 294720,
  "const_table_data_uasyncio___init____lt_module_gt__SleepMs___call__": 294740,
  "raw_code_uasyncio___init____lt_module_gt__SleepMs___call__": 294748,
  "fun_data_uasyncio___init____lt_module_gt__SleepMs___iter__": 294768,
  "const_table_data_uasyncio___init____lt_module_gt__SleepMs___iter__": 294780,
  "raw_code_uasyncio___init____lt_module_gt__SleepMs___iter__": 294784,
  "fun_data_uasyncio___init____lt_module_gt__SleepMs___next__": 294816,
  "const_table_data_uasyncio___init____lt_module_gt__SleepMs___next__": 294868,
  "raw_code_uasyncio___init____lt_module_gt__SleepMs___next__": 294872,
  "fun_data_uasyncio___init____lt_module_gt__SleepMs": 294896,
  "const_table_data_uasyncio___init____lt_module_gt__SleepMs": 294960,
  "raw_code_uasyncio___init____lt_module_gt__SleepMs": 294976,
  "fun_data_uasyncio___init____lt_module_gt__cancel": 295008,
  "const_table_data_uasyncio___init____lt_module_gt__cancel": 295048,
  "raw_code_uasyncio___init____lt_module_gt__cancel": 295052,
  "fun_data_uasyncio___init____lt_module_gt__TimeoutObj___init__": 295072,
  "const_table_data_uasyncio___init____lt_module_gt__TimeoutObj___init__": 295088,
  "raw_code_uasyncio___init____lt_module_gt__TimeoutObj___init__": 295096,
  "fun_data_uasyncio___init____lt_module_gt__TimeoutObj": 295120,
  "const_table_data_uasyncio___init____lt_module_gt__TimeoutObj": 295148,
  "raw_code_uasyncio___init____lt_module_gt__TimeoutObj": 295152,
  "fun_data_uasyncio___init____lt_module_gt__wait_for_ms_waiter": 295184,
  "const_table_data_uasyncio___init____lt_module_gt__wait_for_ms_waiter": 295208,
  "raw_code_uasyncio___init____lt_module_gt__wait_for_ms_waiter": 295216,
  "fun_data_uasyncio___init____lt_module_gt__wait_for_ms_timeout_func": 295248,
  "const_table_data_uasyncio___init____lt_module_gt__wait_for_ms_timeout_func": 295300,
  "raw_code_uasyncio___init____lt_module_gt__wait_for_ms_timeout_func": 295304,
  "fun_data_uasyncio___init____lt_module_gt__wait_for_ms": 295328,
  "const_table_data_uasyncio___init____lt_module_gt__wait_for_ms": 295392,
  "raw_code_uasyncio___init____lt_module_gt__wait_for_ms": 295408,
  "fun_data_uasyncio___init____lt_module_gt__wait_for": 295440,
  "const_table_data_uasyncio___init____lt_module_gt__wait_for": 295468,
  "raw_code_uasyncio___init____lt_module_gt__wait_for": 295476,
  "fun_data_uasyncio___init____lt_module_gt__coroutine": 295504,
  "const_obj_uasyncio___init____lt_module_gt__coroutine_0": 295580,
  "const_table_data_uasyncio___init____lt_module_gt__coroutine": 295596,
  "raw_code_uasyncio___init____lt_module_gt__coroutine": 295604,
  "fun_data_uasyncio___init____lt_module_gt__Task": 295632,
  "const_table_data_uasyncio___init____lt_module_gt__Task": 295656,
  "raw_code_uasyncio___init____lt_module_gt__Task": 295664,
  "fun_data_uasyncio___init____lt_module_gt___event_loop_class___init__": 295696,
  "const_table_data_uasyncio___init____lt_module_gt___event_loop_class___init__": 295744,
  "raw_code_uasyncio___init____lt_module_gt___event_loop_class___init__": 295756,
  "fun_data_uasyncio___init____lt_module_gt___event_loop_class_add_reader": 295776,
  "const_table_data_uasyncio___init____lt_module_gt___event_loop_class_add_reader": 295844,
  "raw_code_uasyncio___init____lt_module_gt___event_loop_class_add_reader": 295856,
  "fun_data_uasyncio___init____lt_module_gt___event_loop_class_remove_reader": 295888,
  "const_table_data_uasyncio___init____lt_module_gt___event_loop_class_remove_reader": 295924,
  "raw_code_uasyncio___init____lt_module_gt___event_loop_class_remove_reader": 295932,
  "fun_data_uasyncio___init____lt_module_gt___event_loop_class_add_writer": 295952,
  "const_table_data_uasyncio___init____lt_module_gt___event_loop_class_add_writer": 296020,
  "raw_code_uasyncio___init____lt_module_gt___event_loop_class_add_writer": 296032,
  "fun_data_uasyncio___init____lt_module_gt___event_loop_class_remove_writer": 296064,
  "const_table_data_uasyncio___init____lt_module_gt___event_loop_class_remove_writer": 296152,
  "raw_code_uasyncio___init____lt_module_gt___event_loop_class_remove_writer": 296160,
  "fun_data_uasyncio___init____lt_module_gt___event_loop_class_wait": 296192,
  "const_table_data_uasyncio___init____lt_module_gt___event_loop_class_wait": 296316,
  "raw_code_uasyncio___init____lt_module_gt___event_loop_class_wait": 296324,
  "fun_data_uasyncio___init____lt_module_gt___event_loop_class": 296352,
  "const_table_data_uasyncio___init____lt_module_gt___event_loop_class": 296432,
  "raw_code_uasyncio___init____lt_module_gt___event_loop_class": 296456,
  "fun_data_uasyncio___init____lt_module_gt_": 296480,
  "const_obj_uasyncio___init____lt_module_gt__0": 297120,
  "const_obj_uasyncio___init____lt_module_gt__1": 297184,
  "const_obj_uasyncio___init____lt_module_gt__2": 297232,
  "const_table_data_uasyncio___init____lt_module_gt_": 297248,
  "raw_code_uasyncio___init____lt_module_gt_": 297368,
  "fun_data_uasyncio_queues__lt_module_gt__QueueEmpty": 297392,
  "raw_code_uasyncio_queues__lt_module_gt__QueueEmpty": 297416,
  "fun_data_uasyncio_queues__lt_module_gt__QueueFull": 297440,
  "raw_code_uasyncio_queues__lt_module_gt__QueueFull": 297464,
  "fun_data_uasyncio_queues__lt_module_gt__Queue___init__": 297488,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue___init__": 297516,
  "raw_code_uasyncio_queues__lt_module_gt__Queue___init__": 297524,
  "fun_data_uasyncio_queues__lt_module_gt__Queue__get": 297552,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue__get": 297572,
  "raw_code_uasyncio_queues__lt_module_gt__Queue__get": 297576,
  "fun_data_uasyncio_queues__lt_module_gt__Queue_get": 297600,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue_get": 297644,
  "raw_code_uasyncio_queues__lt_module_gt__Queue_get": 297648,
  "fun_data_uasyncio_queues__lt_module_gt__Queue_get_nowait": 297680,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue_get_nowait": 297716,
  "raw_code_uasyncio_queues__lt_module_gt__Queue_get_nowait": 297720,
  "fun_data_uasyncio_queues__lt_module_gt__Queue__put": 297744,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue__put": 297768,
  "raw_code_uasyncio_queues__lt_module_gt__Queue__put": 297776,
  "fun_data_uasyncio_queues__lt_module_gt__Queue_put": 297808,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue_put": 297872,
  "raw_code_uasyncio_queues__lt_module_gt__Queue_put": 297880,
  "fun_data_uasyncio_queues__lt_module_gt__Queue_put_nowait": 297904,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue_put_nowait": 297956,
  "raw_code_uasyncio_queues__lt_module_gt__Queue_put_nowait": 297964,
  "fun_data_uasyncio_queues__lt_module_gt__Queue_qsize": 297984,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue_qsize": 298004,
  "raw_code_uasyncio_queues__lt_module_gt__Queue_qsize": 298008,
  "fun_data_uasyncio_queues__lt_module_gt__Queue_empty": 298032,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue_empty": 298048,
  "raw_code_uasyncio_queues__lt_module_gt__Queue_empty": 298052,
  "fun_data_uasyncio_queues__lt_module_gt__Queue_full": 298080,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue_full": 298120,
  "raw_code_uasyncio_queues__lt_module_gt__Queue_full": 298124,
  "fun_data_uasyncio_queues__lt_module_gt__Queue": 298144,
  "const_obj_uasyncio_queues__lt_module_gt__Queue_0": 298248,
  "const_table_data_uasyncio_queues__lt_module_gt__Queue": 298272,
  "raw_code_uasyncio_queues__lt_module_gt__Queue": 298316,
  "fun_data_uasyncio_queues__lt_module_gt_": 298336,
  "const_table_data_uasyncio_queues__lt_module_gt_": 298424,
  "raw_code_uasyncio_queues__lt_module_gt_": 298436,
  "fun_data_uasyncio_ws_server__lt_module_gt__make_respkey": 298464,
  "const_obj_uasyncio_ws_server__lt_module_gt__make_respkey_0": 298560,
  "const_table_data_uasyncio_ws_server__lt_module_gt__make_respkey": 298576,
  "raw_code_uasyncio_ws_server__lt_module_gt__make_respkey": 298584,
  "fun_data_uasyncio_ws_server__lt_module_gt__WSWriter___init__": 298608,
  "const_table_data_uasyncio_ws_server__lt_module_gt__WSWriter___init__": 298624,
  "raw_code_uasyncio_ws_server__lt_module_gt__WSWriter___init__": 298636,
  "fun_data_uasyncio_ws_server__lt_module_gt__WSWriter_awrite": 298656,
  "const_obj_uasyncio_ws_server__lt_module_gt__WSWriter_awrite_0": 298748,
  "const_table_data_uasyncio_ws_server__lt_module_gt__WSWriter_awrite": 298764,
  "raw_code_uasyncio_ws_server__lt_module_gt__WSWriter_awrite": 298776,
  "fun_data_uasyncio_ws_server__lt_module_gt__WSWriter": 298800,
  "const_table_data_uasyncio_ws_server__lt_module_gt__WSWriter": 298836,
  "raw_code_uasyncio_ws_server__lt_module_gt__WSWriter": 298844,
  "fun_data_uasyncio_ws_server__lt_module_gt__WSReader": 298864,
  "const_obj_uasyncio_ws_server__lt_module_gt__WSReader_0": 299060,
  "const_obj_uasyncio_ws_server__lt_module_gt__WSReader_1": 299096,
  "const_obj_uasyncio_ws_server__lt_module_gt__WSReader_2": 299112,
  "const_obj_uasyncio_ws_server__lt_module_gt__WSReader_3": 299152,
  "const_obj_uasyncio_ws_server__lt_module_gt__WSReader_4": 299268,
  "const_obj_uasyncio_ws_server__lt_module_gt__WSReader_5": 299312,
  "const_table_data_uasyncio_ws_server__lt_module_gt__WSReader": 299328,
  "raw_code_uasyncio_ws_server__lt_module_gt__WSReader": 299360,
  "fun_data_uasyncio_ws_server__lt_module_gt_": 299392,
  "const_table_data_uasyncio_ws_server__lt_module_gt_": 299464,
  "raw_code_uasyncio_ws_server__lt_module_gt_": 299476,
  "fun_data_uasyncio_udp__lt_module_gt__set_debug": 299504,
  "const_obj_uasyncio_udp__lt_module_gt__set_debug_0": 299556,
  "const_table_data_uasyncio_udp__lt_module_gt__set_debug": 299572,
  "raw_code_uasyncio_udp__lt_module_gt__set_debug": 299580,
  "fun_data_uasyncio_udp__lt_module_gt__socket": 299600,
  "const_table_data_uasyncio_udp__lt_module_gt__socket": 299640,
  "raw_code_uasyncio_udp__lt_module_gt__socket": 299644,
  "fun_data_uasyncio_udp__lt_module_gt__recv": 299664,
  "const_table_data_uasyncio_udp__lt_module_gt__recv": 299724,
  "raw_code_uasyncio_udp__lt_module_gt__recv": 299732,
  "fun_data_uasyncio_udp__lt_module_gt__recvfrom": 299760,
  "const_table_data_uasyncio_udp__lt_module_gt__recvfrom": 299820,
  "raw_code_uasyncio_udp__lt_module_gt__recvfrom": 299828,
  "fun_data_uasyncio_udp__lt_module_gt__sendto": 299856,
  "const_obj_uasyncio_udp__lt_module_gt__sendto_0": 299936,
  "const_table_data_uasyncio_udp__lt_module_gt__sendto": 299952,
  "raw_code_uasyncio_udp__lt_module_gt__sendto": 299968,
  "fun_data_uasyncio_udp__lt_module_gt__close": 300000,
  "const_table_data_uasyncio_udp__lt_module_gt__close": 300032,
  "raw_code_uasyncio_udp__lt_module_gt__close": 300036,
  "fun_data_uasyncio_udp__lt_module_gt_": 300064,
  "const_table_data_uasyncio_udp__lt_module_gt_": 300176,
  "raw_code_uasyncio_udp__lt_module_gt_": 300200,
  "fun_data_m3__lt_module_gt_": 300224,
  "raw_code_m3__lt_module_gt_": 300260,
  "fun_data_ulogging__lt_module_gt__Logger___init__": 300288,
  "const_table_data_ulogging__lt_module_gt__Logger___init__": 300304,
  "raw_code_ulogging__lt_module_gt__Logger___init__": 300312,
  "fun_data_ulogging__lt_module_gt__Logger__level_str": 300336,
  "const_table_data_ulogging__lt_module_gt__Logger__level_str": 300376,
  "raw_code_ulogging__lt_module_gt__Logger__level_str": 300384,
  "fun_data_ulogging__lt_module_gt__Logger_setLevel": 300416,
  "const_table_data_ulogging__lt_module_gt__Logger_setLevel": 300432,
  "raw_code_ulogging__lt_module_gt__Logger_setLevel": 300440,
  "fun_data_ulogging__lt_module_gt__Logger_isEnabledFor": 300464,
  "const_table_data_ulogging__lt_module_gt__Logger_isEnabledFor": 300488,
  "raw_code_ulogging__lt_module_gt__Logger_isEnabledFor": 300496,
  "fun_data_ulogging__lt_module_gt__Logger_log": 300528,
  "const_table_data_ulogging__lt_module_gt__Logger_log": 300624,
  "raw_code_ulogging__lt_module_gt__Logger_log": 300636,
  "fun_data_ulogging__lt_module_gt__Logger_debug": 300656,
  "const_table_data_ulogging__lt_module_gt__Logger_debug": 300684,
  "raw_code_ulogging__lt_module_gt__Logger_debug": 300692,
  "fun_data_ulogging__lt_module_gt__Logger_info": 300720,
  "const_table_data_ulogging__lt_module_gt__Logger_info": 300748,
  "raw_code_ulogging__lt_module_gt__Logger_info": 300756,
  "fun_data_ulogging__lt_module_gt__Logger_warning": 300784,
  "const_table_data_ulogging__lt_module_gt__Logger_warning": 300812,
  "raw_code_ulogging__lt_module_gt__Logger_warning": 300820,
  "fun_data_ulogging__lt_module_gt__Logger_error": 300848,
  "const_table_data_ulogging__lt_module_gt__Logger_error": 300876,
  "raw_code_ulogging__lt_module_gt__Logger_error": 300884,
  "fun_data_ulogging__lt_module_gt__Logger_critical": 300912,
  "const_table_data_ulogging__lt_module_gt__Logger_critical": 300940,
  "raw_code_ulogging__lt_module_gt__Logger_critical": 300948,
  "fun_data_ulogging__lt_module_gt__Logger_exc": 300976,
  "const_table_data_ulogging__lt_module_gt__Logger_exc": 301020,
  "raw_code_ulogging__lt_module_gt__Logger_exc": 301032,
  "fun_data_ulogging__lt_module_gt__Logger_exception": 301056,
  "const_table_data_ulogging__lt_module_gt__Logger_exception": 301092,
  "raw_code_ulogging__lt_module_gt__Logger_exception": 301100,
  "fun_data_ulogging__lt_module_gt__Logger": 301120,
  "const_table_data_ulogging__lt_module_gt__Logger": 301232,
  "raw_code_ulogging__lt_module_gt__Logger": 301280,
  "fun_data_ulogging__lt_module_gt__getLogger": 301312,
  "const_table_data_ulogging__lt_module_gt__getLogger": 301356,
  "raw_code_ulogging__lt_module_gt__getLogger": 301360,
  "fun_data_ulogging__lt_module_gt__info": 301392,
  "const_table_data_ulogging__lt_module_gt__info": 301424,
  "raw_code_ulogging__lt_module_gt__info": 301428,
  "fun_data_ulogging__lt_module_gt__debug": 301456,
  "const_table_data_ulogging__lt_module_gt__debug": 301488,
  "raw_code_ulogging__lt_module_gt__debug": 301492,
  "fun_data_ulogging__lt_module_gt__basicConfig": 301520,
  "const_obj_ulogging__lt_module_gt__basicConfig_0": 301636,
  "const_obj_ulogging__lt_module_gt__basicConfig_1": 301704,
  "const_table_data_ulogging__lt_module_gt__basicConfig": 301728,
  "raw_code_ulogging__lt_module_gt__basicConfig": 301752,
  "fun_data_ulogging__lt_module_gt_": 301776,
  "const_table_data_ulogging__lt_module_gt_": 301952,
  "raw_code_ulogging__lt_module_gt_": 301972,
  "fun_data_frozen_mpy__lt_module_gt_": 302000,
  "const_obj_frozen_mpy__lt_module_gt__0": 302120,
  "const_obj_frozen_mpy__lt_module_gt__1": 302148,
  "const_table_data_frozen_mpy__lt_module_gt_": 302164,
  "raw_code_frozen_mpy__lt_module_gt_": 302172,
  "fun_data_urequests__lt_module_gt__Response___init__": 302192,
  "const_table_data_urequests__lt_module_gt__Response___init__": 302224,
  "raw_code_urequests__lt_module_gt__Response___init__": 302232,
  "fun_data_urequests__lt_module_gt__Response_close": 302256,
  "const_table_data_urequests__lt_module_gt__Response_close": 302300,
  "raw_code_urequests__lt_module_gt__Response_close": 302304,
  "fun_data_urequests__lt_module_gt__Response_content": 302336,
  "const_table_data_urequests__lt_module_gt__Response_content": 302400,
  "raw_code_urequests__lt_module_gt__Response_content": 302404,
  "fun_data_urequests__lt_module_gt__Response_text": 302432,
  "const_table_data_urequests__lt_module_gt__Response_text": 302456,
  "raw_code_urequests__lt_module_gt__Response_text": 302460,
  "fun_data_urequests__lt_module_gt__Response_json": 302480,
  "const_table_data_urequests__lt_module_gt__Response_json": 302508,
  "raw_code_urequests__lt_module_gt__Response_json": 302512,
  "fun_data_urequests__lt_module_gt__Response": 302544,
  "const_table_data_urequests__lt_module_gt__Response": 302624,
  "raw_code_urequests__lt_module_gt__Response": 302644,
  "fun_data_urequests__lt_module_gt__request": 302672,
  "const_obj_urequests__lt_module_gt__request_0": 303344,
  "const_obj_urequests__lt_module_gt__request_1": 303380,
  "const_obj_urequests__lt_module_gt__request_2": 303408,
  "const_obj_urequests__lt_module_gt__request_3": 303428,
  "const_obj_urequests__lt_module_gt__request_4": 303444,
  "const_obj_urequests__lt_module_gt__request_5": 303496,
  "const_obj_urequests__lt_module_gt__request_6": 303536,
  "const_obj_urequests__lt_module_gt__request_7": 303552,
  "const_obj_urequests__lt_module_gt__request_8": 303568,
  "const_obj_urequests__lt_module_gt__request_9": 303604,
  "const_obj_urequests__lt_module_gt__request_10": 303628,
  "const_obj_urequests__lt_module_gt__request_11": 303660,
  "const_obj_urequests__lt_module_gt__request_12": 303688,
  "const_obj_urequests__lt_module_gt__request_13": 303732,
  "const_table_data_urequests__lt_module_gt__request": 303760,
  "raw_code_urequests__lt_module_gt__request": 303840,
  "fun_data_urequests__lt_module_gt__head": 303872,
  "const_table_data_urequests__lt_module_gt__head": 303896,
  "raw_code_urequests__lt_module_gt__head": 303900,
  "fun_data_urequests__lt_module_gt__get": 303920,
  "const_table_data_urequests__lt_module_gt__get": 303944,
  "raw_code_urequests__lt_module_gt__get": 303948,
  "fun_data_urequests__lt_module_gt__post": 303968,
  "const_table_data_urequests__lt_module_gt__post": 303992,
  "raw_code_urequests__lt_module_gt__post": 303996,
  "fun_data_urequests__lt_module_gt__put": 304016,
  "const_table_data_urequests__lt_module_gt__put": 304040,
  "raw_code_urequests__lt_module_gt__put": 304044,
  "fun_data_urequests__lt_module_gt__patch": 304064,
  "const_table_data_urequests__lt_module_gt__patch": 304088,
  "raw_code_urequests__lt_module_gt__patch": 304092,
  "fun_data_urequests__lt_module_gt__delete": 304112,
  "const_table_data_urequests__lt_module_gt__delete": 304136,
  "raw_code_urequests__lt_module_gt__delete": 304140,
  "fun_data_urequests__lt_module_gt_": 304160,
  "const_table_data_urequests__lt_module_gt_": 304256,
  "raw_code_urequests__lt_module_gt_": 304288,
  "fun_data_site__lt_module_gt__vars": 304320,
  "const_obj_site__lt_module_gt__vars_0": 304408,
  "const_table_data_site__lt_module_gt__vars": 304424,
  "raw_code_site__lt_module_gt__vars": 304432,
  "fun_data_site__lt_module_gt__await_": 304464,
  "const_table_data_site__lt_module_gt__await_": 304512,
  "raw_code_site__lt_module_gt__await_": 304516,
  "fun_data_site__lt_module_gt__awaited_syscall": 304544,
  "const_table_data_site__lt_module_gt__awaited_syscall": 304580,
  "raw_code_site__lt_module_gt__awaited_syscall": 304584,
  "fun_data_site__lt_module_gt__awaited": 304608,
  "const_table_data_site__lt_module_gt__awaited": 304632,
  "raw_code_site__lt_module_gt__awaited": 304640,
  "fun_data_site__lt_module_gt__sleep": 304672,
  "const_table_data_site__lt_module_gt__sleep": 304744,
  "raw_code_site__lt_module_gt__sleep": 304748,
  "fun_data_site__lt_module_gt__late_repl": 304768,
  "const_obj_site__lt_module_gt__late_repl_0": 304828,
  "const_obj_site__lt_module_gt__late_repl_1": 304864,
  "const_table_data_site__lt_module_gt__late_repl": 304880,
  "raw_code_site__lt_module_gt__late_repl": 304892,
  "fun_data_site__lt_module_gt__noop": 304912,
  "raw_code_site__lt_module_gt__noop": 304928,
  "fun_data_site__lt_module_gt__interact": 304960,
  "raw_code_site__lt_module_gt__interact": 305020,
  "fun_data_site__lt_module_gt_": 305040,
  "const_obj_site__lt_module_gt__0": 305796,
  "const_obj_site__lt_module_gt__1": 305836,
  "const_table_data_site__lt_module_gt_": 305856,
  "raw_code_site__lt_module_gt_": 305892,
  "fun_data_hello__lt_module_gt_": 305920,
  "const_obj_hello__lt_module_gt__0": 305964,
  "const_table_data_hello__lt_module_gt_": 305980,
  "raw_code_hello__lt_module_gt_": 305984,
  "file_open_args": 307280,
  "fdfile___exit___obj": 307236,
  "fdfile_fileno_obj": 307268,
  "fileio_stream_p": 307552,
  "rawfile_locals_dict": 307536,
  "textio_stream_p": 307568,
  "rawfile_locals_dict_table": 307440,
  "mod_os_stat_obj": 307652,
  "mod_os_remove_obj": 307680,
  "mod_os_system_obj": 307708,
  "mod_os_getenv_obj": 307736,
  "mod_os_mkdir_obj": 307764,
  "mod_os_ilistdir_obj": 307796,
  "mod_os_errno_obj": 307828,
  "mp_module_os_globals_table": 307856,
  "mp_module_os_globals": 307928,
  "mod_time_clock_obj": 307968,
  "mod_time_time_obj": 307996,
  "mod_time_time_ns_obj": 308028,
  "mod_time_sleep_obj": 308056,
  "mod_time_sleep_ms_obj": 308088,
  "mod_time_sleep_us_obj": 308120,
  "mod_time_localtime_obj": 308152,
  "mp_module_time_globals_table": 308176,
  "mp_module_time_globals": 308280,
  "ffi_type_sint8": 312144,
  "ffi_type_uint8": 312132,
  "ffi_type_uint16": 312156,
  "ffi_type_uint32": 312180,
  "ffi_type_uint64": 312204,
  "ffi_type_void": 312120,
  "ffi_type_pointer": 312228,
  "ffi_type_double": 312252,
  "ffi_type_float": 312240,
  "ffi_type_sint64": 312216,
  "ffi_type_sint32": 312192,
  "ffi_type_sint16": 312168,
  "ffifunc_type": 308408,
  "fficallback_type": 308548,
  "ffivar_type": 308660,
  "ffimod_type": 308816,
  "ffimod_close_obj": 308396,
  "ffimod_func_obj": 308504,
  "mod_ffi_func_obj": 308536,
  "mod_ffi_callback_obj": 308648,
  "ffivar_locals_dict": 309040,
  "ffimod_var_obj": 308732,
  "ffimod_addr_obj": 308756,
  "ffimod_locals_dict_table": 308768,
  "ffimod_locals_dict": 308800,
  "ffivar_get_obj": 308988,
  "ffivar_set_obj": 309012,
  "ffivar_locals_dict_table": 309024,
  "mod_ffi_open_obj": 309072,
  "mod_ffi_as_bytearray_obj": 309112,
  "mp_module_ffi_globals_table": 309136,
  "mp_module_ffi_globals": 309176,
  "embed_hello_type": 312472,
  "mp_type_on_del": 312532,
  "on_del_del_obj": 312604,
  "embed_hello___del__": 312424,
  "embed_hello_locals_dict_table": 312436,
  "embed_hello_locals_dict": 312444,
  "embed_CLI_obj": 313092,
  "embed_FLAGS_IF_obj": 313124,
  "embed_STI_obj": 313152,
  "embed_WAPY_obj": 313180,
  "embed_builtins_vars_obj": 313216,
  "embed_callsome_obj": 313248,
  "embed_echosum1_obj": 313280,
  "embed_log_obj": 313308,
  "embed_os_compile_obj": 313344,
  "embed_os_hideloop_obj": 313380,
  "embed_os_hook_obj": 313412,
  "embed_os_print_obj": 313444,
  "embed_os_read_useless_obj": 313484,
  "embed_os_showloop_obj": 313520,
  "embed_os_stderr_obj": 313552,
  "embed_os_write_obj": 313584,
  "embed_sdl_obj": 313612,
  "embed_sleep_obj": 313640,
  "embed_sleep_ms_obj": 313672,
  "embed_somecall_obj": 313704,
  "embed_ticks_add_obj": 313736,
  "embed_ticks_period_obj": 313772,
  "embed_time_ms_obj": 313804,
  "embed_time_ns_obj": 313836,
  "embed_globals_table": 313856,
  "mp_module_embed_globals": 314080,
  "example_add_ints_obj": 314240,
  "example_module_globals_table": 314256,
  "example_module_globals": 314272,
  "mp_stderr_print": 314312,
  "pyexec_system_exit": 314304,
  "repl": 314354,
  "pyexec_mode_kind": 314300,
  "pyexec_repl_active": 314551,
  "repl_display_debugging_info": 314308,
  "pyb_set_repl_info_obj": 314600,
  "rl": 314632,
  "EMSCRIPTENAUDIO_bootstrap": 382720,
  "DISKAUDIO_bootstrap": 388652,
  "DUMMYAUDIO_bootstrap": 388932,
  "SDL_Convert_S8_to_F32": 319540,
  "SDL_Convert_U8_to_F32": 319544,
  "SDL_Convert_U16_to_F32": 319552,
  "SDL_Convert_S32_to_F32": 319556,
  "SDL_Convert_S16_to_F32": 319548,
  "SDL_Convert_F32_to_S8": 319560,
  "SDL_Convert_F32_to_U8": 319564,
  "SDL_Convert_F32_to_U16": 319572,
  "SDL_Convert_F32_to_S32": 319576,
  "SDL_Convert_F32_to_S16": 319568,
  "SDL_EMSCRIPTEN_JoystickDriver": 388972,
  "GLES2_RenderDriver": 343896,
  "SW_RenderDriver": 356700,
  "SDL_expand_byte": 373616,
  "SDL_GeneratedBlitFuncTable": 367440,
  "Emscripten_bootstrap": 382368,
  "_floor_P": 921840,
  "_residue_P": 921848,
  "mapping0_exportbundle": 920640,
  "residue0_exportbundle": 920660,
  "residue1_exportbundle": 920692,
  "residue2_exportbundle": 920724,
  "floor1_exportbundle": 920756,
  "_mapping_P": 921860,
  "floor0_exportbundle": 946336,
  "__progname": 960728,
  "__progname_full": 960732,
  "__libc": 960736,
  "__hwcap": 960800,
  "__sysinfo": 960804,
  "program_invocation_short_name": 960728,
  "program_invocation_name": 960732,
  "__optreset": 962112,
  "optind": 962104,
  "__optpos": 962116,
  "optarg": 962120,
  "optopt": 962124,
  "opterr": 962108,
  "optreset": 962112,
  "in6addr_loopback": 962568,
  "h_errno": 962868,
  "in6addr_any": 962952,
  "_ns_flagdata": 963504,
  "__fsmu8": 977616,
  "__pio2_hi": 980480,
  "__pio2_lo": 980496,
  "__signgam": 988712,
  "signgam": 988712,
  "__seed48": 989280,
  "__stdin_used": 992324,
  "__stdout_used": 990412,
  "__stderr_used": 991596,
  "__c_locale": 994128,
  "__c_dot_utf8_locale": 994152,
  "__c_dot_utf8": 994100,
  "__environ": 1119652,
  "___environ": 1119652,
  "_environ": 1119652,
  "environ": 1119652,
  "__env_map": 1119660,
  "tzname": 1119664,
  "daylight": 1119672,
  "timezone": 1119676,
  "atanlo": 1123952,
  "atanhi": 1123888,
  "aT": 1124016,
  "__dso_handle": 0,
  "__data_end": 1128282
};
for (var named in NAMED_GLOBALS) {
  Module['_' + named] = gb + NAMED_GLOBALS[named];
}
Module['NAMED_GLOBALS'] = NAMED_GLOBALS;

for (var named in NAMED_GLOBALS) {
  (function(named) {
    var addr = Module['_' + named];
    Module['g$_' + named] = function() { return addr };
  })(named);
}

Module['_fp$nlr_push_tail$ii'] = function() {
  
  assert(Module["_nlr_push_tail"] || typeof _nlr_push_tail !== "undefined", "external function `nlr_push_tail` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['nlr_push_tail'];
  // Try an original version from a side module.
  if (!func) func = Module['_nlr_push_tail'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_nlr_push_tail'];
  if (!func) func = _nlr_push_tail;
  var fp = addFunction(func, 'ii');
  Module['_fp$nlr_push_tail$ii'] = function() { return fp };
  return fp;
}


Module['_fp$nlr_pop$v'] = function() {
  
  assert(Module["_nlr_pop"] || typeof _nlr_pop !== "undefined", "external function `nlr_pop` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['nlr_pop'];
  // Try an original version from a side module.
  if (!func) func = Module['_nlr_pop'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_nlr_pop'];
  if (!func) func = _nlr_pop;
  var fp = addFunction(func, 'v');
  Module['_fp$nlr_pop$v'] = function() { return fp };
  return fp;
}


Module['_fp$eglGetConfigAttrib$iiiii'] = function() {
  
  assert(Module["_eglGetConfigAttrib"] || typeof _eglGetConfigAttrib !== "undefined", "external function `eglGetConfigAttrib` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglGetConfigAttrib'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglGetConfigAttrib'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglGetConfigAttrib'];
  if (!func) func = _eglGetConfigAttrib;
  var fp = addFunction(func, 'iiiii');
  Module['_fp$eglGetConfigAttrib$iiiii'] = function() { return fp };
  return fp;
}


Module['_fp$eglChooseConfig$iiiiii'] = function() {
  
  assert(Module["_eglChooseConfig"] || typeof _eglChooseConfig !== "undefined", "external function `eglChooseConfig` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglChooseConfig'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglChooseConfig'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglChooseConfig'];
  if (!func) func = _eglChooseConfig;
  var fp = addFunction(func, 'iiiiii');
  Module['_fp$eglChooseConfig$iiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$eglTerminate$ii'] = function() {
  
  assert(Module["_eglTerminate"] || typeof _eglTerminate !== "undefined", "external function `eglTerminate` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglTerminate'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglTerminate'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglTerminate'];
  if (!func) func = _eglTerminate;
  var fp = addFunction(func, 'ii');
  Module['_fp$eglTerminate$ii'] = function() { return fp };
  return fp;
}


Module['_fp$eglInitialize$iiii'] = function() {
  
  assert(Module["_eglInitialize"] || typeof _eglInitialize !== "undefined", "external function `eglInitialize` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglInitialize'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglInitialize'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglInitialize'];
  if (!func) func = _eglInitialize;
  var fp = addFunction(func, 'iiii');
  Module['_fp$eglInitialize$iiii'] = function() { return fp };
  return fp;
}


Module['_fp$eglGetDisplay$ii'] = function() {
  
  assert(Module["_eglGetDisplay"] || typeof _eglGetDisplay !== "undefined", "external function `eglGetDisplay` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglGetDisplay'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglGetDisplay'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglGetDisplay'];
  if (!func) func = _eglGetDisplay;
  var fp = addFunction(func, 'ii');
  Module['_fp$eglGetDisplay$ii'] = function() { return fp };
  return fp;
}


Module['_fp$eglGetProcAddress$ii'] = function() {
  
  assert(Module["_eglGetProcAddress"] || typeof _eglGetProcAddress !== "undefined", "external function `eglGetProcAddress` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglGetProcAddress'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglGetProcAddress'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglGetProcAddress'];
  if (!func) func = _eglGetProcAddress;
  var fp = addFunction(func, 'ii');
  Module['_fp$eglGetProcAddress$ii'] = function() { return fp };
  return fp;
}


Module['_fp$eglBindAPI$ii'] = function() {
  
  assert(Module["_eglBindAPI"] || typeof _eglBindAPI !== "undefined", "external function `eglBindAPI` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglBindAPI'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglBindAPI'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglBindAPI'];
  if (!func) func = _eglBindAPI;
  var fp = addFunction(func, 'ii');
  Module['_fp$eglBindAPI$ii'] = function() { return fp };
  return fp;
}


Module['_fp$eglWaitGL$i'] = function() {
  
  assert(Module["_eglWaitGL"] || typeof _eglWaitGL !== "undefined", "external function `eglWaitGL` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglWaitGL'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglWaitGL'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglWaitGL'];
  if (!func) func = _eglWaitGL;
  var fp = addFunction(func, 'i');
  Module['_fp$eglWaitGL$i'] = function() { return fp };
  return fp;
}


Module['_fp$eglWaitNative$ii'] = function() {
  
  assert(Module["_eglWaitNative"] || typeof _eglWaitNative !== "undefined", "external function `eglWaitNative` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglWaitNative'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglWaitNative'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglWaitNative'];
  if (!func) func = _eglWaitNative;
  var fp = addFunction(func, 'ii');
  Module['_fp$eglWaitNative$ii'] = function() { return fp };
  return fp;
}


Module['_fp$eglSwapInterval$iii'] = function() {
  
  assert(Module["_eglSwapInterval"] || typeof _eglSwapInterval !== "undefined", "external function `eglSwapInterval` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglSwapInterval'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglSwapInterval'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglSwapInterval'];
  if (!func) func = _eglSwapInterval;
  var fp = addFunction(func, 'iii');
  Module['_fp$eglSwapInterval$iii'] = function() { return fp };
  return fp;
}


Module['_fp$eglSwapBuffers$iii'] = function() {
  
  assert(Module["_eglSwapBuffers"] || typeof _eglSwapBuffers !== "undefined", "external function `eglSwapBuffers` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglSwapBuffers'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglSwapBuffers'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglSwapBuffers'];
  if (!func) func = _eglSwapBuffers;
  var fp = addFunction(func, 'iii');
  Module['_fp$eglSwapBuffers$iii'] = function() { return fp };
  return fp;
}


Module['_fp$eglMakeCurrent$iiiii'] = function() {
  
  assert(Module["_eglMakeCurrent"] || typeof _eglMakeCurrent !== "undefined", "external function `eglMakeCurrent` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglMakeCurrent'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglMakeCurrent'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglMakeCurrent'];
  if (!func) func = _eglMakeCurrent;
  var fp = addFunction(func, 'iiiii');
  Module['_fp$eglMakeCurrent$iiiii'] = function() { return fp };
  return fp;
}


Module['_fp$eglDestroySurface$iii'] = function() {
  
  assert(Module["_eglDestroySurface"] || typeof _eglDestroySurface !== "undefined", "external function `eglDestroySurface` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglDestroySurface'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglDestroySurface'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglDestroySurface'];
  if (!func) func = _eglDestroySurface;
  var fp = addFunction(func, 'iii');
  Module['_fp$eglDestroySurface$iii'] = function() { return fp };
  return fp;
}


Module['_fp$eglCreateWindowSurface$iiiii'] = function() {
  
  assert(Module["_eglCreateWindowSurface"] || typeof _eglCreateWindowSurface !== "undefined", "external function `eglCreateWindowSurface` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglCreateWindowSurface'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglCreateWindowSurface'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglCreateWindowSurface'];
  if (!func) func = _eglCreateWindowSurface;
  var fp = addFunction(func, 'iiiii');
  Module['_fp$eglCreateWindowSurface$iiiii'] = function() { return fp };
  return fp;
}


Module['_fp$eglDestroyContext$iii'] = function() {
  
  assert(Module["_eglDestroyContext"] || typeof _eglDestroyContext !== "undefined", "external function `eglDestroyContext` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglDestroyContext'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglDestroyContext'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglDestroyContext'];
  if (!func) func = _eglDestroyContext;
  var fp = addFunction(func, 'iii');
  Module['_fp$eglDestroyContext$iii'] = function() { return fp };
  return fp;
}


Module['_fp$eglCreateContext$iiiii'] = function() {
  
  assert(Module["_eglCreateContext"] || typeof _eglCreateContext !== "undefined", "external function `eglCreateContext` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglCreateContext'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglCreateContext'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglCreateContext'];
  if (!func) func = _eglCreateContext;
  var fp = addFunction(func, 'iiiii');
  Module['_fp$eglCreateContext$iiiii'] = function() { return fp };
  return fp;
}


Module['_fp$eglGetError$i'] = function() {
  
  assert(Module["_eglGetError"] || typeof _eglGetError !== "undefined", "external function `eglGetError` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglGetError'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglGetError'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglGetError'];
  if (!func) func = _eglGetError;
  var fp = addFunction(func, 'i');
  Module['_fp$eglGetError$i'] = function() { return fp };
  return fp;
}


Module['_fp$eglQueryString$iii'] = function() {
  
  assert(Module["_eglQueryString"] || typeof _eglQueryString !== "undefined", "external function `eglQueryString` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['eglQueryString'];
  // Try an original version from a side module.
  if (!func) func = Module['_eglQueryString'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_eglQueryString'];
  if (!func) func = _eglQueryString;
  var fp = addFunction(func, 'iii');
  Module['_fp$eglQueryString$iii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGenQueriesEXT$vii'] = function() {
  
  assert(Module["_emscripten_glGenQueriesEXT"] || typeof _emscripten_glGenQueriesEXT !== "undefined", "external function `emscripten_glGenQueriesEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGenQueriesEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGenQueriesEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGenQueriesEXT'];
  if (!func) func = _emscripten_glGenQueriesEXT;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGenQueriesEXT$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteQueriesEXT$vii'] = function() {
  
  assert(Module["_emscripten_glDeleteQueriesEXT"] || typeof _emscripten_glDeleteQueriesEXT !== "undefined", "external function `emscripten_glDeleteQueriesEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteQueriesEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteQueriesEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteQueriesEXT'];
  if (!func) func = _emscripten_glDeleteQueriesEXT;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDeleteQueriesEXT$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsQueryEXT$ii'] = function() {
  
  assert(Module["_emscripten_glIsQueryEXT"] || typeof _emscripten_glIsQueryEXT !== "undefined", "external function `emscripten_glIsQueryEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsQueryEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsQueryEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsQueryEXT'];
  if (!func) func = _emscripten_glIsQueryEXT;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsQueryEXT$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBeginQueryEXT$vii'] = function() {
  
  assert(Module["_emscripten_glBeginQueryEXT"] || typeof _emscripten_glBeginQueryEXT !== "undefined", "external function `emscripten_glBeginQueryEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBeginQueryEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBeginQueryEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBeginQueryEXT'];
  if (!func) func = _emscripten_glBeginQueryEXT;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glBeginQueryEXT$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glEndQueryEXT$vi'] = function() {
  
  assert(Module["_emscripten_glEndQueryEXT"] || typeof _emscripten_glEndQueryEXT !== "undefined", "external function `emscripten_glEndQueryEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glEndQueryEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glEndQueryEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glEndQueryEXT'];
  if (!func) func = _emscripten_glEndQueryEXT;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glEndQueryEXT$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glQueryCounterEXT$vii'] = function() {
  
  assert(Module["_emscripten_glQueryCounterEXT"] || typeof _emscripten_glQueryCounterEXT !== "undefined", "external function `emscripten_glQueryCounterEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glQueryCounterEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glQueryCounterEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glQueryCounterEXT'];
  if (!func) func = _emscripten_glQueryCounterEXT;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glQueryCounterEXT$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetQueryivEXT$viii'] = function() {
  
  assert(Module["_emscripten_glGetQueryivEXT"] || typeof _emscripten_glGetQueryivEXT !== "undefined", "external function `emscripten_glGetQueryivEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetQueryivEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetQueryivEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetQueryivEXT'];
  if (!func) func = _emscripten_glGetQueryivEXT;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetQueryivEXT$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetQueryObjectivEXT$viii'] = function() {
  
  assert(Module["_emscripten_glGetQueryObjectivEXT"] || typeof _emscripten_glGetQueryObjectivEXT !== "undefined", "external function `emscripten_glGetQueryObjectivEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetQueryObjectivEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetQueryObjectivEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetQueryObjectivEXT'];
  if (!func) func = _emscripten_glGetQueryObjectivEXT;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetQueryObjectivEXT$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetQueryObjectuivEXT$viii'] = function() {
  
  assert(Module["_emscripten_glGetQueryObjectuivEXT"] || typeof _emscripten_glGetQueryObjectuivEXT !== "undefined", "external function `emscripten_glGetQueryObjectuivEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetQueryObjectuivEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetQueryObjectuivEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetQueryObjectuivEXT'];
  if (!func) func = _emscripten_glGetQueryObjectuivEXT;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetQueryObjectuivEXT$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetQueryObjecti64vEXT$viii'] = function() {
  
  assert(Module["_emscripten_glGetQueryObjecti64vEXT"] || typeof _emscripten_glGetQueryObjecti64vEXT !== "undefined", "external function `emscripten_glGetQueryObjecti64vEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetQueryObjecti64vEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetQueryObjecti64vEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetQueryObjecti64vEXT'];
  if (!func) func = _emscripten_glGetQueryObjecti64vEXT;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetQueryObjecti64vEXT$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetQueryObjectui64vEXT$viii'] = function() {
  
  assert(Module["_emscripten_glGetQueryObjectui64vEXT"] || typeof _emscripten_glGetQueryObjectui64vEXT !== "undefined", "external function `emscripten_glGetQueryObjectui64vEXT` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetQueryObjectui64vEXT'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetQueryObjectui64vEXT'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetQueryObjectui64vEXT'];
  if (!func) func = _emscripten_glGetQueryObjectui64vEXT;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetQueryObjectui64vEXT$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBindVertexArrayOES$vi'] = function() {
  
  assert(Module["_emscripten_glBindVertexArrayOES"] || typeof _emscripten_glBindVertexArrayOES !== "undefined", "external function `emscripten_glBindVertexArrayOES` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBindVertexArrayOES'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBindVertexArrayOES'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBindVertexArrayOES'];
  if (!func) func = _emscripten_glBindVertexArrayOES;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glBindVertexArrayOES$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteVertexArraysOES$vii'] = function() {
  
  assert(Module["_emscripten_glDeleteVertexArraysOES"] || typeof _emscripten_glDeleteVertexArraysOES !== "undefined", "external function `emscripten_glDeleteVertexArraysOES` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteVertexArraysOES'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteVertexArraysOES'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteVertexArraysOES'];
  if (!func) func = _emscripten_glDeleteVertexArraysOES;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDeleteVertexArraysOES$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGenVertexArraysOES$vii'] = function() {
  
  assert(Module["_emscripten_glGenVertexArraysOES"] || typeof _emscripten_glGenVertexArraysOES !== "undefined", "external function `emscripten_glGenVertexArraysOES` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGenVertexArraysOES'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGenVertexArraysOES'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGenVertexArraysOES'];
  if (!func) func = _emscripten_glGenVertexArraysOES;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGenVertexArraysOES$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsVertexArrayOES$ii'] = function() {
  
  assert(Module["_emscripten_glIsVertexArrayOES"] || typeof _emscripten_glIsVertexArrayOES !== "undefined", "external function `emscripten_glIsVertexArrayOES` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsVertexArrayOES'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsVertexArrayOES'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsVertexArrayOES'];
  if (!func) func = _emscripten_glIsVertexArrayOES;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsVertexArrayOES$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDrawBuffersWEBGL$vii'] = function() {
  
  assert(Module["_emscripten_glDrawBuffersWEBGL"] || typeof _emscripten_glDrawBuffersWEBGL !== "undefined", "external function `emscripten_glDrawBuffersWEBGL` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDrawBuffersWEBGL'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDrawBuffersWEBGL'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDrawBuffersWEBGL'];
  if (!func) func = _emscripten_glDrawBuffersWEBGL;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDrawBuffersWEBGL$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDrawArraysInstancedANGLE$viiii'] = function() {
  
  assert(Module["_emscripten_glDrawArraysInstancedANGLE"] || typeof _emscripten_glDrawArraysInstancedANGLE !== "undefined", "external function `emscripten_glDrawArraysInstancedANGLE` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDrawArraysInstancedANGLE'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDrawArraysInstancedANGLE'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDrawArraysInstancedANGLE'];
  if (!func) func = _emscripten_glDrawArraysInstancedANGLE;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glDrawArraysInstancedANGLE$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDrawElementsInstancedANGLE$viiiii'] = function() {
  
  assert(Module["_emscripten_glDrawElementsInstancedANGLE"] || typeof _emscripten_glDrawElementsInstancedANGLE !== "undefined", "external function `emscripten_glDrawElementsInstancedANGLE` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDrawElementsInstancedANGLE'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDrawElementsInstancedANGLE'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDrawElementsInstancedANGLE'];
  if (!func) func = _emscripten_glDrawElementsInstancedANGLE;
  var fp = addFunction(func, 'viiiii');
  Module['_fp$emscripten_glDrawElementsInstancedANGLE$viiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttribDivisorANGLE$vii'] = function() {
  
  assert(Module["_emscripten_glVertexAttribDivisorANGLE"] || typeof _emscripten_glVertexAttribDivisorANGLE !== "undefined", "external function `emscripten_glVertexAttribDivisorANGLE` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttribDivisorANGLE'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttribDivisorANGLE'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttribDivisorANGLE'];
  if (!func) func = _emscripten_glVertexAttribDivisorANGLE;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glVertexAttribDivisorANGLE$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glActiveTexture$vi'] = function() {
  
  assert(Module["_emscripten_glActiveTexture"] || typeof _emscripten_glActiveTexture !== "undefined", "external function `emscripten_glActiveTexture` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glActiveTexture'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glActiveTexture'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glActiveTexture'];
  if (!func) func = _emscripten_glActiveTexture;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glActiveTexture$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glAttachShader$vii'] = function() {
  
  assert(Module["_emscripten_glAttachShader"] || typeof _emscripten_glAttachShader !== "undefined", "external function `emscripten_glAttachShader` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glAttachShader'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glAttachShader'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glAttachShader'];
  if (!func) func = _emscripten_glAttachShader;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glAttachShader$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBindAttribLocation$viii'] = function() {
  
  assert(Module["_emscripten_glBindAttribLocation"] || typeof _emscripten_glBindAttribLocation !== "undefined", "external function `emscripten_glBindAttribLocation` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBindAttribLocation'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBindAttribLocation'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBindAttribLocation'];
  if (!func) func = _emscripten_glBindAttribLocation;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glBindAttribLocation$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBindBuffer$vii'] = function() {
  
  assert(Module["_emscripten_glBindBuffer"] || typeof _emscripten_glBindBuffer !== "undefined", "external function `emscripten_glBindBuffer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBindBuffer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBindBuffer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBindBuffer'];
  if (!func) func = _emscripten_glBindBuffer;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glBindBuffer$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBindFramebuffer$vii'] = function() {
  
  assert(Module["_emscripten_glBindFramebuffer"] || typeof _emscripten_glBindFramebuffer !== "undefined", "external function `emscripten_glBindFramebuffer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBindFramebuffer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBindFramebuffer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBindFramebuffer'];
  if (!func) func = _emscripten_glBindFramebuffer;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glBindFramebuffer$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBindRenderbuffer$vii'] = function() {
  
  assert(Module["_emscripten_glBindRenderbuffer"] || typeof _emscripten_glBindRenderbuffer !== "undefined", "external function `emscripten_glBindRenderbuffer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBindRenderbuffer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBindRenderbuffer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBindRenderbuffer'];
  if (!func) func = _emscripten_glBindRenderbuffer;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glBindRenderbuffer$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBindTexture$vii'] = function() {
  
  assert(Module["_emscripten_glBindTexture"] || typeof _emscripten_glBindTexture !== "undefined", "external function `emscripten_glBindTexture` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBindTexture'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBindTexture'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBindTexture'];
  if (!func) func = _emscripten_glBindTexture;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glBindTexture$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBlendColor$vffff'] = function() {
  
  assert(Module["_emscripten_glBlendColor"] || typeof _emscripten_glBlendColor !== "undefined", "external function `emscripten_glBlendColor` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBlendColor'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBlendColor'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBlendColor'];
  if (!func) func = _emscripten_glBlendColor;
  var fp = addFunction(func, 'vffff');
  Module['_fp$emscripten_glBlendColor$vffff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBlendEquation$vi'] = function() {
  
  assert(Module["_emscripten_glBlendEquation"] || typeof _emscripten_glBlendEquation !== "undefined", "external function `emscripten_glBlendEquation` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBlendEquation'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBlendEquation'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBlendEquation'];
  if (!func) func = _emscripten_glBlendEquation;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glBlendEquation$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBlendEquationSeparate$vii'] = function() {
  
  assert(Module["_emscripten_glBlendEquationSeparate"] || typeof _emscripten_glBlendEquationSeparate !== "undefined", "external function `emscripten_glBlendEquationSeparate` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBlendEquationSeparate'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBlendEquationSeparate'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBlendEquationSeparate'];
  if (!func) func = _emscripten_glBlendEquationSeparate;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glBlendEquationSeparate$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBlendFunc$vii'] = function() {
  
  assert(Module["_emscripten_glBlendFunc"] || typeof _emscripten_glBlendFunc !== "undefined", "external function `emscripten_glBlendFunc` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBlendFunc'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBlendFunc'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBlendFunc'];
  if (!func) func = _emscripten_glBlendFunc;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glBlendFunc$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBlendFuncSeparate$viiii'] = function() {
  
  assert(Module["_emscripten_glBlendFuncSeparate"] || typeof _emscripten_glBlendFuncSeparate !== "undefined", "external function `emscripten_glBlendFuncSeparate` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBlendFuncSeparate'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBlendFuncSeparate'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBlendFuncSeparate'];
  if (!func) func = _emscripten_glBlendFuncSeparate;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glBlendFuncSeparate$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBufferData$viiii'] = function() {
  
  assert(Module["_emscripten_glBufferData"] || typeof _emscripten_glBufferData !== "undefined", "external function `emscripten_glBufferData` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBufferData'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBufferData'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBufferData'];
  if (!func) func = _emscripten_glBufferData;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glBufferData$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glBufferSubData$viiii'] = function() {
  
  assert(Module["_emscripten_glBufferSubData"] || typeof _emscripten_glBufferSubData !== "undefined", "external function `emscripten_glBufferSubData` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glBufferSubData'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glBufferSubData'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glBufferSubData'];
  if (!func) func = _emscripten_glBufferSubData;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glBufferSubData$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCheckFramebufferStatus$ii'] = function() {
  
  assert(Module["_emscripten_glCheckFramebufferStatus"] || typeof _emscripten_glCheckFramebufferStatus !== "undefined", "external function `emscripten_glCheckFramebufferStatus` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCheckFramebufferStatus'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCheckFramebufferStatus'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCheckFramebufferStatus'];
  if (!func) func = _emscripten_glCheckFramebufferStatus;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glCheckFramebufferStatus$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glClear$vi'] = function() {
  
  assert(Module["_emscripten_glClear"] || typeof _emscripten_glClear !== "undefined", "external function `emscripten_glClear` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glClear'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glClear'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glClear'];
  if (!func) func = _emscripten_glClear;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glClear$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glClearColor$vffff'] = function() {
  
  assert(Module["_emscripten_glClearColor"] || typeof _emscripten_glClearColor !== "undefined", "external function `emscripten_glClearColor` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glClearColor'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glClearColor'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glClearColor'];
  if (!func) func = _emscripten_glClearColor;
  var fp = addFunction(func, 'vffff');
  Module['_fp$emscripten_glClearColor$vffff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glClearDepthf$vf'] = function() {
  
  assert(Module["_emscripten_glClearDepthf"] || typeof _emscripten_glClearDepthf !== "undefined", "external function `emscripten_glClearDepthf` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glClearDepthf'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glClearDepthf'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glClearDepthf'];
  if (!func) func = _emscripten_glClearDepthf;
  var fp = addFunction(func, 'vf');
  Module['_fp$emscripten_glClearDepthf$vf'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glClearStencil$vi'] = function() {
  
  assert(Module["_emscripten_glClearStencil"] || typeof _emscripten_glClearStencil !== "undefined", "external function `emscripten_glClearStencil` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glClearStencil'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glClearStencil'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glClearStencil'];
  if (!func) func = _emscripten_glClearStencil;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glClearStencil$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glColorMask$viiii'] = function() {
  
  assert(Module["_emscripten_glColorMask"] || typeof _emscripten_glColorMask !== "undefined", "external function `emscripten_glColorMask` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glColorMask'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glColorMask'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glColorMask'];
  if (!func) func = _emscripten_glColorMask;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glColorMask$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCompileShader$vi'] = function() {
  
  assert(Module["_emscripten_glCompileShader"] || typeof _emscripten_glCompileShader !== "undefined", "external function `emscripten_glCompileShader` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCompileShader'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCompileShader'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCompileShader'];
  if (!func) func = _emscripten_glCompileShader;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glCompileShader$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCompressedTexImage2D$viiiiiiii'] = function() {
  
  assert(Module["_emscripten_glCompressedTexImage2D"] || typeof _emscripten_glCompressedTexImage2D !== "undefined", "external function `emscripten_glCompressedTexImage2D` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCompressedTexImage2D'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCompressedTexImage2D'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCompressedTexImage2D'];
  if (!func) func = _emscripten_glCompressedTexImage2D;
  var fp = addFunction(func, 'viiiiiiii');
  Module['_fp$emscripten_glCompressedTexImage2D$viiiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii'] = function() {
  
  assert(Module["_emscripten_glCompressedTexSubImage2D"] || typeof _emscripten_glCompressedTexSubImage2D !== "undefined", "external function `emscripten_glCompressedTexSubImage2D` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCompressedTexSubImage2D'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCompressedTexSubImage2D'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCompressedTexSubImage2D'];
  if (!func) func = _emscripten_glCompressedTexSubImage2D;
  var fp = addFunction(func, 'viiiiiiiii');
  Module['_fp$emscripten_glCompressedTexSubImage2D$viiiiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCopyTexImage2D$viiiiiiii'] = function() {
  
  assert(Module["_emscripten_glCopyTexImage2D"] || typeof _emscripten_glCopyTexImage2D !== "undefined", "external function `emscripten_glCopyTexImage2D` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCopyTexImage2D'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCopyTexImage2D'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCopyTexImage2D'];
  if (!func) func = _emscripten_glCopyTexImage2D;
  var fp = addFunction(func, 'viiiiiiii');
  Module['_fp$emscripten_glCopyTexImage2D$viiiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCopyTexSubImage2D$viiiiiiii'] = function() {
  
  assert(Module["_emscripten_glCopyTexSubImage2D"] || typeof _emscripten_glCopyTexSubImage2D !== "undefined", "external function `emscripten_glCopyTexSubImage2D` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCopyTexSubImage2D'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCopyTexSubImage2D'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCopyTexSubImage2D'];
  if (!func) func = _emscripten_glCopyTexSubImage2D;
  var fp = addFunction(func, 'viiiiiiii');
  Module['_fp$emscripten_glCopyTexSubImage2D$viiiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCreateProgram$i'] = function() {
  
  assert(Module["_emscripten_glCreateProgram"] || typeof _emscripten_glCreateProgram !== "undefined", "external function `emscripten_glCreateProgram` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCreateProgram'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCreateProgram'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCreateProgram'];
  if (!func) func = _emscripten_glCreateProgram;
  var fp = addFunction(func, 'i');
  Module['_fp$emscripten_glCreateProgram$i'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCreateShader$ii'] = function() {
  
  assert(Module["_emscripten_glCreateShader"] || typeof _emscripten_glCreateShader !== "undefined", "external function `emscripten_glCreateShader` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCreateShader'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCreateShader'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCreateShader'];
  if (!func) func = _emscripten_glCreateShader;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glCreateShader$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glCullFace$vi'] = function() {
  
  assert(Module["_emscripten_glCullFace"] || typeof _emscripten_glCullFace !== "undefined", "external function `emscripten_glCullFace` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glCullFace'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glCullFace'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glCullFace'];
  if (!func) func = _emscripten_glCullFace;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glCullFace$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteBuffers$vii'] = function() {
  
  assert(Module["_emscripten_glDeleteBuffers"] || typeof _emscripten_glDeleteBuffers !== "undefined", "external function `emscripten_glDeleteBuffers` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteBuffers'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteBuffers'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteBuffers'];
  if (!func) func = _emscripten_glDeleteBuffers;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDeleteBuffers$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteFramebuffers$vii'] = function() {
  
  assert(Module["_emscripten_glDeleteFramebuffers"] || typeof _emscripten_glDeleteFramebuffers !== "undefined", "external function `emscripten_glDeleteFramebuffers` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteFramebuffers'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteFramebuffers'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteFramebuffers'];
  if (!func) func = _emscripten_glDeleteFramebuffers;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDeleteFramebuffers$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteProgram$vi'] = function() {
  
  assert(Module["_emscripten_glDeleteProgram"] || typeof _emscripten_glDeleteProgram !== "undefined", "external function `emscripten_glDeleteProgram` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteProgram'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteProgram'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteProgram'];
  if (!func) func = _emscripten_glDeleteProgram;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glDeleteProgram$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteRenderbuffers$vii'] = function() {
  
  assert(Module["_emscripten_glDeleteRenderbuffers"] || typeof _emscripten_glDeleteRenderbuffers !== "undefined", "external function `emscripten_glDeleteRenderbuffers` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteRenderbuffers'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteRenderbuffers'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteRenderbuffers'];
  if (!func) func = _emscripten_glDeleteRenderbuffers;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDeleteRenderbuffers$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteShader$vi'] = function() {
  
  assert(Module["_emscripten_glDeleteShader"] || typeof _emscripten_glDeleteShader !== "undefined", "external function `emscripten_glDeleteShader` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteShader'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteShader'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteShader'];
  if (!func) func = _emscripten_glDeleteShader;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glDeleteShader$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDeleteTextures$vii'] = function() {
  
  assert(Module["_emscripten_glDeleteTextures"] || typeof _emscripten_glDeleteTextures !== "undefined", "external function `emscripten_glDeleteTextures` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDeleteTextures'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDeleteTextures'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDeleteTextures'];
  if (!func) func = _emscripten_glDeleteTextures;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDeleteTextures$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDepthFunc$vi'] = function() {
  
  assert(Module["_emscripten_glDepthFunc"] || typeof _emscripten_glDepthFunc !== "undefined", "external function `emscripten_glDepthFunc` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDepthFunc'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDepthFunc'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDepthFunc'];
  if (!func) func = _emscripten_glDepthFunc;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glDepthFunc$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDepthMask$vi'] = function() {
  
  assert(Module["_emscripten_glDepthMask"] || typeof _emscripten_glDepthMask !== "undefined", "external function `emscripten_glDepthMask` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDepthMask'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDepthMask'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDepthMask'];
  if (!func) func = _emscripten_glDepthMask;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glDepthMask$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDepthRangef$vff'] = function() {
  
  assert(Module["_emscripten_glDepthRangef"] || typeof _emscripten_glDepthRangef !== "undefined", "external function `emscripten_glDepthRangef` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDepthRangef'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDepthRangef'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDepthRangef'];
  if (!func) func = _emscripten_glDepthRangef;
  var fp = addFunction(func, 'vff');
  Module['_fp$emscripten_glDepthRangef$vff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDetachShader$vii'] = function() {
  
  assert(Module["_emscripten_glDetachShader"] || typeof _emscripten_glDetachShader !== "undefined", "external function `emscripten_glDetachShader` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDetachShader'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDetachShader'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDetachShader'];
  if (!func) func = _emscripten_glDetachShader;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glDetachShader$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDisable$vi'] = function() {
  
  assert(Module["_emscripten_glDisable"] || typeof _emscripten_glDisable !== "undefined", "external function `emscripten_glDisable` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDisable'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDisable'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDisable'];
  if (!func) func = _emscripten_glDisable;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glDisable$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDisableVertexAttribArray$vi'] = function() {
  
  assert(Module["_emscripten_glDisableVertexAttribArray"] || typeof _emscripten_glDisableVertexAttribArray !== "undefined", "external function `emscripten_glDisableVertexAttribArray` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDisableVertexAttribArray'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDisableVertexAttribArray'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDisableVertexAttribArray'];
  if (!func) func = _emscripten_glDisableVertexAttribArray;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glDisableVertexAttribArray$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDrawArrays$viii'] = function() {
  
  assert(Module["_emscripten_glDrawArrays"] || typeof _emscripten_glDrawArrays !== "undefined", "external function `emscripten_glDrawArrays` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDrawArrays'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDrawArrays'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDrawArrays'];
  if (!func) func = _emscripten_glDrawArrays;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glDrawArrays$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glDrawElements$viiii'] = function() {
  
  assert(Module["_emscripten_glDrawElements"] || typeof _emscripten_glDrawElements !== "undefined", "external function `emscripten_glDrawElements` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glDrawElements'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glDrawElements'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glDrawElements'];
  if (!func) func = _emscripten_glDrawElements;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glDrawElements$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glEnable$vi'] = function() {
  
  assert(Module["_emscripten_glEnable"] || typeof _emscripten_glEnable !== "undefined", "external function `emscripten_glEnable` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glEnable'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glEnable'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glEnable'];
  if (!func) func = _emscripten_glEnable;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glEnable$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glEnableVertexAttribArray$vi'] = function() {
  
  assert(Module["_emscripten_glEnableVertexAttribArray"] || typeof _emscripten_glEnableVertexAttribArray !== "undefined", "external function `emscripten_glEnableVertexAttribArray` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glEnableVertexAttribArray'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glEnableVertexAttribArray'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glEnableVertexAttribArray'];
  if (!func) func = _emscripten_glEnableVertexAttribArray;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glEnableVertexAttribArray$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glFinish$v'] = function() {
  
  assert(Module["_emscripten_glFinish"] || typeof _emscripten_glFinish !== "undefined", "external function `emscripten_glFinish` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glFinish'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glFinish'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glFinish'];
  if (!func) func = _emscripten_glFinish;
  var fp = addFunction(func, 'v');
  Module['_fp$emscripten_glFinish$v'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glFlush$v'] = function() {
  
  assert(Module["_emscripten_glFlush"] || typeof _emscripten_glFlush !== "undefined", "external function `emscripten_glFlush` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glFlush'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glFlush'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glFlush'];
  if (!func) func = _emscripten_glFlush;
  var fp = addFunction(func, 'v');
  Module['_fp$emscripten_glFlush$v'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glFramebufferRenderbuffer$viiii'] = function() {
  
  assert(Module["_emscripten_glFramebufferRenderbuffer"] || typeof _emscripten_glFramebufferRenderbuffer !== "undefined", "external function `emscripten_glFramebufferRenderbuffer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glFramebufferRenderbuffer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glFramebufferRenderbuffer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glFramebufferRenderbuffer'];
  if (!func) func = _emscripten_glFramebufferRenderbuffer;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glFramebufferRenderbuffer$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glFramebufferTexture2D$viiiii'] = function() {
  
  assert(Module["_emscripten_glFramebufferTexture2D"] || typeof _emscripten_glFramebufferTexture2D !== "undefined", "external function `emscripten_glFramebufferTexture2D` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glFramebufferTexture2D'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glFramebufferTexture2D'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glFramebufferTexture2D'];
  if (!func) func = _emscripten_glFramebufferTexture2D;
  var fp = addFunction(func, 'viiiii');
  Module['_fp$emscripten_glFramebufferTexture2D$viiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glFrontFace$vi'] = function() {
  
  assert(Module["_emscripten_glFrontFace"] || typeof _emscripten_glFrontFace !== "undefined", "external function `emscripten_glFrontFace` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glFrontFace'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glFrontFace'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glFrontFace'];
  if (!func) func = _emscripten_glFrontFace;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glFrontFace$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGenBuffers$vii'] = function() {
  
  assert(Module["_emscripten_glGenBuffers"] || typeof _emscripten_glGenBuffers !== "undefined", "external function `emscripten_glGenBuffers` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGenBuffers'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGenBuffers'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGenBuffers'];
  if (!func) func = _emscripten_glGenBuffers;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGenBuffers$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGenerateMipmap$vi'] = function() {
  
  assert(Module["_emscripten_glGenerateMipmap"] || typeof _emscripten_glGenerateMipmap !== "undefined", "external function `emscripten_glGenerateMipmap` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGenerateMipmap'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGenerateMipmap'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGenerateMipmap'];
  if (!func) func = _emscripten_glGenerateMipmap;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glGenerateMipmap$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGenFramebuffers$vii'] = function() {
  
  assert(Module["_emscripten_glGenFramebuffers"] || typeof _emscripten_glGenFramebuffers !== "undefined", "external function `emscripten_glGenFramebuffers` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGenFramebuffers'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGenFramebuffers'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGenFramebuffers'];
  if (!func) func = _emscripten_glGenFramebuffers;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGenFramebuffers$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGenRenderbuffers$vii'] = function() {
  
  assert(Module["_emscripten_glGenRenderbuffers"] || typeof _emscripten_glGenRenderbuffers !== "undefined", "external function `emscripten_glGenRenderbuffers` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGenRenderbuffers'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGenRenderbuffers'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGenRenderbuffers'];
  if (!func) func = _emscripten_glGenRenderbuffers;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGenRenderbuffers$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGenTextures$vii'] = function() {
  
  assert(Module["_emscripten_glGenTextures"] || typeof _emscripten_glGenTextures !== "undefined", "external function `emscripten_glGenTextures` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGenTextures'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGenTextures'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGenTextures'];
  if (!func) func = _emscripten_glGenTextures;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGenTextures$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetActiveAttrib$viiiiiii'] = function() {
  
  assert(Module["_emscripten_glGetActiveAttrib"] || typeof _emscripten_glGetActiveAttrib !== "undefined", "external function `emscripten_glGetActiveAttrib` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetActiveAttrib'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetActiveAttrib'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetActiveAttrib'];
  if (!func) func = _emscripten_glGetActiveAttrib;
  var fp = addFunction(func, 'viiiiiii');
  Module['_fp$emscripten_glGetActiveAttrib$viiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetActiveUniform$viiiiiii'] = function() {
  
  assert(Module["_emscripten_glGetActiveUniform"] || typeof _emscripten_glGetActiveUniform !== "undefined", "external function `emscripten_glGetActiveUniform` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetActiveUniform'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetActiveUniform'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetActiveUniform'];
  if (!func) func = _emscripten_glGetActiveUniform;
  var fp = addFunction(func, 'viiiiiii');
  Module['_fp$emscripten_glGetActiveUniform$viiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetAttachedShaders$viiii'] = function() {
  
  assert(Module["_emscripten_glGetAttachedShaders"] || typeof _emscripten_glGetAttachedShaders !== "undefined", "external function `emscripten_glGetAttachedShaders` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetAttachedShaders'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetAttachedShaders'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetAttachedShaders'];
  if (!func) func = _emscripten_glGetAttachedShaders;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glGetAttachedShaders$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetAttribLocation$iii'] = function() {
  
  assert(Module["_emscripten_glGetAttribLocation"] || typeof _emscripten_glGetAttribLocation !== "undefined", "external function `emscripten_glGetAttribLocation` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetAttribLocation'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetAttribLocation'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetAttribLocation'];
  if (!func) func = _emscripten_glGetAttribLocation;
  var fp = addFunction(func, 'iii');
  Module['_fp$emscripten_glGetAttribLocation$iii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetBooleanv$vii'] = function() {
  
  assert(Module["_emscripten_glGetBooleanv"] || typeof _emscripten_glGetBooleanv !== "undefined", "external function `emscripten_glGetBooleanv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetBooleanv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetBooleanv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetBooleanv'];
  if (!func) func = _emscripten_glGetBooleanv;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGetBooleanv$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetBufferParameteriv$viii'] = function() {
  
  assert(Module["_emscripten_glGetBufferParameteriv"] || typeof _emscripten_glGetBufferParameteriv !== "undefined", "external function `emscripten_glGetBufferParameteriv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetBufferParameteriv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetBufferParameteriv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetBufferParameteriv'];
  if (!func) func = _emscripten_glGetBufferParameteriv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetBufferParameteriv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetError$i'] = function() {
  
  assert(Module["_emscripten_glGetError"] || typeof _emscripten_glGetError !== "undefined", "external function `emscripten_glGetError` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetError'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetError'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetError'];
  if (!func) func = _emscripten_glGetError;
  var fp = addFunction(func, 'i');
  Module['_fp$emscripten_glGetError$i'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetFloatv$vii'] = function() {
  
  assert(Module["_emscripten_glGetFloatv"] || typeof _emscripten_glGetFloatv !== "undefined", "external function `emscripten_glGetFloatv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetFloatv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetFloatv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetFloatv'];
  if (!func) func = _emscripten_glGetFloatv;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGetFloatv$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii'] = function() {
  
  assert(Module["_emscripten_glGetFramebufferAttachmentParameteriv"] || typeof _emscripten_glGetFramebufferAttachmentParameteriv !== "undefined", "external function `emscripten_glGetFramebufferAttachmentParameteriv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetFramebufferAttachmentParameteriv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetFramebufferAttachmentParameteriv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetFramebufferAttachmentParameteriv'];
  if (!func) func = _emscripten_glGetFramebufferAttachmentParameteriv;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glGetFramebufferAttachmentParameteriv$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetIntegerv$vii'] = function() {
  
  assert(Module["_emscripten_glGetIntegerv"] || typeof _emscripten_glGetIntegerv !== "undefined", "external function `emscripten_glGetIntegerv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetIntegerv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetIntegerv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetIntegerv'];
  if (!func) func = _emscripten_glGetIntegerv;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glGetIntegerv$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetProgramiv$viii'] = function() {
  
  assert(Module["_emscripten_glGetProgramiv"] || typeof _emscripten_glGetProgramiv !== "undefined", "external function `emscripten_glGetProgramiv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetProgramiv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetProgramiv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetProgramiv'];
  if (!func) func = _emscripten_glGetProgramiv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetProgramiv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetProgramInfoLog$viiii'] = function() {
  
  assert(Module["_emscripten_glGetProgramInfoLog"] || typeof _emscripten_glGetProgramInfoLog !== "undefined", "external function `emscripten_glGetProgramInfoLog` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetProgramInfoLog'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetProgramInfoLog'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetProgramInfoLog'];
  if (!func) func = _emscripten_glGetProgramInfoLog;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glGetProgramInfoLog$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetRenderbufferParameteriv$viii'] = function() {
  
  assert(Module["_emscripten_glGetRenderbufferParameteriv"] || typeof _emscripten_glGetRenderbufferParameteriv !== "undefined", "external function `emscripten_glGetRenderbufferParameteriv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetRenderbufferParameteriv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetRenderbufferParameteriv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetRenderbufferParameteriv'];
  if (!func) func = _emscripten_glGetRenderbufferParameteriv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetRenderbufferParameteriv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetShaderiv$viii'] = function() {
  
  assert(Module["_emscripten_glGetShaderiv"] || typeof _emscripten_glGetShaderiv !== "undefined", "external function `emscripten_glGetShaderiv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetShaderiv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetShaderiv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetShaderiv'];
  if (!func) func = _emscripten_glGetShaderiv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetShaderiv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetShaderInfoLog$viiii'] = function() {
  
  assert(Module["_emscripten_glGetShaderInfoLog"] || typeof _emscripten_glGetShaderInfoLog !== "undefined", "external function `emscripten_glGetShaderInfoLog` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetShaderInfoLog'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetShaderInfoLog'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetShaderInfoLog'];
  if (!func) func = _emscripten_glGetShaderInfoLog;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glGetShaderInfoLog$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetShaderPrecisionFormat$viiii'] = function() {
  
  assert(Module["_emscripten_glGetShaderPrecisionFormat"] || typeof _emscripten_glGetShaderPrecisionFormat !== "undefined", "external function `emscripten_glGetShaderPrecisionFormat` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetShaderPrecisionFormat'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetShaderPrecisionFormat'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetShaderPrecisionFormat'];
  if (!func) func = _emscripten_glGetShaderPrecisionFormat;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glGetShaderPrecisionFormat$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetShaderSource$viiii'] = function() {
  
  assert(Module["_emscripten_glGetShaderSource"] || typeof _emscripten_glGetShaderSource !== "undefined", "external function `emscripten_glGetShaderSource` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetShaderSource'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetShaderSource'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetShaderSource'];
  if (!func) func = _emscripten_glGetShaderSource;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glGetShaderSource$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetString$ii'] = function() {
  
  assert(Module["_emscripten_glGetString"] || typeof _emscripten_glGetString !== "undefined", "external function `emscripten_glGetString` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetString'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetString'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetString'];
  if (!func) func = _emscripten_glGetString;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glGetString$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetTexParameterfv$viii'] = function() {
  
  assert(Module["_emscripten_glGetTexParameterfv"] || typeof _emscripten_glGetTexParameterfv !== "undefined", "external function `emscripten_glGetTexParameterfv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetTexParameterfv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetTexParameterfv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetTexParameterfv'];
  if (!func) func = _emscripten_glGetTexParameterfv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetTexParameterfv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetTexParameteriv$viii'] = function() {
  
  assert(Module["_emscripten_glGetTexParameteriv"] || typeof _emscripten_glGetTexParameteriv !== "undefined", "external function `emscripten_glGetTexParameteriv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetTexParameteriv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetTexParameteriv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetTexParameteriv'];
  if (!func) func = _emscripten_glGetTexParameteriv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetTexParameteriv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetUniformfv$viii'] = function() {
  
  assert(Module["_emscripten_glGetUniformfv"] || typeof _emscripten_glGetUniformfv !== "undefined", "external function `emscripten_glGetUniformfv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetUniformfv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetUniformfv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetUniformfv'];
  if (!func) func = _emscripten_glGetUniformfv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetUniformfv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetUniformiv$viii'] = function() {
  
  assert(Module["_emscripten_glGetUniformiv"] || typeof _emscripten_glGetUniformiv !== "undefined", "external function `emscripten_glGetUniformiv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetUniformiv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetUniformiv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetUniformiv'];
  if (!func) func = _emscripten_glGetUniformiv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetUniformiv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetUniformLocation$iii'] = function() {
  
  assert(Module["_emscripten_glGetUniformLocation"] || typeof _emscripten_glGetUniformLocation !== "undefined", "external function `emscripten_glGetUniformLocation` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetUniformLocation'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetUniformLocation'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetUniformLocation'];
  if (!func) func = _emscripten_glGetUniformLocation;
  var fp = addFunction(func, 'iii');
  Module['_fp$emscripten_glGetUniformLocation$iii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetVertexAttribfv$viii'] = function() {
  
  assert(Module["_emscripten_glGetVertexAttribfv"] || typeof _emscripten_glGetVertexAttribfv !== "undefined", "external function `emscripten_glGetVertexAttribfv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetVertexAttribfv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetVertexAttribfv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetVertexAttribfv'];
  if (!func) func = _emscripten_glGetVertexAttribfv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetVertexAttribfv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetVertexAttribiv$viii'] = function() {
  
  assert(Module["_emscripten_glGetVertexAttribiv"] || typeof _emscripten_glGetVertexAttribiv !== "undefined", "external function `emscripten_glGetVertexAttribiv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetVertexAttribiv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetVertexAttribiv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetVertexAttribiv'];
  if (!func) func = _emscripten_glGetVertexAttribiv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetVertexAttribiv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glGetVertexAttribPointerv$viii'] = function() {
  
  assert(Module["_emscripten_glGetVertexAttribPointerv"] || typeof _emscripten_glGetVertexAttribPointerv !== "undefined", "external function `emscripten_glGetVertexAttribPointerv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glGetVertexAttribPointerv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glGetVertexAttribPointerv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glGetVertexAttribPointerv'];
  if (!func) func = _emscripten_glGetVertexAttribPointerv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glGetVertexAttribPointerv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glHint$vii'] = function() {
  
  assert(Module["_emscripten_glHint"] || typeof _emscripten_glHint !== "undefined", "external function `emscripten_glHint` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glHint'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glHint'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glHint'];
  if (!func) func = _emscripten_glHint;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glHint$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsBuffer$ii'] = function() {
  
  assert(Module["_emscripten_glIsBuffer"] || typeof _emscripten_glIsBuffer !== "undefined", "external function `emscripten_glIsBuffer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsBuffer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsBuffer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsBuffer'];
  if (!func) func = _emscripten_glIsBuffer;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsBuffer$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsEnabled$ii'] = function() {
  
  assert(Module["_emscripten_glIsEnabled"] || typeof _emscripten_glIsEnabled !== "undefined", "external function `emscripten_glIsEnabled` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsEnabled'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsEnabled'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsEnabled'];
  if (!func) func = _emscripten_glIsEnabled;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsEnabled$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsFramebuffer$ii'] = function() {
  
  assert(Module["_emscripten_glIsFramebuffer"] || typeof _emscripten_glIsFramebuffer !== "undefined", "external function `emscripten_glIsFramebuffer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsFramebuffer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsFramebuffer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsFramebuffer'];
  if (!func) func = _emscripten_glIsFramebuffer;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsFramebuffer$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsProgram$ii'] = function() {
  
  assert(Module["_emscripten_glIsProgram"] || typeof _emscripten_glIsProgram !== "undefined", "external function `emscripten_glIsProgram` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsProgram'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsProgram'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsProgram'];
  if (!func) func = _emscripten_glIsProgram;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsProgram$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsRenderbuffer$ii'] = function() {
  
  assert(Module["_emscripten_glIsRenderbuffer"] || typeof _emscripten_glIsRenderbuffer !== "undefined", "external function `emscripten_glIsRenderbuffer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsRenderbuffer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsRenderbuffer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsRenderbuffer'];
  if (!func) func = _emscripten_glIsRenderbuffer;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsRenderbuffer$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsShader$ii'] = function() {
  
  assert(Module["_emscripten_glIsShader"] || typeof _emscripten_glIsShader !== "undefined", "external function `emscripten_glIsShader` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsShader'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsShader'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsShader'];
  if (!func) func = _emscripten_glIsShader;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsShader$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glIsTexture$ii'] = function() {
  
  assert(Module["_emscripten_glIsTexture"] || typeof _emscripten_glIsTexture !== "undefined", "external function `emscripten_glIsTexture` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glIsTexture'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glIsTexture'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glIsTexture'];
  if (!func) func = _emscripten_glIsTexture;
  var fp = addFunction(func, 'ii');
  Module['_fp$emscripten_glIsTexture$ii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glLineWidth$vf'] = function() {
  
  assert(Module["_emscripten_glLineWidth"] || typeof _emscripten_glLineWidth !== "undefined", "external function `emscripten_glLineWidth` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glLineWidth'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glLineWidth'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glLineWidth'];
  if (!func) func = _emscripten_glLineWidth;
  var fp = addFunction(func, 'vf');
  Module['_fp$emscripten_glLineWidth$vf'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glLinkProgram$vi'] = function() {
  
  assert(Module["_emscripten_glLinkProgram"] || typeof _emscripten_glLinkProgram !== "undefined", "external function `emscripten_glLinkProgram` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glLinkProgram'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glLinkProgram'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glLinkProgram'];
  if (!func) func = _emscripten_glLinkProgram;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glLinkProgram$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glPixelStorei$vii'] = function() {
  
  assert(Module["_emscripten_glPixelStorei"] || typeof _emscripten_glPixelStorei !== "undefined", "external function `emscripten_glPixelStorei` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glPixelStorei'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glPixelStorei'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glPixelStorei'];
  if (!func) func = _emscripten_glPixelStorei;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glPixelStorei$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glPolygonOffset$vff'] = function() {
  
  assert(Module["_emscripten_glPolygonOffset"] || typeof _emscripten_glPolygonOffset !== "undefined", "external function `emscripten_glPolygonOffset` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glPolygonOffset'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glPolygonOffset'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glPolygonOffset'];
  if (!func) func = _emscripten_glPolygonOffset;
  var fp = addFunction(func, 'vff');
  Module['_fp$emscripten_glPolygonOffset$vff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glReadPixels$viiiiiii'] = function() {
  
  assert(Module["_emscripten_glReadPixels"] || typeof _emscripten_glReadPixels !== "undefined", "external function `emscripten_glReadPixels` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glReadPixels'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glReadPixels'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glReadPixels'];
  if (!func) func = _emscripten_glReadPixels;
  var fp = addFunction(func, 'viiiiiii');
  Module['_fp$emscripten_glReadPixels$viiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glReleaseShaderCompiler$v'] = function() {
  
  assert(Module["_emscripten_glReleaseShaderCompiler"] || typeof _emscripten_glReleaseShaderCompiler !== "undefined", "external function `emscripten_glReleaseShaderCompiler` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glReleaseShaderCompiler'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glReleaseShaderCompiler'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glReleaseShaderCompiler'];
  if (!func) func = _emscripten_glReleaseShaderCompiler;
  var fp = addFunction(func, 'v');
  Module['_fp$emscripten_glReleaseShaderCompiler$v'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glRenderbufferStorage$viiii'] = function() {
  
  assert(Module["_emscripten_glRenderbufferStorage"] || typeof _emscripten_glRenderbufferStorage !== "undefined", "external function `emscripten_glRenderbufferStorage` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glRenderbufferStorage'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glRenderbufferStorage'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glRenderbufferStorage'];
  if (!func) func = _emscripten_glRenderbufferStorage;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glRenderbufferStorage$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glSampleCoverage$vfi'] = function() {
  
  assert(Module["_emscripten_glSampleCoverage"] || typeof _emscripten_glSampleCoverage !== "undefined", "external function `emscripten_glSampleCoverage` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glSampleCoverage'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glSampleCoverage'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glSampleCoverage'];
  if (!func) func = _emscripten_glSampleCoverage;
  var fp = addFunction(func, 'vfi');
  Module['_fp$emscripten_glSampleCoverage$vfi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glScissor$viiii'] = function() {
  
  assert(Module["_emscripten_glScissor"] || typeof _emscripten_glScissor !== "undefined", "external function `emscripten_glScissor` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glScissor'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glScissor'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glScissor'];
  if (!func) func = _emscripten_glScissor;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glScissor$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glShaderBinary$viiiii'] = function() {
  
  assert(Module["_emscripten_glShaderBinary"] || typeof _emscripten_glShaderBinary !== "undefined", "external function `emscripten_glShaderBinary` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glShaderBinary'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glShaderBinary'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glShaderBinary'];
  if (!func) func = _emscripten_glShaderBinary;
  var fp = addFunction(func, 'viiiii');
  Module['_fp$emscripten_glShaderBinary$viiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glShaderSource$viiii'] = function() {
  
  assert(Module["_emscripten_glShaderSource"] || typeof _emscripten_glShaderSource !== "undefined", "external function `emscripten_glShaderSource` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glShaderSource'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glShaderSource'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glShaderSource'];
  if (!func) func = _emscripten_glShaderSource;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glShaderSource$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glStencilFunc$viii'] = function() {
  
  assert(Module["_emscripten_glStencilFunc"] || typeof _emscripten_glStencilFunc !== "undefined", "external function `emscripten_glStencilFunc` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glStencilFunc'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glStencilFunc'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glStencilFunc'];
  if (!func) func = _emscripten_glStencilFunc;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glStencilFunc$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glStencilFuncSeparate$viiii'] = function() {
  
  assert(Module["_emscripten_glStencilFuncSeparate"] || typeof _emscripten_glStencilFuncSeparate !== "undefined", "external function `emscripten_glStencilFuncSeparate` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glStencilFuncSeparate'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glStencilFuncSeparate'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glStencilFuncSeparate'];
  if (!func) func = _emscripten_glStencilFuncSeparate;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glStencilFuncSeparate$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glStencilMask$vi'] = function() {
  
  assert(Module["_emscripten_glStencilMask"] || typeof _emscripten_glStencilMask !== "undefined", "external function `emscripten_glStencilMask` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glStencilMask'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glStencilMask'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glStencilMask'];
  if (!func) func = _emscripten_glStencilMask;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glStencilMask$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glStencilMaskSeparate$vii'] = function() {
  
  assert(Module["_emscripten_glStencilMaskSeparate"] || typeof _emscripten_glStencilMaskSeparate !== "undefined", "external function `emscripten_glStencilMaskSeparate` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glStencilMaskSeparate'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glStencilMaskSeparate'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glStencilMaskSeparate'];
  if (!func) func = _emscripten_glStencilMaskSeparate;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glStencilMaskSeparate$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glStencilOp$viii'] = function() {
  
  assert(Module["_emscripten_glStencilOp"] || typeof _emscripten_glStencilOp !== "undefined", "external function `emscripten_glStencilOp` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glStencilOp'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glStencilOp'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glStencilOp'];
  if (!func) func = _emscripten_glStencilOp;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glStencilOp$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glStencilOpSeparate$viiii'] = function() {
  
  assert(Module["_emscripten_glStencilOpSeparate"] || typeof _emscripten_glStencilOpSeparate !== "undefined", "external function `emscripten_glStencilOpSeparate` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glStencilOpSeparate'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glStencilOpSeparate'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glStencilOpSeparate'];
  if (!func) func = _emscripten_glStencilOpSeparate;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glStencilOpSeparate$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glTexImage2D$viiiiiiiii'] = function() {
  
  assert(Module["_emscripten_glTexImage2D"] || typeof _emscripten_glTexImage2D !== "undefined", "external function `emscripten_glTexImage2D` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glTexImage2D'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glTexImage2D'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glTexImage2D'];
  if (!func) func = _emscripten_glTexImage2D;
  var fp = addFunction(func, 'viiiiiiiii');
  Module['_fp$emscripten_glTexImage2D$viiiiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glTexParameterf$viif'] = function() {
  
  assert(Module["_emscripten_glTexParameterf"] || typeof _emscripten_glTexParameterf !== "undefined", "external function `emscripten_glTexParameterf` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glTexParameterf'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glTexParameterf'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glTexParameterf'];
  if (!func) func = _emscripten_glTexParameterf;
  var fp = addFunction(func, 'viif');
  Module['_fp$emscripten_glTexParameterf$viif'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glTexParameterfv$viii'] = function() {
  
  assert(Module["_emscripten_glTexParameterfv"] || typeof _emscripten_glTexParameterfv !== "undefined", "external function `emscripten_glTexParameterfv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glTexParameterfv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glTexParameterfv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glTexParameterfv'];
  if (!func) func = _emscripten_glTexParameterfv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glTexParameterfv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glTexParameteri$viii'] = function() {
  
  assert(Module["_emscripten_glTexParameteri"] || typeof _emscripten_glTexParameteri !== "undefined", "external function `emscripten_glTexParameteri` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glTexParameteri'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glTexParameteri'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glTexParameteri'];
  if (!func) func = _emscripten_glTexParameteri;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glTexParameteri$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glTexParameteriv$viii'] = function() {
  
  assert(Module["_emscripten_glTexParameteriv"] || typeof _emscripten_glTexParameteriv !== "undefined", "external function `emscripten_glTexParameteriv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glTexParameteriv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glTexParameteriv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glTexParameteriv'];
  if (!func) func = _emscripten_glTexParameteriv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glTexParameteriv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glTexSubImage2D$viiiiiiiii'] = function() {
  
  assert(Module["_emscripten_glTexSubImage2D"] || typeof _emscripten_glTexSubImage2D !== "undefined", "external function `emscripten_glTexSubImage2D` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glTexSubImage2D'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glTexSubImage2D'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glTexSubImage2D'];
  if (!func) func = _emscripten_glTexSubImage2D;
  var fp = addFunction(func, 'viiiiiiiii');
  Module['_fp$emscripten_glTexSubImage2D$viiiiiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform1f$vif'] = function() {
  
  assert(Module["_emscripten_glUniform1f"] || typeof _emscripten_glUniform1f !== "undefined", "external function `emscripten_glUniform1f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform1f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform1f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform1f'];
  if (!func) func = _emscripten_glUniform1f;
  var fp = addFunction(func, 'vif');
  Module['_fp$emscripten_glUniform1f$vif'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform1fv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform1fv"] || typeof _emscripten_glUniform1fv !== "undefined", "external function `emscripten_glUniform1fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform1fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform1fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform1fv'];
  if (!func) func = _emscripten_glUniform1fv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform1fv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform1i$vii'] = function() {
  
  assert(Module["_emscripten_glUniform1i"] || typeof _emscripten_glUniform1i !== "undefined", "external function `emscripten_glUniform1i` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform1i'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform1i'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform1i'];
  if (!func) func = _emscripten_glUniform1i;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glUniform1i$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform1iv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform1iv"] || typeof _emscripten_glUniform1iv !== "undefined", "external function `emscripten_glUniform1iv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform1iv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform1iv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform1iv'];
  if (!func) func = _emscripten_glUniform1iv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform1iv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform2f$viff'] = function() {
  
  assert(Module["_emscripten_glUniform2f"] || typeof _emscripten_glUniform2f !== "undefined", "external function `emscripten_glUniform2f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform2f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform2f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform2f'];
  if (!func) func = _emscripten_glUniform2f;
  var fp = addFunction(func, 'viff');
  Module['_fp$emscripten_glUniform2f$viff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform2fv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform2fv"] || typeof _emscripten_glUniform2fv !== "undefined", "external function `emscripten_glUniform2fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform2fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform2fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform2fv'];
  if (!func) func = _emscripten_glUniform2fv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform2fv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform2i$viii'] = function() {
  
  assert(Module["_emscripten_glUniform2i"] || typeof _emscripten_glUniform2i !== "undefined", "external function `emscripten_glUniform2i` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform2i'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform2i'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform2i'];
  if (!func) func = _emscripten_glUniform2i;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform2i$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform2iv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform2iv"] || typeof _emscripten_glUniform2iv !== "undefined", "external function `emscripten_glUniform2iv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform2iv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform2iv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform2iv'];
  if (!func) func = _emscripten_glUniform2iv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform2iv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform3f$vifff'] = function() {
  
  assert(Module["_emscripten_glUniform3f"] || typeof _emscripten_glUniform3f !== "undefined", "external function `emscripten_glUniform3f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform3f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform3f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform3f'];
  if (!func) func = _emscripten_glUniform3f;
  var fp = addFunction(func, 'vifff');
  Module['_fp$emscripten_glUniform3f$vifff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform3fv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform3fv"] || typeof _emscripten_glUniform3fv !== "undefined", "external function `emscripten_glUniform3fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform3fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform3fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform3fv'];
  if (!func) func = _emscripten_glUniform3fv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform3fv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform3i$viiii'] = function() {
  
  assert(Module["_emscripten_glUniform3i"] || typeof _emscripten_glUniform3i !== "undefined", "external function `emscripten_glUniform3i` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform3i'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform3i'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform3i'];
  if (!func) func = _emscripten_glUniform3i;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glUniform3i$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform3iv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform3iv"] || typeof _emscripten_glUniform3iv !== "undefined", "external function `emscripten_glUniform3iv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform3iv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform3iv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform3iv'];
  if (!func) func = _emscripten_glUniform3iv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform3iv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform4f$viffff'] = function() {
  
  assert(Module["_emscripten_glUniform4f"] || typeof _emscripten_glUniform4f !== "undefined", "external function `emscripten_glUniform4f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform4f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform4f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform4f'];
  if (!func) func = _emscripten_glUniform4f;
  var fp = addFunction(func, 'viffff');
  Module['_fp$emscripten_glUniform4f$viffff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform4fv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform4fv"] || typeof _emscripten_glUniform4fv !== "undefined", "external function `emscripten_glUniform4fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform4fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform4fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform4fv'];
  if (!func) func = _emscripten_glUniform4fv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform4fv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform4i$viiiii'] = function() {
  
  assert(Module["_emscripten_glUniform4i"] || typeof _emscripten_glUniform4i !== "undefined", "external function `emscripten_glUniform4i` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform4i'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform4i'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform4i'];
  if (!func) func = _emscripten_glUniform4i;
  var fp = addFunction(func, 'viiiii');
  Module['_fp$emscripten_glUniform4i$viiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniform4iv$viii'] = function() {
  
  assert(Module["_emscripten_glUniform4iv"] || typeof _emscripten_glUniform4iv !== "undefined", "external function `emscripten_glUniform4iv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniform4iv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniform4iv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniform4iv'];
  if (!func) func = _emscripten_glUniform4iv;
  var fp = addFunction(func, 'viii');
  Module['_fp$emscripten_glUniform4iv$viii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniformMatrix2fv$viiii'] = function() {
  
  assert(Module["_emscripten_glUniformMatrix2fv"] || typeof _emscripten_glUniformMatrix2fv !== "undefined", "external function `emscripten_glUniformMatrix2fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniformMatrix2fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniformMatrix2fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniformMatrix2fv'];
  if (!func) func = _emscripten_glUniformMatrix2fv;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glUniformMatrix2fv$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniformMatrix3fv$viiii'] = function() {
  
  assert(Module["_emscripten_glUniformMatrix3fv"] || typeof _emscripten_glUniformMatrix3fv !== "undefined", "external function `emscripten_glUniformMatrix3fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniformMatrix3fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniformMatrix3fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniformMatrix3fv'];
  if (!func) func = _emscripten_glUniformMatrix3fv;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glUniformMatrix3fv$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUniformMatrix4fv$viiii'] = function() {
  
  assert(Module["_emscripten_glUniformMatrix4fv"] || typeof _emscripten_glUniformMatrix4fv !== "undefined", "external function `emscripten_glUniformMatrix4fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUniformMatrix4fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUniformMatrix4fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUniformMatrix4fv'];
  if (!func) func = _emscripten_glUniformMatrix4fv;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glUniformMatrix4fv$viiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glUseProgram$vi'] = function() {
  
  assert(Module["_emscripten_glUseProgram"] || typeof _emscripten_glUseProgram !== "undefined", "external function `emscripten_glUseProgram` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glUseProgram'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glUseProgram'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glUseProgram'];
  if (!func) func = _emscripten_glUseProgram;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glUseProgram$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glValidateProgram$vi'] = function() {
  
  assert(Module["_emscripten_glValidateProgram"] || typeof _emscripten_glValidateProgram !== "undefined", "external function `emscripten_glValidateProgram` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glValidateProgram'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glValidateProgram'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glValidateProgram'];
  if (!func) func = _emscripten_glValidateProgram;
  var fp = addFunction(func, 'vi');
  Module['_fp$emscripten_glValidateProgram$vi'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib1f$vif'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib1f"] || typeof _emscripten_glVertexAttrib1f !== "undefined", "external function `emscripten_glVertexAttrib1f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib1f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib1f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib1f'];
  if (!func) func = _emscripten_glVertexAttrib1f;
  var fp = addFunction(func, 'vif');
  Module['_fp$emscripten_glVertexAttrib1f$vif'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib1fv$vii'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib1fv"] || typeof _emscripten_glVertexAttrib1fv !== "undefined", "external function `emscripten_glVertexAttrib1fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib1fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib1fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib1fv'];
  if (!func) func = _emscripten_glVertexAttrib1fv;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glVertexAttrib1fv$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib2f$viff'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib2f"] || typeof _emscripten_glVertexAttrib2f !== "undefined", "external function `emscripten_glVertexAttrib2f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib2f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib2f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib2f'];
  if (!func) func = _emscripten_glVertexAttrib2f;
  var fp = addFunction(func, 'viff');
  Module['_fp$emscripten_glVertexAttrib2f$viff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib2fv$vii'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib2fv"] || typeof _emscripten_glVertexAttrib2fv !== "undefined", "external function `emscripten_glVertexAttrib2fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib2fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib2fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib2fv'];
  if (!func) func = _emscripten_glVertexAttrib2fv;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glVertexAttrib2fv$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib3f$vifff'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib3f"] || typeof _emscripten_glVertexAttrib3f !== "undefined", "external function `emscripten_glVertexAttrib3f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib3f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib3f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib3f'];
  if (!func) func = _emscripten_glVertexAttrib3f;
  var fp = addFunction(func, 'vifff');
  Module['_fp$emscripten_glVertexAttrib3f$vifff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib3fv$vii'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib3fv"] || typeof _emscripten_glVertexAttrib3fv !== "undefined", "external function `emscripten_glVertexAttrib3fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib3fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib3fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib3fv'];
  if (!func) func = _emscripten_glVertexAttrib3fv;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glVertexAttrib3fv$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib4f$viffff'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib4f"] || typeof _emscripten_glVertexAttrib4f !== "undefined", "external function `emscripten_glVertexAttrib4f` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib4f'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib4f'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib4f'];
  if (!func) func = _emscripten_glVertexAttrib4f;
  var fp = addFunction(func, 'viffff');
  Module['_fp$emscripten_glVertexAttrib4f$viffff'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttrib4fv$vii'] = function() {
  
  assert(Module["_emscripten_glVertexAttrib4fv"] || typeof _emscripten_glVertexAttrib4fv !== "undefined", "external function `emscripten_glVertexAttrib4fv` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttrib4fv'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttrib4fv'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttrib4fv'];
  if (!func) func = _emscripten_glVertexAttrib4fv;
  var fp = addFunction(func, 'vii');
  Module['_fp$emscripten_glVertexAttrib4fv$vii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glVertexAttribPointer$viiiiii'] = function() {
  
  assert(Module["_emscripten_glVertexAttribPointer"] || typeof _emscripten_glVertexAttribPointer !== "undefined", "external function `emscripten_glVertexAttribPointer` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glVertexAttribPointer'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glVertexAttribPointer'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glVertexAttribPointer'];
  if (!func) func = _emscripten_glVertexAttribPointer;
  var fp = addFunction(func, 'viiiiii');
  Module['_fp$emscripten_glVertexAttribPointer$viiiiii'] = function() { return fp };
  return fp;
}


Module['_fp$emscripten_glViewport$viiii'] = function() {
  
  assert(Module["_emscripten_glViewport"] || typeof _emscripten_glViewport !== "undefined", "external function `emscripten_glViewport` is missing.perhaps a side module was not linked in? if this symbol was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=XX in the environment");
  // Use the original wasm function itself, for the table, from the main module.
  var func = Module['asm']['emscripten_glViewport'];
  // Try an original version from a side module.
  if (!func) func = Module['_emscripten_glViewport'];
  // Otherwise, look for a regular function or JS library function.
  if (!func) func = Module['_emscripten_glViewport'];
  if (!func) func = _emscripten_glViewport;
  var fp = addFunction(func, 'viiii');
  Module['_fp$emscripten_glViewport$viiii'] = function() { return fp };
  return fp;
}

function invoke_iiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  var sp = stackSave();
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_ii(index,a1) {
  var sp = stackSave();
  try {
    return Module["dynCall_ii"](index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_v(index) {
  var sp = stackSave();
  try {
    Module["dynCall_v"](index);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return Module["dynCall_iiiii"](index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    Module["dynCall_viii"](index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_X() {
  var sp = stackSave();
  try {
    
        var args = Array.prototype.slice.call(arguments);
        return wasmTable.get(args[0]).apply(null, args.slice(1));
      
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}


/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;

if (!Object.getOwnPropertyDescriptor(Module, "intArrayFromString")) Module["intArrayFromString"] = function() { abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "intArrayToString")) Module["intArrayToString"] = function() { abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ccall")) Module["ccall"] = function() { abort("'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "cwrap")) Module["cwrap"] = function() { abort("'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setValue")) Module["setValue"] = function() { abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getValue")) Module["getValue"] = function() { abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["allocate"] = allocate;
Module["getMemory"] = getMemory;
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ArrayToString")) Module["UTF8ArrayToString"] = function() { abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ToString")) Module["UTF8ToString"] = function() { abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8Array")) Module["stringToUTF8Array"] = function() { abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8")) Module["stringToUTF8"] = function() { abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF8")) Module["lengthBytesUTF8"] = function() { abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = function() { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreRun")) Module["addOnPreRun"] = function() { abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnInit")) Module["addOnInit"] = function() { abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreMain")) Module["addOnPreMain"] = function() { abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnExit")) Module["addOnExit"] = function() { abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPostRun")) Module["addOnPostRun"] = function() { abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeStringToMemory")) Module["writeStringToMemory"] = function() { abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeArrayToMemory")) Module["writeArrayToMemory"] = function() { abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeAsciiToMemory")) Module["writeAsciiToMemory"] = function() { abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["addRunDependency"] = addRunDependency;
Module["removeRunDependency"] = removeRunDependency;
Module["FS_createFolder"] = FS.createFolder;
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
Module["FS_createLazyFile"] = FS.createLazyFile;
Module["FS_createLink"] = FS.createLink;
Module["FS_createDevice"] = FS.createDevice;
Module["FS_unlink"] = FS.unlink;
if (!Object.getOwnPropertyDescriptor(Module, "dynamicAlloc")) Module["dynamicAlloc"] = function() { abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadDynamicLibrary")) Module["loadDynamicLibrary"] = function() { abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadWebAssemblyModule")) Module["loadWebAssemblyModule"] = function() { abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getLEB")) Module["getLEB"] = function() { abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFunctionTables")) Module["getFunctionTables"] = function() { abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "alignFunctionTables")) Module["alignFunctionTables"] = function() { abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registerFunctions")) Module["registerFunctions"] = function() { abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addFunction")) Module["addFunction"] = function() { abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "removeFunction")) Module["removeFunction"] = function() { abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFuncWrapper")) Module["getFuncWrapper"] = function() { abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "prettyPrint")) Module["prettyPrint"] = function() { abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "makeBigInt")) Module["makeBigInt"] = function() { abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "dynCall")) Module["dynCall"] = function() { abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getCompilerSetting")) Module["getCompilerSetting"] = function() { abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "print")) Module["print"] = function() { abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "printErr")) Module["printErr"] = function() { abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getTempRet0")) Module["getTempRet0"] = function() { abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setTempRet0")) Module["setTempRet0"] = function() { abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "callMain")) Module["callMain"] = function() { abort("'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "abort")) Module["abort"] = function() { abort("'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToNewUTF8")) Module["stringToNewUTF8"] = function() { abort("'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "abortOnCannotGrowMemory")) Module["abortOnCannotGrowMemory"] = function() { abort("'abortOnCannotGrowMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscripten_realloc_buffer")) Module["emscripten_realloc_buffer"] = function() { abort("'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ENV")) Module["ENV"] = function() { abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "DLFCN")) Module["DLFCN"] = function() { abort("'DLFCN' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setjmpId")) Module["setjmpId"] = function() { abort("'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ERRNO_CODES")) Module["ERRNO_CODES"] = function() { abort("'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ERRNO_MESSAGES")) Module["ERRNO_MESSAGES"] = function() { abort("'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setErrNo")) Module["setErrNo"] = function() { abort("'setErrNo' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "DNS")) Module["DNS"] = function() { abort("'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GAI_ERRNO_MESSAGES")) Module["GAI_ERRNO_MESSAGES"] = function() { abort("'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Protocols")) Module["Protocols"] = function() { abort("'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Sockets")) Module["Sockets"] = function() { abort("'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UNWIND_CACHE")) Module["UNWIND_CACHE"] = function() { abort("'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readAsmConstArgs")) Module["readAsmConstArgs"] = function() { abort("'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jstoi_q")) Module["jstoi_q"] = function() { abort("'jstoi_q' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jstoi_s")) Module["jstoi_s"] = function() { abort("'jstoi_s' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "reallyNegative")) Module["reallyNegative"] = function() { abort("'reallyNegative' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "formatString")) Module["formatString"] = function() { abort("'formatString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PATH")) Module["PATH"] = function() { abort("'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PATH_FS")) Module["PATH_FS"] = function() { abort("'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SYSCALLS")) Module["SYSCALLS"] = function() { abort("'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "syscallMmap2")) Module["syscallMmap2"] = function() { abort("'syscallMmap2' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "syscallMunmap")) Module["syscallMunmap"] = function() { abort("'syscallMunmap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "JSEvents")) Module["JSEvents"] = function() { abort("'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "specialHTMLTargets")) Module["specialHTMLTargets"] = function() { abort("'specialHTMLTargets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "demangle")) Module["demangle"] = function() { abort("'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "demangleAll")) Module["demangleAll"] = function() { abort("'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jsStackTrace")) Module["jsStackTrace"] = function() { abort("'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = function() { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getEnvStrings")) Module["getEnvStrings"] = function() { abort("'getEnvStrings' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64")) Module["writeI53ToI64"] = function() { abort("'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64Clamped")) Module["writeI53ToI64Clamped"] = function() { abort("'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64Signaling")) Module["writeI53ToI64Signaling"] = function() { abort("'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToU64Clamped")) Module["writeI53ToU64Clamped"] = function() { abort("'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToU64Signaling")) Module["writeI53ToU64Signaling"] = function() { abort("'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readI53FromI64")) Module["readI53FromI64"] = function() { abort("'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readI53FromU64")) Module["readI53FromU64"] = function() { abort("'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "convertI32PairToI53")) Module["convertI32PairToI53"] = function() { abort("'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "convertU32PairToI53")) Module["convertU32PairToI53"] = function() { abort("'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Browser")) Module["Browser"] = function() { abort("'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "FS")) Module["FS"] = function() { abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "MEMFS")) Module["MEMFS"] = function() { abort("'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "TTY")) Module["TTY"] = function() { abort("'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PIPEFS")) Module["PIPEFS"] = function() { abort("'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SOCKFS")) Module["SOCKFS"] = function() { abort("'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GL")) Module["GL"] = function() { abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGet")) Module["emscriptenWebGLGet"] = function() { abort("'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetTexPixelData")) Module["emscriptenWebGLGetTexPixelData"] = function() { abort("'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetUniform")) Module["emscriptenWebGLGetUniform"] = function() { abort("'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetVertexAttrib")) Module["emscriptenWebGLGetVertexAttrib"] = function() { abort("'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "AL")) Module["AL"] = function() { abort("'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_unicode")) Module["SDL_unicode"] = function() { abort("'SDL_unicode' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_ttfContext")) Module["SDL_ttfContext"] = function() { abort("'SDL_ttfContext' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_audio")) Module["SDL_audio"] = function() { abort("'SDL_audio' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL")) Module["SDL"] = function() { abort("'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_gfx")) Module["SDL_gfx"] = function() { abort("'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLUT")) Module["GLUT"] = function() { abort("'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "EGL")) Module["EGL"] = function() { abort("'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLFW_Window")) Module["GLFW_Window"] = function() { abort("'GLFW_Window' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLFW")) Module["GLFW"] = function() { abort("'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLEW")) Module["GLEW"] = function() { abort("'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "IDBStore")) Module["IDBStore"] = function() { abort("'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "runAndAbortIfError")) Module["runAndAbortIfError"] = function() { abort("'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Fetch")) Module["Fetch"] = function() { abort("'Fetch' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "__emscripten_fetch_delete_cached_data")) Module["__emscripten_fetch_delete_cached_data"] = function() { abort("'__emscripten_fetch_delete_cached_data' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "__emscripten_fetch_load_cached_data")) Module["__emscripten_fetch_load_cached_data"] = function() { abort("'__emscripten_fetch_load_cached_data' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "__emscripten_fetch_cache_data")) Module["__emscripten_fetch_cache_data"] = function() { abort("'__emscripten_fetch_cache_data' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "__emscripten_fetch_xhr")) Module["__emscripten_fetch_xhr"] = function() { abort("'__emscripten_fetch_xhr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "LZ4")) Module["LZ4"] = function() { abort("'LZ4' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "warnOnce")) Module["warnOnce"] = function() { abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackSave")) Module["stackSave"] = function() { abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackRestore")) Module["stackRestore"] = function() { abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackAlloc")) Module["stackAlloc"] = function() { abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "AsciiToString")) Module["AsciiToString"] = function() { abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToAscii")) Module["stringToAscii"] = function() { abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF16ToString")) Module["UTF16ToString"] = function() { abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF16")) Module["stringToUTF16"] = function() { abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF16")) Module["lengthBytesUTF16"] = function() { abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF32ToString")) Module["UTF32ToString"] = function() { abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF32")) Module["stringToUTF32"] = function() { abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF32")) Module["lengthBytesUTF32"] = function() { abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8")) Module["allocateUTF8"] = function() { abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8OnStack")) Module["allocateUTF8OnStack"] = function() { abort("'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
Module["abortStackOverflow"] = abortStackOverflow;if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NORMAL")) Object.defineProperty(Module, "ALLOC_NORMAL", { configurable: true, get: function() { abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_STACK")) Object.defineProperty(Module, "ALLOC_STACK", { configurable: true, get: function() { abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_DYNAMIC")) Object.defineProperty(Module, "ALLOC_DYNAMIC", { configurable: true, get: function() { abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NONE")) Object.defineProperty(Module, "ALLOC_NONE", { configurable: true, get: function() { abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });



var calledRun;


/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;


dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  var entryFunction = Module['_main'];

  // Main modules can't tell if they have main() at compile time, since it may
  // arrive from a dynamic library.
  if (!entryFunction) return;

  args = args || [];

  var argc = args.length+1;
  var argv = stackAlloc((argc + 1) * 4);
  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
  for (var i = 1; i < argc; i++) {
    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
  }
  HEAP32[(argv >> 2) + argc] = 0;


  try {

    Module['___set_stack_limit'](STACK_MAX);

    var ret = entryFunction(argc, argv);


    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed
    // off to a pthread.
    // if we're not running an evented main loop, it's time to exit
      exit(ret, /* implicit = */ true);
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'unwind') {
      // running an evented main loop, don't immediately exit
      noExitRuntime = true;
      return;
    } else {
      var toLog = e;
      if (e && typeof e === 'object' && e.stack) {
        toLog = [e, e.stack];
      }
      err('exception thrown: ' + toLog);
      quit_(1, e);
    }
  } finally {
    calledMain = true;
  }
}




/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  writeStackCookie();

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var print = out;
  var printErr = err;
  var has = false;
  out = err = function(x) {
    has = true;
  }
  try { // it doesn't matter if it fails
    var flush = Module['_fflush'];
    if (flush) flush(0);
    // also flush in the JS FS layer
    ['stdout', 'stderr'].forEach(function(name) {
      var info = FS.analyzePath('/dev/' + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty && tty.output && tty.output.length) {
        has = true;
      }
    });
  } catch(e) {}
  out = print;
  err = printErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
  }
}

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  checkUnflushedContent();

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && noExitRuntime && status === 0) {
    return;
  }

  if (noExitRuntime) {
    // if exit() was called, we may warn the user if the runtime isn't actually being shut down
    if (!implicit) {
      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');
    }
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;


  noExitRuntime = true;

run();





// {{MODULE_ADDITIONS}}



